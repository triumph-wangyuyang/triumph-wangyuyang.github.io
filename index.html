<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JVM基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-12-08T12:29:21.000Z" itemprop="datePublished">2021-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">JVM基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴<a target="_blank" rel="noopener" href="https://pdai.tech/">https://pdai.tech/</a></p>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/kmjnhbgvfcdx5612.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>​	程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。这里，并非是广义上所指的物理寄存器，叫程序计数器（或<code> PC</code> 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。**<code>JVM</code> 中的 <code>PC</code> 寄存器是对物理 <code>PC</code> 寄存器的一种抽象模拟**。</p>
<p>​	另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>通过对程序执行命令<code>javap -verbose -p xxx.class</code>反编译查看字节码文件</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc5kmznm1sj31m50u0wph.jpg"></p>
<p>注意：<strong>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p><strong>问题：</strong>使用 <code>PC</code> 寄存器存储字节码指令地址有什么用呢？为什么使用 <code>PC</code> 寄存器记录当前线程的执行地址呢？</p>
<p><strong>答：</strong>因为 <code>CPU</code> 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 <code>JVM</code> 的字节码解释器就需要通过改变 <code>PC</code> 寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><strong>问题：</strong><code>PC</code> 寄存器为什么会被设定为线程私有的？</p>
<p><strong>答：</strong>多线程在一个特定的时间段内只会执行其中某一个线程方法， <code>CPU</code> 会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个 <code>PC</code> 寄存器，每个线程都独立计算，不会互相影响。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域；</li>
</ul>
<ul>
<li>在 <code>JVM</code> 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致；</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 <code>Java</code> 方法，程序计数器记录的是 <code>JVM</code> 字节码指令地址，<strong>如果是执行 <code>native</code> 方法，则是未指定值（<code>undefined</code>）</strong>；</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成；</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；</li>
<li><strong>它是唯一一个在 <code>JVM</code> 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域；</strong></li>
</ul>
</blockquote>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote>
<p><code>Java</code>虚拟机栈也称为<code>Java</code>栈，每个方法被执行的时候，<code>Java</code>虚拟机都会同步创建一个栈帧（<code>Stack Frame</code>）</p>
<ol>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。</li>
<li>栈帧包括局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息。</li>
<li>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
</ol>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li><code>JVM</code> 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈&#x2F;压栈），方法执行结束<strong>出栈</strong></li>
<li><strong>栈不存在垃圾回收问题</strong></li>
</ul>
</blockquote>
<h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><blockquote>
<ul>
<li><code>Java</code> 虚拟机规范允许 <strong><code>Java</code>虚拟机栈的大小是动态的或者是固定不变的</strong></li>
</ul>
<ul>
<li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 <code>Java</code> 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 <code>Java</code> 虚拟机栈允许的最大容量，<code>Java</code> 虚拟机将会抛出一个 <strong><code>StackOverflowError</code></strong> 异常</li>
<li>如果 <code>Java</code> 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 <code>Java</code> 虚拟机将会抛出一个**<code>OutOfMemoryError</code>**异常</li>
</ul>
</blockquote>
<h4 id="栈中存储什么"><a href="#栈中存储什么" class="headerlink" title="栈中存储什么"></a>栈中存储什么</h4><blockquote>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（<code>Stack Frame</code>）</strong>的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
</blockquote>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><blockquote>
<ul>
<li><p><code>JVM</code> 直接对 <code>Java</code> 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出&#x2F;后进先出”原则</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（<code>Current Frame</code>），与当前栈帧对应的方法就是<strong>当前方法</strong>（<code>Current Method</code>），定义这个方法的类就是<strong>当前类</strong>（<code>Current Class</code>）</p>
</li>
<li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧中引用另外一个线程的栈帧</strong></p>
</li>
<li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
</li>
<li><p><code>Java</code> 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 <code>return</code> 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></p>
</li>
</ul>
<p><code>IDEA</code> 在 <code>debug</code> 时候，可以在 <code>debug</code> 窗口看到 <code>Frames</code> 中各种方法的压栈和出栈情况，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc9lezaxrbj319v0u0k4w.jpg"></p>
</blockquote>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><blockquote>
<ul>
<li>局部变量表（<code>Local Variables</code>）</li>
<li>操作数栈（<code>Operand Stack</code>）(或称为表达式栈)</li>
<li>动态链接（<code>Dynamic Linking</code>）：指向运行时常量池的方法引用</li>
<li>方法返回地址（<code>Return Address</code>）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc8tjehg8bj318m0lbtbu.jpg"></p>
</blockquote>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote>
<p>​	局部变量表也被称为局部变量数组或者本地变量表，是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 <code>Java</code> 虚拟机<strong>基本数据类型</strong>（<code>boolean、byte、char、short、int、float、long、double</code>）、<strong>对象引用</strong>（<code>reference</code> 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</p>
<p>​	由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
<p>​	<strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 <code>Code</code> 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
<p>​	方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>​	<strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<p>参数值的存放总是在局部变量数组的 <code>index0</code> 开始，到数组长度 <code>-1</code> 的索引结束</p>
</blockquote>
<h6 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽 Slot"></a>槽 <code>Slot</code></h6><blockquote>
<ul>
<li>局部变量表最基本的存储单元是 <code>Slot</code>（变量槽）</li>
<li>在局部变量表中，<code>32</code> 位以内的类型只占用一个 <code>Slot</code>(包括 <code>returnAddress</code> 类型)，<code>64</code> 位的类型（<code>long</code> 和 <code>double</code>）占用两个连续的 <code>Slot</code></li>
<li><code>byte</code>、<code>short</code>、<code>char</code> 在存储前被转换为 <code>int</code>，<code>boolean</code> 也被转换为 <code>int</code>，<code>0</code> 表示 <code>false</code>，非 <code>0</code> 表示 <code>true</code></li>
<li><code>long</code> 和 <code>double</code> 则占据两个 <code>Slot</code></li>
<li><code>JVM</code> 会为局部变量表中的每一个 <code>Slot</code> 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 <code>0</code> 开始到局部变量表最大的 <code>Slot</code> 数量</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 <code>Slot</code> 上</li>
<li><strong>如果需要访问局部变量表中一个 <code>64bit</code> 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 <code>long</code> 或 <code>double</code> 类型变量，不允许采用任何方式单独访问其中的某一个 <code>Slot</code>）</li>
<li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 <code>this</code> 将会存放在 <code>index</code> 为 <code>0 </code>的 <code>Slot</code> 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 <code>this</code>，就是因为在静态方法的局部变量表中并不存在this变量，所以在静态方法中不能使用；而在构造方法和实例方法中，<code>this</code> 变量会存放在局部变量表中 <code>index</code> 为 <code>0</code> 的位置。）</li>
<li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，<code>this</code>、<code>a</code>、<code>b</code>、<code>c</code> 理论上应该有 <code>4</code> 个变量，<code>c</code> 复用了 <code>b</code> 的槽）</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc9s12g5wlj31li0owdm9.jpg"></p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
</blockquote>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><blockquote>
<ul>
<li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（<code>Last-In-First-Out</code>）的操作数栈，也可以称为<strong>表达式栈</strong>（<code>Expression Stack</code>）</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（<code>push</code>）、出栈（<code>pop</code>）</strong></li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li>
</ul>
</blockquote>
<h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><blockquote>
<ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>操作数栈就是 <code>JVM</code> 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 <code>Code</code> 属性的 <code>max_stack</code> 数据项中</li>
<li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul>
<li><code>32bit</code> 的类型占用一个栈单位深度</li>
<li><code>64bit</code> 的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 <code>PC</code> 寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>另外，我们说 <strong><code>Java</code> 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li>
</ul>
</blockquote>
<h6 id="栈顶缓存（Top-of-stack-Cashing）"><a href="#栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="栈顶缓存（Top-of-stack-Cashing）"></a>栈顶缓存（<code>Top-of-stack-Cashing</code>）</h6><blockquote>
<p>​		<code>HotSpot</code> 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 <code>HotSpot VM</code> 的实现并没有间接利用到寄存器资源。寄存器是物理 <code>CPU</code> 中的组成部分之一，它同时也是 <code>CPU</code> 中非常重要的高速存储资源。一般来说，寄存器的读&#x2F;写速度非常迅速，甚至可以比内存的读&#x2F;写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 <code>CPU</code> 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p>
<p>​		基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（<code>instruction dispatch</code>）次数和内存读&#x2F;写次数。由于操作数是存储在内存中的，因此频繁的执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，<code>HotSpot JVM</code> 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 <code>CPU</code> 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</strong></p>
</blockquote>
<h5 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h5><blockquote>
<p>​	<strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(<code>Dynamic Linking</code>)。</p>
<p>​	在 <code>Java</code> 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（<code>Symbolic Reference</code>）保存在 <code>Class</code> 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gca4k4gndgj31d20o2td0.jpg"></p>
</blockquote>
<h6 id="JVM-是如何执行方法调用的"><a href="#JVM-是如何执行方法调用的" class="headerlink" title="JVM 是如何执行方法调用的"></a><code>JVM</code> 是如何执行方法调用的</h6><blockquote>
<p>​	方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。<code>Class</code> 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 <code>Class</code> 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>
<p>在 <code>JVM</code> 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p>
<ul>
<li><strong>静态链接</strong>：当一个字节码文件被装载进 <code>JVM</code> 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（<code>Early Binding</code>）和晚期绑定（<code>Late Binding</code>）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p>
<ul>
<li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li>
</ul>
</blockquote>
<h6 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h6><blockquote>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、<code>final</code> 方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法称为虚方法</li>
</ul>
</blockquote>
<h6 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h6><blockquote>
<p>​	在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法 元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，<code>JVM</code> 采用在类的方法区建立一个虚方法表（<code>virtual method table</code>），使用索引表来代替查找。非虚方法不会出现在表中。</p>
<p>​	每个类中都有一个虚方法表，<strong>表中存放着各个方法的实际入口</strong>。</p>
<p>​	虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，<code>JVM</code> 会把该类的方法表也初始化完毕。</p>
</blockquote>
<h5 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（<code>return address</code>）</h5><blockquote>
<p>用来存放调用该方法的 <code>PC</code> 寄存器的值。</p>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 <code>PC</code> 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。<strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息</strong>。</p>
</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p>
<p>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定；</p>
<p>在字节码指令中，返回指令包含 <code>ireturn</code>(当返回值是 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code> 和 <code>int</code> 类型时使用)、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code> 以及 <code>areturn</code>，另外还有一个 <code>return</code> 指令供声明为 <code>void</code> 的方法、实例初始化方法、类和接口的初始化方法使用。</p>
</li>
<li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 <code>PC</code> 寄存器值等，让调用者方法继续执行下去。</p>
</li>
</ol>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p>
</blockquote>
<h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><blockquote>
<p>​	栈帧中还允许携带与 <code>Java</code> 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><blockquote>
<p>简单的讲，一个 <code>Native Method</code> 就是一个 <code>Java</code> 调用非 <code>Java</code> 代码的接口。我们知道的 <code>Unsafe </code>类就有很多本地方法。</p>
</blockquote>
<blockquote>
<p>为什么要使用本地方法（<code>Native Method</code>）?</p>
<ul>
<li>与 <code>Java</code> 环境外交互：有时 <code>Java</code> 应用需要与 <code>Java</code> 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：<code>JVM</code> 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 <code>Java</code> 与实现了 <code>JRE</code> 的底层系统交互，<code> JVM</code> 的一些部分就是 <code>C</code> 语言写的。</li>
<li><code>Sun&#39;s Java</code>：<code>Sun</code> 的解释器就是 <code>C</code> 实现的，这使得它能像一些普通的 <code>C</code>一样与外部交互。<code>JRE</code> 大部分都是用 <code>Java</code> 实现的，它也通过一些本地方法与外界交互。比如，类 &#96;&#96;java.lang.Thread<code>的</code>setPriority() <code>的方法是用 </code>Java<code>实现的，但它实现调用的是该类的本地方法</code>setPrioruty()<code>，该方法是 </code>C<code>实现的，并被植入</code>JVM&#96; 内部。</li>
</ul>
</blockquote>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（<code>Native Method Stack</code>）</h4><blockquote>
<ul>
<li><code>Java</code> 虚拟机栈用于管理 <code>Java</code> 方法的调用，而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈也是线程私有的</li>
<li>允许线程固定或者可动态扩展的内存大小<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，<code>Java</code> 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 <code>Java</code> 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
</li>
<li><strong>本地方法是使用 C 语言实现的</strong></li>
<li>它的具体做法是 <code>Native Method Stack</code> 中登记 <code>native</code> 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li>
<li>并不是所有 <code>JVM</code> 都支持本地方法。因为 <code>Java</code> 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 <code>JVM</code> 产品不打算支持 <code>native</code> 方法，也可以无需实现本地方法栈</li>
<li>在 <code>Hotspot JVM</code> 中，直接将本地方法栈和虚拟机栈合二为一</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>
<ul>
<li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p>
</li>
<li><p>堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</li>
</ul>
</blockquote>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><blockquote>
<p>​	对于大多数应用，<code>Java</code> 堆是 <code>Java</code> 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 <code>GC</code> 性能）：</p>
<ul>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（<code>JDK1.8</code> 之前叫永久代）：像一些方法中的操作临时对象等，<code>JDK1.8</code> 之前是占用 <code>JVM</code> 内存，<code>JDK1.8</code> 之后直接使用物理内存</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg"></p>
<p>​	<code>Java</code> 虚拟机规范规定，<code>Java</code> 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h5 id="年轻代-Young-Generation"><a href="#年轻代-Young-Generation" class="headerlink" title="年轻代 (Young Generation)"></a>年轻代 (<code>Young Generation</code>)</h5><blockquote>
<p>​	年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 **<code>Minor GC</code><strong>。年轻一代被分为三个部分——伊甸园（</strong><code>Eden Memory</code><strong>）和两个幸存区（</strong><code>Survivor Memory</code>**，被称为 <code>from/to</code> 或 <code>s0/s1</code>），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 <code>Eden</code> 内存空间中</li>
<li>当 <code>Eden</code> 空间被对象填充时，执行 **<code>Minor GC</code>**，并将所有幸存者对象移动到一个幸存者空间中</li>
<li><code>Minor GC</code> 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 <code>GC</code> 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ul>
</blockquote>
<h5 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(<code>Old Generation</code>)</h5><blockquote>
<p>​	旧的一代内存包含那些经过许多轮小型 <code>GC</code> 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 <code>GC</code>（<code>Major GC</code>），通常需要更长的时间。</p>
<p>​	大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 <code>Eden</code> 区和两个 <code>Survivor</code> 区之间发生大量的内存拷贝</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg"></p>
</blockquote>
<h5 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h5><blockquote>
<p>​	不管是 <code>JDK8</code> 之前的永久代，还是 <code>JDK8</code> 及以后的元空间，都可以看作是 <code>Java</code> 虚拟机规范中方法区的实现。</p>
<p>​	虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <code>Non-Heap</code>（非堆），目的应该是与 <code>Java</code> 堆区分开。</p>
</blockquote>
<h4 id="设置堆内存大小和-OOM"><a href="#设置堆内存大小和-OOM" class="headerlink" title="设置堆内存大小和 OOM"></a>设置堆内存大小和 <code>OOM</code></h4><blockquote>
<p><code>Java</code> 堆用于存储 <code>Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 </code>-Xmx<code>和</code>-Xms&#96; 来设定</p>
<ul>
<li><p><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></p>
</li>
<li><p><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></p>
<p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p>
</li>
<li><p>默认情况下，初始堆内存大小为：电脑内存大小 <code>/64</code></p>
</li>
<li><p>默认情况下，最大堆内存大小为：电脑内存大小 <code>/4</code></p>
</li>
</ul>
<p>可以通过代码获取到我们的设置值，当然也可以模拟 <code>OOM</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//返回 JVM 堆大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//返回 JVM 堆的最大内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initalMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + initalMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="查看-JVM-堆内存分配"><a href="#查看-JVM-堆内存分配" class="headerlink" title="查看 JVM 堆内存分配"></a>查看 <code>JVM</code> 堆内存分配</h4><blockquote>
<ol>
<li><p>在默认不配置 <code>JVM</code> 堆内存大小的情况下，<code>JVM</code> 根据默认值来配置当前内存大小</p>
</li>
<li><p>默认情况下新生代和老年代的比例是 <code>1:2</code>，可以通过 <code>–XX:NewRatio</code> 来配置</p>
<ul>
<li>新生代中的 <strong><code>Eden</code></strong>:<strong><code>From Survivor</code></strong>:<strong><code>To Survivor</code></strong> 的比例是 **<code>8:1:1</code>**，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li>
</ul>
</li>
<li><p>若在 <code>JDK 7</code> 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，<code>JVM</code> 会动态调整 <code>JVM</code> 堆中各个区域的大小以及进入老年代的年龄</p>
<p>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code>  将会失效，而 <code>JDK 8</code> 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code></p>
<p>在 <code>JDK 8</code> 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</p>
</li>
</ol>
<p>每次 <code>GC</code> 后都会重新计算 <code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code> 的大小</p>
<p>计算依据 是 <strong><code>GC</code>过程</strong>中统计的**<code>GC</code>时间<strong>、</strong>吞吐量<strong>、</strong>内存占用量**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ErgoHeapSizeLimit</span>                         <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">HeapSizePerGCThread</span>                       <span class="operator">=</span> <span class="number">87241520</span>                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := <span class="number">134217728</span>                           &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">LargePageHeapSizeThreshold</span>                <span class="operator">=</span> <span class="number">134217728</span>                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := <span class="number">2147483648</span>                          &#123;product&#125;</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 进程号</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h4><blockquote>
<ol>
<li>在 <code>JVM</code> 内存模型的堆中，堆被划分为新生代和老年代<ul>
<li>新生代又被进一步划分为 <strong><code>Eden</code> 区</strong> 和 <strong><code>Survivor</code></strong> 区，**<code>Survivor</code>** 区由 **<code>From Survivor</code>**和 <strong><code>To Survivor</code></strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 <code>Eden</code> 区<ul>
<li>此时 <code>JVM</code> 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 <code>Eden</code> 空间不足时，<code>JVM</code> 将执行新生代的垃圾回收（<code>Minor GC</code>）<ul>
<li><code>JVM</code> 会把存活的对象转移到 <code>Survivor</code> 中，并且对象年龄 <code>+1</code></li>
<li>对象在 <code>Survivor</code> 中同样也会经历 <code>Minor GC</code>，每经历一次 <code>Minor GC</code>，对象年龄都会<code>+1</code></li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，默认的阈值是 <code>16</code> 次，从 <code>0</code> 开始算，当计算器是 <code>15</code> 时，，对象会<strong>直接被分配到老年代</strong></li>
</ol>
</blockquote>
<h4 id="对象的分配过程"><a href="#对象的分配过程" class="headerlink" title="对象的分配过程"></a>对象的分配过程</h4><blockquote>
<p>​	为对象分配内存是一件非常严谨和复杂的任务，<code>JVM</code> 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 <code>GC</code> 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><code>Minor GC</code> 触发条件：<code>Eden</code> 区满时</p>
<p><code>Full GC</code> 触发条件：<br>（1）调用 <code>System.gc</code> 时，系统建议执行 <code>Full GC</code>，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过 <code>Minor GC</code> 后进入老年代的平均大小大于老年代的可用内存<br>（5）由 <code>Eden</code> 区、<code> From Space</code> 区向 <code>To Space</code> 区复制时，对象大小大于 <code>To Space</code> 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>
<p><code>Minor GC</code> 过程：</p>
<ol>
<li>在初始阶段，新创建的对象被分配到 <code>Eden </code>区，<code>survivor</code> 的两块空间都为空。</li>
<li>当 <code>Eden</code> 区满了的时候，<code>minor garbage</code> 被触发 。</li>
<li>经过扫描与标记，存活的对象被复制到 <code>S0 </code>，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</li>
<li>在下一次的 <code>Minor GC</code> 中，<code>Eden</code> 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 <code>survivor</code> 区。当 <code>Eden</code>  和 <code> S0</code> 区空间满了，<code>S0</code> 的所有的数据都被复制到 <code>S1</code>，需要注意的是，在上次 <code>minor GC </code>过程中移动到 <code>S0</code> 中的对象在复制到 <code>S1</code> 后其年龄要加1。此时 <code>Eden</code> 区 <code>S0</code> 区被清空，所有存活的数据都复制到了 <code>S1</code> 区，并且 <code>S1</code> 区存在着年龄不一样的对象</li>
<li>再下一次 <code>MinorGC</code> 则重复这个过程，这一次 <strong><code>survivor</code> 的两个区对换</strong>，存活的对象被复制到 <code>S0</code>，存活的对象年龄加 <code>1</code> <code> Eden</code> 区和另一个 <code>survivor</code> 区被清空。</li>
<li>再经过几次 <code>Minor GC</code> 之后，当存活对象的年龄达到一个阈值之后（<code>-XX：MaxTenuringThreshold</code> 默认是<code>15</code>），就会被从年轻代 <code>Promotion</code> 到老年代。</li>
<li>随着 <code>MinorGC</code> 一次又一次的进行，不断会有新的对象被 <code>promote</code> 到老年代。</li>
<li>什么时候才会去养老区呢？ 默认是 <code>15</code> 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 <code>Major GC</code>，进行养老区的内存清理</li>
<li>若养老区执行了 <code>Major GC</code>  之后发现依然无法进行对象的保存，就会产生 <code>OOM</code> 异常</li>
</ol>
</blockquote>
<h4 id="GC-垃圾回收简介"><a href="#GC-垃圾回收简介" class="headerlink" title="GC 垃圾回收简介"></a><code>GC</code> 垃圾回收简介</h4><blockquote>
<h6 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a><code>Minor GC、Major GC、Full GC</code></h6><p><code>JVM</code> 在进行 <code>GC</code> 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 <code>HotSpot VM</code> 的实现，它里面的 <code>GC</code> 按照回收区域又分为两大类：部分收集（<code>Partial GC</code>），整堆收集（<code>Full  GC</code>）</p>
<ul>
<li>部分收集：不是完整收集整个 <code>Java</code> 堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（<code>Minor GC/Young GC</code>）：只是新生代的垃圾收集</li>
<li>老年代收集（<code>Major GC/Old GC</code>）：只是老年代的垃圾收集<ul>
<li>目前，只有 <code>CMS GC</code> 会有单独收集老年代的行为</li>
<li>很多时候 <code>Major GC</code> 会和 <code>Full GC</code>  混合使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（<code>Mixed GC</code>）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前只有 <code>G1 GC</code> 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（<code>Full GC</code>）：收集整个 <code>Java</code> 堆和方法区的垃圾</li>
</ul>
</blockquote>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a><code>TLAB</code></h5><h6 id="TLAB-（Thread-Local-Allocation-Buffer）"><a href="#TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB （Thread Local Allocation Buffer）"></a><code>TLAB</code> （<code>Thread Local Allocation Buffer</code>）</h6><blockquote>
<ul>
<li>从内存模型而不是垃圾回收的角度，对 <code>Eden</code> 区域继续进行划分，<code>JVM</code> 为每个线程分配了一个私有缓存区域，它包含在 <code>Eden</code> 空间内</li>
<li>多线程同时分配内存时，使用 <code>TLAB</code> 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li>
<li><code>TLAB</code>是虚拟机在堆内存的 <code>Eden</code> 划分出来的一块专用空间，是线程专属的。在虚拟机的<code>TLAB</code> 功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块 <code>TLAB</code> 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。这里值得注意的是，我们说<code>TLAB </code>是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的，而且在使用上也没有什么区别<strong>。</strong></li>
</ul>
</blockquote>
<h6 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 <code>TLAB</code> ?</h6><blockquote>
<ul>
<li><p>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在 <code>JVM</code> 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
<p>尽管不是所有的对象实例都能够在 <code>TLAB</code> 中成功分配内存，但<code> JVM</code> 确实是将 <code>TLAB</code> 作为内存分配的首选。</p>
<p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 <code>TLAB</code> 空间。</p>
<p>默认情况下，<code>TLAB</code> 空间的内存非常小，仅占有整个 <code>Eden</code> 空间的 <code>1%</code>，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 <code>TLAB</code> 空间所占用 <code>Eden</code> 空间的百分比大小。</p>
<p>一旦对象在 <code>TLAB</code> 空间分配内存失败时，<code>JVM</code> 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 <code>Eden</code> 空间中分配内存。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82ZnVUM2VtV0k1SjNRWHFEaWM1SVJoQzIxRmdKUTVJclNHMlhpYW1JSkFRYVpYeURQZVN0RHZQT0l0UTJpYnN3V2hTZmE3Nk1OMExhNjEzazl1dHdxemNHQS82NDA.png"></p>
<ul>
<li><p>也就是说，虽然每个线程在初始化时都会去堆内存中申请一块<code> TLAB</code> ，并不是说这个 <code>TLAB</code>区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。</p>
</li>
<li><p>并且，在 <code>TLAB</code> 分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过 <code>TLAB</code> 分配内存，存放在 <code>Eden</code> 区，但是还是会被垃圾回收或者被移到 <code>Survivor Space、Old Gen</code>等。</p>
</li>
<li><p>还有一点需要注意的是，我们说 <code>TLAB</code> 是在 <code>Eden</code> 区分配的，因为 <code>Eden</code> 区域本身就不太大，而且 <code>TLAB</code> 空间的内存也非常小，默认情况下仅占有整个 <code>Eden</code> 空间的 <code>1%</code> 。所以，必然存在一些大对象是无法在 <code>TLAB</code> 直接分配。</p>
</li>
<li><p>遇到 <code>TLAB</code> 中无法分配的大对象，对象还是可能在 <code>Eden</code> 区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。</p>
</li>
</ul>
</blockquote>
<h6 id="TLAB-带来的问题"><a href="#TLAB-带来的问题" class="headerlink" title="TLAB 带来的问题"></a><code>TLAB</code> 带来的问题</h6><blockquote>
<p>​	虽然在一定程度上，<code> TLAB</code>大大的提升了对象的分配速度，但是 <code>TLAB</code> 并不是就没有任何问题的。</p>
<p>前面我们说过，因为 <code>TLAB</code> 内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：</p>
<p>​	比如一个线程的TLAB空间有 <code>100KB</code> ，其中已经使用了 <code>80KB</code> ，当需要再分配一个 <code>30KB</code> 的对象时，就无法直接在 <code>TLAB</code> 中分配，遇到这种情况时，有两种处理方案：</p>
<ul>
<li><p>1、如果一个对象需要的空间大小超过<code> TLAB</code> 中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。</p>
</li>
<li><p>2、如果一个对象需要的空间大小超过 <code>TLAB</code> 中剩余的空间大小，则废弃当前 <code>TLAB</code> ，重新申请<code>TLAB</code> 空间再次进行内存分配。</p>
</li>
</ul>
<p>以上两个方案各有利弊，如果采用方案 <code>1</code>，那么就可能存在着一种极端情况，就是 <code>TLAB</code> 只剩下<code>1KB</code>，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。</p>
<p>如果采用方案 <code>2</code> ，也有可能存在频繁废弃 <code>TLAB</code> ，频繁申请 <code>TLAB</code> 的情况，而我们知道，虽然在<code>TLAB</code> 上分配内存是线程独享的，但是 <code>TLAB</code> 内存自己从堆中划分出来的过程确实可能存在冲突的，所以，<code>TLAB</code> 的分配过程其实也是需要并发控制的。而频繁的 <code>TLAB</code> 分配就失去了使用 <code>TLAB </code>的意义。</p>
<p>为了解决这两个方案存在的问题，虚拟机定义了一个**<code>refill_waste</code>**的值，这个值可以翻译为“最大浪费空间”。</p>
<blockquote>
<p>当请求分配的内存大于 <code>refill_waste</code> 的时候，会选择在堆内存中分配。若小于 <code>refill_waste</code> 值，则会废弃当前 <code>TLAB</code> ，重新创建 <code>TLAB</code> 进行对象内存分配。</p>
<p>前面的例子中，<code>TLAB</code> 总空间<code> 100KB</code>，使用了 <code>80KB</code> ，剩余 <code>20KB</code>，如果设置的<code>refill_waste</code> 的值为 <code>25KB</code> ，那么如果新对象的内存大于 <code>25KB</code> ，则直接堆内存分配，如果小于 <code>25KB</code>，则会废弃掉之前的那个 <code>TLAB</code> ，重新分配一个 <code>TLAB</code> 空间，给新对象分配内存。</p>
</blockquote>
</blockquote>
<h6 id="堆是分配对象存储的唯一选择吗"><a href="#堆是分配对象存储的唯一选择吗" class="headerlink" title="堆是分配对象存储的唯一选择吗"></a>堆是分配对象存储的唯一选择吗</h6><blockquote>
<blockquote>
<p>​	随着 <code>JIT</code> 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。  ——《深入理解 <code>Java</code> 虚拟机》</p>
</blockquote>
</blockquote>
<h6 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h6><blockquote>
<p>​	<strong>逃逸分析(<code>Escape Analysis</code>)是目前 <code>Java</code> 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 <code>Java</code> 程序中同步负载和内存堆分配压力的<strong>跨函数全局数据流分析算法</strong>。通过逃逸分析，<code>Java Hotspot</code> 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 <code>sb</code> 返回，这样这个 <code>StringBuffer</code> 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 <code>StringBuffer</code>，那么 <code>StringBuffer</code> 将不会逃逸出方法。</p>
<h6 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h6><blockquote>
<p>1、全局逃逸（<code>GlobalEscape</code>）<br>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p>
<ul>
<li><p>对象是一个静态变量</p>
</li>
<li><p>对象是一个已经发生逃逸的对象</p>
</li>
<li><p>对象作为当前方法的返回值</p>
</li>
</ul>
<p>2、参数逃逸（<code>ArgEscape</code>）<br>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p>
<p>3、没有逃逸<br>即方法中的对象没有发生逃逸。</p>
</blockquote>
<p>逃逸分析优化<br>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p>
<ol>
<li>锁消除<br>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</li>
<li>标量替换<br>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</li>
<li>栈上分配<br>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 <code>GC</code> 压力，提高了应用程序性能。</li>
</ol>
<h6 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h6><ul>
<li>在 <code>JDK 6u23</code> 版本之后，<code>HotSpot</code> 中默认就已经开启了逃逸分析</li>
<li>如果使用较早版本，可以通过<code>-XX&quot;+DoEscapeAnalysis</code>显式开启</li>
</ul>
<p>开发中使用局部变量，就不要在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做优化：</p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 <code>CPU</code> 寄存器</li>
</ul>
<p><code>JIT</code> 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p>
<p>代码优化之同步省略（消除）</p>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li>
<li>在动态编译同步块的时候，<code>JIT</code> 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 <code>JIT</code> 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (keeper) &#123;</span><br><span class="line">        System.out.println(keeper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如上代码，代码中对 <code>keeper</code> 这个对象进行加锁，但是 <code>keeper</code> 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 <code>JIT</code> 编译阶段就会被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化之标量替换</p>
<p>​	<strong>标量</strong>（<code>Scalar</code>）是指一个无法再分解成更小的数据的数据。<code>Java</code> 中的原始数据类型就是标量。</p>
<p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（<code>Aggregate</code>），<code>Java</code> 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p>
<p>​	在 <code>JIT</code> 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<code>JVM</code> 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p>
<p>​	通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>, <span class="number">2</span>）;</span><br><span class="line">        System.out.println(<span class="string">&quot;point.x=&quot;</span> + point.x + <span class="string">&quot;; point.y=&quot;</span> + point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以上代码中，<code>point</code> 对象并没有逃逸出 <code>alloc()</code> 方法，并且 <code>point</code> 对象是可以拆解成标量的。那么，<code>JIT</code> 就不会直接创建 <code>Point </code>对象，而是直接使用两个标量 <code>int x ，int y</code> 来替代 <code>Point</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化之栈上分配</p>
<p>​	我们通过 <code>JVM</code> 内存分配可以知道 <code>JAVA</code> 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 <code>GC</code> 进行回收内存，如果对象数量较多的时候，会给<code> GC</code> 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，<code>JVM</code> 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>​	方法区（<code>Method Area</code>）与 <code>Java</code> 堆一样，是所有线程共享的内存区域。</p>
<p>​	虽然 <code>Java</code> 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <code>Non-Heap</code>（非堆），目的应该是与 <code>Java</code> 堆区分开。</p>
<p>​	运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<code>Class</code> 文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（<code>Constant Pool Table</code>），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>​	方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</p>
<p>​	<code>JVM</code> 关闭后方法区即被释放</p>
<p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？</p>
<ul>
<li><strong>方法区（<code>method area</code>）只是 JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、<strong>静态变量</strong>、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（<code>PermGen</code>）是 <code>Hotspot</code>虚拟机特有的概念， <code>Java8</code> 的时候又被元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li>
<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 <code>JVM</code> 限制了，也比较难发生 <code>OOM</code>（都会有溢出异常）</li>
<li><code>Java7</code> 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，<code>Java8</code> 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li>
<li>存储内容不同，<strong>元空间存储类的元信息，静态变量和常量池等并入堆中</strong>。相当于永久代的数据被分到了堆和元空间中</li>
<li>如果方法区域中的内存不能用于满足分配请求，则 <code>Java</code> 虚拟机抛出 <code>OutOfMemoryError</code></li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 <code>Java</code> 堆分开的（<code>Non-Heap</code>）</li>
</ul>
<p>所以对于方法区，<code>Java8</code> 之后的变化：</p>
<ul>
<li>移除了永久代（<code>PermGen</code>），替换为元空间（<code>Metaspace</code>）；</li>
<li>永久代中的 <code>class metadata</code> 转移到了 <code>native memory</code>（本地内存，而不是虚拟机）；</li>
<li>永久代中的 <code>interned Strings</code> 和 <code>class static variables</code> 转移到了 <code>Java heap</code>；</li>
<li>永久代参数 （<code>PermSize MaxPermSize</code>） -&gt; 元空间参数（<code>MetaspaceSize MaxMetaspaceSize</code>）</li>
</ul>
</blockquote>
<h4 id="设置方法区内存的大小"><a href="#设置方法区内存的大小" class="headerlink" title="设置方法区内存的大小"></a>设置方法区内存的大小</h4><blockquote>
<p>JDK8 及以后：</p>
<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。<code>Windows</code> 下，<code>-XX:MetaspaceSize</code> 是 <code>21M</code>,-XX:MaxMetaspacaSize<code>的值是</code>-1&#96;，即没有限制</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 <code>64</code> 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为<code>20.75MB</code>，这就是初始的高水位线，一旦触及这个水位线，<code>Full GC</code> 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 <code>GC</code> 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 <code>Full GC</code> 多次调用。为了避免频繁 <code>GC</code>，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li>
</ul>
</blockquote>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><blockquote>
<p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
</blockquote>
<h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><blockquote>
<p>​	对每个加载的类型（类 <code>class</code>、接口 <code>interface</code>、枚举 <code>enum</code>、注解 <code>annotation</code>），<code>JVM </code>必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 <code>interface</code>或是 <code>java.lang.Object</code>，都没有父类）</li>
<li>这个类型的修饰符（<code>public，abstract，final</code> 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</blockquote>
<h5 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h5><blockquote>
<ul>
<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（<code>public、private、protected、static、final、volatile、transient</code> 的某个子集）</li>
</ul>
</blockquote>
<h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><blockquote>
<p>JVM 必须保存所有方法的</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（<code>public，private，protected，static，final，synchronized，native，abstract</code> 的一个子集）</li>
<li>方法的字符码（<code>bytecodes</code>）、操作数栈、局部变量表及大小（<code>abstract</code> 和 <code>native</code> 方法除外）</li>
<li>异常表（<code>abstract</code> 和 <code>native</code> 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/db050d0052a44605a13043a0bec204f0.png"></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote>
<p>​	运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（<code>Class</code> 文件）中的常量池（常量池表）</p>
</blockquote>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><blockquote>
<p>​	一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（<code>Constant Pool Table</code>），包含各种字面量和对类型、域和方法的符号引用。</p>
</blockquote>
<h5 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h5><blockquote>
<p>​	一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p>
<p>​	如下，我们通过 <code>jclasslib</code> 查看一个只有 <code>Main</code> 方法的简单类，字节码中的 <code>#2</code> 指向的就是 <code>Constant Pool</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/007S8ZIlly1gg9i91ze2gj320i0riahe.jpg"></p>
<p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
</blockquote>
<h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><blockquote>
<ul>
<li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li>
<li>常量池表（<code>Constant Pool Table</code>）是 <code>Class</code> 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li>
<li><code>JVM</code> 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul>
<li>运行时常量池，相对于 <code>Class</code> 文件常量池的另一个重要特征是：<strong>动态性</strong>，<code>Java</code> 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，<code>String</code> 类的 <code>intern()</code> 方法就是这样的</li>
</ul>
</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 <code>JVM</code> 会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
</blockquote>
<h5 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h5><blockquote>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ul>
<li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>（2）节省运行时间：比较字符串时，<code>==</code> 比 <code>equals()</code> 快。对于两个引用变量，只用 <code>==</code> 判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<blockquote>
<p>双等号&#x3D;&#x3D;的含义</p>
<ul>
<li>基本数据类型之间应用双等号，比较的是他们的数值。</li>
<li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h5><blockquote>
<p><code>java</code>中基本类型的包装类的大部分都实现了常量池技术，即<code>Byte,Short,Integer,Long,Character,Boolean</code>。</p>
<p>这 <code>5</code> 种包装类默认创建了数值 <code>[-128，127]</code> 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 <code>Float,Double</code> 并没有实现常量池技术。</p>
<p>Integer与常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));  </span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>(1) <code>Integer i1=40</code> ；<code>Java</code>在编译的时候会直接将代码封装成<code>Integer i1=Integer.valueOf(40)</code>;，从而使用常量池中的对象。</li>
<li>(2) <code>Integer i1 = new Integer(40)</code>;这种情况下会创建新的对象。</li>
<li>(3)语句 <code>i4 == i5 + i6</code> ，因为 <code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>i5</code> 和 <code>i6</code> 进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。然后 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4 </code>自动拆箱转为 <code>int</code> 值 <code>40</code> ，最终这条语句转为 <code>40 == 40</code> 进行数值比较。</li>
</ul>
<p>String与常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>(1) <code>new String(&quot;abcd&quot;)</code> 是在常量池中拿对象，<code>&quot;abcd&quot;</code>  是直接在堆内存空间创建一个新的对象。只要使用 <code>new</code> 方法，便需要创建新的对象。</li>
<li>(2)连接表达式 <code>+</code><br>只有使用引号包含文本的方式创建的 <code>String</code> 对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含 <code>new</code> 方式新建对象（包括 <code>null</code> ）的 <code>“+”</code> 连接表达式，它所产生的新对象都不会被加入字符串池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B;    <span class="comment">// 常量B</span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">   A = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">   B = <span class="string">&quot;cd&quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"><span class="comment">// 将两个常量用+连接对s进行初始化  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> A + B;  </span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;  </span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>s</code> 不等于 <code>t</code> ，它们不是同一个对象。</p>
<p><code>A</code> 和 <code>B</code> 虽然被定义为常量，但是它们都没有马上被赋值。在运算出 <code>s</code> 的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此 <code>A</code> 和 <code>B</code> 在被赋值之前，性质类似于一个变量。那么 <code>s</code> 就不能在编译期被确定，而只能在运行时被创建了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>考虑类加载阶段和实际执行时。</p>
<ul>
<li>（1）类加载对一个类只会进行一次。<code>”xyz”</code> 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 <code>”xyz”</code> 字符串被驻留过则不需要重复创建用于驻留的 <code>”xyz”</code> 实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li>
<li>（2）在这段代码后续被运行的时候，<code>”xyz”</code> 字面量对应的 <code>String</code> 实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到 <code>heap</code> 中，并且把 <code>heap</code> 中的这个对象的引用交给 <code>s1</code> 持有。</li>
</ul>
<p>这条语句创建了 <code>2</code> 个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s1 == s2? &quot;</span> + (s1 == s2));</span><br><span class="line">    System.out.println(<span class="string">&quot;s3 == s2? &quot;</span> + (s3 == s2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 ==s2 ? <span class="literal">false</span></span><br><span class="line">s3 ==s2 ? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>String</code> 的 <code>intern()</code> 方法会查找在常量池中是否存在一份 <code>equal</code> 相等的字符串,如果有则返回该字符串的引用，如果没有则添加自己的字符串进入常量池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>, lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">            System.out.println((hello == <span class="string">&quot;Hello&quot;</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((Other.hello == hello) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((other.Other.hello == hello) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((hello == (<span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>)) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((hello == (<span class="string">&quot;Hel&quot;</span> + lo)) + <span class="string">&quot; &quot;</span>); <span class="comment">//false</span></span><br><span class="line">            System.out.println(hello == (<span class="string">&quot;Hel&quot;</span> + lo).intern()); <span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><p>在同包同类下,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在同包不同类下,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在不同包不同类下,依然引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在编译成.class时能够识别为同一字符串的,自动优化成常量,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在运行时创建的字符串具有独立的内存地址,所以不引用自同一 <code>String</code> 对象.</p>
</li>
</ul>
</blockquote>
<h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p> ​	引用计数算法在每个对象都维护着一个内存字段来统计它被多少”部分”使用—引用计数器,每当有一个新的引用指向该对象时,引用计数器就 <code>+1</code>  ,每当指向该引用对象失效时该计数器就 <code>-1</code> ,当引用数量为 <code>0</code> 的时候,则说明对象没有被任何引用指向,可以认定是”垃圾”对象。</p>
</blockquote>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote>
<ol>
<li>可以立即回收垃圾。因为每个对象在被引用次数为 <code>0</code> 的时候，是立即就可以知道的。</li>
<li>没有暂停时间。这个很容易理解，对象的回收根本不需要另外的 <code>GC</code> 线程专门去做，业务线程自己就搞定了。所以不需要 <code>stop the world</code>，当然，在多线程的情况下，必要的同步和互斥操作还是需要的。</li>
</ol>
</blockquote>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ol>
<li><p>在每次赋值操作的时候都要做相当大的计算，尤其这里面还有<strong>递归调用</strong>。这是比较麻烦的。</p>
</li>
<li><p>一个致命缺陷是循环引用，就是， <code>objA</code> 引用了 <code>objB</code> ，<code>objB</code> 也引用了 <code>objA </code>，但是除此之外，再没有其他的地方引用这两个对象了，这两个对象的引用计数就都是 <code>1</code>。这种情况下，这两个对象是不能被回收的。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">GcObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GcObject</span>(); <span class="comment">//Step1</span></span><br><span class="line">  GcObject obj <span class="number">2</span> = <span class="keyword">new</span> <span class="title class_">GcObject</span>();<span class="comment">//Step2</span></span><br><span class="line">  obj1.instance = obj2; <span class="comment">//Step3</span></span><br><span class="line">  obj2.instance = obj1;<span class="comment">// //Step4</span></span><br><span class="line">  obj1 = <span class="literal">null</span>; <span class="comment">//Step5</span></span><br><span class="line">  obj2 = <span class="literal">null</span>; <span class="comment">//Step6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步: <code>GcObject</code>  实例 <code>1</code> 被 <code>obj1</code> 引用,所以它的引用数 <code>+1</code> ,为 <code>1</code></p>
</li>
<li><p>第二步: <code>GcObject</code> 实例 <code>2</code> 被 <code>obj2</code> 引用,所以它的引用数<code> +1</code> ,为 <code>1</code></p>
</li>
<li><p>第三步: <code>obj1</code> 的 <code>instance</code> 属性指向 <code>obj2 </code>,而 <code>obj2</code> 指向 <code>GcObject</code> 实例 <code>2</code> ,故 <code>GcObject</code>实例<code> 2</code> 引用 <code>+1 </code>,为 <code>2</code></p>
</li>
<li><p>第四步: <code>obj2</code> 的 <code>instance</code> 属性指向 <code>obj1 </code>,而 <code>obj1</code> 指向 <code>GcOjbect</code> 实例 <code>1</code> ,故 <code>GcObject</code>实例 <code>1</code> 引用 <code>+1 </code>,为 <code>2</code></p>
<p>到此前4步, <code>GcOjbect</code> 实例<code> 1</code> 和 <code>GcOjbect </code>实例 <code>2</code> 的引用数量均为 <code>2</code> ,此时结果图如下.</p>
<p><code>PS</code>：注意想一下,为什么是 <code>obj</code> 的 <code>instance</code> 属性,而不是写成 <code>obj </code>本身?</p>
</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/647994-20170218225201894-1235824981.png"></p>
<ol start="5">
<li>第五步:<code>obj1</code>不再指向 <code>GcOjbect</code> 实例 <code>1</code> ,其引用计数减 <code>1</code> ,结果为 <code>1</code> .</li>
<li>第六步:<code>obj2</code>不再指向 <code>GcOjbect</code> 实例 <code>2</code> ,其引用计数减 <code>1</code> ,结果为 <code>1</code> .</li>
</ol>
<p>​    到此,发现<code>GcObject</code> 实例 <code>1</code> 和实例 <code>2</code> 的计数引用都不为 <code>0</code> ,那么如果采用的引用计数算法的话,那么这两个实例所占的内存将得不到释放,这便产生了内存泄露。</p>
</blockquote>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过 <code>GC Roots</code> 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0635cbe8.png"></p>
</blockquote>
<h5 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a><code>GC Roots</code> 对象</h5><blockquote>
<ul>
<li><p>虚拟机栈中引用的对象 </p>
</li>
<li><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><p>本地方法栈内 <code>JNI</code>（通常说的本地方法）引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象 </p>
</li>
<li><ul>
<li>比如：<code>Java</code> 类的引用类型静态变量</li>
</ul>
</li>
<li><p>方法区中常量引用的对象 </p>
</li>
<li><ul>
<li>比如：字符串常量池（<code>String Table</code>）里的引用</li>
</ul>
</li>
<li><p>所有被同步锁 <code>synchronized</code> 持有的对象</p>
</li>
<li><p>Java虚拟机内部的引用。 </p>
</li>
<li><ul>
<li>基本数据类型对应的 <code>Class</code> 对象，一些常驻的异常对象（如：<code>NullPointerException</code>、<code>OutOfMemoryError</code>），系统类加载器。</li>
</ul>
</li>
<li><p>反映 <code>java</code> 虚拟机内部情况的 <code>JMXBean</code>、<code>JVMTI</code> 中注册的回调、本地代码缓存等。</p>
</li>
</ul>
</blockquote>
<h5 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h5><blockquote>
<ul>
<li>Java语言提供了对象终止（<code>finalization</code>）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 <code>finalize()</code> 方法。</li>
<li><code>finalize()</code>  方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li>
</ul>
</blockquote>
<h6 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a><code>finalize()</code></h6><blockquote>
<p>永远不要主动调用某个对象的 <code>finalize()</code> 方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ol>
<li><code>在finalize()</code> 时可能会导致对象复活。</li>
<li><code>finalize()</code> 方法的执行时间是没有保障的，它完全由 <code>GC</code> 线程决定，极端情况下，若不发生 <code>GC</code> ，则 <code>finalize()</code> 方法将没有执行机会。</li>
<li>一个糟糕的 <code>finalize()</code> 会严重影响 <code>GC</code> 的性能。</li>
</ol>
</blockquote>
<p>虚拟机中的对象一般处于三种可能的状态</p>
<blockquote>
<p>​	由于 <code>finalize()</code> 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<p>​	如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><p><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</p>
</li>
<li><p><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 <code>finalize()</code> 中复活。</p>
</li>
<li><p><strong>不可触及的</strong>：对象的 <code>finalize()</code> 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 <strong><code>finalize()</code> 只会被调用一次</strong>。</p>
</li>
</ul>
<p>以上3种状态中，是由于 <code>finalize()</code> 方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</blockquote>
<h5 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h5><blockquote>
<p>判定一个对象 <code>objA</code> 是否可回收，至少要经历两次标记过程：</p>
<ol>
<li><p>如果对象 <code>objA</code> 到 <code>GC Roots</code> 没有引用链，则进行第一次标记。</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行 <code>finalize()</code> 方法</p>
</li>
<li><p>如果对象 <code>objA</code> 没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，<code>objA</code> 被判定为不可触及的。</p>
</li>
<li><p>如果对象 <code>objA </code>重写了 <code>finalize()</code> 方法，且还未执行过，那么 <code>objA</code> 会被插入到 <code>F-Queue</code> 队列中，由一个虚拟机自动创建的、低优先级的 <code>Finalizer</code> 线程触发其 <code>finalize()</code>方法执行。</p>
</li>
<li><p><code>finalize()</code> 方法是对象逃脱死亡的最后机会，稍后 <code>GC</code> 会对 <code>F-Queue</code> 队列中的对象进行第二次标记。如果 <code>objA</code> 在 <code>finalize()</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，<code>objA</code> 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，<code>finalize</code> 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 <code>finalize </code>方法只会被调用一次。</p>
</li>
</ol>
</blockquote>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote>
<p>​	无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p><code>Java</code> 具有四种强度不同的引用类型：</p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>​	被强引用关联的对象不会被回收。</p>
<p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>​	被软引用关联的对象只有在内存不够的情况下才会被回收。软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真实来源中查询数据，可以显著地提升网站性能。当内存不足时，能让 <code>JVM</code> 进行内存回收，从而删除缓存，这时候只能从真实来源查询数据。</p>
<p>使用 <code>SoftReference</code> 类来创建软引用。</p>
<p>​	软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>​	被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。弱引用可以在回调函数防止内存泄露。因为回调函数往往是匿名内部类，<strong>一个非静态的内部类会隐式地持有外部类的一个强引用</strong>，当 <code>JVM</code> 在回收外部类的时候，此时回调函数在某个线程里面被回调的时候，<code>JVM</code> 就无法回收外部类，造成内存泄漏。在安卓 <code>activity</code> 内声明一个非静态的内部类时，如果考虑防止内存泄露的话，应当显示地声明此内部类持有外部类的一个弱引用。</p>
<p>​	弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。  </p>
<p>使用 <code>WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><ul>
<li>虚引用也称为 幽灵引用 或者 幻影引用；</li>
<li>虚引用并不会决定对象的生命周期，<strong>在任何时间都会被回收掉</strong>；</li>
<li>在使用虚引用的时候，<strong>必须和引用队列一起使用</strong>，虚引用的 <strong>构造器必须传入一个该类型的引用队列</strong>；</li>
</ul>
<p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知</strong>。</p>
<p>​	虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列 （<code>ReferenceQueue</code>）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。  </p>
<p>使用 <code>PhantomReference</code> 来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（<code>Mark-Sweep</code>）</h4><blockquote>
<p>​	当堆中的有效内存空间（<code>available memory</code>）被耗尽的时候，就会停止整个程序（也被称为<code>stop the world</code>），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li><p>标记：<code>Collector</code> 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 </p>
</li>
<li><p>清除：<code>Collector</code> <strong>对堆内存从头到尾进行线性的遍历</strong>，如果发现某个对象在其<code>Header</code>中没有标记为可达对象，则将其回收 。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/fc6c84a5-8946-4a42-bc40-287d1492aaf4.png"></p>
</blockquote>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>标记清除算法的效率不算高</p>
</li>
<li><p>在进行 <code>GC</code> 的时候，需要停止整个应用程序(<code>STW</code>)，用户体验较差</p>
</li>
<li><p>这种方式清理出来的空闲内存是不连续的，产生内碎片，<strong>因此需要维护一个空闲列表</strong></p>
</li>
</ul>
</blockquote>
<h5 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h5><blockquote>
<p>​	这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
</blockquote>
<h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（<code>Copying</code>）算法</h4><blockquote>
<p>​	将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg"></p>
<p>​	现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 空间和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象一次性复制到另一块 <code>Survivor</code> 空间上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p>
<p>​	<code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 的大小比例默认为 <code>8:1:1</code>，保证了内存的利用率达到 <code>90%</code>。如果每次回收有多于 <code>10%</code> 的对象存活，那么一块 <code>Survivor</code> 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
</blockquote>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>此算法的缺点也是很明显的，就是需要<strong>两倍的内存空间</strong>。</p>
</li>
<li><p>对于 <code>G1</code> 这种分拆成为大量 <code>region</code> 的 <code>GC</code> ，复制而不是移动，意味着 <code>GC</code>需要维护<code>region</code> 之间对象引用关系，不管是内存占用或者时间开销也不小</p>
</li>
</ul>
</blockquote>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><blockquote>
<p>​	在新生代，对常规应用的垃圾回收，一次通常可以回收 <code>70% - 99%</code> 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
</blockquote>
<h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、<code>Mark-Compact</code>）算法</h4><blockquote>
<p>​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>​	标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 <code>JVM</code> 的设计者需要在此基础之上进行改进。标记-压缩（<code>Mark-Compact</code>）算法由此诞生。</p>
<ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 </li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 </li>
<li>清理边界外所有的空间。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1d2df46e-b7a2-4cb2-81cb-d41110838ae8.png"></p>
</blockquote>
<blockquote>
<p>​	二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
</blockquote>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote>
<ul>
<li><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可。</p>
</li>
<li><p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
</blockquote>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>从效率上来说，标记-整理算法要低于复制算法。</p>
</li>
<li><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</p>
</li>
<li><p>移动过程中，需要全程暂停用户应用程序。即：<code>STW</code></p>
</li>
</ul>
</blockquote>
<h4 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><code>Mark-Sweep</code></th>
<th align="center"><code>Mark-Compact</code></th>
<th align="center"><code>Copying</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>速率</strong></td>
<td align="center">中等</td>
<td align="center">最慢</td>
<td align="center">最快</td>
</tr>
<tr>
<td align="center"><strong>空间开销</strong></td>
<td align="center">少（但会堆积碎片）</td>
<td align="center">少（不堆积碎片）</td>
<td align="center">通常需要活对象的 <code>2</code> 倍空间（不堆积碎片）</td>
</tr>
<tr>
<td align="center"><strong>移动对象</strong></td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>效率：复制算法&gt;标记&#x2F;整理算法&gt;标记&#x2F;清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</strong></p>
<p><strong>内存整齐度：复制算法&#x3D;标记&#x2F;整理算法&gt;标记&#x2F;清除算法。</strong></p>
<p>*<em>内存利用率：*<em>标记&#x2F;整理算法&#x3D;*</em>*<em>标记&#x2F;清除算法*</em>&gt;复制算法。</em>*</p>
</blockquote>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><blockquote>
<p>​	现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>​	一般将堆分为新生代和老年代,还有元空间（持久代：代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，<code>Java</code> 虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。<strong>元空间存储类的元信息，静态变量和常量池等并入堆中</strong>。）</p>
<ul>
<li>新生代使用: <strong>复制算法</strong></li>
<li>老年代使用: <strong>标记 - 清除</strong> 或者 <strong>标记 - 整理</strong> 算法</li>
</ul>
</blockquote>
<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><blockquote>
<p>​	由于 <code>GC</code> 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 <code>OOM</code> 的情况。</p>
<p>​	大多数情况下，<code>GC</code> 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 <code>Full GC</code>操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>​	<code>javadoc</code> 中对 <code>OutOfMemoryError</code> 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
<p>首先说没有空闲内存的情况：说明 <code>Java </code>虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><code>Java</code>虚拟机的堆内存设置不够。</li>
</ol>
<p>​       比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 <code>JVM</code> 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code>、<code>-Xmx</code>来调整。 </p>
<ol start="2">
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ol>
<p>​       对于老版本的 <code>Oracle JDK</code>，因为永久代的大小是有限的，并且 <code>JVM</code> 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code> 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 <code>intern</code> 字符串缓存占用太多空间，也会导致 <code>OOM</code> 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。<br>   随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 <code>OOM</code> 有所改观，出现 <code>OOM</code>，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 <code>OOM</code>。 </p>
<p>这里面隐含着一层意思是，在抛出 <code>OutOfMemoryError</code> 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li><p>例如：在引用机制分析中，涉及到 <code>JVM</code> 会去尝试回收软引用指向的对象等。</p>
</li>
<li><p>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</p>
</li>
</ul>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，<code>JVM</code> 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 <code>OutOfMemoryError</code>。</li>
</ul>
</blockquote>
<h4 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（<code>Memory Leak</code>）</h4><blockquote>
<p>​	也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 <code>GC</code>又不能回收他们的情况，才叫内存泄漏。</p>
<p>​	但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 <code>00M</code> ，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>​	尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 <code>OutOfMemory</code> 异常，导致程序崩溃。</p>
<p>​	注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><ol>
<li>单例模式</li>
</ol>
<p>  单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 </p>
<ol start="2">
<li>一些提供 <code>close</code> 的资源未关闭导致内存泄漏<br> 数据库连接（<code>dataSourse.getConnection()</code> ），网络连接（<code>socket</code>）和 <code>IO</code> 连接必须手动close，否则是不能被回收的。</li>
</ol>
</blockquote>
<h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a><code>Stop The World</code></h3><blockquote>
<ol>
<li><code>Stop-the-World</code>，简称 <code>STW</code>，指的是 <code>GC</code> 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 <code>STW</code>。</li>
</ol>
<p>2.可达性分析算法中枚举根节点（<code>GC Roots</code>）会导致所有 <code>Java</code> 执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
</ul>
<ul>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p>
</li>
</ul>
<ol start="3">
<li><p>被 <code>STW</code> 中断的应用程序线程会在完成 <code>GC</code> 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 <code>STW</code> 的发生。</p>
</li>
<li><p><code>STW</code> 事件和采用哪款 <code>GC</code> 无关，所有的 <code>GC</code> 都有这个事件。哪怕是 <code>G1</code> 也不能完全避免<code>Stop-the-World</code> 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p><code>STW</code> 是 <code>JVM</code> 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li><p>开发中不要用 <code>System.gc()</code> 会导致 <code>Stop-the-World</code> 的发生。</p>
</li>
</ol>
</blockquote>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（<code>Concurrent</code>）</h4><blockquote>
<ul>
<li><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
</li>
<li><p>并发不是真正意义上的“同时进行”，只是<code>CPU</code>把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于<code>CPU</code>处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
</li>
<li><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/b8043d6d-32e2-4a7b-929b-1ae733372a20.png"></p>
</li>
</ul>
</blockquote>
<h4 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（<code>Parallel</code>）</h4><blockquote>
<ul>
<li>当系统有一个以上<code>CPU</code>时，当一个<code>CPU</code>执行一个进程时，另一个<code>CPU</code>可以执行另一个进程，两个进程互不抢占<code>CPU</code>资源，可以同时进行，我们称之为并行（<code>Parallel</code>）。</li>
<li>其实决定并行的因素不是<code>CPU</code>的数量，而是<code>CPU</code>的核心数量，比如一个<code>CPU</code>多个核也可以并行。</li>
<li>适合科学计算，后台处理等弱交互场景</li>
<li><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/6916a4ba-74ee-4078-bef9-3681a564c8b5.png"></li>
</ul>
</blockquote>
<h4 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h4><blockquote>
<ul>
<li><p>并发，指的是多个事情，在同一时间段内同时发生了。 </p>
</li>
<li><p>并行，指的是多个事情，在同一时间点上同时发生了。 </p>
</li>
<li><p>并发的多个任务之间是互相抢占资源的。 </p>
</li>
<li><p>并行的多个任务之间是不互相抢占资源的。 </p>
</li>
<li><p>只有在多 <code>CPU</code>或者一个<code>CPU</code>多核的情况中，才会发生并行。 </p>
</li>
<li><p>否则，看似同时发生的事情，其实都是并发执行的。</p>
</li>
</ul>
</blockquote>
<h4 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h4><blockquote>
<h6 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（<code>Parallel</code>）</h6><p>​	<strong>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</strong>。如<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Parallel Old</code>；</p>
<h6 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（<code>Serial</code>）</h6><p>​	相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动<code>JVM</code>垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/786e856c-3dfb-4346-9f6f-2740eab133af.png"></p>
<h6 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（<code>Concurrent</code>）</h6><p>​	指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个 <code>CPU</code> 上；如：<code>CMS</code>、<code>G1</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/eed9d7bb-322e-4259-981f-ace5cfc6e1c9.png"></p>
</blockquote>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg"></p>
<p>以上是 <code>HotSpot</code> 虚拟机中的 <code>7</code> 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
</ul>
</blockquote>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><blockquote>
<ul>
<li>多线程堆内存较大，多核 <code>CPU</code></li>
<li>让单位时间内，<code>STW</code> 的时间最短    </li>
<li>例如一个小时发生了 <code>2</code> 次 <code>STW</code>，每次 <code>0.2</code> 秒，共 <code>0.4</code> 秒，强调总的时间最短</li>
</ul>
</blockquote>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 <code>CPU</code> </li>
<li>尽可能让单次 <code>STW</code> 的时间最短</li>
<li>例如一个小时发生了 <code>5</code> 次 <code>STW</code>，每次 <code>0.1</code> 秒，共 <code>0.5</code> 秒，强调单次时间最短</li>
</ul>
</blockquote>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a><code>Serial</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg"></p>
<ul>
<li><code>Serial</code> 翻译为串行，也就是说它以串行的方式执行。</li>
<li>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</li>
<li>它的优点是简单高效，对于单个 <code>CPU</code> 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li>
<li>它是 <strong><code>Client</code> 模式下的默认新生代收集器</strong>，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</li>
</ul>
</blockquote>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a><code>ParNew</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg"></p>
<ul>
<li>它是 <code>Serial</code> 收集器的多线程版本。</li>
<li>是 <strong><code>Server</code> 模式下的虚拟机首选新生代收集器</strong>，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</li>
<li><strong>默认开启的线程数量与 <code>CPU</code> 数量相同</strong>，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</li>
</ul>
</blockquote>
<p><code>Parallel Scavenge</code> 收集器</p>
<blockquote>
<ul>
<li><p>与 <code>ParNew</code> 一样是多线程收集器。</p>
</li>
<li><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为<strong>“吞吐量优先”收集器</strong>。这里的吞吐量指 <code>CPU</code> 用于运行用户代码的时间占总时间的比值。</p>
</li>
<li><p>吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)</p>
</li>
<li><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 <code>CPU</code> 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
</li>
<li><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
</li>
<li><p>可以通过一个开关参数打卡 <code>GC</code> 自适应的调节策略(<code>GC Ergonomics</code>)，就不需要手工指定新生代的大小(<code>-Xmn</code>)、<code>Eden</code> 和 <code>Survivor</code> 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</li>
</ul>
</blockquote>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><code>Serial Old</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg"></p>
<p>​	是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在 <code>Server</code> 模式下，它有两大用途:</p>
<ul>
<li>在 <code>JDK 1.5</code> 以及之前版本(<code>Parallel Old</code> 诞生以前)中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li>
<li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li>
</ul>
</blockquote>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><code>Parallel Old</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/278fe431-af88-4a95-a895-9c3b80117de3.jpg"></p>
<ul>
<li><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p>
</li>
<li><p>在注重吞吐量以及 <code>CPU</code> 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p>
</li>
</ul>
</blockquote>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a><code>CMS</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/46c061c6-8a27-4222-9ff7-6cf71b63b40a.png"></p>
<p>​	<code>CMS</code>(<code>Concurrent Mark Sweep</code>)，<code>Mark Sweep</code> 指的是标记 - 清除算法。</p>
<p>​	<code>CMS</code>收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>​	不幸的是，<code>CMS</code> 作为老年代的收集器，却无法与 <code>JDK1.4.0</code> 中已经存在的新生代收集器 <code>Parallel Scavenge</code> 配合工作，所以在 <code>JDK1.5</code>中使用<code>CMS</code>来收集老年代的时候，新生代只能选择<code>ParNew</code>或者<code>Serial</code>收集器中的一个。</p>
<p>分为以下四个流程:</p>
<ul>
<li><p><strong>初始标记</strong>（<code>Initial-Mark</code>）阶段：在这个阶段中，程序中所有的工作线程都将会因为“<code>Stop-the-World</code>”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出<code>GCRoots</code>能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p><strong>并发标记</strong>（<code>Concurrent-Mark</code>）阶段：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p><strong>重新标记</strong>（<code>Remark</code>）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间(<code>STW</code>)通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</strong>。</p>
</li>
<li><p><strong>并发清除</strong>（<code>Concurrent-Sweep</code>）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
</ul>
<p>​    尽管<code>CMS</code>收集器采用的是并发回收（非独占式），但是在其初始化标记和重新标记这两个阶段中仍然需要执行“<code>Stop-the-World</code>”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“<code>stop-the-World</code>”，只是尽可能地缩短暂停时间。 </p>
<p>​	由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。  </p>
<p>​	另外，由于在垃圾收集阶段用户线程没有中断，所以在<code>CMS</code>回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，**<code>CMS</code>收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在<code>CMS</code>工作过程中依然有足够的空间支持应用程序运行。**要是<code>CMS</code>运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用<code>Serial Old</code>收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>​	<code>CMS</code>收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么<code>CMS</code>在为新对象分配内存空间时，将无法使用指针碰撞（<code>Bump the Pointer</code>）技术，而只能够选择空闲列表（<code>Free List</code>）执行内存分配。</p>
<p>​	指针碰撞：<code>Java</code>堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：<code>Serial、ParNew</code>等收集器。指针碰撞技术会跟踪在<code>Eden</code>空间创建的最后一个对象，这个对象会被放在伊甸园空间的顶部。如果之后再需要创建对象，只需要检查伊甸园空间是否有足够的剩余空间。如果有足够的空间，对象就会被创建在伊甸园空间，并且被放置在顶部。这样一来，每次创建新的对象时，只需要检查最后被创建的对象。这将极大地加快内存分配速度。但是，如果我们在多线程的情况下，事情将截然不同。如果想要以线程安全的方式以多线程在伊甸园空间存储对象，不可避免的需要加锁，而这将极大地的影响性能。**<code>TLAB</code>** 是<code>HotSpot</code>虚拟机针对这一问题的解决方案。该方案为每一个线程在伊甸园空间分配一块独享的空间，这样每个线程只访问他们自己的<code>TLAB</code>空间，再与<code>bump-the-pointer</code>技术结合可以在不加锁的情况下分配内存。</p>
<h6 id="并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？"><a href="#并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？" class="headerlink" title="并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？"></a>并发垃圾收集器（<code>CMS</code>）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？</h6><p>答案：分代式<code>GC</code>里，年老代常用<code>mark-sweep</code>；或者是<code>mark-sweep/mark-compact</code>的混合方式，一般情况下用<code>mark-sweep</code>，统计估算碎片量达到一定程度时用<code>mark-compact</code>。<strong>这是因为传统上大家认为年老代的对象可能会长时间存活且存活率高，或者是比较大，这样拷贝起来不划算，还不如采用就地收集的方式。</strong>因为<code>CMS</code>作为第一款实现用户线程和收集线程并发执行的收集器！当时的设计理念是减少停顿时间，最好是能并发执行！但是问题来了，<strong>如要用户线程也在执行，那么就不能轻易的改变堆中对象的内存地址！不然会导致用户线程无法定位引用对象，从而无法正常运行！而标记整理算法和复制算法都会移动存活的对象，</strong>这就与上面的策略不符！因此<code>CMS</code>采用的是标记清理算法！</p>
<h6 id="CMS-出现Full-GC的原因："><a href="#CMS-出现Full-GC的原因：" class="headerlink" title="CMS 出现Full GC的原因："></a><code>CMS</code> 出现<code>Full GC</code>的原因：</h6><p><strong>1、年轻代晋升到老年代没有足够的连续空间，很有可能是内存碎片导致的，因此会触发<code>FULL GC</code></strong></p>
<p>2、在并发过程中<code>JVM</code>觉得在并发过程结束之前堆就会满，需要提前触发<code>Full GC</code></p>
<h6 id="CMS的优点"><a href="#CMS的优点" class="headerlink" title="CMS的优点"></a><code>CMS</code>的优点</h6><ul>
<li><p>并发收集</p>
</li>
<li><p>低延迟</p>
</li>
</ul>
<h6 id="CMS的弊端"><a href="#CMS的弊端" class="headerlink" title="CMS的弊端"></a><code>CMS</code>的弊端</h6><ul>
<li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发<code>Full GC</code>。</p>
</li>
<li><p><code>CMS</code>收集器对<code>CPU</code>资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p><code>CMS</code>收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次<code>Full GC</code>的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，<code>CMS</code>将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行<code>GC</code>时释放这些之前未被回收的内存空间。</p>
</li>
</ul>
</blockquote>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a><code>G1</code> 收集器</h4><blockquote>
<p>​	<code>G1</code>收集器伴随<code>JAVA9</code>于<code>2017-9-21</code>发布,<code>G1</code>收集器兼顾低延迟和高吞吐在服务端运行,<code>HotSpot</code>团队期望取代<code>CMS</code>收集器。也就是在满足停顿时间的情况下获取最大的吞度量。有两种收集模式<code>Young GC</code>和<code>Mixed GC</code>。<code>G1</code>收集器将堆内存划分成大小相等的<code>Region</code>,新生代,老年代也就成了逻辑概念。整体上采用的是标记-整理算法,局部采用了复制算法。</p>
</blockquote>
<h5 id="G1回收器的特点（优势）"><a href="#G1回收器的特点（优势）" class="headerlink" title="G1回收器的特点（优势）"></a><code>G1</code>回收器的特点（优势）</h5><h6 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h6><blockquote>
<ul>
<li><p>并行性：<code>G1</code>在回收期间，可以有多个<code>GC</code>线程同时工作，有效利用多核计算能力。此时用户线程STW</p>
</li>
<li><p>并发性：<code>G1</code>拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>
</li>
</ul>
</blockquote>
<h6 id="分代收集-1"><a href="#分代收集-1" class="headerlink" title="分代收集"></a>分代收集</h6><blockquote>
<ul>
<li><p>从分代上看，<code>G1</code>依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有<code>Eden</code>区和Survivor区。但从堆的结构上看，它不要求整个<code>Eden</code>区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p>将堆空间分为若干个区域（<code>Region</code>），这些区域中包含了逻辑上的年轻代和老年代。</p>
</li>
<li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</p>
</li>
<li><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/4c820316-e12f-42ff-943d-e56286de1d7b.png"></p>
</li>
</ul>
</blockquote>
<h6 id="G1的内存模型空间整合"><a href="#G1的内存模型空间整合" class="headerlink" title="G1的内存模型空间整合"></a><code>G1</code>的内存模型空间整合</h6><blockquote>
<ul>
<li><p><code>CMS</code>：“标记-清除”算法、内存碎片、若干次<code>GC</code>后进行一次碎片整理</p>
</li>
<li><p><code>G1</code>将内存划分为一个个的<code>region</code>。内存的回收是以<code>region</code>作为基本单位的。<code>Region</code>之间是复制算法，但整体上实际可看作是标记-压缩（<code>Mark-Compact</code>）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次<code>GC</code>。尤其是当Java堆非常大的时候，<code>G1</code>的优势更加明显。</p>
</li>
</ul>
</blockquote>
<h6 id="可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时soft real-time）"></a>可预测的停顿时间模型（即：软实时<code>soft real-time</code>）</h6><blockquote>
<p>这是<code>G1</code>相对于<code>CMS</code>的另一大优势，<code>G1</code>除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为<code>M</code>毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li><p>由于分区的原因，<code>G1</code>可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p>
</li>
<li><p><code>G1</code>跟踪各个<code>Region</code>里面的垃圾堆积的价值大小（<strong>回收所获得的空间大小以及回收所需时间的经验值</strong>），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的<code>Region</code>。保证了<code>G1</code>收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>相比于<code>CMS GC</code>，<code>G1</code>未必能做到<code>CMS</code>在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
</ul>
</blockquote>
<h5 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a><code>G1</code>垃圾收集器的缺点</h5><blockquote>
<p>相较于<code>CMS</code>，<code>G1</code>还不具备全方位、压倒性优势。比如在用户程序运行过程中，<code>G1</code>无论是为了垃圾收集产生的内存占用（<code>Footprint</code>）还是程序运行时的额外执行负载（<code>Overload</code>）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上<code>CMS</code>的表现大概率会优于<code>G1</code>，而<code>G1</code>在大内存应用上则发挥其优势。平衡点在<code>6-8 GB</code>之间。</p>
</blockquote>
<h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><blockquote>
<p>1、<code>G1</code>分区示意图</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-1.jpeg"></p>
<p>2、分区<code>Region</code></p>
<p>​	<code>G1</code>采用了分区(<code>Region</code>)的思路，将整个堆空间分成若干个<strong>大小相等</strong>的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，<code>G1</code>并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数&#96;&#96;-XX:G1HeapRegionSize&#x3D;n<code>可指定分区大小(</code>1MB~32MB<code>，且必须是</code>2<code>的幂)，默认将整堆划分为</code>2048&#96;个分区。</p>
<p>3、卡片<code>Card</code></p>
<p>​	在每个分区内部又被分成了若干个大小为<code>512Byte</code>卡片(<code>Card</code>)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(<code>Global Card Table</code>)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见<code>RSet</code>)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<p>4、堆<code>Heap</code></p>
<p>​	<code>G1</code>同样可以通过<code>-Xms/-Xmx</code>来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算<code>GC</code>与应用的耗费时间比，自动调整堆空间大小。如果<code>GC</code>频率太高，则通过增加堆尺寸，来减少<code>GC</code>频率，相应地<code>GC</code>占用的时间也随之降低；目标参数<code>-XX:GCTimeRatio</code>即为<code>GC</code>与应用的耗费时间比，<code>G1</code>默认为<code>9</code>，而<code>CMS</code>默认为<code>99</code>，因为<code>CMS</code>的设计原则是耗费在<code>GC</code>上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，<code>G1</code>会首先尝试增加堆空间，如果扩容失败，则发起担保的<code>Full GC</code>。<code>Full GC</code>后，堆尺寸计算结果也会调整堆空间。</p>
</blockquote>
<h5 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-2.jpeg"></p>
<p>1、分代垃圾收集</p>
<p>​	分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但<code>G1</code>依然使用了分代的思想。与其他垃圾收集器类似，<code>G1</code>将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为<code>Eden</code>空间和<code>Survivor</code>空间。<strong>但年轻代空间并不是固定不变的，当现有年轻代分区占满时，<code>JVM</code>会分配新的空闲分区加入到年轻代空间。</strong></p>
<p>​	整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆<code>5%</code>)与最大空间(默认<code>60%</code>)之间动态变化，且由参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认<code>200ms</code>)、需要扩缩容的大小以<code>-XX:G1MaxNewSizePercent</code>及分区的已记忆集合(<code>RSet</code>)计算得到。当然，<code>G1</code>依然可以设置固定的年轻代大小(参数<code>-XX:NewRatio、-Xmn</code>)，但同时暂停目标将失去意义.</p>
<p>2、本地分配缓冲 <code>Local allocation buffer (Lab)</code></p>
<p>​	值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和<code>GC</code>线程都会独立的使用分区，进而减少同步时间，提升<code>GC</code>效率，这个分区称为本地分配缓冲区(<code>Lab</code>)。</p>
<p>其中，应用线程可以独占一个本地缓冲区(<code>TLAB</code>)来创建的对象，而大部分都会落入<code>Eden</code>区域(巨型对象或分配失败除外)，因此<code>TLAB</code>的分区属于<code>Eden</code>空间；而每次垃圾收集时，每个<code>GC</code>线程同样可以独占一个本地缓冲区(<code>GCLAB</code>)用来转移对象，每次回收会将对象复制到<code>Suvivor</code>空间或老年代空间；对于从<code>Eden/Survivor</code>空间晋升(<code>Promotion</code>)到<code>Survivor</code>&#x2F;老年代空间的对象，同样有<code>GC</code>独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(<code>PLAB</code>)。</p>
</blockquote>
<h5 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a>分区模型</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-3.jpeg"></p>
<p>​	<strong><code>G1</code>对内存的使用以分区(<code>Region</code>)为单位，而对对象的分配则以卡片(<code>Card</code>)为单位。</strong></p>
<p>1、巨形对象(<code>Humongous Region</code>)</p>
<p>​	一个大小达到甚至超过分区大小一半的对象称为巨型对象(<code>Humongous Object</code>)。当线程为巨型分配空间时，不能简单在<code>TLAB</code>进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(<code>Humongous Region</code>)。**<code>G1</code>内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。**</p>
<p>​	巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(<code>StartsHumongous</code>)，相邻连续分区被标记为连续巨型(<code>ContinuesHumongous</code>)。由于无法享受<code>Lab</code>带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<p>2、已记忆集合<code>Remember Set (RSet)</code></p>
<p>​	在串行和并行收集器中，<code>GC</code>通过整堆扫描，来确定对象是否处于可达路径中。然而<code>G1</code>为了避免<code>STW</code>式的整堆扫描，在每个分区记录了一个已记忆集合(<code>RSet</code>)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的<code>RSet</code>，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>​	事实上，并非所有的引用都需要记录在<code>RSet</code>中，如果一个分区确定需要扫描，那么无需<code>RSet</code>也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入<code>RSet</code>中；同时，<code>G1 GC</code>每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在<code>RSet</code>中记录。最后只有老年代的分区可能会有<code>RSet</code>记录，这些分区称为拥有<code>RSet</code>分区。</p>
<p>3、<code>Per Region Table (PRT)</code></p>
<p>​	<code>RSet</code>在内部使用<code>Per Region Table(PRT)</code>记录分区的引用情况。由于<code>RSet</code>的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么<code>RSet</code>占用的空间会上升，从而降低分区的可用空间。<code>G1</code>应对这个问题采用了改变<code>RSet</code>的密度的方式，在<code>PRT</code>中将会以三种模式记录引用：</p>
<ul>
<li><p>稀少：直接记录引用对象的卡片索引</p>
</li>
<li><p>细粒度：记录引用对象的分区索引</p>
</li>
<li><p>粗粒度：只记录引用情况，每个分区对应一个比特位</p>
</li>
</ul>
<p>由上可知，粗粒度的<code>PRT</code>只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
</blockquote>
<h5 id="收集集合-CSet"><a href="#收集集合-CSet" class="headerlink" title="收集集合 (CSet)"></a>收集集合 (<code>CSet</code>)</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-4.jpeg"></p>
<p>​	收集集合(<code>CSet</code>)代表每次<code>GC</code>暂停时回收的一系列目标分区。在任意一次收集暂停中，<code>CSet</code>所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集<code>CSet</code>只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到<code>CSet</code>中。</p>
<p>​	候选老年代分区的<code>CSet</code>准入条件，可以通过活跃度阈值<code>-XX:G1MixedGCLiveThresholdPercent</code>(默认<code>85%</code>)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据<code>CSet</code>对堆的总大小占比<code>-XX:G1OldCSetRegionThresholdPercent</code>(默认<code>10%</code>)设置数量上限。</p>
<p>由上述可知，<code>G1</code>的收集都是根据<code>CSet</code>进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<p>1、年轻代收集集合 （<code>CSet of Young Collection</code>）</p>
<p>​	应用线程不断活动后，年轻代空间会被逐渐填满。当<code>JVM</code>分配对象到<code>Eden</code>区域失败(<code>Eden</code>区已满)时，便会触发一次<code>STW</code>式的年轻代收集。在年轻代收集中，<code>Eden</code>分区存活的对象将被拷贝到<code>Survivor</code>分区；原有<code>Survivor</code>分区存活的对象，将根据任期阈值(<code>tenuring threshold</code>)分别晋升到<code>PLAB</code>中，新的<code>survivor</code>分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>​	同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(<code>tenuring</code>)对象晋升的时候是到<code>Survivor</code>分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、<code>Survivor</code>尺寸、<code>Survivor</code>填充容量<code>-XX:TargetSurvivorRatio</code>(默认<code>50%</code>)、最大任期阈值<code>-XX:MaxTenuringThreshold</code>(默认<code>15</code>)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<p>2、混合收集集合 （<code>CSet of Mixed Collection</code>）</p>
<p>​	年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比<code>IHOP</code>阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(默认<code>45%</code>)时，<code>G1</code>就会启动一次混合垃圾收集周期。为了满足暂停目标，<code>G1</code>可能不能一口气将所有的候选分区收集掉，因此<code>G1</code>可能会产生连续多次的混合收集与应用线程交替执行，每次<code>STW</code>的混合收集与年轻代收集过程相类似。</p>
<p>​	为了确定包含到年轻代收集集合<code>CSet</code>的老年代分区，JVM通过参数混合周期的最大总次数<code>-XX:G1MixedGCCountTarget</code>(默认<code>8</code>)、堆废物百分比<code>-XX:G1HeapWastePercent</code>(默认<code>5%</code>)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到<code>CSet</code>的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到<code>CSet</code>的分区，则通过计算得到的<code>GC</code>效率进行安排。</p>
<p>并发标记算法（三色标记法）</p>
<p><code>CMS</code>和<code>G1</code>在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p>
<p><strong>白色</strong>：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚举完仍是白色的对象将会被当做垃圾对象被清理。 </p>
<p><strong>灰色</strong>：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有一个没有被访问到，表示这个对象正在枚举中。 </p>
<p><strong>黑色</strong>：对象和它所直接引用的所有对象都被访问过。这里只要访问过就行，比如<code>A</code>只引用了<code>B</code>，<code>B</code>引用了<code>C</code>、<code>D</code>，那么只要<code>A</code>和<code>B</code>都被访问过，<code>A</code>就是黑色，即使<code>B</code>所引用的<code>C</code>或<code>D</code>还没有被访问到，此时<code>B</code>就是灰色。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-5.png"></p>
<p><strong>根据这些定义，我们可以得出：</strong></p>
<p>​	在可达性分析的初始阶段，所有对象都是白色，一旦访问了这个对象，那么就变成灰色，一旦这个对象所有直接引用的对象都访问过（或者没有引用其它对象），那么就变成黑色 初始标记之后，<code>GC Root</code>节点变为黑色（<code>GC Root</code>不会是垃圾），<code>GC Root</code>直接引用的对象变为灰色 正常情况下，一个对象如果是黑色，那么其直接引用的对象要么是黑色，要么是灰色，不可能是白色（如果出现了黑色对象直接引用白色对象的情况，就说明漏标了，就会导致对象误删，后面会介绍如何解决），这个特性也可以说是三色标记算法正确性保障的前提条件。</p>
<p><strong>算法大致的流程是（初始状态所有对象都是白色）：</strong></p>
<p>​	首先我们从<code>GC Roots</code>开始枚举，它们所有的直接引用变为灰色，自己变为黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个队列中 然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没有直接引用，那么直接变成黑色 继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直重复直到灰色队列为空 分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理 最后重置标记状态</p>
</blockquote>
<p>前面的描述都比较抽象，这里以一个例子进行说明，假设现在有以下引用关系：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jhbugvyfctdxtcfygubhij.png"></p>
<p>首先，所有<code>GC Root</code>的直接引用（<code>A</code>、<code>B</code>、<code>E</code>）变为灰色，放入队列中，<code>GC Root</code>变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/nibuvcrtybyuiompo,[..png"></p>
<p>然后从队列中取出一个灰色对象进行分析，比如取出<code>A</code>对象，将它的直接引用<code>C</code>、<code>D</code>变为灰色，放入队列，<code>A</code>对象变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnihbugvfcdxrctfvybhj.png"></p>
<p>继续从队列中取出一个灰色对象，比如取出<code>B</code>对象，将它的直接引用<code>F</code>变为灰色，放入队列，<code>B</code>对象变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibhugvycftxetcryybiimop.png"></p>
<p>继续从队列中取出一个灰色对象<code>E</code>，但是E对象没有直接引用，变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhugvyfcdtfyvbhijnom,l.png"></p>
<p>同理依次取出<code>C</code>、<code>D</code>、<code>F</code>对象，他们都没有直接引用，那么变成黑色（这里就不一个一个的画了）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jkhjghftdrxtcfvgubhim.png"></p>
<blockquote>
<p><code>GC</code> 开始前所有对象都是白色，<code>GC</code> 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 <code>GC</code> 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-5-1.gif"></p>
<p>漏标问题</p>
<p>在<code>remark</code>过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色<code>D</code>对象当作没有新引用指向从而回收掉。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-6.png"></p>
<p>并发标记过程中，<code>Mutator</code>删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p>
<p>产生漏标问题的条件有两个：</p>
<ul>
<li>黑色对象指向了白色对象</li>
<li>灰色对象指向白色对象的引用消失</li>
</ul>
<p>所以要解决漏标问题，打破两个条件之一即可：</p>
<ul>
<li><strong>跟踪黑指向白的增加</strong> <code>incremental update</code>：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。<code>CMS</code>采用该方法。</li>
<li><strong>记录灰指向白的消失</strong> <code>SATB snapshot at the beginning</code>：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到<code>GC</code>的堆栈，保证白还能被<code>GC</code>扫描到。<code>G1</code>采用该方法。</li>
</ul>
<p>**为什么<code>G1</code>采用<code>SATB</code>而不用<code>incremental update</code>**？</p>
<p>因为采用<code>incremental update</code>把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。<code>G1</code>有<code>RSet</code>与<code>SATB</code>相配合。<code>Card Table</code>里记录了<code>RSet</code>，<code>RSet</code>里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描<code>RSet</code>就可以了。</p>
<p>也就是说 灰色–&gt;白色 引用消失时，如果没有 黑色–&gt;白色，引用会被<code>push</code>到堆栈，下次扫描时拿到这个引用，由于有<code>RSet</code>的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。<code>SATB</code>配合<code>RSet</code>浑然天成。</p>
</blockquote>
<h5 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a><code>G1</code>收集器的常见操作步骤</h5><blockquote>
<p><code>G1</code>的设计原则就是简化<code>JVM</code>性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li><p>第一步：开启<code>G1</code>垃圾收集器</p>
</li>
<li><p>第二步：设置堆的最大内存</p>
</li>
<li><p>第三步：设置最大的停顿时间</p>
</li>
</ul>
<p><code>G1</code>中提供了三种垃圾回收模式：<code>Young GC</code>、<code>Mixed GC</code>和<code>Full GC</code>，在不同的条件下被触发。</p>
</blockquote>
<h5 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a><code>G1</code>收集器的适用场景</h5><blockquote>
<p>​	面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>​	最主要的应用是需要低<code>GC</code>延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约<code>6GB</code>或更大时，可预测的暂停时间可以低于<code>0.5</code>秒；（<code>G1</code>通过每次只清理一部分而不是全部的<code>Region</code>的增量式清理来保证每次<code>GC</code>停顿时间不会过长）。</p>
<p>用来替换掉<code>JDK1.5</code>中的<code>CMS</code>收集器；在下面的情况时，使用<code>G1</code>可能比<code>CMS</code>好：</p>
<ul>
<li><p>超过<code>50%</code>的<code>Java</code>堆被活动数据占用；</p>
</li>
<li><p>对象分配频率或年代提升频率变化很大；</p>
</li>
<li><p><code>GC</code>停顿时间过长（长于<code>0.5</code>至<code>1</code>秒）</p>
</li>
</ul>
<p><strong><code>HotSpot</code>垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的<code>JVM</code>线程执行<code>GC</code>的多线程操作，而<code>G1 GC</code>可以采用应用线程承担后台运行的<code>GC</code>工作，即当<code>JVM</code>的<code>GC</code>线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</strong></p>
</blockquote>
<h5 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区<code>Region</code>：化整为零</h5><blockquote>
<p>​	使用<code>G1</code>收集器时，它将整个<code>Java</code>堆划分成约**<code>2048</code><strong>个大小相同的独立<code>Region</code>块，每个<code>Region</code>块大小根据堆空间的实际大小而定，</strong>整体被控制在<code>1MB</code>到<code>32MB</code>之间，且为<code>2</code>的<code>N</code>次幂**，即<code>1MB，2MB，4MB，8MB，16MB，32MB</code>。可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的<code>Region</code>大小相同，且在<code>JVM</code>生命周期内不会被改变。</p>
<p>​	虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分<code>Region</code>（不需要连续）的集合。通过<code>Region</code>的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/a5e91275-9f8c-4ea8-a34e-e20d3624a88a.png"></p>
<p>​	一个<code>region</code>有可能属于<code>Eden</code>，<code>Survivor</code>或者<code>Old/Tenured</code>内存区域。但是一个<code>region</code>只可能属于一个角色。图中的<code>E</code>表示该<code>region</code>属于<code>Eden</code>内存区域，<code>S</code>表示属于<code>survivor</code>内存区域，<code>O</code>表示属于<code>Old</code>内存区域。图中空白的表示未使用的内存空间。</p>
<p>​	<code>G1</code>垃圾收集器还增加了一种新的内存区域，叫做<code>Humongous</code>内存区域，如图中的H块。主要用于存储大对象，<strong>如果超过<code>1.5</code>个<code>region</code>，就放到<code>Humongous</code>。</strong></p>
<p>​	设置<code>Humongous</code>的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，<code>G1</code>划分了一个<code>Humongous</code>区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么<code>G1</code>会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动<code>Full GC</code>。**<code>G1</code>的大多数行为都把<code>Humongous</code>区作为老年代的一部分来看待。**</p>
<p>​	每个<code>Region</code>都是通过指针碰撞来分配空间</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/96f629bc-62b5-45ca-8fa5-553a099ca2b5.png"></p>
</blockquote>
<h5 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a><code>G1</code>垃圾回收器的回收过程</h5><blockquote>
<p><code>G1 GC</code>的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代<code>GC（Young GC） </code></p>
</li>
<li><p>老年代并发标记过程<code>（Concurrent Marking） </code></p>
</li>
<li><p>混合回收<code>（Mixed GC）</code><br>（如果需要，单线程、独占式、高强度的<code>Full GC</code>还是继续存在的。它针对<code>GC</code>的评估失败提供了一种失败保护机制，即强力回收。）</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/96bc3935-7c03-4e0e-bece-57f0eee1303e.png"></p>
<p>​	顺时针，<code>Young gc</code> -&gt; <code>Young gc</code> + <code>Concurrent mark</code>-&gt;<code>Mixed GC</code>顺序，进行垃圾回收。</p>
<p>​	应用程序分配内存，当年轻代的<code>Eden</code>区用尽时开始年轻代回收过程；<code>G1</code>的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，<code>G1 GC</code>暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到<code>Survivor</code>区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>​	当堆内存使用达到一定值（默认<code>45%</code>）时，开始老年代并发标记过程。</p>
<p>​	标记完成马上开始混合回收过程。对于一个混合回收期，<code>G1 GC</code>从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的<code>G1</code>回收器和其他<code>GC</code>不同，<code>G1</code>的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的<code>Region</code>就可以了。同时，这个老年代<code>Region</code>是和年轻代一起被回收的。</p>
<p>​	举个例子：一个<code>Web</code>服务器，<code>Java</code>进程最大堆内存为<code>4G</code>，每分钟响应<code>1500</code>个请求，每<code>45</code>秒钟会新分配大约<code>2G</code>的内存。<code>G1</code>会每<code>45</code>秒钟进行一次年轻代回收，每<code>31</code>个小时整个堆的使用率会达到<code>45%</code>，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
</blockquote>
<h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a><code>Remembered Set</code></h5><blockquote>
<ul>
<li><p>一个对象被不同区域引用的问题 </p>
</li>
<li><p>一个<code>Region</code>不可能是孤立的，一个<code>Region</code>中的对象可能被其他任意<code>Region</code>中对象引用，判断对象存活时，是否需要扫描整个<code>Java</code>堆才能保证准确？ </p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而<code>G1</code>更突出）回收新生代也不得不同时扫描老年代？ </p>
</li>
<li><p>这样的话会降低<code>Minor GC</code>的效率；</p>
</li>
</ul>
<h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><ul>
<li><p>无论<code>G1</code>还是其他分代收集器，<code>JVM</code>都是使用<code>Remembered Set</code>来避免全局扫描：</p>
</li>
<li><p>每个<code>Region</code>都有一个对应的<code>Remembered Set</code>； </p>
</li>
<li><p>每次<code>Reference</code>类型数据写操作时，都会产生一个<code>Write Barrier</code>暂时中断操作；</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该<code>Reference</code>类型数据在不同的<code>Region</code>（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li><p>如果不同，通过<code>Card Table</code>把相关引用信息记录到引用指向对象的所在<code>Region</code>对应的<code>Remembered Set</code>中；</p>
</li>
<li><p>当进行垃圾收集时，在<code>GC</code>根节点的枚举范围加入<code>Remembered Set</code>；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1c48bcfc-fa6f-4309-b0a6-92820e401504.png"></p>
</blockquote>
<h5 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a><code>G1</code>回收过程一：年轻代<code>GC</code></h5><blockquote>
<p>​	<code>JVM</code>启动时，<code>G1</code>先准备好<code>Eden</code>区，程序在运行过程中不断创建对象到<code>Eden</code>区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>​	<strong>年轻代垃圾回收只会回收<code>Eden</code>区和<code>Survivor</code>区。</strong>	</p>
<p>​	首先<code>G1</code>停止应用程序的执行（<code>Stop-The-World</code>），<code>G1</code>创建回收集（<code>Collection Set</code>），回收集是指需要被回收的内存分段的集合，<strong>年轻代回收过程的回收集包含年轻代<code>Eden</code>区和<code>Survivor</code>区所有的内存分段。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/b22d93c2-2a69-46e0-88b0-4130dea1d2d6.png"></p>
<p>然后开始如下回收过程：</p>
<p><strong>第一阶段，扫描<code>GCRoot</code>寻找可达对象</strong><br>    根是指<code>static</code>变量指向的对象，正在执行的方法调用链条上的局部变量等。<br>    根据扫描到的可达对象, 以及关联的<code>RSet</code>的外部对象都作为 可达对象。<br><strong>第二阶段，更新<code>RSet</code></strong><br>    处理<code>dirty card queue</code>（见备注）中的<code>card</code>，更新<code>RSet</code>。<br>    此阶段完成后，<code>RSet</code>可以准确的反映老年代对所在的内存分段中对象的引用。<br><strong>第三阶段，处理<code>RSet</code></strong><br>    识别被老年代对象指向的<code>Eden</code>中的对象，这些被指向的<code>Eden</code>中的对象被认为是存活的对象。<br><strong>第四阶段，复制对象。(<code>Eden</code>中的对象复制到<code>Survivor</code>中)</strong><br>    此阶段，对象树被遍历，<code>Eden</code>区内存段中存活的对象会被复制到<code>Survivor</code>区中空的内存分段，<code>Survivor</code>区内存段中存活的对象<br>    如果年龄未达阈值，年龄会加<code>1</code>，达到阀值会被会被复制到<code>Old</code>区中空的内存分段。<br>    如果<code>Survivor</code>空间不够，<code>Eden</code>空间的部分数据会直接晋升到老年代空间。<br><strong>第五阶段，处理引用</strong><br>    处理<code>Soft，Weak，Phantom，Final，JNI Weak</code> 等引用。最终<code>Eden</code>空间的数据为空，<code>GC</code>停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
</blockquote>
<blockquote>
<p>备注：增加对象引用, 通过<code>Region</code>的记忆集</p>
<ol>
<li>对于应用程序的引用赋值语句 <code>oldObject.field=new Object()</code>，<code>JVM</code>会在之前和之后执行特殊的操作以在<code>dirty card queue</code>中入队一个保存了对象引用信息的<code>card</code> (卡表)。</li>
<li>在年轻代回收的时候，<code>G1</code>会对<code>Dirty Card Queue</code>中所有的<code>card</code>进行处理，以更新<code>RSet</code>，保证<code>RSet</code>实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新<code>RSet</code>呢？这是为了性能的需要，<code>RSet</code>的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ol>
</blockquote>
<h5 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a><code>G1</code>回收过程二：并发标记过程</h5><blockquote>
<p>​	当越来越多的对象晋升到老年代<code>Old Region</code>时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即<code>Mixed GC</code>， 该算法并不是一个<code>Old GC</code>，除了回收整个<code>Young Region</code>，还会回收一部分的<code>Old Region</code>。<br>​	这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些<code>Old Region</code>进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<code>Mixed GC</code>并不是<code>Full GC</code>。</p>
</blockquote>
<blockquote>
<p><strong>初始标记阶段：</strong>标记从根节点直接可达的对象。这个阶段是<code>STW</code>的，并且会触发一次年轻代<code>GC</code>。正是由于该阶段时<code>STW</code>的，所以我们只扫描根节点可达的对象，以节省时间。<br><strong>根区域扫描（<code>Root Region Scanning</code>）：</strong><code>G1 GC</code>扫描<code>Survivor</code>区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在<code>Young GC</code>之前完成，因为<code>Young GC</code>会使用复制算法对<code>Survivor</code>区进行<code>GC</code>。<br><strong>并发标记（<code>Concurrent Marking</code>）：</strong>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被<code>Young GC</code>中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。(为了选择性回收<code>Region</code>)<br><strong>再次标记（<code>Remark</code>）：</strong>由于应用程序持续进行，需要修正上一次的标记结果。是<code>STW</code>的。<code>G1</code>中采用了比<code>CMS</code>更快的初始快照算法：<code>Snapshot-At-The-Beginning（SATB）</code>。<br><strong>独占清理（<code>cleanup，STW</code>）：</strong>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是<code>STW</code>的。这个阶段并不会实际上去做垃圾的收集<br><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p>
</blockquote>
<h5 id="G1回收过程三：混合回收"><a href="#G1回收过程三：混合回收" class="headerlink" title="G1回收过程三：混合回收"></a><code>G1</code>回收过程三：混合回收</h5><blockquote>
<p>​	当越来越多的对象晋升到老年代<code>old region</code>时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即<code>Mixed GC</code>，该算法并不是一个<code>Old GC</code>，除了回收整个<code>Young Region</code>，还会回收一部分的<code>Old Region</code>。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些<code>Old Region</code>进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<code>Mixed GC</code>并不是<code>Full GC</code>。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1476cd19-28a1-46c5-a469-b4837ce165a4.png"></p>
<blockquote>
<p>​	并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。<br>​	默认情况下，这些老年代的内存分段会分<code>8</code>次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收<br>​	混合回收的回收集（<code>Collection Set</code>）包括八分之一的老年代内存分段，<code>Eden</code>区内存分段，<code>Survivor</code>区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。<br>​	由于老年代中的内存分段默认分<code>8</code>次回收，<code>G1</code>会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。<br>​	<code>XX:G1MixedGCLiveThresholdPercent</code>，默认为<code>65%</code>，意思是垃圾占内存分段比例要达到<code>65%</code>才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。<br>​	混合回收并不一定要进行<code>8</code>次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为<code>10%</code>，意思是允许整个堆内存中有<code>10%</code>的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于<code>10%</code>，则不再进行混合回收。因为<code>GC</code>会花费很多的时间但是回收到的内存却很少。</p>
</blockquote>
<h5 id="G1回收可选的过程四：Full-GC"><a href="#G1回收可选的过程四：Full-GC" class="headerlink" title="G1回收可选的过程四：Full GC"></a><code>G1</code>回收可选的过程四：<code>Full GC</code></h5><blockquote>
<p>​	<code>G1</code>的初衷就是要避免<code>Full GC</code>的出现。但是如果上述方式不能正常工作，<code>G1</code>会停止应用程序的执行（<code>Stop-The-World</code>），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>​	要避免<code>Full GC</code>的发生，一旦发生需要进行调整。什么时候会发生<code>Full GC</code>呢？比如堆内存太小，当<code>G1</code>在复制存活对象的时候没有空的内存分段可用，则会回退到<code>Full GC</code>，这种情况可以通过增大内存解决。</p>
<p>导致<code>G1 Full GC</code>的原因可能有两个：</p>
<ul>
<li><p><code>Evacuation</code>的时候没有足够的<code>to-space</code>来存放晋升的对象；</p>
</li>
<li><p>并发处理过程完成之前空间耗尽。</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">分类</th>
<th align="center">作用位置</th>
<th align="center">使用算法</th>
<th align="center">特点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Serial</code></td>
<td align="center">串行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单<code>CPU</code>环境下的<code>client</code>模式</td>
</tr>
<tr>
<td align="center"><code>ParNew</code></td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多<code>CPU</code>环境<code>Server</code>模式下与<code>CMS</code>配合使用</td>
</tr>
<tr>
<td align="center"><code>Parallel</code></td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="center"><code>Serial Old</code></td>
<td align="center">串行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-压缩算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单<code>CPU</code>环境下的<code>Client</code>模式</td>
</tr>
<tr>
<td align="center"><code>Parallel Old</code></td>
<td align="center">并行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-压缩算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="center"><code>CMS</code></td>
<td align="center">并发运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-清除算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于互联网或<code>B／S</code>业务</td>
</tr>
<tr>
<td align="center"><code>G1</code></td>
<td align="center">并发、并行运行</td>
<td align="center">作用于新生代、老年代</td>
<td align="center">标记-压缩算法、复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用</td>
</tr>
</tbody></table>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><blockquote>
<p><code>JVM</code>将类的加载分为<code>3</code>个步骤：</p>
<p>​	装载（<code>Load</code>）</p>
<p>​	链接（<code>Link</code>）</p>
<p>​	初始化（<code>Initialize</code>）</p>
<p>其中 链接（<code>Link</code>）又分<code>3</code>个步骤，如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_2.png"></p>
<p>​	在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持<code>Java</code>语言的运行时绑定（也成为动态绑定或晚期绑定）。<strong>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</strong></p>
</blockquote>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote>
<p>​	加载：指的是将类的<code>class</code>文件读入到内存，并为之创建一个<code>java.lang.Class</code>对象，也就是说，当程序中使用任何类时，系统都会为之建立一个<code>java.lang.Class</code>对象。</p>
<p>​	类的加载由类加载器完成，类加载器通常由<code>JVM</code>提供，这些类加载器也是前面所有程序运行的基础，<code>JVM</code>提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承<code>ClassLoader</code>基类来创建自己的类加载器。</p>
<p><strong>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载<code>.class</code>文件</li>
<li>从<code>zip，jar</code>等归档文件中加载<code>.class</code>文件</li>
<li>从专有数据库中提取<code>.class</code>文件</li>
<li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li>
</ul>
<p><strong>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</strong></p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。（<strong>全限定类名：</strong>就是类名全称，带包路径的用点隔开，例如: <code>java.lang.String。</code>）</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在<code>Java</code>堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_1.png"></p>
<p>​	相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>​	加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在<code>Java</code>堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>​	类加载器并不需要等到某个类被“首次主动使用”时再加载它，<code>JVM</code>规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(<code>LinkageError</code>错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote>
<p>验证：是连接阶段的第一步，这一阶段的目的是为了确保<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成<code>4</code>个阶段的检验动作:</p>
<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合<code>Class</code>文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合<code>Java</code>语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p>
</blockquote>
</blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>为类的静态变量分配内存，并将其初始化为默认值</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p>
<ul>
<li><p>这时候进行内存分配的<strong>仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</strong></p>
</li>
<li><p><strong>这里所设置的初始值通常情况下是数据类型默认的零值</strong>(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何<code>Java</code>方法，而把<code>value</code>赋值为<code>3</code>的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把<code>value</code>赋值为<code>3</code>的动作将在初始化阶段才会执行。</p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>对基本数据类型来说，对于类变量<code>(static)</code>和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</strong></li>
<li><strong>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</strong></li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量<code>value</code>就会被初始化为<code>ConstValue</code>属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时<code>Javac</code>将会为<code>value</code>生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将<code>value</code>赋值为<code>3</code>。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
</blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
</blockquote>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote>
<p>初始化，为类的静态变量赋予正确的初始值，<code>JVM</code>负责对类进行初始化，主要对类变量进行初始化。在<code>Java</code>中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>类访问方法区内的数据结构的接口， 对象是<code>Heap</code>区的数据。</p>
</blockquote>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><blockquote>
<p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致<code>Java</code>虚拟机进程终止</li>
</ul>
</blockquote>
<h3 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h3><blockquote>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h4><blockquote>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_3.png"></p>
<p>​	站在<code>Java</code>虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用<code>C++</code>实现(这里仅限于<code>Hotspot</code>，也就是<code>JDK1.5</code>之后默认的虚拟机，有很多其他的虚拟机是用<code>Java</code>语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
</blockquote>
<h5 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，<code>Bootstrap ClassLoader</code>）</h5><blockquote>
<ul>
<li><p>这个类加载使用<code>C/C++</code>语言实现的，嵌套在<code>JVM</code>内部。</p>
</li>
<li><p>它用来加载<code>Java</code>的核心库（<code>JAVA_HOME/jre/lib/rt.jar、resources.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供<code>JVM</code>自身需要的类</p>
</li>
<li><p>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，<code>Bootstrap</code>启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类</p>
</li>
</ul>
</blockquote>
<h5 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（<code>Extension ClassLoader</code>）</h5><blockquote>
<ul>
<li><p><code>Java</code>语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</p>
</li>
<li><p>派生于<code>ClassLoader</code>类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从<code>JDK</code>的安装目录的<code>jre/1ib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的<code>JAR</code>放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
</blockquote>
<h5 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，<code>AppClassLoader</code>）</h5><blockquote>
<ul>
<li><p><code>java</code>语言编写，由<code>sun.misc.LaunchersAppClassLoader</code>实现</p>
</li>
<li><p>派生于<code>ClassLoader</code>类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</p>
</li>
<li><p>该类加载是程序中默认的类加载器，一般来说，<code>Java</code>应用的类都是由它来完成加载</p>
</li>
<li><p>通过<code>ClassLoader#getSystemclassLoader()</code> 方法可以获取到该类加载器</p>
</li>
</ul>
</blockquote>
<h5 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h5><blockquote>
<p>​	在<code>Java</code>的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p>
<ul>
<li><p>隔离加载类</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>扩展加载源</p>
</li>
<li><p>防止源码泄漏</p>
</li>
</ul>
</blockquote>
<p>用户自定义类加载器实现步骤：</p>
<blockquote>
<ul>
<li><p>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</p>
</li>
<li><p>在<code>JDK1.2</code>之前，在自定义类加载器时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass()</code> 方法，从而实现自定义的类加载类，但是在<code>JDK1.2</code>之后已不再建议用户去覆盖<code>loadclass()</code> 方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中</p>
</li>
<li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
</li>
</ul>
</blockquote>
<h4 id="获取ClassLoader的途径"><a href="#获取ClassLoader的途径" class="headerlink" title="获取ClassLoader的途径"></a>获取<code>ClassLoader</code>的途径</h4><h5 id="获取当前ClassLoader"><a href="#获取当前ClassLoader" class="headerlink" title="获取当前ClassLoader"></a>获取当前<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取当前线程上下文的ClassLoader"><a href="#获取当前线程上下文的ClassLoader" class="headerlink" title="获取当前线程上下文的ClassLoader "></a>获取当前线程上下文的<code>ClassLoader </code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取系统的ClassLoader"><a href="#获取系统的ClassLoader" class="headerlink" title="获取系统的ClassLoader"></a>获取系统的<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取调用者的ClassLoader"><a href="#获取调用者的ClassLoader" class="headerlink" title="获取调用者的ClassLoader"></a>获取调用者的<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>

<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><h4 id="类加载有三种方式"><a href="#类加载有三种方式" class="headerlink" title="类加载有三种方式"></a>类加载有三种方式</h4><blockquote>
<ul>
<li>命令行启动应用时候由<code>JVM</code>初始化加载</li>
<li>通过<code>Class.forName()</code>方法动态加载</li>
<li>通过<code>ClassLoader.loadClass()</code>方法动态加载</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loaderTest</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;, false, loader); </span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别?"></a><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>区别?</h4><blockquote>
<ul>
<li><code>Class.forName()</code>: 将类的<code>.class</code>文件加载到<code>jvm</code>中之外，还会对类进行解释，执行类中的<code>static</code>块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将<code>.class</code>文件加载到<code>jvm</code>中，不会执行static中的内容,只有在<code>newInstance</code>才会去执行<code>static</code>块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载<code>static</code>块。并且只有调用了<code>newInstance()</code>方法采用调用构造函数，创建类的对象 。</li>
</ul>
</blockquote>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote>
<p>​	<code>Java</code>虚拟机对<code>class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>class</code>文件加载到内存生成<code>class</code>对象。而且加载某个类的<code>class</code>文件时，<code>Java</code>虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
</blockquote>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><blockquote>
<ul>
<li>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个<code>class</code>时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ul>
</blockquote>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                         <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = findBootstrapClass0(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tomcat如何破坏双亲委派机制"><a href="#Tomcat如何破坏双亲委派机制" class="headerlink" title="Tomcat如何破坏双亲委派机制"></a>Tomcat如何破坏双亲委派机制</h4><h5 id="为什么要打破双亲委派"><a href="#为什么要打破双亲委派" class="headerlink" title="为什么要打破双亲委派"></a>为什么要打破双亲委派</h5><blockquote>
<p>​	Tomcat中会部署多个应用(webapp)，每个应用可能会出现相同的类名，或者引用相同的jar包但<strong>版本不同</strong>，若使用双亲委派，一个类只会加载一次，项目就互相之间有冲突，若打破双亲委派，可以实现各自的应用加载自己应用的类，互不影响。</p>
</blockquote>
<h5 id="Tomcat如何实现多个Web应用的隔离"><a href="#Tomcat如何实现多个Web应用的隔离" class="headerlink" title="Tomcat如何实现多个Web应用的隔离"></a>Tomcat如何实现多个Web应用的隔离</h5><p>Tomcat作为一个Web服务器需要解决以下问题：</p>
<ul>
<li>多个Web应用隔离类库：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当可以保证两个应用程序的类库可以互相独立使用</li>
<li>多个Web应用共享类库：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。例如用户可能有10个使用Spring的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区很容易就会出现过度膨胀的风险</li>
<li>隔离Tomcat与Web应用的类：Tomcat服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响，服务器所使用的类库应该与应用程序的类库互相独立</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/jnibugvyfexrtcyubiomkjniuvyctrtyuio.webp"></p>
<p><strong>WebAppClassLoader：</strong></p>
<blockquote>
<p>​	为了解决多个Web应用隔离类库的问题，Tomcat自定义了一个类加载器WebAppClassLoader，并且给每个Web应用创建一个WebAppClassLoader加载器实例，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。这背后的原理是，不同的加载器实例加载的类被认为是不同的类，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离</p>
</blockquote>
<p><strong>SharedClassLoader：</strong></p>
<blockquote>
<p>​	多个Web应用共享类库的问题本质是多个Web应用之间共享类库并且不能重复加载相同的类。在双亲委派模型里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗。SharedClassLoader作为WebAppClassLoader的父加载器专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，来解决共享的问题</p>
</blockquote>
<p><strong>CatalinaClassLoader：</strong></p>
<blockquote>
<p>​	如何隔离Tomcat与Web应用的类？要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此Tomcat又设计一个类加载器CatalinaClassLoader专门来加载Tomcat自身的类</p>
</blockquote>
<p><strong>CommonClassLoader：</strong></p>
<blockquote>
<p>​	如果Tomcat和各Web应用之间需要共享一些类时该怎么办呢？CommonClassLoader作为CatalinaClassLoader和SharedClassLoader的父加载器</p>
<p>​	CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离</p>
</blockquote>
<h5 id="顺序：Bootstrap-ClassLoader-Extension-ClassLoader-CatalinaClassLoader-WebAppClassLoader-CommonClassLoader"><a href="#顺序：Bootstrap-ClassLoader-Extension-ClassLoader-CatalinaClassLoader-WebAppClassLoader-CommonClassLoader" class="headerlink" title="顺序：Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt; CatalinaClassLoader -&gt; WebAppClassLoader -&gt; CommonClassLoader"></a>顺序：Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt; CatalinaClassLoader -&gt; WebAppClassLoader -&gt; CommonClassLoader</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="clpsh97910001xgvs9es3dhdp" data-title="JVM基础知识" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-12-06T13:23:10.000Z" itemprop="datePublished">2021-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴传智播客并发编程资料与<a target="_blank" rel="noopener" href="https://pdai.tech/%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9">https://pdai.tech/网站内容</a></p>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p>　　我们都知道计算机的核心是<code>CPU</code>，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。</p>
<p>　　<strong>进程是一个具有一定独立功能的程序，在一个数据集上的一次动态执行的过程</strong>，是表示资源分配的基本单位，又是调度运行的基本单位，是应用程序运行的载体。进程一般由<strong>程序，数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志</p>
</blockquote>
<blockquote>
<p><strong>进程具有的特征：</strong></p>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进行一起并发执行；</li>
<li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序，数据和进程控制块三部分组成</li>
</ul>
</blockquote>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><h5 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h5><p>按进程在执行过程中的不同情况至少要定义三种状态：</p>
<ul>
<li><p><strong>运行（<code>running</code>）态：</strong>进程占有处理器正在运行的状态。</p>
<blockquote>
<p>​	进程已获得<code>CPU</code>，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</p>
</blockquote>
</li>
<li><p><strong>就绪（<code>ready</code>）态：</strong>进程具备运行条件，等待系统分配处理器以便运行的状态。</p>
<blockquote>
<p>​	当进程已分配到除<code>CPU</code>以外的所有必要资源后，只要再获得<code>CPU</code>，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
</blockquote>
</li>
<li><p><strong>阻塞（<code>Blocked</code>）态：</strong>指进程不具备运行条件，正在等待某个时间完成的状态。</p>
<blockquote>
<p>​	也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/AryWDI.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>就绪态—→运行态：<code>CPU</code> 空闲时选择一个就绪进程。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h5><p>五态模型在三态模型的基础上增加了新建态（<code>new</code>）和终止态（<code>exit</code>）。</p>
<ul>
<li><p><strong>新建态：</strong>对应于进程被创建时的状态，尚未进入就绪队列。</p>
<blockquote>
<p>创建一个进程需要通过两个步骤：</p>
<p>​	1.为新进程分配所需要资源和建立必要的管理信息。</p>
<p>​	2.设置该进程为就绪态，并等待被调度执行。</p>
</blockquote>
</li>
<li><p><strong>终止态：</strong>指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。</p>
<blockquote>
<p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。</p>
<p>终止一个进程需要两个步骤：</p>
<p>​	1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。</p>
<p>​	2.然后回收占用的资源并被系统删除。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Aryfbt.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>NULL→新建态：执行一个程序，创建一个子进程。</p>
<p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
<p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>终止态→NULL：完成善后操作。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的七态模型"><a href="#进程的七态模型" class="headerlink" title="进程的七态模型"></a>进程的七态模型</h5><blockquote>
<p>​	三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（<code>suspend</code>），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。</p>
</blockquote>
<blockquote>
<p>引起进程挂起的原因是多样的，主要有：</p>
<ul>
<li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。 </li>
<li>父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 </li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 </li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 </li>
<li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</li>
</ul>
</blockquote>
<blockquote>
<p>七态模型在五态模型的基础上增加了挂起就绪态（<code>ready suspend</code>）和挂起等待态（<code>blocked suspend</code>）。</p>
<ul>
<li>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。</li>
<li>挂起等待态：表明进程正在等待某一个事件发生且在外存中。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Ary4VP.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下:</p>
<blockquote>
<p>等待态→挂起等待态：操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</p>
<p>挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态</p>
<p>挂起就绪态→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</p>
<p>就绪态→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</p>
<p>挂起等待态→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>运行态→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 <code>CPU</code>，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</p>
<p>新建态→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>​	挂起进程等同于不在内存中的进程，因此挂起进程将不参与低级调度直到它们被调换进内存。</p>
<p>挂起进程具有如下特征：</p>
<ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。 （等待事件结束后进程变为挂起就绪态）</li>
<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>
</ul>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p>​	它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</blockquote>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><h5 id="线程状态之五种状态"><a href="#线程状态之五种状态" class="headerlink" title="线程状态之五种状态"></a>线程状态之五种状态</h5><blockquote>
<p>从操作系统角度：线程的状态一共可以描述为五种：初始态，可运行，运行态，阻塞态，终止态。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583507073055.png"></p>
<ol>
<li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联；</li>
<li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待<code>CPU</code>给它分配时间片就可运行；</li>
<li>运行状态，指线程获取了<code>CPU</code>时间片，正在运行<ol>
<li>当<code>CPU</code>时间片用完，线程会转换至【可运行状态】，等待<code>CPU</code>再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ol>
</li>
<li>阻塞状态<ol>
<li>如果调用了阻塞<code>API</code>，如<code>BIO</code>读写文件，那么线程实际上不会用到<code>CPU</code>，不会分配<code>CPU</code>时间片，会导致上下文切换，进入【阻塞状态】</li>
<li>等待<code>BIO</code>操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，<code>CPU</code>就一直不会分配时间片</li>
</ol>
</li>
<li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ol>
</blockquote>
<h5 id="线程状态之六种状态"><a href="#线程状态之六种状态" class="headerlink" title="线程状态之六种状态"></a>线程状态之六种状态</h5><blockquote>
<p>从<code>Java</code>线程角度：线程的状态一共可以描述为六种：初始态，运行态，阻塞态，等待态、超时等待态、终止态。</p>
<ol>
<li>**初始(<code>NEW</code>)**：新创建了一个线程对象，但还没有调用<code>start()</code>方法。</li>
<li>**运行(<code>RUNNABLE</code>)**：Java线程中将就绪（<code>ready</code>）和运行中（<code>running</code>）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如<code>main</code>线程）调用了该对象的<code>start()</code>方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取<code>CPU</code>的使用权，此时处于就绪状态（<code>ready</code>）。就绪状态的线程在获得<code>CPU</code>时间片后变为运行中状态（<code>running</code>）。</li>
<li>**阻塞(<code>BLOCKED</code>)**：表示线程阻塞于锁。</li>
<li>**等待(<code>WAITING</code>)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>**超时等待(<code>TIMED_WAITING</code>)**：该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li>
<li>**终止(<code>TERMINATE</code>D)**：表示该线程已经执行完毕。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2018070117435683.png"></p>
</blockquote>
<p><strong>假设有线程 Thread t</strong></p>
<h6 id="NEW-RUNNABLE"><a href="#NEW-RUNNABLE" class="headerlink" title="NEW &lt;–&gt; RUNNABLE"></a>NEW &lt;–&gt; RUNNABLE</h6><blockquote>
<p><code>t.start()</code>方法时, <code>NEW --&gt; RUNNABLE</code></p>
</blockquote>
<h6 id="RUNNABLE-WAITING"><a href="#RUNNABLE-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<p>线程用<code>synchronized(obj)</code>获取了对象锁后</p>
<ol>
<li>调用<code>obj.wait()</code>方法时，<code>t</code> 线程从<code>RUNNABLE --&gt; WAITING</code></li>
<li>调用<code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ol>
<li>竞争锁成功，<code>t</code> 线程从<code>WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code> 线程从<code>WAITING --&gt; BLOCKED</code></li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="RUNNABLE-WAITING-1"><a href="#RUNNABLE-WAITING-1" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-WAITING-2"><a href="#RUNNABLE-WAITING-2" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 &#96;&#96;RUNNABLE –&gt; WAITING<code>注意是当前线程在</code>t&#96; 线程对象的监视器上等待</li>
<li><code>t</code> 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING"><a href="#RUNNABLE-TIMED-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<p><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p>
<ol>
<li>调用 <code>obj.wait(long n)</code> 方法时，<code>t </code>线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li><code>t</code> 线程等待时间超过了 <code>n</code> 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时,唤醒的线程都到**<code>entrySet</code>**阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列，和其他线程再进行 <strong>竞争锁</strong><ol>
<li>竞争锁成功，<code>t</code> 线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code> 线程从 <code>TIMED_WAITING --&gt; BLOCKED</code></li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-1"><a href="#RUNNABLE-TIMED-WAITING-1" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><br>注意是当前线程在t 线程对象的监视器上等待</li>
<li>当前线程等待时间超过了 <code>n</code> 毫秒，或 <code>t</code> 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从<br><code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-2"><a href="#RUNNABLE-TIMED-WAITING-2" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>当前线程等待时间超过了 <code>n</code> 毫秒或调用了线程 的 <code>interrupt()</code> ，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-3"><a href="#RUNNABLE-TIMED-WAITING-3" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a>RUNNABLE &lt;–&gt; TIMED_WAITING</h6><blockquote>
<ol>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线<br>程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从<br><code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-BLOCKED"><a href="#RUNNABLE-BLOCKED" class="headerlink" title="RUNNABLE &lt;–&gt; BLOCKED"></a><code>RUNNABLE &lt;–&gt; BLOCKED</code></h6><blockquote>
<p><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE –&gt; BLOCKED</code>, 持 <code>obj</code> 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 <code>t</code> 线程竞争 成功，从 <code>BLOCKED –&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></p>
</blockquote>
<h6 id="RUNNABLE-TERMINATED"><a href="#RUNNABLE-TERMINATED" class="headerlink" title="RUNNABLE &lt;–&gt; TERMINATED"></a><code>RUNNABLE</code> &lt;–&gt; <code>TERMINATED</code></h6><blockquote>
<p>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></p>
</blockquote>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><blockquote>
<ul>
<li>线程是进程的一部分</li>
<li>一个线程只能属于一个进程，而一个进程至少有一个线程</li>
</ul>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote>
<p>​	理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）</p>
<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p><strong>开销方面：</strong>每个进程都有独立的代码和数据空间（程序上下文），进程之间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小</p>
<p><strong>所处环境：</strong>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行</p>
<p><strong>内存分配：</strong>系统为每个进程分配不同的内存空间；而对线程而言，除了<code>CPU</code>外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>
<p><strong>包含关系：</strong>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>
</blockquote>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote>
<p>​	<strong>并发（<code>Concurrent</code>），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</strong></p>
<p>​	并发不是真正意义上的“同时进行”，只是<code>CPU</code>把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于<code>CPU</code>处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。如：打游戏和听音乐两件事情在<strong>同一个时间段内</strong>都是在同一台电脑上完成了<strong>从开始到结束的动作</strong>。那么，就可以说听音乐和打游戏是并发的。</p>
</blockquote>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><blockquote>
<p>​	<strong>并行（<code>Parallel</code>），当系统有一个以上<code>CPU</code>时，当一个<code>CPU</code>执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占<code>CPU</code>资源，可以同时进行，这种方式我们称之为并行(<code>Parallel</code>)。</strong></p>
<p>​	<strong>其实决定并行的因素不是<code>CPU</code>的数量，而是<code>CPU</code>的核心数量，比如一个<code>CPU</code>多个核也可以并行。</strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1628624-20190505161932608-1136050215.jpg"></p>
<h3 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h3><blockquote>
<ul>
<li><p><strong>并发：</strong>指的是多个事情，在同一时间段内同时发生了。 </p>
</li>
<li><p><strong>并行：</strong>指的是多个事情，在同一时间点上同时发生了。</p>
</li>
<li><p>并发的多个任务之间是互相抢占资源的。 </p>
</li>
<li><p>并行的多个任务之间是不互相抢占资源的</p>
</li>
</ul>
<p>只有在多<code>CPU</code>或者一个<code>CPU</code>多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
</blockquote>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><blockquote>
<p>​	<code>Java</code>使用<code>Thread</code>类代表线程，所有的线程对象都必须是<code>Thread</code>类或其子类的实例。<code>Java</code>可以用四种方式来创建线程，如下所示：</p>
<p>​	1）继承<code>Thread</code>类创建线程</p>
<p>​	2）实现<code>Runnable</code>接口创建线程</p>
<p>​	3）使用<code>Callable</code>和<code>Future</code>创建线程</p>
<p>​	4）使用线程池例如用<code>Executor</code>框架</p>
</blockquote>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><code>Thread</code></h3><blockquote>
<ul>
<li>定义<code>Thread</code>类的子类，并重写该类的<code>run()</code>方法，该方法的方法体就是线程需要完成的任务，<code>run()</code>方法也称为线程执行体；</li>
<li>创建<code>Thread</code>子类的实例，也就是创建了线程对象；</li>
<li>启动线程，即调用线程的<code>start()</code>方法；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a><code>Runnable</code></h3><blockquote>
<ul>
<li><p>定义<code>Runnable</code>接口的实现类，一样要重写<code>run()</code>方法，这个<code>run（）</code>方法和<code>Thread</code>中的<code>run()</code>方法一样是线程的执行体；</p>
</li>
<li><p>创建<code>Runnable</code>实现类的实例，并用这个实例作为<code>Thread</code>的<code>target</code>来创建<code>Thread</code>对象，这个<code>Thread</code>对象才是真正的线程对象；</p>
</li>
<li><p>第三部依然是通过调用线程对象的<code>start()</code>方法来启动线程；</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t1&quot;</span>).start();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="Callable-Future"><a href="#Callable-Future" class="headerlink" title="Callable + Future"></a><code>Callable + Future</code></h3><h4 id="Callable和Runnable不同点："><a href="#Callable和Runnable不同点：" class="headerlink" title="Callable和Runnable不同点："></a><code>Callable</code>和<code>Runnable</code>不同点：</h4><blockquote>
<ul>
<li><p><code>Callable</code>规定的方法是<code>call()</code>，而<code>Runnable</code>规定的方法是<code>run()</code>.</p>
</li>
<li><p><code>Callable</code>的任务执行后可返回值，而<code>Runnable</code>的任务是不能返回值的。</p>
</li>
<li><p><code>call()</code>方法可抛出异常，而<code>run()</code>方法是不能抛出异常的。</p>
</li>
<li><p>运行<code>Callable</code>任务可拿到一个<code>Future</code>对象，<code>Future</code>表示异步计算的结果。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>创建<code>Callable</code>接口的实现类，并实现<code>call()方</code>法，然后创建该实现类的实例；</p>
</li>
<li><p>使用<code>FutureTask</code>类来包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了<code>Callable</code>对象的<code>call()</code>方法的返回值；</p>
</li>
<li><p>使用<code>FutureTask</code>对象作为<code>Thread</code>对象的<code>target</code>创建并启动线程（因为<code>FutureTask</code>实现了<code>Runnable</code>接口）；</p>
</li>
<li><p>调用<code>FutureTask</code>对象的<code>get()</code>方法来获得子线程执行结束后的返回值；</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, futureTask.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, futureTask.get());</span><br></pre></td></tr></table></figure>

<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（<code>Thread Context Switch</code>）</h3><blockquote>
<p>因为以下一些原因导致 <code>cpu</code> 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 <code>cpu</code> 时间片用完(每个线程轮流执行，看前面并行的概念)</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>​	当 <code>Context Switch</code> 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，<code>Java</code> 中对应的概念就是程序计数器（<code>Program Counter Register</code>），它的作用是记住下一条 <code>jvm</code> 指令的执行地址，是线程私有的</p>
</blockquote>
<h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center"><code>static</code></th>
<th align="center">功能说明</th>
<th align="center">注意</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>start()</code></td>
<td align="center"></td>
<td align="center">启动一个新线程，在新的线程运行run方法中的代码</td>
<td align="center"><code>start</code>方法只是让线程进入就绪，里面代码不一定立刻运行(<code>CPU</code>的时间片还没分给它)。每个线程对象的<code>start</code>方法只能调用一次 ,如果调用了多次会出现<code>IllegalThreadStateException</code></td>
</tr>
<tr>
<td align="center"><code>run()</code></td>
<td align="center"></td>
<td align="center">新线程启动后会调用的方法</td>
<td align="center">如果在构造<code>Thread</code>对象时传递了<code>Runnable</code>参数，则线程启动后会调用<code>Runnable</code>中的<code>run</code>方法，否则默认不执行任何操作。但可以创建<code>Thread</code>的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td align="center"><code>join()</code></td>
<td align="center"></td>
<td align="center">等待线程运行结束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>join(long n)</code></td>
<td align="center"></td>
<td align="center">等待线程运行结束，最多等待 <code>n</code> 毫秒</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>getId()</code></td>
<td align="center"></td>
<td align="center">获取线程长整型的<code>id</code></td>
<td align="center"><code>id</code> 唯一</td>
</tr>
<tr>
<td align="center"><code>getName()</code></td>
<td align="center"></td>
<td align="center">获取线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>setNmae(String)</code></td>
<td align="center"></td>
<td align="center">修改线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>getPriority()</code></td>
<td align="center"></td>
<td align="center">获取线程优先级</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>setPriority()</code></td>
<td align="center"></td>
<td align="center">修改线程优先级</td>
<td align="center"><code>java</code>中规定线程优先级是<code>1-10</code>的整数,较大的优先级能提高该线程被<code>CPU</code>调度的几率</td>
</tr>
<tr>
<td align="center"><code>getState()</code></td>
<td align="center"></td>
<td align="center">获取线程状态</td>
<td align="center"><code>Java</code>中线程状态是用<code>6</code>个<code>enum</code>表示，分别为:<code>NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</code></td>
</tr>
<tr>
<td align="center"><code>isInterrupted()</code></td>
<td align="center"></td>
<td align="center">判断是否被打断</td>
<td align="center">不会清除<code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>isAlive()</code></td>
<td align="center"></td>
<td align="center">线程是否存活(还没有运行完毕)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>interrupt()</code></td>
<td align="center"></td>
<td align="center">打断线程</td>
<td align="center">如果被打断线程正在<code>sleep，wait，join</code>会导致被打断的线程抛出<code>InterruptedException</code>，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记; <code>park</code>的线程被打断，也会设置 <code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>interrupted()</code></td>
<td align="center"><code>static</code></td>
<td align="center">判断当前线程是否被打断</td>
<td align="center">会清除<code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>currentThread()</code></td>
<td align="center"><code>static</code></td>
<td align="center">获取当前正在执行的线程</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a><code>start</code> 与 <code>run</code></h4><h5 id="调用start"><a href="#调用start" class="headerlink" title="调用start"></a>调用<code>start</code></h5><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          log.debug(<span class="string">&quot;我是一个新建的线程正在运行中&quot;</span>);</span><br><span class="line">          FileReader.read(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">&quot;新建线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出：程序在 <code>t1</code> 线程运行， <code>run()</code>方法里面内容的调用是异步的 <code>Test4.java</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">11</span>:<span class="string">59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms</span></span><br></pre></td></tr></table></figure>

<h5 id="调用run"><a href="#调用run" class="headerlink" title="调用run"></a>调用<code>run</code></h5><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>输出结果如下：程序仍在 <code>main </code>线程运行，<code>run()</code>方法里面内容的调用还是同步的</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">12</span>:<span class="string">03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.727 [main] DEBUG com.concurrent.test.FileReader - read [test] start ...</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.729 [main] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 2 ms</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程</span></span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程<br>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p>
</blockquote>
<h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a><code>sleep</code> 与 <code>yield</code></h4><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a><code>sleep</code></h5><blockquote>
<ol>
<li>调用 <code>sleep</code> 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>
<li>其它线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li>
<li>睡眠结束后的线程未必会立刻得到执行(需要分配到<code>cpu</code>时间片)</li>
<li>建议用 <code>TimeUnit</code> 的 <code>sleep()</code> 代替 <code>Thread</code> 的 <code>sleep()</code>来获得更好的可读性</li>
</ol>
</blockquote>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a><code>yield</code></h5><blockquote>
<ol>
<li>调用 <code>yield</code> 会让当前线程从 <code>Running</code> 进入 <code>Runnable</code> 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了<code>yield</code>方法，但是也没有用)</li>
</ol>
</blockquote>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>​	<code>yield</code>使<code>cpu</code>调用其它线程，但是<code>cpu</code>可能会再分配时间片给该线程；而<code>sleep</code>需要等过了休眠时间之后才有可能被分配<code>cpu</code>时间片</p>
</blockquote>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程的优先级属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程所能拥有的最大优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程默认的优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程所能拥有的最大优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h4><p>在主线程中调用<code>t1.join</code>，则主线程会等待<code>t1</code>线程执行完之后再继续执行 <code>Test10.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583483843354.png"></p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><code>interrupt</code></h4><p> <code>sleep，wait，join</code> 的线程，这几个方法都会让线程进入阻塞状态，以 <code>sleep</code> 为例<code>Test7.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;线程任务执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                log.debug(<span class="string">&quot;被打断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;111是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	输出结果：（我下面将中断和打断两个词混用）可以看到，打断 <code>sleep</code> 的线程, 会清空中断状态，刚被中断完之后<code>t1.isInterrupted()</code>的值为<code>true</code>，后来变为<code>false</code>，即中断状态会被清除。那么线程是否被中断过可以通过异常来判断。【同时要注意如果打断被<code>join()</code>，<code>wait()</code> <code>blocked</code>的线程也是一样会被清除，被清除(<code>interrupt status will be cleared</code>)的意思即中断状态设置为<code>false</code>，被设置(<code>interrupt status will be set</code>)的意思就是中断状态设置为<code>true</code>】</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">17</span>:<span class="string">06:11.890 [Thread-0] DEBUG com.concurrent.test.Test7 - 线程任务执行</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.387 [main] DEBUG com.concurrent.test.Test7 - 111是否被打断？false</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.390 [Thread-0] DEBUG com.concurrent.test.Test7 - 被打断</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.390 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？true</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？false</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 主线程</span></span><br></pre></td></tr></table></figure>

<h4 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h4><p>​	打断正常运行的线程, 线程并不会暂停，只是调用方法<code>Thread.currentThread().isInterrupted();</code>的返回值为<code>true</code>，可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO bat.Main - interrupt</span><br><span class="line">[t1] INFO bat.Main - 被打断了, 退出循环</span><br></pre></td></tr></table></figure>

<h4 id="终止模式之两阶段终止模式"><a href="#终止模式之两阶段终止模式" class="headerlink" title="终止模式之两阶段终止模式"></a>终止模式之两阶段终止模式</h4><blockquote>
<p>​	<code>Two Phase Termination</code>，就是考虑在一个线程<code>T1</code>中如何优雅地终止另一个线程<code>T2</code>？这里的优雅指的是给<code>T2</code>一个料理后事的机会（如释放锁）。</p>
<p>​	如下所示：那么线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为<code>false</code>，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。处理好这两种情况那我们就可以放心地来料理后事啦！</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583496991915.png"></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoParseTermination</span> <span class="variable">twoParseTermination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoParseTermination</span>();</span><br><span class="line">        twoParseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);  <span class="comment">// 让监控线程执行一会儿</span></span><br><span class="line">        twoParseTermination.stop(); <span class="comment">// 停止监控线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoParseTermination</span>&#123;</span><br><span class="line">    Thread thread ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程结束。。正在料理后事中&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行监控的功能&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a><code>sleep，yiled，wait，join</code> 对比</h4><blockquote>
<ol>
<li><p><code>sleep，join，yield，interrupted</code>是<code>Thread</code>类中的方法</p>
</li>
<li><p><code>wait/notify</code>是<code>object</code>中的方法</p>
<p><code>sleep</code> 不释放锁、释放<code>cpu</code></p>
<p><code>join</code> 释放锁、抢占<code>cpu</code></p>
<p><code>yiled</code> 不释放锁、释放<code>cpu</code></p>
<p><code>wait</code> 释放锁、释放<code>cpu</code></p>
</li>
</ol>
</blockquote>
<h4 id="park与unpark"><a href="#park与unpark" class="headerlink" title="park与unpark"></a><code>park</code>与<code>unpark</code></h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><blockquote>
<p>它们是 <code>LockSupport</code> 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="park与unpark-原理"><a href="#park与unpark-原理" class="headerlink" title="park与unpark 原理"></a><code>park</code>与<code>unpark</code> 原理</h5><blockquote>
<p>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成 <code>_counter</code>， <code>_cond</code>和 <code>_mutex</code></p>
<ol>
<li>打个比喻线程就像一个旅人，<code>Parker</code> 就像他随身携带的背包，条件变量 <code>_cond</code>就好比背包中的帐篷。<code>_counter</code> 就好比背包中的备用干粮（<code>0</code> 为耗尽，<code>1</code> 为充足）</li>
<li>调用 <code>park</code> 就是要看需不需要停下来歇息<ol>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ol>
</li>
<li>调用 <code>unpark</code>，就好比令干粮充足<ol>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 <code>park</code> 时，仅是消耗掉备用干粮，不需停留继续前进<ol>
<li>因为背包空间有限，多次调用 <code>unpark</code> 仅会补充一份备用干粮</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="先调用park再调用unpark的过程"><a href="#先调用park再调用unpark的过程" class="headerlink" title="先调用park再调用unpark的过程"></a>先调用<code>park</code>再调用<code>unpark</code>的过程</h6><blockquote>
<p><strong>一、先调用<code>park</code></strong></p>
<ol>
<li><p>当前线程调用 <code>Unsafe.park()</code> 方法</p>
</li>
<li><p>检查 <code>_counter</code> ，本情况为 <code>0</code>，这时，获得 <code>_mutex</code> 互斥锁(<code>mutex</code>对象有个等待队列 <code>_cond</code>)</p>
</li>
<li><p>线程进入 <code>_cond</code> 条件变量阻塞</p>
</li>
<li><p>设置 <code>_counter = 0</code></p>
</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594531894163.png"></p>
<blockquote>
<p><strong>二、调用<code>unpark</code></strong></p>
<p>​    1. 调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 <code>1</code></p>
<p>​    2. 唤醒 <code>_cond</code> 条件变量中的 <code>Thread_0</code></p>
<p>​    3. <code>Thread_0</code> 恢复运行</p>
<p>​    4. 设置 <code>_counter</code> 为 <code>0</code></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594532057205.png"></p>
<h6 id="先调用unpark再调用park的过程"><a href="#先调用unpark再调用park的过程" class="headerlink" title="先调用unpark再调用park的过程"></a>先调用<code>unpark</code>再调用<code>park</code>的过程</h6><blockquote>
<ol>
<li>调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 <code>1</code></li>
<li>当前线程调用 <code>Unsafe.park()</code> 方法</li>
<li>检查 <code>_counter</code> ，本情况为 <code>1</code>，这时线程无需阻塞，继续运行</li>
<li>设置 <code>_counter</code> 为 <code>0</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594532135616.png"></p>
<h4 id="wait与notify-属于重量级锁的方法"><a href="#wait与notify-属于重量级锁的方法" class="headerlink" title="wait与notify(属于重量级锁的方法)"></a><code>wait</code>与<code>notify</code>(属于重量级锁的方法)</h4><blockquote>
<p> <img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220084652893.png"></p>
<p>​	当线程<code>0</code>获得到了锁, 成为<code>Monitor</code>的<code>Owner</code>, 但是此时它发现自己想要执行<code>synchroized</code>代码块的条件不满足; 此时它就调用<code>obj.wait</code>方法, 进入到<code>Monitor</code>中的<code>WaitSet</code>集合, 此时线程<code>0</code>的状态就变为<code>WAITING</code><br>​	处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为阻塞状态，<code>CPU</code>都不会分给他们时间片。但是有所区别：<br>​		<code>BLOCKED</code>状态的线程是在竞争锁对象时，发现<code>Monitor</code>的<code>Owner</code>已经是别的线程了，此时就会进入<code>EntryList</code>中，并处于<code>BLOCKED</code>状态<br>​		<code>WAITING</code>状态的线程是获得了对象的锁，但是自身的原因无法执行<code>synchroized</code>的临界区资源需要进入阻塞状态时，锁对象调用了<code>wait</code>方法而进入了<code>WaitSet</code>中，处于<code>WAITING</code>状态<br>​	<strong>处于<code>BLOCKED</code>状态的线程会在锁被释放的时候被唤醒</strong><br>​	<strong>处于<code>WAITING</code>状态的线程只有被锁对象调用了<code>notify</code>方法<code>(obj.notify/obj.notifyAll)</code>，才会被唤醒。然后它会进入到<code>EntryList</code>, 重新竞争锁 (此时就将锁升级为重量级锁)</strong></p>
</blockquote>
<h5 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a><code>API</code>介绍</h5><blockquote>
<p>下面的三个方法都是<code>Object</code>中的方法; 通过锁对象来调用</p>
<p>​	<code>wait()</code>: 让获得对象锁的线程到<code>waitSet</code>中一直等待</p>
<p>​	<code>wait(long n)</code> : 当该等待线程没有被<code>notify</code>, 等待时间到了之后, 也会自动唤醒</p>
<p>​	<code>notify()</code>: 让获得对象锁的线程, 使用锁对象调用<code>notify</code>去<code>waitSet</code>的等待线程中挑一个唤醒</p>
<p>​	<code>notifyAll()</code> : 让获得对象锁的线程, 使用锁对象调用<code>notifyAll</code>去唤醒<code>waitSet</code>中所有的等待线程</p>
<p>​	它们都是线程之间进行协作的手段, 都属于<code>Object</code>对象的方法, 必须获得此对象的锁, 才能调用这些方法</p>
</blockquote>
<p><strong>注：只有当对象被锁以后(成为<code>Owner</code>)，才能调用<code>wait</code>和<code>notify</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//只有在对象被锁住后才能调用wait方法</span></span><br><span class="line">		<span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">			LOCK.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>演示<code>wait和notify</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 只有获得锁对象之后, 才能调用wait/notify</span></span><br><span class="line">                    obj.wait(); <span class="comment">// 此时t1线程进入WaitSet等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// 此时t2线程进入WaitSet等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程等两秒在执行,为了`唤醒`,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;唤醒waitSet中的线程!&quot;</span>);</span><br><span class="line">        <span class="comment">// 只有获得锁对象之后, 才能调用wait/notify</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// obj.notify(); // 唤醒waitset中的一个线程</span></span><br><span class="line">             obj.notifyAll(); <span class="comment">// 唤醒waitset中的全部等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">36.176</span> guizy.WaitNotifyTest [t1] - 执行...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">36.178</span> guizy.WaitNotifyTest [t2] - 执行...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [main] - 唤醒waitSet中的线程!</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [t2] - 其它代码...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [t1] - 其它代码...</span><br></pre></td></tr></table></figure>

<h5 id="sleep-long-n-和-wait-long-n-的区别-重点"><a href="#sleep-long-n-和-wait-long-n-的区别-重点" class="headerlink" title="sleep(long n) 和 wait(long n)的区别 (重点)"></a><code>sleep(long n)</code> 和 <code>wait(long n)</code>的区别 <code>(重点)</code></h5><blockquote>
<p><strong>不同点:</strong></p>
<p>​	<code>sleep</code>是<code>Thread</code>类的静态方法，<code>wait</code>是<code>Object</code>的方法，<code>Object</code>又是所有类的父类，所以所有类都有<code>Wait</code>方法。<br>​	<code>sleep</code>在阻塞的时候不会释放锁，而<code>wait</code>在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)<br>​	<code>sleep</code>方法不需要与<code>synchronized</code>一起使用，而<code>wait</code>方法需要与<code>synchronized</code>一起使用（<code>wait/notify</code>等方法, 必须要使用对象锁来调用）<br><strong>相同点:</strong></p>
<p>​	阻塞状态都为<code>TIMED_WAITING</code> (限时等待)</p>
</blockquote>
<p><strong><code>sleep</code>方法 &#x2F; <code>wait</code>方法 测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 测试sleep不释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SleepTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得锁了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的</span></span><br><span class="line">                    lock.wait(<span class="number">5000</span>); <span class="comment">// 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程睡一秒</span></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获得锁了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep打印结果 : 表明在sleep期间, 锁是不会被释放的</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220094013513.png"></p>
<p>wait打印结果 : 当调用wait方法后, 锁就会被立刻释放</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220094129242.png"></p>
<h5 id="wait-notify的正确使用"><a href="#wait-notify的正确使用" class="headerlink" title="wait/notify的正确使用"></a><code>wait/notify</code>的正确使用</h5><h6 id="Step-1-逐渐向下优化"><a href="#Step-1-逐渐向下优化" class="headerlink" title="Step 1 : 逐渐向下优化"></a><strong>Step 1 : 逐渐向下优化</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//思考下面的解决方案好不好，为什么？</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    Sleeper.sleep(<span class="number">2</span>);   <span class="comment">// 会阻塞2s, 不会释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 此时没有加锁, 所以会优先于其他人先执行</span></span><br><span class="line">            <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="comment">//synchronized (room) &#123; // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..</span></span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不给<code>送烟线程加synchronized</code>输出情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">32.311</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">32.318</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">33.318</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [小南] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.321</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.321</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<ul>
<li>给<code>送烟线程加synchronized</code>输出情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">57.565</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">57.570</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.574</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.574</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.576</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220101906421.png"></p>
<h6 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a><strong>Step2:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 小南进入等待状态了, 其他线程就可以获得锁了</span></span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                room.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.840</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.847</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.847</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.848</span> guizy.WaitNotifyTest [小南] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<p>如果此时除了小南在等待唤醒, 还有一个线程也在等待唤醒呢? 此时的<code>notify</code>方法会唤醒谁呢?</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220110553609.png"></p>
<h6 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a><strong>Step3:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.516</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">40.521</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">40.521</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br></pre></td></tr></table></figure>

<p>问题: 当外卖送到了, 却唤醒了<code>小南</code>, 此时就出现了问题</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220111243224.png"></p>
<h6 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a><strong>Step4:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">	 hasTakeout = <span class="literal">true</span>;</span><br><span class="line">	 log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">	 room.notifyAll();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.670</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [小女] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.675</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br></pre></td></tr></table></figure>

<p>还是唤醒了小南, 小南还是回去看看送来的是外卖还是烟. 很麻烦, 怎么解决?</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220111655619.png"></p>
<h6 id="Step5"><a href="#Step5" class="headerlink" title="Step5:"></a><strong>Step5:</strong></h6><ul>
<li>使用<code>while循环</code>来解决<code>虚假唤醒</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.275</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.282</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.282</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.283</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [小女] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.288</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为改为<code>while</code>如果唤醒之后, 就在<code>while</code>循环中执行了, 不会跑到<code>while</code>外面去执行”有烟没…”, 此时小南就不需要每次<code>notify</code>, 就去看是不是送来的烟, 如果是烟, <code>while</code>就为<code>false</code>了.</p>
</blockquote>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><h3 id="线程出现问题的根本原因分析"><a href="#线程出现问题的根本原因分析" class="headerlink" title="线程出现问题的根本原因分析"></a>线程出现问题的根本原因分析</h3><blockquote>
<p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面举一个例子 <code>Test13.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">               count--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.join();</span><br><span class="line">       t2.join();</span><br><span class="line">       log.debug(<span class="string">&quot;count的值是&#123;&#125;&quot;</span>,count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从字节码的层面进行分析：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br><span class="line">    </span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到<code>count++</code> 和 <code>count--</code> 操作实际都是需要这个<code>4</code>个指令完成的，那么这里问题就来了！<code>Java</code> 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569253392.png"></p>
<blockquote>
<p>如果代码是正常按顺序运行的，那么<code>count</code>的值不会计算错</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569326977.png"></p>
<blockquote>
<p>出现负数的情况：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569380639.png"></p>
<blockquote>
<p>出现正数的情况：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569416016.png"></p>
<h3 id="问题的进一步描述"><a href="#问题的进一步描述" class="headerlink" title="问题的进一步描述"></a>问题的进一步描述</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><blockquote>
<ol>
<li><p>一个程序运行多线程本身是没有问题的</p>
</li>
<li><p>问题出现在多个线程共享资源的时候</p>
<ol>
<li>多个线程同时对共享资源进行读操作本身也没有问题</li>
<li>问题出现在对对共享资源同时进行读写操作时就有问题了</li>
</ol>
</li>
<li><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区，如：</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h4><blockquote>
<p>​	多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件</p>
</blockquote>
<h3 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a><code>synchronized</code> 解决方案</h3><blockquote>
<p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p>
<ul>
<li>阻塞式解决方案：<code>synchronized</code> ，<code>Lock</code></li>
<li>非阻塞式解决方案：原子变量</li>
</ul>
</blockquote>
<h4 id="synchronized加锁方式"><a href="#synchronized加锁方式" class="headerlink" title="synchronized加锁方式"></a><code>synchronized</code>加锁方式</h4><h5 id="修饰普通方法（锁住的是当前实例对象）"><a href="#修饰普通方法（锁住的是当前实例对象）" class="headerlink" title="修饰普通方法（锁住的是当前实例对象）"></a>修饰普通方法（锁住的是当前实例对象）</h5><blockquote>
<ul>
<li>同一个实例调用会阻塞</li>
<li>不同实例调用不会阻塞</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">   <span class="comment">//锁住了本类的实例对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test1 进入了同步方法&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test1 休眠结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test1();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test1();</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步代码块传参this（锁住的是当前实例对象）"><a href="#同步代码块传参this（锁住的是当前实例对象）" class="headerlink" title="同步代码块传参this（锁住的是当前实例对象）"></a>同步代码块传参<code>this</code>（锁住的是当前实例对象）</h5><blockquote>
<ul>
<li>同一个实例调用会阻塞</li>
<li>不同实例调用不会阻塞</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">   <span class="comment">//锁住了本类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test2 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test2 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test2();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test2();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步代码块传参变量对象-（锁住的是变量对象）"><a href="#同步代码块传参变量对象-（锁住的是变量对象）" class="headerlink" title="同步代码块传参变量对象 （锁住的是变量对象）"></a>同步代码块传参变量对象 （锁住的是变量对象）</h5><blockquote>
<ul>
<li>同一个属性对象才会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> Integer lockObject;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(Integer lockObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockObject = lockObject;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//锁住了实例中的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test3 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test3 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test3();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test3();</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	同一个实例对象的成员属性肯定是同一个，此处列举的是不同实例的情况，但是 依旧实现了同步，原因如下：</p>
<p>​	<code>Integer</code>存在静态缓存，范围是<code>-128 ~ 127</code>，当使用<code>Integer A = 127</code> 或者 <code>Integer A = Integer.valueOf(127)</code> 这样的形式，都是从此缓存拿。如果使用 <code>Integer A = new Integer(127)</code>，每次都是一个新的对象。此例中，两个对象实例的成员变量 <code>lockObject</code> 其实是同一个对象，因此实现了同步。还有字符串常量池也要注意。所以此处关注是，同步代码块传参的对象是否是同一个。这跟第二个方式其实是同一种。</p>
</blockquote>
<h5 id="同步代码块传参class对象（全局锁）"><a href="#同步代码块传参class对象（全局锁）" class="headerlink" title="同步代码块传参class对象（全局锁）"></a>同步代码块传参class对象（全局锁）</h5><blockquote>
<ul>
<li>所有调用该方法的线程都会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//全局锁，类是全局唯一的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test4 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test4 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test4();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test4();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰静态方法（全局锁）"><a href="#修饰静态方法（全局锁）" class="headerlink" title="修饰静态方法（全局锁）"></a>修饰静态方法（全局锁）</h5><blockquote>
<ul>
<li>所有调用该方法的线程都会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//全局锁，静态方法全局唯一的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test5 进入同步方法&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test5 休眠结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            SynchronizedTest.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a><code>Java</code>对象内存布局</h2><blockquote>
<p><code>HotSpot</code>虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（<code>Header</code>）、实例数据（<code>Instance Data</code>）和对齐填充（<code>Padding</code>）。</p>
</blockquote>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote>
<p><code>java</code>的对象头由以下三部分组成：</p>
<ul>
<li><code>Mark Word</code> </li>
<li>指向类的指针</li>
<li>数组长度（只有数组对象才有）</li>
</ul>
</blockquote>
<h4 id="32位的虚拟机"><a href="#32位的虚拟机" class="headerlink" title="32位的虚拟机"></a><code>32</code>位的虚拟机</h4><h5 id="普通对象的对象头"><a href="#普通对象的对象头" class="headerlink" title="普通对象的对象头"></a>普通对象的对象头</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                     Object <span class="title function_">Header</span> <span class="params">(<span class="number">64</span> bits)</span>                  |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|        Mark <span class="title function_">Word</span> <span class="params">(<span class="number">32</span> bits)</span>         |    Klass <span class="title function_">Word</span> <span class="params">(<span class="number">32</span> bits)</span> |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure>

<h5 id="数组对象的对象头"><a href="#数组对象的对象头" class="headerlink" title="数组对象的对象头"></a>数组对象的对象头</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-----------------------------------------------------------------|</span><br><span class="line">|                       Object <span class="title function_">Header</span> <span class="params">(<span class="number">96</span> bits)</span>                   |</span><br><span class="line">|-----------------------|--------------------|--------------------|</span><br><span class="line">|    Mark <span class="title function_">Word</span><span class="params">(32bits)</span>  | Klass <span class="title function_">Word</span><span class="params">(32bits)</span> |array <span class="title function_">length</span><span class="params">(32bits)</span>|</span><br><span class="line">|----------------- -----|--------------------|--------------------|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="32位虚拟机详情"><a href="#32位虚拟机详情" class="headerlink" title="32位虚拟机详情"></a><code>32</code>位虚拟机详情<img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/KLLTKNY3CW9T7YPF9NX3%7BCK.png"></h5><h4 id="64位虚拟机详情"><a href="#64位虚拟机详情" class="headerlink" title="64位虚拟机详情"></a><code>64</code>位虚拟机详情</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/79O0H$36]$4HIW%60%60Q~Y2HE0.png"></p>
<h4 id="下面以32位虚拟机为例"><a href="#下面以32位虚拟机为例" class="headerlink" title="下面以32位虚拟机为例"></a>下面以<code>32</code>位虚拟机为例</h4><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a><code>Mark Word</code></h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/91Y8W[0~8FMG3E_$G$_3P%J.png"></p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><code>Monitor</code></h2><blockquote>
<p><code>Monitor</code> 被翻译为监视器或管程</p>
</blockquote>
<h4 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a><code>Monitor</code>原理</h4><blockquote>
<p>​	每个 <code>Java</code> 对象都可以关联一个 <code>Monitor</code> 对象， 如果使用 <code>synchronized</code> 给对象上锁（重量级）之后，该对象头的 <code>Mark Word</code> 中就被设置指向 <code>Monitor</code> 对象的指针</p>
</blockquote>
<blockquote>
<p>下图原理解释:</p>
<ul>
<li>当<code>Thread1</code>访问到<code>synchronized(obj)</code>中的共享资源的时候</li>
<li>首先会将<code>synchronized</code>中的锁对象中对象头的<code>MarkWord</code>去尝试指向操作系统的<code>Monitor</code>对象, 让锁对象中的<code>MarkWord</code>和<code>Monitor</code>对象相关联, 如果关联成功, 将<code>obj</code>对象头中的<code>MarkWord</code>的对象状态从<code>01</code>改为<code>10</code>。</li>
<li>因为<code>Monitor</code>没有和其他的<code>obj</code>的<code>MarkWord</code>相关联, 所以<code>Thread1</code>就成为了该<code>Monitor</code>的<code>Owner</code>(所有者)。</li>
<li>又来了个<code>Thread1</code>执行<code>synchronized(obj)</code>代码, 它首先会看看能不能执行该临界区的代码; 它会检查<code>obj</code>是否关联了<code>Montior</code>, 此时已经有关联了, 它就会去看看该<code>Montior</code>有没有所有者(<code>Owner</code>), 发现有所有者了(<code>Thread2</code>); <code>Thread1</code>也会和该<code>Monitor</code>关联, 该线程就会进入到它的<code>EntryList</code>(阻塞队列);</li>
<li>当<code>Thread2</code>执行完临界区代码后, <code>Monitor</code>的<code>Owner</code>(所有者)就空出来了. 此时就会通知<code>Monitor</code>中的<code>EntryList</code>阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201219192811839.png"></li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/98c3189e41fd654fe34ead273ec76eba.png"></p>
</blockquote>
<blockquote>
<ul>
<li>刚开始时<code>Monitor</code>中的<code>Owner</code>为<code>null</code></li>
<li>当<code>Thread-2</code> 执行<code>synchronized(obj)&#123;&#125;</code>代码时就会将<code>Monitor</code>的所有者<code>Owner</code> 设置为 <code>Thread-2</code>，上锁成功，<code>Monitor</code>中同一时刻只能有一个<code>Owner</code></li>
<li>当<code>Thread-2</code> 占据锁时，如果线程<code>Thread-3</code>，<code>Thread-4</code>也来执行<code>synchronized(obj)&#123;&#125;</code>代码，就会进入<code>EntryList</code>中变成<code>BLOCKED</code>状态</li>
<li><code>Thread-2</code> 执行完同步代码块的内容，然后唤醒 EntryList&#96; 中等待的线程来竞争锁，竞争时是非公平的 (仍然是抢占式)</li>
<li>图中 <code>WaitSet</code> 中的<code>Thread-0，Thread-1</code> 是之前获得过锁，但条件不满足进入 <code>WAITING</code> 状态的线程，后面讲<code>wait-notify</code> 时会分析</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>synchronized</code> 必须是进入同一个锁对象的<code>monitor</code> 才有上述的效果; —&gt; 也就要使用同一把锁</li>
<li>不加 <code>synchronized</code>的锁对象不会关联监视器，不遵从以上规则</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201219200615817.png"></p>
<p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p>
<ul>
<li>在<code>JDK6</code>的时候, 对<code>synchronized</code>进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在<code>JVM</code>的层面上进行加锁逻辑, 就没有了切换的消耗~</li>
</ul>
</blockquote>
<h2 id="Synchronized原理分析"><a href="#Synchronized原理分析" class="headerlink" title="Synchronized原理分析"></a><code>Synchronized</code>原理分析</h2><h3 id="加锁和释放锁的原理加锁和释放锁的原理"><a href="#加锁和释放锁的原理加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理加锁和释放锁的原理"></a>加锁和释放锁的原理加锁和释放锁的原理</h3><blockquote>
<p>深入<code>JVM</code>看字节码，创建如下的代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>javac</code>命令进行编译生成<code>.class</code>文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; javac SynchronizedDemo2.java</span><br></pre></td></tr></table></figure>

<p>使用<code>javap</code>命令反编译查看<code>.class</code>文件的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; javap -verbose SynchronizedDemo2.class</span><br></pre></td></tr></table></figure>

<p>得到如下的信息：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-schronized-x1.png"></p>
<blockquote>
<p>关注红色方框里的<code>monitorenter</code>和<code>monitorexit</code>即可。</p>
<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加<code>1</code>或者减<code>1</code>。每一个对象在同一时间只与一个<code>monitor</code>(锁)相关联，而一个<code>monitor</code>在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的<code>Monitor</code>锁的所有权的时候，<code>monitorenter</code>指令会发生如下<code>3</code>中情况之一：</p>
<ul>
<li><code>monitor</code>计数器为<code>0</code>，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器<code>+1</code>，一旦<code>+1</code>，别的线程再想获取，就需要等待</li>
<li><strong>如果这个<code>monitor</code>已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成<code>2</code>，并且随着重入的次数，会一直累加</strong></li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code>：释放对于<code>monitor</code>的所有权，释放过程很简单，就是讲<code>monitor</code>的计数器减<code>1</code>，如果减完以后，计数器不是<code>0</code>，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成<code>0</code>，则代表当前线程不再拥有该<code>monitor</code>的所有权，即释放锁。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-schronized-2.png"></p>
<blockquote>
<p>​	该图可以看出，任意线程对<code>Object</code>的访问，首先要获得<code>Object</code>的监视器，如果获取失败，该线程就进入同步状态，线程状态变为<code>BLOCKED</code>，当<code>Object</code>的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
</blockquote>
<h3 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h3><blockquote>
<p>​	上面的<code>demo</code>中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条<code>monitorexit</code>指令，并没有<code>monitorenter</code>获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。</p>
<p>​	<code>Synchronized</code>先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p>
</blockquote>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote>
<p>​	轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁<br>eg: 线程A来操作临界区的资源, 给资源加锁,到执行完临界区代码,释放锁的过程, 没有线程来竞争, 此时就可以使用轻量级锁; 如果这期间有线程来竞争的话, 就会升级为重量级锁(<code>synchronized</code>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、每次指向到<code>synchronized</code>代码块时，都会创建锁记录（<code>Lock Record</code>）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的<code>Mark Word</code>和对象引用<code>reference</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755737580.png"></p>
<p>2、让锁记录中的<code>Object reference</code>指向对象，并且尝试用<code>cas(compare and sweep)</code>替换<code>Object</code>对象的<code>Mark Word</code> ，将<code>Mark Word</code> 的值存入锁记录中</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755888236.png"></p>
<p>3、如果<code>cas</code>替换成功，那么对象的对象头储存的就是锁记录的地址和状态<code>01</code>，如下所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755964276.png"></p>
<p>4、如果<code>cas</code>失败，有两种情况</p>
<p>​	1、如果是其它线程已经持有了该<code>Object</code>的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</p>
<p>​	2、如果是自己的线程已经执行了<code>synchronized</code>进行加锁，那么那么再添加一条 <code>Lock Record</code> 作为重入的计数</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583756190177.png"></p>
<p>5、当线程退出<code>synchronized</code>代码块的时候，**如果获取的是取值为 <code>null</code> 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583756357835.png"></p>
<p>6、当线程退出<code>synchronized</code>代码块的时候，如果获取的锁记录取值不为 <code>null</code>，那么使用<code>cas</code>将<code>Mark Word</code>的值恢复给对象</p>
<p>​	1、成功则解锁成功</p>
<p>​	2、失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
</blockquote>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><blockquote>
<p>​	如果在尝试加轻量级锁的过程中，<code>cas</code>操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p>
</blockquote>
<blockquote>
<ol>
<li>当 <code>Thread-1</code> 进行轻量级加锁时，<code>Thread-0</code> 已经对该对象加了轻量级锁</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583757433691.png"></p>
<p>2、这时 <code>Thread-1</code> 加轻量级锁失败，进入锁膨胀流程</p>
<p>​	即为对象申请<code>Monitor</code>锁，让<code>Object</code>指向重量级锁地址，然后自己进入<code>Monitor</code> 的<code>EntryList</code> 变成<code>BLOCKED</code>状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583757586447.png"></p>
<p>3、当<code>Thread-0</code> 线程执行完<code>synchronized</code>同步块时，使用<code>cas</code>将<code>Mark Word</code>的值恢复给对象头, 肯定恢复失败,因为对象的对象头中存储的是重量级锁的地址,状态变为<code>10</code>了之前的是<code>00</code>, 肯定恢复失败。那么会进入重量级锁的解锁过程，即按照<code>Monitor</code>的地址找到<code>Monitor</code>对象，将<code>Owner</code>设置为<code>null</code>，唤醒<code>EntryList</code>中的<code>Thread-1</code>线程</p>
</blockquote>
<h3 id="自旋锁优化-优化重量级锁竞争"><a href="#自旋锁优化-优化重量级锁竞争" class="headerlink" title="自旋锁优化 (优化重量级锁竞争)"></a>自旋锁优化 (优化重量级锁竞争)</h3><blockquote>
<p>​	引入背景：大家都知道，在没有加入锁优化时，<code>Synchronized</code>是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时<code>HotSpot</code>团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃<code>CPU</code>的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。	</p>
<p>​	自旋锁早在<code>JDK1.4</code> 中就引入了，只是当时默认时关闭的。在<code>JDK 1.6</code>后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用<code>CPU</code>的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉<code>CPU</code>资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在<code>JDK</code>定义中，自旋锁默认的自旋次数为<code>10</code>次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
<p>​	可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p>
<p><strong>自适应自旋锁</strong></p>
<p>​	在<code>JDK 1.6</code>中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，<strong>而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</strong>。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么<code>JVM</code>会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到<code>100</code>次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，<code>JVM</code>对程序的锁的状态预测会越来越准确，<code>JVM</code>也会越来越聪明。</p>
<p>​	当发生重量级锁竞争的时候，还可以使用自旋来进行优化 (不加入<code>Monitor</code>的阻塞队列<code>EntryList</code>中)，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换(持锁线程执行完<code>synchronized</code>同步块后,释放锁,<code>Owner</code>为空,唤醒阻塞队列来竞争,胜出的线程得到<code>cpu</code>执行权的过程) 就获得了锁<br>优化的点: 不用将线程加入到阻塞队列, 减少<code>cpu</code>切换.<br>1、自旋重试成功的情况<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583758113724.png"></p>
<p>2、自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583758136650.png"></p>
</blockquote>
<blockquote>
<p>​	自旋会占用 <code>CPU</code> 时间，单核 <code>CPU</code> 自旋就是浪费，多核 <code>CPU</code> 自旋才能发挥优势。<br>​	在 <code>Java 6</code> 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。<code>Java 7</code> 之后不能控制是否开启自旋功能</p>
</blockquote>
<h3 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (<code>biased lock</code>) (用于优化轻量级锁重入)</h3><blockquote>
<p>场景:</p>
<ul>
<li><p>没有竞争的时候, 一个线程中多次使用<code>synchronized</code>需要重入加锁的情况; (只有一个线程进入临界区)</p>
</li>
<li><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过<code>JVM</code>的配置, 将偏向锁给关闭</p>
</li>
<li><p>将进入临界区的线程的<code>ID</code>, 直接设置给锁对象的<code>Mark word</code>, 下次该线程又获取锁, 发现线程<code>ID</code>是自己, 就不需要<code>CAS</code>了</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块A</span></span><br><span class="line">            m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块B</span></span><br><span class="line">            m3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块C</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583760728806.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202174407252.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202174448323.png"></p>
<blockquote>
<p>一个对象的创建过程</p>
<ol>
<li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，<code>Mark Word</code> 最后三位的值<code>101</code>，并且这是它的<code>Thread</code>，<code>epoch</code>，<code>age</code>都是<code>0</code>，在加锁的时候进行设置这些的值.</p>
</li>
<li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p>
</li>
<li><p>注意：处于偏向锁的对象解锁后，线程 <code>id</code> 仍存储于对象头中</p>
</li>
<li><p>实验<code>Test18.java</code>，加上虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t))；</span><br><span class="line">        <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">            test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">        &#125;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，三次输出的状态码都为<code>101</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure>

<p>测试禁用：如果没有开启偏向锁，那么对象创建后最后三位的值为<code>001</code>，这时候它的<code>hashcode</code>，<code>age</code>都为<code>0</code>，<code>hashcode</code>是第一次用到<code>hashcode</code>时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出<code>synchronized</code>状态变回<code>001</code></p>
<ol>
<li><p>测试代码<code>Test18.java</code> 虚拟机参数<code>-XX:-UseBiasedLocking</code></p>
</li>
<li><p>输出结果如下，最开始状态为001，然后加轻量级锁变成<code>00</code>，最后恢复成<code>001</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">	LockFlag (2bit): <span class="number">01</span></span><br><span class="line">LockFlag (2bit): <span class="number">00</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">	LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>撤销偏向锁-hashcode方法</strong></p>
<p>测试 <code>hashCode</code>：当调用对象的<code>hashcode</code>方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p>
<ol>
<li><p>测试代码如下，使用虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>  ，确保我们的程序最开始使用了偏向锁！但是结果显示程序还是使用了轻量级锁。  <code>Test20.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    t.hashCode();</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<p><strong>撤销 - 调用 <code>wait/notify</code></strong></p>
<p>会使对象的锁变成重量级锁，因为<code>wait/notify</code>方法之后重量级锁才支持</p>
</blockquote>
<blockquote>
<p><strong>批量重偏向</strong><br>    如果对象被多个线程访问，但是没有竞争 (上面撤销偏向锁就是这种情况: 一个线程执行完, 另一个线程再来执行, 没有竞争), 这时偏向<code>T1</code>的对象仍有机会重新偏向<code>T2</code>，重偏向会重置<code>Thread ID</code><br>    当撤销偏向锁<code>101</code> 升级为 轻量级锁<code>00</code>超过<code>20</code>次后（超过阈值），<code>JVM</code>会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程 <code>(T2)</code>。<br><strong>批量撤销偏向锁</strong><br>    当撤销偏向锁的阈值超过<code>40</code>以后 ，就会将整个类的对象都改为不可偏向的</p>
</blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2><h3 id="Lock和synchronized区别"><a href="#Lock和synchronized区别" class="headerlink" title="Lock和synchronized区别"></a><code>Lock</code>和<code>synchronized</code>区别</h3><table>
<thead>
<tr>
<th></th>
<th><code>Lock</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>层次方面</td>
<td>1、<code>Lock</code>是一个接口，是在类级别上的实现<br/>2、<code>JDK</code>层次的实现</td>
<td>1、是Java关键字<br/>2、在JVM层次定义的</td>
</tr>
<tr>
<td>灵活性方面</td>
<td><code>Lock</code>接口提供的<code>lock()</code>和<code>unlock()</code>方法，可以随时获得锁、释放锁，非常灵活</td>
<td>1、释放锁、获得锁是被动的<br/>2、释放锁只有两种情况:① 同步代码块执行完毕；② 抛出异常，同步器执行<code>monitorexit</code>释放锁</td>
</tr>
<tr>
<td>锁的状态方面</td>
<td>① <code>Lock</code>可以判断锁的状态<br/>它会提供<code>tryLock()</code>方法来告诉我们是否获得锁成功<br/>② <code>tryLock()</code>方法有返回值，用来尝试获取锁，如果获取成功，则返回<code>true</code>;获取失败，返回<code>false</code>, 这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</td>
<td>1、在锁的状态方面，<code>synchronized</code> 完全是被动的，没法判断锁的状态。<br/>2、<code>synchronized</code>在拿不到锁时，则会阻塞在那里，一直等待</td>
</tr>
<tr>
<td>锁的类型方面</td>
<td>1、基于<code>Lock</code>接口，有多种锁的实现。如:<br/>① 可重入锁: <code>ReentrantLock</code><br/>② 可重入读写锁: <code>ReentrantReadWriteLock</code> 等<br/>2、针对可重入锁，还有公平锁和非公平锁之分</td>
<td>1、对于<code>synchronized</code>来说，它只是一个<code>JVM</code>层次的关键字，并不是一个接口，没有具体实现。<br/>2、<code>synchronized</code>相当于非公平锁。</td>
</tr>
</tbody></table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p><strong>概念：</strong> 多个并发进程因争夺系统资源而产生相互等待的现象。</p>
<p><strong>原理：</strong> 当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p>
</blockquote>
<p>​	如：线程<code>1</code>获取<code>A</code>对象锁, 线程<code>2</code>获取<code>B</code>对象锁; 此时线程<code>1</code>又想获取<code>B</code>对象锁, 线程<code>2</code>又想获取<code>A</code>对象锁; 它们都等着对象释放锁, 此时就称为死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发生死锁的必要条件-重点"><a href="#发生死锁的必要条件-重点" class="headerlink" title="发生死锁的必要条件 (重点)"></a>发生死锁的必要条件 (重点)</h4><blockquote>
<p><strong>互斥：</strong> 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。<br><strong>占有且等待：</strong> 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。<br><strong>不可抢占：</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。<br><strong>循环等待：</strong> 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。<br>       当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。</p>
</blockquote>
<h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><h5 id="方式一、JPS-JStack-进程ID"><a href="#方式一、JPS-JStack-进程ID" class="headerlink" title="方式一、JPS + JStack 进程ID"></a>方式一、<code>JPS</code> + <code>JStack 进程ID</code></h5><blockquote>
<ul>
<li><code>jps</code>先找到<code>JVM</code>进程</li>
<li><code>jstack 进程ID</code><ul>
<li>在<code>Java</code>控制台中的<code>Terminal</code>中输入 <strong><code>jps</code></strong> 指令可以查看<code>正在运行中的进程ID</code>，使用 <strong><code>jstack 进程ID</code></strong> 可以查看进程状态。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123336643.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123406253.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123554788.png"></p>
<h5 id="方式二、-jconsole检测死锁"><a href="#方式二、-jconsole检测死锁" class="headerlink" title="方式二、 jconsole检测死锁"></a>方式二、 <code>jconsole</code>检测死锁</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/359638cf867dbe8d03da37c3e19fefe3.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e9f23bd07142b38d856fef84e6ded641.png"></p>
<h3 id="ReentrantLock-的特点"><a href="#ReentrantLock-的特点" class="headerlink" title="ReentrantLock 的特点"></a><code>ReentrantLock</code> 的特点</h3><blockquote>
<p><strong>支持锁重入</strong><br>    可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此 有权利再次获取这把锁<br><strong>可中断</strong><br>    <code>lock.lockInterruptibly()</code> : 可以被其他线程打断的中断锁<br><strong>可以设置超时时间</strong><br>    <code>lock.tryLock(时间)</code> : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁<br><strong>可以设置为公平锁</strong><br>    (先到先得) 默认是非公平, <code>true</code>为公平 <code>new ReentrantLock(true)</code><br><strong>支持多个条件变量( 有多个<code>waitset</code>)</strong><br>    (可避免虚假唤醒) - <code>lock.newCondition()</code>创建条件变量对象; 通过条件变量对象调用 <code>await/signal</code>方法, 等待&#x2F;唤醒</p>
</blockquote>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要执行的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持锁重入"><a href="#支持锁重入" class="headerlink" title="支持锁重入"></a>支持锁重入</h4><blockquote>
<ul>
<li>可重入锁是指<code>同一个线程如果首次获得了这把锁</code>，那么因为它是这把<code>锁的拥有者</code>，因此 <strong>有权利再次获取这把锁</strong></li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;entry main...&quot;</span>);</span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;entry m1...&quot;</span>);</span><br><span class="line">            m2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;entry m2....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.324</span> guizy.ReentrantTest [main] - entry main...</span><br><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.326</span> guizy.ReentrantTest [main] - entry m1...</span><br><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.326</span> guizy.ReentrantTest [main] - entry m2....</span><br></pre></td></tr></table></figure>

<h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><blockquote>
<p> (针对于<code>lockInterruptibly()</code>方法获得的中断锁) 直接退出阻塞队列, 获取锁失败</p>
<p><code>synchronized</code> 和 <code>reentrantlock.lock()</code> 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断</p>
<p>​	可被中断的锁, 通过<code>lock.lockInterruptibly()</code>获取的锁对象, 可以通过调用阻塞线程的<code>interrupt()</code>方法</p>
<ul>
<li>如果某个线程处于阻塞状态，可以调用其<code>interrupt</code>方法让其停止阻塞，获得锁失败<ul>
<li>处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</li>
</ul>
</li>
<li>可中断的锁, 在一定程度上可以<code>被动</code>的减少<code>死锁</code>的概率, 之所以被动, 是因为我们需要手动调用<code>阻塞线程的interrupt</code>方法;</li>
</ul>
</blockquote>
<p>测试使用<code>lock.lockInterruptibly()</code>可以从阻塞队列中,打断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的可打断锁方法 lock.lockInterruptibly();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;t1线程启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); <span class="comment">//没有获得锁就被打断跑出的异常</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;t1线程获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程获得锁(此锁不可打断)</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;main线程获得了锁&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动t1线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            t1.interrupt();            <span class="comment">//打断t1线程</span></span><br><span class="line">            log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><blockquote>
<h4 id="锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败"><a href="#锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败" class="headerlink" title="锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败"></a>锁超时 (<code>lock.tryLock()</code>) 直接退出阻塞队列, 获取锁失败</h4><p><strong>防止<code>无限制</code>等待, 减少死锁</strong></p>
<p>​	使用 <code>lock.tryLock()</code> 方法会返回获取锁是否成功。如果成功则返回<code>true</code>，反之则返回<code>false</code>。<br>​	并且<code>tryLock</code>方法可以设置指定等待时间，参数为：<code>tryLock(long timeout, TimeUnit unit)</code> , 其中<code>timeout</code>为最长等待时间，<code>TimeUnit</code>为时间单位<br>​	获取锁的过程中, 如果<code>超过等待时间</code>, <code>或者被打断</code>, 就直接从<code>阻塞队列</code>移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)</p>
</blockquote>
<ul>
<li><strong>不设置等待时间, 立即失败</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(), 获取锁立即失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="comment">// 此时肯定获取失败, 因为主线程已经获得了锁对象</span></span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 主线程2s之后才释放锁</span></span><br><span class="line">        Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.726</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.728</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.728</span> guizy.WaitNotifyTest [t1] - 获取立刻失败，返回</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">21.728</span> guizy.WaitNotifyTest [main] - 释放了锁</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(long mills), 超过锁设置的等待时间,就从阻塞队列移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置等待时间, 超过等待时间 / 被打断, 都会获取锁失败; 退出阻塞队列</span></span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;获取锁超时，返回&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;被打断了, 获取锁失败, 返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//        t1.interrupt();</span></span><br><span class="line">        <span class="comment">// 主线程2s之后才释放锁</span></span><br><span class="line">        Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;main线程释放了锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时的打印</span></span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">56.647</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">56.651</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">57.652</span> guizy.WaitNotifyTest [t1] - 获取锁超时，返回</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">58.652</span> guizy.WaitNotifyTest [main] - main线程释放了锁</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断的打印</span></span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.258</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.260</span> guizy.WaitNotifyTest [main] - main线程释放了锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.261</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.261</span> guizy.WaitNotifyTest [t1] - 被打断了, 获取锁失败, 返回</span><br><span class="line">java.lang.InterruptedException</span><br></pre></td></tr></table></figure>

<h4 id="通过lock-tryLock-来解决-哲学家就餐问题-重点"><a href="#通过lock-tryLock-来解决-哲学家就餐问题-重点" class="headerlink" title="通过lock.tryLock()来解决, 哲学家就餐问题 (重点)"></a>通过<code>lock.tryLock()</code>来解决, <code>哲学家就餐</code>问题 (<code>重点</code>)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用了ReentrantLock锁, 该类中有一个tryLock()方法, 在指定时间内获取不到锁对象, 就从阻塞队列移除,不用一直等待。</span></span><br><span class="line"><span class="comment"> *              当获取了左手边的筷子之后, 尝试获取右手边的筷子, 如果该筷子被其他哲学家占用, 获取失败, 此时就先把自己左手边的筷子,</span></span><br><span class="line"><span class="comment"> *              给释放掉. 这样就避免了死锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhilosopherEat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得了左手边筷子 (针对五个哲学家, 它们刚开始肯定都可获得左筷子)</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">// 此时发现它的right筷子被占用了, 使用tryLock(), </span></span><br><span class="line">                	<span class="comment">// 尝试获取失败, 此时它就会将自己左筷子也释放掉</span></span><br><span class="line">                    <span class="comment">// 临界区代码</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123; <span class="comment">//尝试获取右手边筷子, 如果获取失败, 则会释放左边的筷子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类称为锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">01.793</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">01.795</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.293</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.295</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.794</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.796</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.294</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.296</span> guizy.Philosopher [柏拉图] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.795</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.797</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.295</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.297</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.796</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.798</span> guizy.Philosopher [阿基米德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">05.296</span> guizy.Philosopher [柏拉图] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">05.299</span> guizy.Philosopher [赫拉克利特] - eating...</span><br></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><blockquote>
<h4 id="公平锁-new-ReentrantLock-true"><a href="#公平锁-new-ReentrantLock-true" class="headerlink" title="公平锁 new ReentrantLock(true)"></a>公平锁 <code>new ReentrantLock(true)</code></h4><p>​	<code>ReentrantLock</code>默认是非公平锁, 可以指定为公平锁。</p>
<p>​	在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置<code>ReentrantLock</code>为公平的, 会降低并发度</p>
<p><code>Synchronized</code>底层的<code>Monitor</code>锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="什么是公平锁-什么是非公平锁"><a href="#什么是公平锁-什么是非公平锁" class="headerlink" title="什么是公平锁? 什么是非公平锁?"></a>什么是公平锁? 什么是非公平锁?</h5><blockquote>
<p>公平锁 (<code>new ReentrantLock(true)</code>)<br>    公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上<br>    只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁<br>非公平锁 (<code>synchronized</code>, <code>new ReentrantLock()</code>)<br>    非公平锁, 当阻塞队列中已经有等待的线程<code>A</code>了, 此时后到的线程<code>B</code>, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程<code>B</code>就先活的到锁了<br>**所以公平和非公平的区别:**线程执行同步代码块时, 是否回去尝试获取锁, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的</p>
<p>如果不进如队列呢? 线程一直尝试获取锁不就行了?<br>    一直尝试获取锁, 在<code>synchronized</code>轻量级锁升级为重量级锁时, 做的一个优化, 叫做自旋锁, 一般很消耗资源, <code>cpu</code>一直空转, 最后获取锁也失败, 所以不推荐使用。在<code>jdk6</code>对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等</p>
</blockquote>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><blockquote>
<h4 id="条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒"><a href="#条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒" class="headerlink" title="条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用await/signal方法, 等待&#x2F;唤醒"></a>条件变量 (可避免虚假唤醒) - <code>lock.newCondition()</code>创建条件变量对象; 通过条件变量对象调用<code>await/signal</code>方法, 等待&#x2F;唤醒</h4><p>​	<code>Synchronized</code> 中也有条件变量，就是<code>Monitor</code>监视器中的 <code>waitSet</code>等待集合，当条件不满足时进入<code>waitSet</code> 等待<br>​	<code>ReentrantLock</code> 的条件变量比 <code>synchronized</code> 强大之处在于,它是 支持多个条件变量。这就好比<code>synchronized</code> 是那些不满足条件的线程都在一间休息室等通知; (此时会造成虚假唤醒), 而 <code>ReentrantLock </code>支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; (可以避免虚假唤醒)<br>使用要点：</p>
<p>​	<code>await</code> 前需要 获得锁</p>
<p>​	<code>await</code> 执行后，会释放锁，进入 <code>conditionObject (条件变量)</code>中等待</p>
<p>​	<code>await</code> 的线程被唤醒（或打断、或超时）取重新竞争 <code>lock</code> 锁</p>
<p>​	竞争 <code>lock </code>锁成功后，从 <code>await</code> 后继续执行</p>
<p>​	<code>signal</code> 方法用来唤醒条件变量(等待室)汇总的某一个等待的线程</p>
<p>​	<code>signalAll</code>方法, 唤醒条件变量(休息室)中的所有线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock可以设置多个条件变量(多个休息室), 相对于synchronized底层monitor锁中waitSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ConditionVariable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionVariable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeoutSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到 等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到 等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:08:<span class="number">58.231</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.234</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.235</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.235</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">15</span>:08:<span class="number">59.232</span> guizy.WaitNotifyTest [送外卖的] - 送外卖的来咯~</span><br><span class="line"><span class="number">15</span>:08:<span class="number">59.233</span> guizy.WaitNotifyTest [小女] - 外卖来咯, 可以开始干活了</span><br><span class="line"><span class="number">15</span>:09:<span class="number">00.233</span> guizy.WaitNotifyTest [送烟的] - 送烟的来咯~</span><br><span class="line"><span class="number">15</span>:09:<span class="number">00.234</span> guizy.WaitNotifyTest [小南] - 烟来咯, 可以开始干活了</span><br></pre></td></tr></table></figure>

<h3 id="同步模式之顺序控制-案例"><a href="#同步模式之顺序控制-案例" class="headerlink" title="同步模式之顺序控制 (案例)"></a>同步模式之顺序控制 (案例)</h3><ul>
<li>假如有两个线程, 线程<code>A</code>打印<code>1</code>, 线程<code>B</code>打印<code>2</code>.</li>
<li>要求: <strong>程序先打印<code>2</code>, 再打印<code>1</code></strong></li>
</ul>
<h4 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a><code>wait/notify</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用wait/notify来实现顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// t2线程释放执行过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!t2Runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 进入等待(waitset), 会释放锁</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                t2Runned = <span class="literal">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="await-signal版本"><a href="#await-signal版本" class="headerlink" title="await/signal版本"></a><code>await/signal</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用ReentrantLock的await/sinal 来实现顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// t2线程释放执行过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">                <span class="keyword">while</span> (!t2Runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                t2Runned = <span class="literal">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="park-unpartk版本"><a href="#park-unpartk版本" class="headerlink" title="park/unpartk版本"></a><code>park/unpartk</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用LockSupport中的park,unpark来实现, 顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>需求</p>
<ul>
<li><strong>线程<code>1</code> 输出 <code>a</code> <code>5</code>次, 线程<code>2</code> 输出 <code>b</code> <code>5</code>次, 线程<code>3</code> 输出 <code>c</code> <code>5</code>次。现在要求输出 <code>abcabcabcabcabcabc</code></strong></li>
</ul>
<h4 id="wait-notify版本-1"><a href="#wait-notify版本-1" class="headerlink" title="wait/notify版本"></a><code>wait/notify</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用wait/notify来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWaitNotify</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotify</span> <span class="variable">waitNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotify</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotify&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="built_in">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="built_in">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="await-signal版本-1"><a href="#await-signal版本-1" class="headerlink" title="await/signal版本"></a><code>await/signal</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用await/signal来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAwaitSignal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    <span class="comment">//System.out.print(&quot;i:===&quot;+i);</span></span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="park-unpark版本"><a href="#park-unpark版本" class="headerlink" title="park/unpark版本"></a><code>park/unpark</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用park/unpark来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParkUnpark</span> <span class="variable">parkUnpark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Thread nextThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个线程轮流打印1-100"><a href="#三个线程轮流打印1-100" class="headerlink" title="三个线程轮流打印1-100"></a>三个线程轮流打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> loop;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> _flag, <span class="type">int</span> _loop, <span class="type">int</span> _a)</span> &#123;</span><br><span class="line">        flag = _flag;</span><br><span class="line">        loop = _loop;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> _flag, <span class="type">int</span> _nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != _flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                flag = _nextFlag;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><code>Java</code> 内存模型</h2><blockquote>
<p>​	<code>JMM</code>定义了程序中各个共享变量的访问规则，即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节。</p>
<p>​	在 <code>java</code> 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（<code>Local variables</code>），方法定义参数（<code>java</code> 语言规范称之为 <code>formal method parameters</code>）和异常处理器参数（<code>exception handler parameters</code>）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>​	<code>Java</code> 线程之间的通信由 <code>Java</code> 内存模型（本文简称为 <code>JMM</code>）控制，<code>JMM</code> 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，<code>JMM</code> 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（<code>main memory</code>）中，每个线程都有一个私有的本地内存（<code>local memory</code>），本地内存中存储了该线程以读 &#x2F; 写共享变量的副本。本地内存是 <code>JMM</code> 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
</blockquote>
<blockquote>
<p><code>Java</code> 内存模型是一种规范，定义了很多东西：</p>
<ul>
<li>所有的变量都存储在主内存（<code>Main Memory</code>）中。</li>
<li>每个线程都有一个私有的本地内存（<code>Local Memory</code>），本地内存中存储了该线程以读&#x2F;写共享变量的拷贝副本。</li>
<li>线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。</li>
<li>不同的线程之间无法直接访问对方本地内存中的</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/3be664e6b9167e361954a15cd1d8edf3.png"></p>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>​	原子性指的是一个操作不可中断，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>​	在<code>Java</code>中，对于基本数据类型的变量的读取和赋值操作是原子性操作需要注意的是：对于<code>32</code>位系统来说，<code>long</code> 类型数据和 <code>double</code> 类型数据（对于基本类型数据：<code>byte、short、int、float、boolean、char</code> 读写是原子操作），它们的读写并非原子性的，也就是说如果存在两条线程同时对 <code>long</code> 类型或者 <code>double</code> 类型的数据进行读写是存在相互干扰的，因为对于<code>32</code>位虚拟机来说，每次原子读写是<code>32</code>位，而 <code>long</code> 和 <code>double</code> 则是<code>64</code>位的存储单元，这样回导致一个线程在写时，操作完成前<code>32</code>位的原子操作后，轮到<code>B</code>线程读取时，恰好只读取来后<code>32</code>位的数据，这样可能回读取到一个即非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即<code>64</code>位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少，至少在目前的商用虚拟机中，几乎都把<code>64</code>位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道怎么回事即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">10</span>; <span class="comment">//原子性(简单的读取、将数字赋值给变量) </span></span><br><span class="line">Y = x; <span class="comment">//变量之间的相互赋值，不是原子操作 </span></span><br><span class="line">X++; <span class="comment">//对变量进行计算操作 X=x+1; </span></span><br></pre></td></tr></table></figure>

<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote>
<p>​	可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取到这个变量，并且是修改过的新值。</p>
<p>​	但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量 <code>x</code> 的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量 <code>x</code> 进行操作，但此时A线程工作内存中共享变量 <code>x</code> 对线程B来说并不可见，这种工作内存与主内存同步延迟现象就会造成可见性问题，另外指令重排以及编译器优化也可能回导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实回导致程序乱序执行的问题，从而也就导致可见性问题。</p>
</blockquote>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote>
<p>​	有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，比较对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译称机器码指令后可能回会现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在<code>Java</code>程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指令重排现象和工作内存与主内存同步延迟现象</p>
</blockquote>
<h3 id="JMM如何解决原子性、可见性和有序性问题"><a href="#JMM如何解决原子性、可见性和有序性问题" class="headerlink" title="JMM如何解决原子性、可见性和有序性问题"></a>JMM如何解决原子性、可见性和有序性问题</h3><h4 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h4><blockquote>
<p>​	除了 <code>JVM</code> 自身提供的对基本数据类型读写操作的原子性外，可以通过 <code>synchronized</code> 和<code>Lock</code> 实现原子性。因为 <code>synchronized</code> 和 <code>Lock</code> 能够保证任一时刻只有一个线程访问该代码块。</p>
</blockquote>
<h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4><blockquote>
<p>​	<code>volatile</code> 关键字可以保证可见性。当一个共享变量被 <code>volatile</code> 关键字修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。<code>synchronized</code> 和 <code>Lock</code> 也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。</p>
</blockquote>
<h4 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h4><blockquote>
<p>​	在<code>Java</code>里面，可以通过 <code>volatile</code> 关键字来保证一定的“有序性”。另外可以通过 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性，很显然，<code>synchronized</code> 和 <code>Lock</code> 保证每个时刻是只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证来有序性。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><blockquote>
<p>　　<code>java</code>语言规范<code>JVM</code>线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑不一致，这个过程就叫做执行重排序；</p>
</blockquote>
<blockquote>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，重排序分为三种类型：</p>
<p>​	1.编译器优化的重排序：编译器在不改变单线程程序的语义下，可以重新安排语句的执行顺序；</p>
<p>​	2.指令级并行重排序：线程处理器采用了指令级并行技术来将多条指令重叠执行；如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；</p>
<p>​	3.内存系统重排序：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱执行；</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1508365-20200327133446831-1974934373.png"></p>
<blockquote>
<p>​	这些重排序可能会导致多线程程序出现内存可见性问题；对于编译器，<code>JMM</code>的编译器重排序规则会禁止特定类型的编译器重排序；对于处理器重排序，<code>JMM</code>的处理器重排序规则会要求<code>java</code>编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型处理器重排序；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PossibleReordering</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	很容易想到这段代码的运行结果可能为<code>(1,0)</code>、<code>(0,1)</code>或<code>(1,1)</code>，因为线程<code>one</code>可以在线程<code>two</code>开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p>
<p>​	然而，这段代码的执行结果也可能是<code>(0,0)</code>, 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到<code>(0,0)</code>结果的语句执行过程，如下图所示。值得注意的是，<code>a=1</code>和<code>x=b</code>这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”<code>(reordering)</code>。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/decdc45db40d1775e8b16db006e21a4232890.png"></p>
<p>对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/319709161b06ee0c058a08a77bb8a32126550.png"></p>
<blockquote>
<p>​	实验代码是构造一个循环，反复执行上面的实例代码，直到出现<code>a=0</code>且<code>b=0</code>的输出为止。实验结果说明，循环执行到第<code>13830</code>次时输出了<code>(0,0)</code>.</p>
<p>​	大多数现代微处理器都会采用将指令乱序执行（<code>out-of-order execution</code>，简称<code>OoOE</code>或&#96;OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。	通过乱序执行的技术，处理器可以大大提高执行效率。</p>
<p>​	除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p>
</blockquote>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><code>as-if-serial</code>语义</h4><blockquote>
<p>​	<code>As-if-serial</code>语义的意思是，所有的动作(<code>Action</code>)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。<code>Java</code>编译器、运行时和处理器都会保证单线程下的<code>as-if-serial</code>语义。 比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p>
<ul>
<li><code>int a = 1</code>;</li>
<li><code>int b = 2</code>;</li>
<li><code>int c = a + b</code>;</li>
</ul>
<p>将上面的代码编译成<code>Java</code>字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</p>
<ol>
<li>对<code>a</code>赋值<code>1</code></li>
<li>对<code>b</code>赋值<code>2</code></li>
<li>取<code>a</code>的值</li>
<li>取<code>b</code>的值</li>
<li>将取到两个值相加后存入<code>c</code></li>
</ol>
<p>​    在上面<code>5</code>个动作中，动作<code>1</code>可能会和动作<code>2、4</code>重排序，动作<code>2</code>可能会和动作<code>1、3</code>重排序，动作<code>3</code>可能会和动作<code>2、4</code>重排序，动作<code>4</code>可能会和<code>1、3</code>重排序。但动作<code>1</code>和动作<code>3、5</code>不能重排序。动作<code>2</code>和动作<code>4、5</code>不能重排序。因为它们之间存在数据依赖关系，一旦重排，<code>as-if-serial</code>语义便无法保证。</p>
<p>​	为保证<code>as-if-serial</code>语义，<code>Java</code>异常处理机制也会为重排序做一些特殊处理。例如在下面的代码中，<code>y = 0 / 0</code>可能会被重排序在<code>x = 2</code>之前执行，为了保证最终不致于输出<code>x = 1</code>的错误结果，<code>JIT</code>在重排序时会在<code>catch</code>语句中插入错误代偿代码，将<code>x</code>赋值为<code>2</code>，将程序恢复到发生异常时应有的状态。这种做法的确将异常捕捉的逻辑变得复杂了，但是<code>JIT</code>的优化的原则是，尽力优化正常运行下的代码逻辑，哪怕以<code>catch</code>块逻辑变得复杂为代价，毕竟，进入<code>catch</code>块内是一种“异常”情况的表现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reordering</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = <span class="number">2</span>;</span><br><span class="line">            y = <span class="number">0</span> / <span class="number">0</span>;    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><code>happens-before</code> 原则</h4><blockquote>
<p>​	只靠 <code>synchronized</code> 和 <code>volatile</code> 关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从<code>JDK 5</code> 开始，<code>Java</code> 使用新的 <code>JSR-133</code> 内存模型，提供了 <code>happens-before</code> 原则 来辅助保证程序执行的原子性、可见性和有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。<code>happens-before</code> 原则内容如下：</p>
<ol>
<li><strong>程序顺序原则</strong>，即在一个线程内必须保证语义串行，也就是说按照代码顺序执行。</li>
<li><strong>锁规则</strong>，解锁（<code>unlock</code>）操作必然发生在后续的同一个锁的加锁（<code>lock</code>）之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后（同一个锁）。</li>
<li><strong><code>volatile</code>规则</strong>， <code>volatile</code>变量的写，先发生于读，这保证了<code>volatile</code>变量的可见性，简单理解就是，<code>volatile</code>变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>
<li><strong>线程启动规则</strong>，线程的 <code>start()</code> 方法先于它的每一个动作，即如果线程<code>A</code>在执行线程<code>B</code>的 <code>start</code> 方法之前修改了共享变量的值，那么当线程<code>B</code>执行<code>start</code>方法时，线程<code>A</code>对共享变量的修改对线程<code>B</code>可见。</li>
<li><strong>传递性</strong>，<code>A</code>先于<code>B</code>，<code>B</code>先于<code>C</code>，那么<code>A</code>必然先于<code>C</code>。</li>
<li><strong>线程终止原则</strong>，线程的所有操作先于线程的终结，<code>Thread.join()</code> 方法的作用是等待当前执行的线程终止。假设在线程<code>B</code>终止之前，修改了共享变量，线程<code>A</code>从线程<code>B</code>的<code>join</code>方法成功返回，线程<code>B</code>对共享变量的修改将对线程<code>A</code>可见。</li>
<li><strong>线程中断规则</strong>，对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检查到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测线程十分中断。</li>
<li><strong>对象终结规则</strong>，对象的构造函数执行，结束先于 <code>finalize()</code> 方法。</li>
</ol>
</blockquote>
<blockquote>
<p>​	除此之外，<code>Java</code>内存模型对<code>volatile</code>和<code>final</code>的语义做了扩展。对<code>volatile</code>语义的扩展保证了<code>volatile</code>变量在一些情况下不会重排序，<code>volatile</code>的<code>64</code>位变量<code>double</code>和<code>long</code>的读取和赋值操作都是原子的。对<code>final</code>语义的扩展保证一个对象的构建方法结束前，所有<code>final</code>成员变量都必须完成初始化（的前提是没有<code>this</code>引用溢出）。</p>
</blockquote>
<p><code>Java</code>内存模型关于重排序的规定，总结后如下表所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/94e93b3a7b49dc4c46b528fde1a03cd967665.png"></p>
<blockquote>
<p>​	表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有<code>volatile</code>写重排序。另外，<code>JMM</code>也规定了上述<code>volatile</code>和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括<code>JIT</code>，下同）证明了一个<code>volatile</code>变量只能被单线程访问，那么就可能会把它做为普通变量来处理。</p>
<p>​	留白的单元格代表允许在不违反<code>Java</code>基本语义的情况下重排序。例如，编译器不会对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。</p>
</blockquote>
<blockquote>
<p>​	为了保证内存可见性，<code>java</code> 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。<code>JMM</code> 把内存屏障指令分为下列四类：</p>
</blockquote>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LoadLoad Barriers</code></td>
<td><code>Load1; LoadLoad; Load2</code></td>
<td>确保 <code>Load1</code> 数据的装载，之前于 <code>Load2</code> 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td><code>StoreStore Barriers</code></td>
<td><code>Store1; StoreStore; Store2</code></td>
<td>确保 <code>Store1</code> 数据对其他处理器可见（刷新到内存），之前于 <code>Store2</code> 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td><code>LoadStore Barriers</code></td>
<td><code>Load1; LoadStore; Store2</code></td>
<td>确保 <code>Load1</code> 数据装载，之前于 <code>Store2</code> 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td><code>StoreLoad Barriers</code></td>
<td><code>Store1; StoreLoad; Load2</code></td>
<td>确保 <code>Store1</code> 数据对其他处理器变得可见（指刷新到内存），之前于 <code>Load2</code> 及所有后续装载指令的装载。</td>
</tr>
</tbody></table>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-volatile-3.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-volatile-4.png"></p>
<blockquote>
<p>​	<code>StoreLoad Barriers</code> 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p>
<p>​	<code>StoreLoad Barriers</code> 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（<code>buffer fully flush</code>）。</p>
</blockquote>
<h3 id="并发编程的两个关键问题"><a href="#并发编程的两个关键问题" class="headerlink" title="并发编程的两个关键问题"></a>并发编程的两个关键问题</h3><h4 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a>线程之间如何通信</h4><blockquote>
<p>两种通信机制，<strong>共享内存</strong>和<strong>消息传递</strong>，<code>Java</code>内存模型中使用共享内存</p>
</blockquote>
<h4 id="线程之间如何同步"><a href="#线程之间如何同步" class="headerlink" title="线程之间如何同步"></a>线程之间如何同步</h4><blockquote>
<ul>
<li>共享内存通信机制中，线程同步是显式的，程序员要显式指定</li>
<li>消息传递通信机制中，线程同步是隐式的，消息的发送必须在消息的接受之前</li>
</ul>
</blockquote>
<h3 id="JMM原子操作"><a href="#JMM原子操作" class="headerlink" title="JMM原子操作"></a><code>JMM</code>原子操作</h3><h4 id="八种原子操作"><a href="#八种原子操作" class="headerlink" title="八种原子操作"></a>八种原子操作</h4><table>
<thead>
<tr>
<th align="center">名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lock</code>(锁定)</td>
<td>作用于主内存的变量，一个变量在同一时间只能一个线程锁定。该操作表示该线程独占锁定的变量。</td>
</tr>
<tr>
<td align="center"><code>unlock</code>(解锁)</td>
<td>作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定。</td>
</tr>
<tr>
<td align="center"><code>read</code>(读取)</td>
<td>作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用。</td>
</tr>
<tr>
<td align="center"><code>load</code>(载入)</td>
<td>作用于线程的工作内存的变量，表示把<code>read</code>操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</td>
</tr>
<tr>
<td align="center"><code>use</code>(使用)</td>
<td>作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</td>
</tr>
<tr>
<td align="center"><code>assign</code>(赋值)</td>
<td>作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</td>
</tr>
<tr>
<td align="center"><code>store</code>(存储)</td>
<td>作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的<code>write</code>操作使用。</td>
</tr>
<tr>
<td align="center"><code>write</code>(写入)</td>
<td>作用于主内存的变量，把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中。</td>
</tr>
</tbody></table>
<h4 id="JMM规定了以上8中操作需要按照如下规则进行"><a href="#JMM规定了以上8中操作需要按照如下规则进行" class="headerlink" title="JMM规定了以上8中操作需要按照如下规则进行"></a><code>JMM</code>规定了以上<code>8</code>中操作需要按照如下规则进行</h4><blockquote>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li>
<li><strong>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值。</strong></li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被其他线程锁定住的变量。<br>以上<code>8</code>中规则看着也是比较生涩的，其实如果你没看明白也没关系，其实这些规则就是保障数据同步的一些规则。不是很重要，重要的在后面的<code>happens-before</code>原则。</li>
</ul>
</blockquote>
<h4 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200203151627869.png"></p>
<blockquote>
<p>线程<code>1</code>：先把<code>initFlag</code>变量<code>read</code>读取出来，再<code>load</code>载入工作内存，<code>use</code>使用线程<code>1</code>执行代码<code>!initFlag</code></p>
<p>线程<code>2</code>：先把<code>initFlag</code>变量<code>read</code>读取出来，再<code>load</code>载入工作内存，<code>use</code>使用线程<code>2</code>执行代码<code>initFlag=true</code>，再<code>assign</code>重新赋值，<code>store</code>存储并写入主内存，<code>write</code>写入到主内存中的变量。（线程<code>2</code>对缓存行<code>lock</code>加锁，<code>write</code>写入主内存后会解锁<code>unlock</code>，防止<code>initFlag</code>还未<code>write</code>写入主内存就被线程<code>1</code>读取为<code>false</code>）。</p>
<p>线程<code>1</code>：因为<code>initFlag</code>被<code>volatile</code>修饰，使用<code>MESI</code>缓存一致性协议，线程<code>1</code>cpu总线嗅探机制监听到了<code>initFlag</code>值的修改，线程<code>1</code>中<code>initFlag=false</code>失效变为true&#96;退出循环继续执行，体现了多线程同步运行共享变量副本的可见性。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200702162128208.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibilityTest</span> &#123;</span><br><span class="line">    <span class="comment">//volatile变量，用来确保将变量的更新操作通知到其他线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;waiting data...&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!initFlag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;==============success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                prepareData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareData</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;preparing data...&quot;</span>);</span><br><span class="line">            initFlag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;prepare data end...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lock和unlock"><a href="#lock和unlock" class="headerlink" title="lock和unlock"></a><code>lock</code>和<code>unlock</code></h4><blockquote>
<p>​	上面的<code>8</code>个原子操作中没有具体说<code>lock</code>和<code>unlock</code>，这里单拿出来聊一聊，因为这两个操作相比于其他操作涉及的东西多一些。在早些时候<code>lock</code>和<code>unlock</code>操作是通过总线加锁方式实现的，这种实现方式是在<code>read</code>之前就进行了<code>lock</code>操作，如下图所示，这种方式的弊端之一就是性能低下，因为这样的话一个<code>cpu</code>在从主内存读取数据到工作内存回对整个过程加锁，这样的话其他<code>cpu</code>就没有办法从主内存读取这个数据，直到这个<code>cpu</code>使用完数据后释放掉锁之后其他<code>cpu</code>才能继续读取数据。这样多核<code>cpu</code>“并行”执行任务的优点就体现不出来，因为这样的话，虽然有多个<code>cpu</code>,但其实在执行任务的时候还是“串行”执行。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200519001952558.png"></p>
<blockquote>
<p>​	而<code>volatile</code>方式的<code>lock</code>操作是在<code>store</code>之前进行的，这个锁的粒度相比于上面的粒度要小很多，因为上面的锁它的作用范围横跨了主内存和工作内存交换数据的整个过程<code>（read、load、use、assign、store、write）</code>,而这个锁只涉及<code>store</code>和<code>write</code>两个过程，这样效率得到了很大的提升。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2020051717501490.png"></p>
<blockquote>
<p>​	清楚了上面的概念后我们再思考一个问题：<code>lock</code>和<code>unlock</code>操作可不可以省略？其实我们在上面讲的时候就没有在流程图中画这两个操作，感觉也很好的实现了共享变量的可见性，但仔细分析你就会发现没有这两个操作是不行的，主要原因还是“高并发”会引起的问题，思考下面两个场景：</p>
<p>​	假如线程<code>1</code>和线程<code>2</code>同时往主内存中回写数据，如果没有锁机制是不是会导致数据出错。<br>​	假如线程<code>2</code>执行完了<code>store</code>操作（已经写入主内存中，但是还没有赋值给<code>initFlag</code>变量，此时的<code>initFlag</code>依旧是<code>false</code>)，而正在此时，线程<code>1</code>进行了read操作，那么它拿到的值依旧时<code>initFlag=false</code>的值。<br>​	所以综上，<code>lock</code>和<code>unlock</code>是必须要有的操作。</p>
</blockquote>
<h3 id="JMM-缓存不一致问题"><a href="#JMM-缓存不一致问题" class="headerlink" title="JMM 缓存不一致问题"></a><code>JMM</code> 缓存不一致问题</h3><blockquote>
<p>​	如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题，这个时候该怎么解决呢？</p>
<p>解决 <code>JMM</code> 中的本地内存变量的缓存不一致问题有两种解决方案，分别是<strong>总线加锁</strong>和**<code>MESI</code>缓存一致性协议**。</p>
</blockquote>
<h4 id="总线加锁"><a href="#总线加锁" class="headerlink" title="总线加锁"></a>总线加锁</h4><blockquote>
<p>​	总线加锁是 <code>CPU</code> 从主内存读取数据到本地内存时，会先在总线对这个数据加锁，这样其它 <code>CPU</code> 就没法去读或者去写这个数据，直到这个 <code>CPU</code> 使用完数据释放锁后，其它的 <code>CPU</code> 才能读取该数据。</p>
<p>​	总线加锁虽然能保证数据一致，但是它却严重降低了系统性能，因为当一个线程多总线加锁后，其它线程都只能等待，将原有的并行操作转成了串行操作。<br>​	通常情况下，我们不采用这种方法，而是使用性能较高的缓存一致性协议。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/340ebc442de393e5d6eada74e0f5cea6.png"></p>
<h4 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI 缓存一致性协议"></a><code>MESI</code> 缓存一致性协议</h4><blockquote>
<p>​	<code>MESI</code> 缓存一致性协议是多个 <code>CPU</code> 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 <code>CPU</code> 修改了缓存里的数据，该数据会马上同步回主内存，其它 <code>CPU</code> 通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据<strong>失效</strong>。<br>​	在并发编程中，如果多个线程对同一个共享变量进行操作时，我们通常会在变量名称前加上关键在<code>volatile</code>,因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发<code>read</code>操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上，<code>volatile</code>的工作原理就是依赖于 <code>MESI</code> 缓存一致性协议实现的。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><h3 id="防重排序"><a href="#防重排序" class="headerlink" title="防重排序"></a>防重排序</h3><blockquote>
<p>​	我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁<code>(DCL)</code>的方式来实现。其源码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在我们分析一下为什么要在变量<code>singleton</code>之间加上<code>volatile</code>关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为<code>volatile</code>类型的变量。</p>
</blockquote>
<h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><blockquote>
<p>​	可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。<code>volatile</code>关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span>+b+<span class="string">&quot;;a=&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">VolatileTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest</span>();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	直观上说，这段代码的结果只可能有两种：<code>b=3;a=3</code> 或 <code>b=2;a=1</code>。不过运行上面的代码(可能时间上要长一点)，你会发现除了上两种结果之外，还出现了第三种结果：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...... </span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">1</span> <span class="comment">// 这里</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	为什么会出现<code>b=3;a=1</code>这种结果呢? 正常情况下，如果先执行<code>change</code>方法，再执行<code>print</code>方法，输出结果应该为<code>b=3;a=3</code>。相反，如果先执行的<code>print</code>方法，再执行<code>change</code>方法，结果应该是 <code>b=2;a=1</code>。那<code>b=3;a=1</code>的结果是怎么出来的? 原因就是第一个线程将值<code>a=3</code>修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将<code>a</code>和<code>b</code>都改成<code>volatile</code>类型的变量再执行，则再也不会出现<code>b=3;a=1</code>的结果了。</p>
</blockquote>
<h3 id="保证原子性-单次读-写"><a href="#保证原子性-单次读-写" class="headerlink" title="保证原子性:单次读&#x2F;写"></a>保证原子性:单次读&#x2F;写</h3><blockquote>
<p>​	<code>volatile</code>不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）：</p>
</blockquote>
<h4 id="问题1：-i-为什么不能保证原子性"><a href="#问题1：-i-为什么不能保证原子性" class="headerlink" title="问题1： i++为什么不能保证原子性?"></a>问题1： <code>i++</code>为什么不能保证原子性?</h4><blockquote>
<p>​	对于原子性，需要强调一点，也是大家容易误解的一点：对<code>volatile</code>变量的单次读&#x2F;写操作可以保证原子性的，如<code>long</code>和<code>double</code>类型变量，但是并不能保证<code>i++</code>这种操作的原子性，因为本质上<code>i++</code>是读、写两次操作。</p>
<p>​	现在我们就通过下列程序来演示一下这个问题：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest01</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addI</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span>  <span class="type">VolatileTest01</span> <span class="variable">test01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest01</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">1000</span>; n++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test01.addI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);<span class="comment">//等待10秒，保证上面程序执行完成</span></span><br><span class="line">        System.out.println(test01.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	大家可能会误认为对变量<code>i</code>加上关键字<code>volatile</code>后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：<code>981</code> 可能每个人运行的结果不相同。不过应该能看出，<code>volatile</code>是无法保证原子性的(否则结果应该是<code>1000</code>)。原因也很简单，<code>i++</code>其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取<code>i</code>的值。</li>
<li>对<code>i</code>加<code>1</code>。</li>
<li>将i的值写回内存。 <code>volatile</code>是无法保证这三个操作是具有原子性的，我们可以通过<code>AtomicInteger</code>或者<code>Synchronized</code>来保证<code>+1</code>操作的原子性。 注：上面几段代码中多处执行了<code>Thread.sleep()</code>方法，目的是为了增加并发问题的产生几率，无其他作用。</li>
</ul>
</blockquote>
<h4 id="问题2：-共享的long和double变量的为什么要用volatile"><a href="#问题2：-共享的long和double变量的为什么要用volatile" class="headerlink" title="问题2： 共享的long和double变量的为什么要用volatile?"></a>问题2： 共享的<code>long</code>和<code>double</code>变量的为什么要用<code>volatile</code>?</h4><blockquote>
<p>​	因为<code>long``和double</code>两种数据类型的操作可分为高<code>32</code>位和低<code>32</code>位两部分，因此普通的<code>long</code>或<code>double</code>类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的<code>long</code>和<code>double</code>变量设置为<code>volatile</code>类型，这样能保证任何情况下对<code>long</code>和<code>double</code>的单次读&#x2F;写操作都具有原子性。</p>
</blockquote>
<h3 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a><code>volatile</code> 的实现原理</h3><h4 id="volatile可见性实现"><a href="#volatile可见性实现" class="headerlink" title="volatile可见性实现"></a><code>volatile</code>可见性实现</h4><blockquote>
<p><code>volatile</code> 变量的内存可见性是基于内存屏障<code>(Memory Barrier)</code>实现:</p>
<ul>
<li>内存屏障，又称内存栅栏，是一个 <code>CPU</code> 指令。</li>
<li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，<code>JMM</code> 为了保证在不同的编译器和 <code>CPU</code> 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 <code>CPU</code>：不管什么指令都不能和这条 <code>Memory Barrier</code> 指令重排序。</li>
</ul>
</blockquote>
<p>写一段简单的 <code>Java</code> 代码，声明一个 <code>volatile</code> 变量，并赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  <span class="number">0x0000000002951563</span>: and    $<span class="number">0xffffffffffffff87</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951567</span>: je     <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295156d</span>: test   $<span class="number">0x7</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951574</span>: jne    <span class="number">0x00000000029515bd</span></span><br><span class="line">  <span class="number">0x0000000002951576</span>: test   $<span class="number">0x300</span>,%rdi</span><br><span class="line">  <span class="number">0x000000000295157d</span>: jne    <span class="number">0x000000000295159c</span></span><br><span class="line">  <span class="number">0x000000000295157f</span>: and    $<span class="number">0x37f</span>,%rax</span><br><span class="line">  <span class="number">0x0000000002951586</span>: mov    %rax,%rdi</span><br><span class="line">  <span class="number">0x0000000002951589</span>: or     %r15,%rdi</span><br><span class="line">  <span class="number">0x000000000295158c</span>: lock cmpxchg %rdi,(%rdx)  <span class="comment">//在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span></span><br><span class="line">  <span class="number">0x0000000002951591</span>: jne    <span class="number">0x0000000002951a15</span></span><br><span class="line">  <span class="number">0x0000000002951597</span>: jmpq   <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295159c</span>: mov    <span class="number">0x8</span>(%rdx),%edi</span><br><span class="line">  <span class="number">0x000000000295159f</span>: shl    $<span class="number">0x3</span>,%rdi</span><br><span class="line">  <span class="number">0x00000000029515a3</span>: mov    <span class="number">0xa8</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">0x00000000029515aa</span>: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lock</code> 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 <code>CPU</code> 里缓存了该内存地址的额数据无效。</li>
</ul>
<p>​    为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(<code>L1，L2</code> 或其他)后再进行操作，但操作完不知道何时会写到内存。</p>
<p>​	如果对声明了 <code>volatile</code> 的变量进行写操作，<code>JVM</code> 就会向处理器发送一条 <code>lock</code> 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>​	为了保证各个处理器的缓存是一致的，实现了缓存一致性协议<code>(MESI)</code>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>​	所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>​	<code>volatile</code> 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
</blockquote>
<h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a><code>volatile</code> 禁止重排序</h4><blockquote>
<p>​	为了性能优化，<code>JMM</code> 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。<code>JMM</code> 提供了内存屏障阻止这种重排序。</p>
</blockquote>
<h3 id="volatile-的应用场景"><a href="#volatile-的应用场景" class="headerlink" title="volatile 的应用场景"></a><code>volatile</code> 的应用场景</h3><blockquote>
<p>使用 <code>volatile</code> 必须具备的条件</p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
<li>只有在状态真正独立于程序内其他内容时才能使用 <code>volatile</code>。</li>
</ul>
</blockquote>
<h4 id="模式1：状态标志"><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式<code>1</code>：状态标志</h4><blockquote>
<p>​	也许实现 <code>volatile</code> 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequested;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式2：一次性安全发布-one-time-safe-publication"><a href="#模式2：一次性安全发布-one-time-safe-publication" class="headerlink" title="模式2：一次性安全发布(one-time safe publication)"></a>模式<code>2</code>：一次性安全发布(<code>one-time safe publication</code>)</h4><blockquote>
<p>​	缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(<code>double-checked-locking</code>)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackgroundFloobleLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initInBackground</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> <span class="title class_">Flooble</span>();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeOtherClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="literal">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式3：独立观察-independent-observation"><a href="#模式3：独立观察-independent-observation" class="headerlink" title="模式3：独立观察(independent observation)"></a>模式<code>3</code>：独立观察(<code>independent observation</code>)</h4><blockquote>
<p>​	安全使用 <code>volatile</code> 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 <code>volatile</code> 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">authenticate</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式4：volatile-bean-模式"><a href="#模式4：volatile-bean-模式" class="headerlink" title="模式4：volatile bean 模式"></a>模式<code>4</code>：<code>volatile bean</code> 模式</h4><blockquote>
<p>​	在 <code>volatile bean</code> 模式中，<code>JavaBean</code> 的所有数据成员都是 <code>volatile</code> 类型的，并且 <code>getter </code>和 <code>setter</code> 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 <code>volatile </code>时，只有引用而不是数组本身具有 <code>volatile</code> 语义)。对于任何 <code>volatile</code> 变量，不变式或约束都不能包含 JavaBean 属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式5：开销较低的读－写锁策略"><a href="#模式5：开销较低的读－写锁策略" class="headerlink" title="模式5：开销较低的读－写锁策略"></a>模式<code>5</code>：开销较低的读－写锁策略</h4><blockquote>
<p>​	<code>volatile</code> 的功能还不足以实现计数器。因为 <code>++x</code> 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 <code>volatile</code> 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 <code>volatile</code> 变量来减少公共代码路径的开销。 安全的计数器使用 <code>synchronized</code> 确保增量操作是原子的，并使用 <code>volatile</code> 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 <code>volatile</code> 读操作，这通常要优于一个无竞争的锁获取的开销。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesyCounter</span> &#123;</span><br><span class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></span><br><span class="line">    <span class="comment">// All mutative operations MUST be done with the &#x27;this&#x27; lock held</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检查-double-checked"><a href="#双重检查-double-checked" class="headerlink" title="双重检查(double-checked)"></a>双重检查(<code>double-checked</code>)</h4><blockquote>
<p>​	单例模式的一种实现方式，但很多人会忽略 <code>volatile</code> 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 <code>100%</code>，说不定在未来的某个时刻，隐藏的 <code>bug </code>就出来了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><blockquote>
<p>​	当某个类的整体定义为<code>final</code>时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
</blockquote>
<blockquote>
<p>​	注意：<code>final</code>类中的所有方法都隐式为<code>final</code>，因为无法覆盖他们，所以在<code>final</code>类中给任何方法添加<code>final</code>关键字是没有任何意义的。</p>
</blockquote>
<blockquote>
<p>​	这里顺道说说<code>final</code>类型的类如何拓展? 比如<code>String</code>是<code>final</code>类型，我们想写个<code>MyString</code>复用所有<code>String</code>中方法，同时增加一个新的<code>toMyString()</code>的方法，应该如何做? </p>
</blockquote>
<blockquote>
<p>​	设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的(<code>final</code>修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toMyString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><blockquote>
<p>常规的使用就不说了，这里说下:</p>
<ul>
<li><code>private</code> 方法是隐式的<code>final</code></li>
<li><code>final</code>方法是可以被重载的</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重载(<code>Overload</code>)</strong></p>
<ul>
<li>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数&#x2F;类型。</li>
<li>是一个类中多态性的一种表现。</li>
<li>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是<code>fun(int, float)</code>， 但是不能为<code>fun(int, int)）</code>；</li>
<li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
<li>方法的异常类型和数目不会对重载造成影响；</li>
<li>对于继承来说，如果某一方法在父类中是访问权限是<code>priavte</code>，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li>
</ul>
<p><strong>重写(<code>Override</code>)</strong></p>
<ul>
<li>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</li>
<li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li>
<li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li>
<li>被覆盖的方法不能为<code>private</code>，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
</ul>
</blockquote>
<h4 id="private-final"><a href="#private-final" class="headerlink" title="private final"></a><code>private final</code></h4><blockquote>
<p>​	类中所有<code>private</code>方法都隐式地指定为<code>final</code>的，由于无法取用<code>private</code>方法，所以也就不能覆盖它。可以对<code>private</code>方法增添<code>final</code>关键字，但这样做并没有什么好处。看下下面的例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Base</span> <span class="variable">father</span> <span class="operator">=</span> son;</span><br><span class="line">        <span class="comment">//father.test();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>Base</code>和<code>Son</code>都有方法<code>test()</code>，但是这并不是一种覆盖，因为<code>private</code>所修饰的方法是隐式的<code>final</code>，也就是无法被继承，所以更不用说是覆盖了，在<code>Son</code>中的<code>test()</code>方法不过是属于<code>Son</code>的新成员罢了，<code>So</code>n进行向上转型得到<code>father</code>，但是<code>father.test()</code>是不可执行的，因为<code>Base</code>中的<code>test</code>方法是<code>private</code>的，无法被访问到。</p>
</blockquote>
<h4 id="final方法是可以被重载的"><a href="#final方法是可以被重载的" class="headerlink" title="final方法是可以被重载的"></a><code>final</code>方法是可以被重载的</h4><blockquote>
<p>​	我们知道父类的<code>final</code>方法是不能够被子类重写的，那么<code>final</code>方法可以被重载吗?  答案是可以的，下面代码是正确的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExampleParent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h3><blockquote>
<p>​	<code>Java</code>允许在参数列表中以声明的方式将参数指明为<code>final</code>，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
</blockquote>
<h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><blockquote>
<p>常规的用法比较简单，这里通过下面三个问题进一步说明。</p>
</blockquote>
<h4 id="所有的final修饰的字段都是编译期常量吗"><a href="#所有的final修饰的字段都是编译期常量吗" class="headerlink" title="所有的final修饰的字段都是编译期常量吗?"></a>所有的<code>final</code>修饰的字段都是编译期常量吗?</h4><blockquote>
<p>​	现在来看编译期常量和非编译期常量, 如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是<code>k</code>的值在被初始化后无法被更改。</p>
</blockquote>
<h4 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a><code>static final</code></h4><blockquote>
<p>​	一个既是<code>static</code>又是<code>final</code> 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码某次输出结果：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=2 k2=7</span><br><span class="line">k=8 k2=7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	我们可以发现对于不同的对象k的值是不同的，但是<code>k2</code>的值却是相同的，这是为什么呢? 因为<code>static</code>关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为<code>static final</code>所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p>
</blockquote>
<h4 id="blank-final"><a href="#blank-final" class="headerlink" title="blank final"></a><code>blank final</code></h4><blockquote>
<p>​	<code>Java</code>允许生成空白<code>final</code>，也就是说被声明为<code>final</code>但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白<code>final</code>)</li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。</li>
</ul>
<p>这增强了<code>final</code>的灵活性。</p>
</blockquote>
<blockquote>
<p>看下面代码:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> i2;<span class="comment">//空白final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        i2 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到<code>i2</code>的赋值更为灵活。但是请注意，如果字段由<code>static</code>和<code>final</code>修饰，仅能在定义处赋值，因为该字段不属于对象，属于这个类。</p>
</blockquote>
<h3 id="使用-final-的限制条件和局限性"><a href="#使用-final-的限制条件和局限性" class="headerlink" title="使用 final 的限制条件和局限性"></a>使用 <code>final</code> 的限制条件和局限性</h3><blockquote>
<p>当声明一个 <code>final</code> 成员时，必须在构造函数退出前设置它的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">myField</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> myField;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    myField = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将指向对象的成员声明为 <code>final</code> 只能将该引用设为不可变的，而非所指的对象。</p>
</blockquote>
<blockquote>
<p>下面的方法仍然可以修改该 <code>list</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明为 <code>final</code> 可以保证如下操作不合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">myList = someOtherList;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 <code>final</code>，则必须提供其他方式保证线程安全。</p>
<p>​	“ 其他方式 “ 可以包括声明成员为 <code>volatile</code>，使用 <code>synchronized</code> 或者显式 <code>Lock</code> 控制所有该成员的访问。</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><code>CAS</code></h2><blockquote>
<ul>
<li><code>Java</code>中 <strong><code>synchronized</code></strong> 和 <strong><code>ReentrantLock</code></strong> 等 独占锁 就是 <strong><code>悲观锁</code></strong> 思想的实现</li>
<li>在<code>Java</code>中**<code>java.util.concurrent.atomic</code>包下面的原子变量类**就是使用了<code>乐观锁</code>的一种实现方式 <strong><code>CAS</code></strong> 实现的</li>
<li>管程即<code>monitor</code>是<code>阻塞式的悲观锁</code>实现<code>并发控制</code>，这章我们将通过<code>非阻塞式的乐观锁</code>的来实现<code>并发控制</code></li>
<li><strong>CAS有三个操作值：内存值V，预期值A，要修改的值B，当且仅当预期值A等于当前内存值V的时候，才将内存值更新为B。</strong></li>
</ul>
</blockquote>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><blockquote>
<p>有如下需求，保证<code>account.withdraw</code>取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用重量级锁synchronized来保证多线程访问共享资源发生的安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountCas</span>(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决思路-无锁</strong></p>
<blockquote>
<p>​	上面的代码中使用<code>synchronized加锁</code>操作来<code>保证线程安全</code>，但是 **<code>synchronized</code>加锁操作太耗费资源 (因为底层使用了操作系统<code>mutex</code>指令, 造成内核态和用户态的切换)**，这里我们使用 <strong><code>无锁</code></strong> 来解决此问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountCas</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">	<span class="comment">//使用原子整数: 底层使用CAS+重试的机制</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AccountCas</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//得到原子整数的值</span></span><br><span class="line">		<span class="keyword">return</span> balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">//获得修改前的值</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">			<span class="comment">//获得修改后的值</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">			<span class="comment">//比较并设置值</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,</span></span><br><span class="line"><span class="comment">				就继续where(true),如果匹配上了, 将next值设置给共享变量.</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS-与-volatile-重点"><a href="#CAS-与-volatile-重点" class="headerlink" title="CAS 与 volatile (重点)"></a><code>CAS</code> 与 <code>volatile</code> (重点)</h3><blockquote>
<p>​	使用原子操作来保证线程访问共享资源的安全性, <code>cas+重试</code>的机制来确保(乐观锁思想), 相对于悲观锁思想的<code>synchronized</code>,<code>reentrantLock</code>来说, <code>cas</code>的方式效率会更好!</p>
</blockquote>
<h4 id="cas-重试-的原理"><a href="#cas-重试-的原理" class="headerlink" title="cas + 重试 的原理"></a><code>cas</code> + 重试 的原理</h4><blockquote>
<p>前面看到的<code>AtomicInteger</code>的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         compareAndSet 保证操作共享变量安全性的操作:</span></span><br><span class="line"><span class="comment">         ① 线程A首先获取balance.get(),拿到当前的balance值prev</span></span><br><span class="line"><span class="comment">         ② 根据这个prev值 - amount值 = 修改后的值next</span></span><br><span class="line"><span class="comment">         ③ 调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的</span></span><br><span class="line"><span class="comment">         	balance值相同;</span></span><br><span class="line"><span class="comment">         	3.1、如果相同,表示其他线程没有修改balance的值, 此时就可以将next值</span></span><br><span class="line"><span class="comment">         		设置给balance属性</span></span><br><span class="line"><span class="comment">         	3.2、如果不相同,表示其他线程也修改了balance值, 此时就设置next值失败, </span></span><br><span class="line"><span class="comment">				然后一直重试, 重新获取balance.get()的值,计算出next值,</span></span><br><span class="line"><span class="comment">				并判断本次的prev和balnce的值是否相同...重复上面操作</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (atomicInteger.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	其中的关键是 <code>compareAndSet（比较并设置值）</code>，它的简称就是 <code>CAS</code> （也有 <code>Compare And Swap </code>的说法），它必须是<code>原子操作</code>。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/436a166f7e783537464879edf14ccc0c.png"></p>
<p><strong>流程 :</strong></p>
<blockquote>
<p>​	当一个线程要去修改<code>Account</code>对象中的值时，先获取值<code>prev</code>（调用<code>get</code>方法），然后再将其设置为新的值<code>next</code>（调用<code>cas</code>方法）。在调用<code>cas</code>方法时，会将<code>prev</code>与<code>Account</code>中的余额进行比较。<br>​	如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。<br>​	如果两者不相等，就不设置值，重新获取值<code>prev</code>（调用<code>get</code>方法），然后再将其设置为新的值<code>next</code>（调用cas方法），直到修改成功为止。</p>
</blockquote>
<p><strong>注意 :</strong></p>
<blockquote>
<p>​	其实 <code>CAS</code> 的底层是 <code>lock cmpxchg</code> 指令（<code>X86</code> 架构），在单核 <code>CPU</code> 和多核 <code>CPU</code> 下都能够保证【比较-交换】的 原子性。<br>​	在多核状态下，某个核执行到带 <code>lock</code> 的指令时，<code>CPU</code> 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p>
</blockquote>
<h4 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a><code>volatile</code>的作用</h4><blockquote>
<p>​	在上面代码中的<code>AtomicInteger</code>类，保存值的<code>value</code>属性使用了<code>volatile</code> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 <code>volatile</code> 修饰。<br>​	<code>volatile</code>可以用来修饰 成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <code>volatile</code> 变量都是直接操作主存。即一个线程对 <code>volatile</code> 变量的修改，对另一个线程可见。<br>​	注意: <code>volatile</code> 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
<p>​	<strong><code>CAS</code> 必须借助 <code>volatile</code> 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
</blockquote>
<h4 id="为什么CAS-重试-无锁-效率高"><a href="#为什么CAS-重试-无锁-效率高" class="headerlink" title="为什么CAS+重试(无锁)效率高"></a>为什么<code>CAS</code>+重试(无锁)效率高</h4><blockquote>
<p>​	使用<code>CAS+重试</code>—无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 <code>synchronized</code>会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。<br>​	打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大<br>​	但无锁情况下，因为线程要保持运行，需要额外 <code>CPU</code> 的支持，<code>CPU</code> 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p>
</blockquote>
<h3 id="CAS-的特点-乐观锁和悲观锁的特点"><a href="#CAS-的特点-乐观锁和悲观锁的特点" class="headerlink" title="CAS 的特点 (乐观锁和悲观锁的特点)"></a><code>CAS</code> 的特点 (乐观锁和悲观锁的特点)</h3><blockquote>
<p>​	结合 <code>CAS</code> 和 <code>volatile</code> 可以实现无锁并发，适用于线程数少、多核 <code>CPU</code> 的场景下。</p>
<p>​	<code>CAS</code> 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br>​	<code>synchronized</code> 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。<br>​	<strong><code>CAS</code> 体现的是无锁并发、无阻塞并发</strong>，请仔细体会这两句话的意思<br>​	因为没有使用 <code>synchronized</code>，所以线程不会陷入阻塞，这是效率提升的因素之一<br>​	但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</p>
</blockquote>
<h3 id="原子整数-内部通过CAS来实现-Atom"><a href="#原子整数-内部通过CAS来实现-Atom" class="headerlink" title="原子整数 (内部通过CAS来实现-Atom)"></a>原子整数 (内部通过<code>CAS</code>来实现-<code>Atom</code>)</h3><blockquote>
<p>​	<code>java.util.concurrent.atomic</code>并发包提供了一些并发工具类，这里把它分成五类：<br>​	使用原子的方式 (共享数据为基本数据类型原子类)<br>​	<code>AtomicInteger</code>：整型原子类<br>​	<code>AtomicLong</code>：长整型原子类<br>​	<code>AtomicBoolean</code> ：布尔型原子类<br>​	上面三个类提供的方法几乎相同，所以我们将以 <code>AtomicInteger</code>为例子来介绍。<br>​	先讨论原子整数类，以 <code>AtomicInteger</code> 为例讨论它的<code>api</code>接口：通过观察源码可以发现<br>​	<code>AtomicInteger</code> 内部都是通过<code>cas</code>的原理来实现的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子: updateAndGet的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> <span class="title class_">IntUnaryOperator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">applyAsInt</span><span class="params">(<span class="type">int</span> operand)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (<code>AtomicReference</code>)</h3><blockquote>
<p>原子引用的作用: <strong>保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)</strong></p>
</blockquote>
<blockquote>
<p>为什么需要原子引用类型 ? (引用数据类型原子类)</p>
<ul>
<li><code>AtomicReference</code></li>
<li><code>AtomicMarkableReference</code></li>
<li><code>AtomicStampedReference</code> (可以解决<code>ABA</code>问题)</li>
</ul>
<p>为什么需要原子引用类型？保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。</p>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 <code>CAS</code> 进行原子更新时可能出现的 <code>ABA</code> 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记的引用类型。该类将 <code>boolean</code> 标记与引用关联起来，也可以解决使用 <code>CAS</code> 进行原子更新时可能出现的 <code>ABA</code> 问题。</li>
</ul>
</blockquote>
<p>例子 : 使用原子引用实现<code>BigDecimal</code>存取款的线程安全：</p>
<p>下面这个是不安全的实现过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决代码如下：在<code>AtomicReference类</code>中，存在一个<code>value</code>类型的变量，保存对<code>BigDecimal</code>对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用，泛型类型为小数类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ABA-问题及解决-重点"><a href="#ABA-问题及解决-重点" class="headerlink" title="ABA 问题及解决 (重点)"></a><code>ABA</code> 问题及解决 (<code>重点</code>)</h3><blockquote>
<p>​	如下程序所示，虽然 <strong>在 <code>other</code> 方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值</strong>，**<code>main</code>线程对<code>修改过共享变量的过程</code>是不可见的，这种操作这对业务代码并无影响。**</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="comment">// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS</span></span><br><span class="line">        	<span class="comment">// 可以修改成功, B</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="comment">// 同上, 修改为A</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201227200916774.png"></p>
<blockquote>
<p>​	因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是<code>A</code>，变成了<code>B</code>，又变成了<code>A</code>，那么使用<code>CAS</code>进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>​	<code>ABA</code>问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加<code>1</code>，那么<code>A-&gt;B-&gt;A</code>就会变成<code>1A-&gt;2B-&gt;3A</code>。</p>
<p>​	从<code>Java 1.5</code>开始，<code>JDK</code>的<code>Atomic</code>包里提供了一个类<code>AtomicStampedReference</code>来解决<code>ABA</code>问题。这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</blockquote>
<h3 id="AtomicStampedReference-加版本号解决ABA问题"><a href="#AtomicStampedReference-加版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (加版本号解决ABA问题)"></a><code>AtomicStampedReference</code> (加版本号解决<code>ABA</code>问题)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference-标记cas的共享变量是否被修改过"><a href="#AtomicMarkableReference-标记cas的共享变量是否被修改过" class="headerlink" title="AtomicMarkableReference (标记cas的共享变量是否被修改过)"></a><code>AtomicMarkableReference</code> (标记<code>cas</code>的共享变量是否被修改过)</h3><blockquote>
<ul>
<li><code>AtomicStampedReference</code> 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：<code>A -&gt; B -&gt; A -&gt;C</code>，通过<code>AtomicStampedReference</code>，我们可以知道，引用变量中途被更改了几次。</li>
<li>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了<code>AtomicMarkableReference</code></li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/23026a8d2e27e7a4f474d15f0e3684bc.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestABAAtomicMarkableReference&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;打扫卫生的线程 start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.062</span> guizy.TestABAAtomicMarkableReference [main] - 主线程 start...</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.069</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 装满了垃圾</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.312</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="number">0</span>] - 打扫卫生的线程 start...</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.313</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="number">0</span>] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.313</span> guizy.TestABAAtomicMarkableReference [main] - 主线程想换一只新垃圾袋？</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - 换了么？<span class="literal">false</span></span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋</span><br></pre></td></tr></table></figure>

<p>举例2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C mark &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;A mark &quot;</span> + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201227201642314.png"></p>
<h3 id="AtomicStampedReference和AtomicMarkableReference两者的区别"><a href="#AtomicStampedReference和AtomicMarkableReference两者的区别" class="headerlink" title="AtomicStampedReference和AtomicMarkableReference两者的区别"></a><code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>两者的区别</h3><blockquote>
<ul>
<li><code>AtomicStampedReference</code> 需要我们传入 整型变量 作为版本号，来判定是否被更改过</li>
<li><code>AtomicMarkableReference</code>需要我们传入布尔变量 作为标记，来判断是否被更改过</li>
</ul>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。(创建的线程,实际最后要和操作系统的线程做映射,很消耗资源)</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</blockquote>
<h3 id="线程池的继承关系"><a href="#线程池的继承关系" class="headerlink" title="线程池的继承关系"></a>线程池的继承关系</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210102231106611.png"></p>
<h3 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a><code>Executor</code> 框架结构</h3><h4 id="任务类-Runnable-Callable"><a href="#任务类-Runnable-Callable" class="headerlink" title="任务类 (Runnable &#x2F;Callable)"></a>任务类 (<code>Runnable</code> &#x2F;<code>Callable</code>)</h4><blockquote>
<p>​	执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code>接口。<code>Runnable</code> 接口或 <code>Callable</code> 接口 实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p>
</blockquote>
<h4 id="任务的执行-Executor"><a href="#任务的执行-Executor" class="headerlink" title="任务的执行 (Executor)"></a>任务的执行 (<code>Executor</code>)</h4><blockquote>
<p>​	如上图所示，包括任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。<br>​	这里有很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，它在我们实际使用线程池的过程中，使用频率非常高。</p>
</blockquote>
<h4 id="异步计算的结果-Future"><a href="#异步计算的结果-Future" class="headerlink" title="异步计算的结果 (Future)"></a>异步计算的结果 (<code>Future</code>)</h4><blockquote>
<ul>
<li><code>Future</code> 接口 以及 <code>Future</code>接口的 实现类 <code>FutureTask</code> 类 都可以代表异步计算的结果。</li>
<li>当把 <code>Runnable</code>接口 或 <code>Callable</code> 接口 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个<code> FutureTask</code>对象）<ul>
<li><code>Futrue</code>和<code>join</code>方法类似, <code>futrue</code>的<code>get</code>方法需要等待线程执行完毕,才可以获取的线程的执行结果。也称之为保护性暂停</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210102232801152.png"></p>
<h3 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a><code>Executor</code> 框架的使用示意图</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw.png"></p>
<blockquote>
<ol>
<li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p>
</li>
<li><p>把创建完成的实现 <code>Runnable</code>&#x2F;<code>Callable</code>接口的对象 直接交给 <code>ExecutorService</code> 执行:</p>
<ul>
<li><code>ExecutorService.execute（Runnable command））</code></li>
<li><code>ExecutorService.submit（Runnable task）</code></li>
<li><code>ExecutorService.submit（Callable &lt;T&gt; task）</code>。</li>
</ul>
</li>
<li><p>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现Future接口的对象<br>（刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，submit()会返回一个 <code>FutureTask</code> 对象）。</p>
</li>
<li><p>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning</code>）来取消此任务的执行</p>
</li>
</ol>
</blockquote>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><blockquote>
<p><code>ThreadPoolExecutor</code> 使用 <code>int</code> 的高 <code>3</code> 位来表示线程池状态，低 <code>29</code> 位表示线程数量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// RUNNING 高3位为111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHUTDOWN 高3位为000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">高3位的值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center">任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center">终结状态</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>从数字上比较(第一位是符号位)，<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code></li>
</ul>
</blockquote>
<blockquote>
<p>线程池状态和线程池中线程的数量 <strong>由一个原子整型<code>ctl</code>来共同表示</strong></p>
<ul>
<li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次<code>CAS</code>同时更改两个属性的值</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不是所有平台的int都是32位。</span></span><br><span class="line"><span class="comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span></span><br><span class="line"><span class="comment">// 高3位为0，剩余位数全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span></span><br><span class="line"><span class="comment">// CAPACITY 的高3位为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	获取线程池状态、线程数量以及合并两个值的操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="comment">// 该操作会让除高3位以外的数全部变为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行线程数</span></span><br><span class="line"><span class="comment">// 该操作会让高3位为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算ctl新值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这些信息存储在一个原子变量 <code>ctl</code> 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 <code>cas </code>原子操作进行赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的属性"><a href="#线程池的属性" class="headerlink" title="线程池的属性"></a>线程池的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程，内部封装了Thread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="构造方法及参数"><a href="#构造方法及参数" class="headerlink" title="构造方法及参数"></a>构造方法及参数</h3><blockquote>
<p>​	<code>ThreadPoolExecutor</code>最全的构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong><code>corePoolSize</code></strong> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于<code>corePoolSize</code>, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为<code>corePoolSize</code>，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有核心线程。</li>
<li><strong><code>workQueue</code></strong> 用来保存等待被执行的任务的阻塞队列. 在<code>JDK</code>中提供了如下阻塞队列: <ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按<code>FIFO</code>排序任务；</li>
<li><code>LinkedBlockingQuene</code>: 基于链表结构的阻塞队列，按<code>FIF</code>O排序任务，吞吐量通常要高于<code>ArrayBlockingQuene</code>；</li>
<li><code>SynchronousQuene</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQuene</code>；</li>
<li><code>PriorityBlockingQuene</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><p><strong><code>maximumPoolSize</code></strong> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于<code>maximumPoolSize</code>；当阻塞队列是无界队列, 则<code>maximumPoolSize</code>则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入<code>workQueue</code>.</p>
</li>
<li><p>**<code>keepAliveTime</code> **线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于<code>corePoolSize</code>时才有用, 超过这个时间的空闲线程将被终止；</p>
</li>
<li><p><strong><code>unit</code></strong> <code>keepAliveTime</code>的单位</p>
</li>
<li><p>**<code>threadFactory</code> **创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为<code>DefaultThreadFactory</code></p>
</li>
<li><p>**<code>handler</code> **线程池的饱和策略，拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
<p> 当然也可以根据应用场景实现<code>RejectedExecutionHandler</code>接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
</li>
</ul>
</blockquote>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式<img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202214622633.png"></h3><blockquote>
<p>当一个任务传给线程池以后，可能有以下几种可能:</p>
<ul>
<li>将任务分配给一个核心线程来执行</li>
<li>核心线程都在执行任务，将任务放到阻塞队列<code>workQueue</code>中等待被执行</li>
<li>阻塞队列满了，使用救急线程来执行任务<ul>
<li>救急线程用完以后，超过生存时间（<code>keepAliveTime</code>）后会被释放</li>
</ul>
</li>
<li>任务总数大于了 最大线程数（<code>maximumPoolSize</code>）与阻塞队列容量的最大值（<code>workQueue.capacity</code>），使用拒接策略</li>
</ul>
</blockquote>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><h4 id="AbortPolicy-中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略"><a href="#AbortPolicy-中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略" class="headerlink" title="AbortPolicy 中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略"></a><code>AbortPolicy</code> 中止策略：丢弃任务并抛出<code>RejectedExecutionException</code>异常。这是默认策略</h4><blockquote>
<ul>
<li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li>
<li><strong>功能：</strong>当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.</li>
<li><strong>使用场景：</strong>这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。<code>ThreadPoolExecutor</code>中默认的策略就是<code>AbortPolicy</code>，<code>ExecutorService</code>接口的系列<code>ThreadPoolExecutor</code>因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，<code>ExecutorService</code>中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</li>
</ul>
</blockquote>
<h4 id="CallerRunsPolicy-调用者运行策略：由调用线程处理该任务。"><a href="#CallerRunsPolicy-调用者运行策略：由调用线程处理该任务。" class="headerlink" title="CallerRunsPolicy 调用者运行策略：由调用线程处理该任务。"></a><code>CallerRunsPolicy 调用者运行策略</code>：由调用线程处理该任务。</h4><blockquote>
<ul>
<li><strong>功能：</strong>当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。</li>
<li><strong>使用场景：</strong>一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</li>
</ul>
</blockquote>
<h4 id="DiscardPolicy-丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。"><a href="#DiscardPolicy-丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。" class="headerlink" title="DiscardPolicy 丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。"></a><code>DiscardPolicy 丢弃策略</code>：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</h4><blockquote>
<ul>
<li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li>
<li><strong>功能：</strong>直接静悄悄的丢弃这个任务，不触发任何动作。</li>
<li><strong>使用场景：</strong>如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</li>
</ul>
</blockquote>
<h4 id="DiscardOldestPolicy-弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。"><a href="#DiscardOldestPolicy-弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。" class="headerlink" title="DiscardOldestPolicy 弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。"></a><code>DiscardOldestPolicy 弃老策略</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</h4><blockquote>
<ul>
<li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li>
<li><strong>功能：</strong>如果线程池未关闭，就弹出队列头部的元素，然后尝试执行</li>
<li><strong>使用场景：</strong>这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 <code>corePoolSize</code> 并没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 <code>maximumPoolSize - corePoolSize</code> 数目的线程来救急。</li>
<li>如果线程到达 <code>maximumPoolSize</code> 仍然有新任务这时会执行拒绝策略。拒绝策略 <code>jdk</code> 提供了 下面的前<code>4</code> 种实现，其它著名框架也提供了实现<ol>
<li><code>ThreadPoolExecutor.AbortPolicy</code>让调用者抛出 <code>RejectedExecutionException</code> 异常，这是默认策略</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 让调用者运行任务</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code> 放弃本次任务</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 放弃队列中最早的任务，本任务取而代之</li>
<li><code>Dubbo</code> 的实现，在抛出 <code>RejectedExecutionException</code> 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位问题</li>
<li><code>Netty</code> 的实现，是创建一个新线程来执行任务</li>
<li><code>ActiveMQ</code> 的实现，带超时等待<code>（60s）</code>尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li><code>PinPoint</code> 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ol>
</li>
<li>当高峰过去后，超过<code>corePoolSize</code> 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由<code>keepAliveTime</code> 和 <code>unit</code> 来控制。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        <span class="comment">// 创建有界阻塞队列, 用来存放任务对象</span></span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建线程工厂: 主要给线程起名字</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;guizy_thread&quot;</span> + threadId.getAndIncrement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        <span class="comment">// 拒绝策略采用默认策略</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行20个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210103001214433.png"></p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h3><blockquote>
<ul>
<li>这个是<code>Executors类</code>提供的工厂方法来创建线程池！<code>Executors</code> 是<code>Executor</code> 框架的工具类！</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFixedThreadPool</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 自定义线程工厂</span></span><br><span class="line">      <span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">         <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread_&quot;</span> + atomicInteger.getAndIncrement());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建核心线程数量为2的线程池</span></span><br><span class="line">      <span class="comment">// 通过 ThreadFactory可以给线程添加名字</span></span><br><span class="line"></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, factory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 任务</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;this is fixedThreadPool&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      executorService.execute(runnable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>固定大小的线程池可以传入两个参数</p>
<ul>
<li>核心线程数：**<code>nThreads</code>**</li>
<li>线程工厂：**<code>threadFactory</code>**</li>
</ul>
</blockquote>
<blockquote>
<p>内部调用的构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li><code>阻塞队列是无界的，可以放任意数量的任务</code></li>
<li><strong>适用于任务量已知，相对耗时的任务</strong></li>
</ol>
</blockquote>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 内部构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ul>
<li><p>没有核心线程，最大线程数为<code>Integer.MAX_VALUE</code>，所有创建的线程都是救急线程 (可以无限创建)，空闲时生存时间为<code>60</code>秒</p>
</li>
<li><p>阻塞队列使用的是<code>SynchronousQueue</code></p>
</li>
<li><p><code>SynchronousQueue</code>是一种特殊的队列</p>
<ul>
<li>没有容量，没有线程来取是放不进去的</li>
<li>只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
<li><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 <code>1</code>分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
<li><p><code>newCachedThreadPool</code>在没有任务执行时，当线程的空闲时间超过<code>keepAliveTime</code>，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开&#96;销；</p>
</li>
</ul>
</blockquote>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><blockquote>
<ul>
<li><p>希望多个任务排队执行。线程数固定为 <code>1</code>，任务数多于 <code>1 </code>时，会放入无界队列排队。 任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p>区别：</p>
<ul>
<li>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而<code>newSingleThreadExecutor</code>线程池还会新建一个线程，保证池的正常工作</li>
<li><code>Executors.newSingleThreadExecutor()</code> 线程个数始终为<code>1</code>，不能修改<br><code>FinalizableDelegatedExecutorService</code> 应用的是装饰器模式，只对外暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中特有的方法</li>
<li>和<code>Executors.newFixedThreadPool(1)</code> 初始时为<code>1</code>时的区别：<code>Executors.newFixedThreadPool(1)</code> 初始时为<code>1</code>，以后还可以修改，对外暴露的是 <code>ThreadPoolExecutor</code> 对象，可以强转后调用 <code>setCorePoolSize</code> 等方法进行修改</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Executors-返回线程池对象的弊端如下"><a href="#Executors-返回线程池对象的弊端如下" class="headerlink" title="Executors 返回线程池对象的弊端如下"></a><code>Executors</code> 返回线程池对象的弊端如下</h3><blockquote>
<p>注意: <code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许<strong>请求</strong>的队列长度为 <code>Integer.MAX_VALUE</code> (无界阻塞队列),可能堆积大量的请求，从而导致 <code>OOM</code>。</li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许<strong>创建</strong>的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li>
</ul>
</blockquote>
<blockquote>
<p>避免上面的措施 : 使用有界队列，控制线程创建数量。</p>
<p>除了避免 <code>OOM</code> 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
</blockquote>
<h3 id="执行-提交任务-execute-submit"><a href="#执行-提交任务-execute-submit" class="headerlink" title="执行&#x2F;提交任务 execute/submit"></a>执行&#x2F;提交任务 <code>execute/submit</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a><code>execute()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute(Runnable command)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入一个<code>Runnable</code>对象，执行其中的<code>run</code>方法</p>
</blockquote>
<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a><code>submit()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入一个<code>Callable</code>对象，用<code>Future</code>来<strong>捕获返回值</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过submit执行Callable中的call方法</span></span><br><span class="line"><span class="comment">// 通过Future来捕获返回值</span></span><br><span class="line">Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello submit&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看捕获的返回值</span></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池-shutdown"><a href="#关闭线程池-shutdown" class="headerlink" title="关闭线程池 shutdown()"></a>关闭线程池 <code>shutdown()</code></h3><blockquote>
<ul>
<li><strong>将线程池的状态改为 <code>SHUTDOWN</code></strong></li>
<li><strong>不再接受新任务，但是会将阻塞队列中的任务执行完</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程池的状态改为 SHUTDOWN</span></span><br><span class="line"><span class="comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        </span><br><span class="line">  		<span class="comment">// 中断空闲线程（没有执行任务的线程）</span></span><br><span class="line">        <span class="comment">// Idle：空闲的</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结，不一定成功</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 终结失败的条件</span></span><br><span class="line">        <span class="comment">// 线程池状态为RUNNING</span></span><br><span class="line">        <span class="comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span></span><br><span class="line">        <span class="comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果活跃线程数不为0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 中断空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处于可以终结的状态</span></span><br><span class="line">            <span class="comment">// 通过CAS将线程池状态改为TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过CAS将线程池状态改为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a><code>shutdownNow()</code></h3><blockquote>
<ul>
<li><strong>将线程池的状态改为 <code>STOP</code></strong></li>
<li><strong>不再接受新任务，也不会再执行阻塞队列中的任务</strong></li>
<li>会将阻塞队列中未执行的任务返回给调用者</li>
<li>并用 <code>interrupt</code> 的方式中断正在执行的任务</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程池的状态改为 STOP</span></span><br><span class="line"><span class="comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span></span><br><span class="line"><span class="comment">* 会将阻塞队列中未执行的任务返回给调用者</span></span><br><span class="line"><span class="comment">* 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改状态为STOP，不执行任何任务</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 中断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将未执行的任务从队列中移除，然后返回给调用者</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="创建多大的线程池合适"><a href="#创建多大的线程池合适" class="headerlink" title="创建多大的线程池合适?"></a>创建多大的线程池合适?</h3><blockquote>
<p>过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存</p>
<ol>
<li><h6 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a><code>CPU</code> 密集型运算</h6><p>通常采用 <code>cpu</code> 核数 <code>+ 1</code> 能够实现最优的 <code>CPU</code> 利用率，<code>+1</code> 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 <code>CPU</code> 时钟周期不被浪费</p>
</li>
<li><h6 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a><code>I/O</code> 密集型运算</h6><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 <code>CPU</code> 资源，但当你执行 <code>I/O</code> 操作时、远程<code>RPC</code> 调用时，包括进行数据库操作时，这时候 <code>CPU</code> 就闲下来了，你可以利用多线程提高它的利用率。</p>
<ol>
<li>经验公式如下：<code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code><br>例如 <code>4</code> 核 <code>CPU</code> 计算时间是 <code>50%</code> ，其它等待时间是 <code>50%</code>，期望 <code>cpu</code> 被 <code>100% </code>利用，套用公式<br><code>4 * 100% * 100% / 50% = 8</code><br>例如 <code>4</code> 核 <code>CPU</code> 计算时间是 <code>10%</code> ，其它等待时间是 <code>90%</code>，期望<code> cpu</code> 被 <code>100% </code>利用，套用公式<br><code>4 * 100% * 100% / 10% = 40</code></li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h3><blockquote>
<p>​	<code>ScheduledThreadPoolExecutor</code>继承自<code> ThreadPoolExecutor</code>，为任务提供延迟或周期执行，属于线程池的一种。和 <code>ThreadPoolExecutor </code>相比，它还具有以下几种特性:</p>
<ul>
<li>使用专门的任务类型—<code>ScheduledFutureTask</code> 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 <code>ExecutorService</code> 来执行)。</li>
<li>使用专门的存储队列—<code>DelayedWorkQueue</code> 来存储任务，<code>DelayedWorkQueue</code> 是无界延迟队列<code>DelayQueue</code> 的一种。相比<code>ThreadPoolExecutor</code>也简化了执行机制(<code>delayedExecute</code>方法，后面单独分析)。</li>
<li>支持可选的<code>run-after-shutdown</code>参数，在池被关闭(<code>shutdown</code>)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 <code>shutdown</code> 操作重叠时，复查逻辑也不相同</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">&quot;任务1, 执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">&quot;任务2, 执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任务<span class="number">1</span>, 执行时间:Sun Jan <span class="number">03</span> 08:<span class="number">53</span>:<span class="number">54</span> CST <span class="number">2021</span></span><br><span class="line">任务<span class="number">2</span>, 执行时间:Sun Jan <span class="number">03</span> 08:<span class="number">53</span>:<span class="number">54</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<h4 id="ScheduledExecutorService-中-scheduleAtFixedRate方法的使用"><a href="#ScheduledExecutorService-中-scheduleAtFixedRate方法的使用" class="headerlink" title="ScheduledExecutorService 中 scheduleAtFixedRate方法的使用"></a><code>ScheduledExecutorService</code> 中 <code>scheduleAtFixedRate</code>方法的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; log.debug(<span class="string">&quot;running&quot;</span>), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">08:<span class="number">51</span>:<span class="number">59.930</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">52</span>:<span class="number">01.050</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">02.049</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">03.045</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">04.046</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">05.045</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">06.047</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡眠时间 &gt; 速率, 按睡眠时间打印</span></span><br><span class="line">08:<span class="number">54</span>:<span class="number">58.567</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">54</span>:<span class="number">59.675</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">01.684</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">03.685</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">05.690</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br></pre></td></tr></table></figure>

<h4 id="ScheduledExecutorService-中scheduleWithFixedDelay方法的使用"><a href="#ScheduledExecutorService-中scheduleWithFixedDelay方法的使用" class="headerlink" title="ScheduledExecutorService 中scheduleWithFixedDelay方法的使用"></a><code>ScheduledExecutorService</code> 中<code>scheduleWithFixedDelay</code>方法的使用</h4><ul>
<li>睡眠时间 + 速率时间, 为打印的间隔时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">08:<span class="number">56</span>:<span class="number">22.581</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">56</span>:<span class="number">23.674</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">26.679</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">29.680</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">32.689</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br></pre></td></tr></table></figure>

<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><code>AQS</code></h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202223902808.png"></p>
<blockquote>
<p><strong><code>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</code>。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制<code>AQS</code>是用<code>CLH</code>队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>​	<code>CLH</code>锁其实就是一种基于逻辑队列非线程饥饿的一种自旋公平锁。当多个线程竞争一把锁时，获取不到锁的线程，会排队进入<code>CLH</code>队列的队尾，然后自旋等待，直到其前驱线程释放锁。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210119105644735.png"></p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li><p>用 <code>state</code> 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p>
<ul>
<li><code>getState</code> - 获取 <code>state</code> 状态</li>
<li><code>setState</code> - 设置 <code>state</code> 状态</li>
<li><code>compareAndSetState</code> - <code>cas</code> 机制设置 <code>state</code> 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li><p>提供了基于 <code>FIFO</code> 的等待队列，类似于 <code>Monitor</code> 的 <code>EntryList</code></p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 <code>Monitor</code> 的 <code>WaitSet</code></p>
</li>
</ul>
</blockquote>
<p>​	子类主要实现这样一些方法（默认抛出 <code>UnsupportedOperationException</code>）</p>
<blockquote>
<ul>
<li><strong><code>tryAcquire</code></strong></li>
<li><strong><code>tryRelease</code></strong></li>
<li><strong><code>tryAcquireShared</code></strong></li>
<li><strong><code>tryReleaseShared</code></strong></li>
<li><strong><code>isHeldExclusively</code></strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	下面实现一个不可重入的阻塞式锁：使用<code>AbstractQueuedSynchronizer</code>自定义一个同步器来实现自定义锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guizy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/4 23:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestAQS&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAqs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁, 同一线程在锁释放前, 只能加一次锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 这里不需要确定原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的, 具体见volatile原理(写屏障)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a><code>ReentrantLock</code> 原理</h3><blockquote>
<p><code>ReentrantLock</code>提供了两个同步器，实现<code>公平锁</code>和<code>非公平锁</code>，默认是非公平锁！</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/14f43b7a0fa8b979b9101ab5170398cc.png"></p>
<h4 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h4><h5 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h5><blockquote>
<ul>
<li><code>加锁, 解锁</code>流程，先从构造器开始看，默认为非公平锁实现</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line"> 	sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有竞争时</p>
<ul>
<li>Thread-0成为锁的持有者</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/5ed1f22fcfc9dda5a8b3b1cc737f2bb5.png"></p>
<ul>
<li>第一个竞争出现时，查看源码的<code>NonfairSync</code>的<code>lock</code>方法</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/07d53face5cb7d27d43a9b8dbee38820.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的lock</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Thread-1</code> 执行了</p>
<ol>
<li><code>lock</code>方法中<code>CAS</code> 尝试将 <code>state</code> 由 <code>0</code> 改为 <code>1</code>，结果失败 (因为此时<code>CAS</code>操作, <code>state</code>已经为<code>1</code>了)</li>
<li><code>lock</code>方法中进一步调用<code>acquire</code>方法，进入 <code>tryAcquire</code> 逻辑，这里我们认为这时 <code>state</code> 已经是1，结果仍然失败</li>
<li>接下来进入 <code>acquire</code>方法的<code>addWaiter</code> 逻辑，构造 <code>Node</code> 队列 (双向链表实现)<ol>
<li>下图中黄色三角表示该 <code>Node</code> 的<code>waitStatus</code>状态，其中 <code>0</code> 为默认正常状态</li>
<li><code>Node</code> 的创建是懒惰的</li>
<li>其中第一个 <code>Node</code> 称为 <code>Dummy</code>（哑元）或哨兵，用来占位，并不关联线程</li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/be834858592889523943183e15acfa58.png"></p>
<blockquote>
<p>当前线程进入 <code>acquire</code>方法的 <code>acquireQueued</code> 逻辑</p>
<ol>
<li><code>acquireQueued</code> 会在一个死循环中不断尝试获得锁，失败后进入 <code>park</code> 阻塞</li>
<li>如果自己是紧邻着 <code>head</code>（排第二位），那么再次 <code>tryAcquire</code> 尝试获取锁，我们这里设置这时 <code>state</code> 仍为 <code>1</code>，失败</li>
<li>进入 <code>shouldParkAfterFailedAcquire</code> 逻辑，将前驱 <code>node</code>，即 <code>head</code> 的 <code>waitStatus</code> 改为 <code>-1</code>，这次返回 <code>false</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/d66b53fa0c1ecaffa3fae6580c846292.png"></p>
<blockquote>
<ol start="4">
<li><code>shouldParkAfterFailedAcquire</code> 执行完毕回到 <code>acquireQueued</code> ，再次 <code>tryAcquire</code> 尝试获取锁，当然这时 <code>state</code> 仍为 <code>1</code>，失败</li>
<li>当再次进入 <code>shouldParkAfterFailedAcquire</code> 时，这时因为其前驱 <code>node</code> 的 <code>waitStatus</code> 已经是 <code>-1</code>，这次返回 <code>true</code></li>
<li>进入<code>parkAndCheckInterrupt</code>， <code>Thread-1 park</code>（灰色表示已经阻塞）</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210105234001801.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/844a2077a9096fed80b31ae91e8e8c13.png"></p>
<blockquote>
<ul>
<li>再次有多个线程经历上述过程竞争失败，变成这个样子</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c673a02e84847dd8e7fbef4944863a5f.png"></p>
<blockquote>
<p>​	<code>Thread-0</code> 调用<code>unlock</code>方法里的<code>release</code>方法释放锁，进入<code>tryRelease</code>(使用<code>ctrl+alt+b</code>查看<code>tryRelease</code>方法的具体<code>ReentrantLock</code>实现)流程，如果成功，<strong>设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>，<code>state = 0</code></strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/674d24535dcb379439c6105468bcb72b.png"></p>
<blockquote>
<p>​	<code>unlock</code>方法里的<code>release</code>方法方法中，如果当前队列不为 <code>null</code>，并且 <code>head</code> 的 <code>waitStatus = -1</code>，进入 <code>unparkSuccessor</code> 流程： <code>unparkSuccessor</code>中会找到队列中离 <code>head</code> 最近的一个 <code>Node</code>（没取消的），<code>unpark</code> 唤醒<code>Thread-1</code> 恢复其运行，本例中即为 <code>Thread-1</code> 回到 <code>Thread-1</code> 阻塞的位置继续执行, 会继续执行 <code>acquireQueued</code> 流程</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210105235033126.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0c4dd83170dbced9979e3c0a5b7cc69c.png"></p>
<blockquote>
<p>如果加锁成功（没有竞争），会设置 （<code>acquireQueued</code> 方法中）</p>
<ol>
<li><code>exclusiveOwnerThread</code> 为 <code>Thread-1</code>，<code>state = 1</code></li>
<li><code>head</code> 指向刚刚 <code>Thread-1</code> 所在的<code> Node</code>，该 <code>Node</code> 清空 <code>Thread</code></li>
<li>原本的 <code>head</code> 因为从链表断开，而可被垃圾回收</li>
</ol>
</blockquote>
<blockquote>
<p><strong>如果这时候有其它线程来竞争（非公平的体现）</strong>，例如这时有 <code>Thread-4</code> 来了</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/990731fe3d516c3947623aeba1a356d3.png"></p>
<blockquote>
<p>如果不巧又被 <code>Thread-4</code> 占了先</p>
<ol>
<li><code>Thread-4</code> 被设置为 <code>exclusiveOwnerThread</code>，<code>state = 1</code></li>
<li><code>Thread-1</code> 再次进入 <code>acquireQueued</code> 流程，获取锁失败，重新进入 <code>park</code> 阻塞</li>
</ol>
</blockquote>
<p><code>加锁</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            	<span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"><span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>解锁</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><blockquote>
<p>​	同一个线程, 锁重入, 会对<code>state</code>进行自增. 释放锁的时候, <code>state</code>进行自减; 当<code>state</code>自减为<code>0</code>的时候. 此时线程才会将<code>锁</code>释放成功, 才会进一步去唤醒<code>其他线程</code>来竞争锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><blockquote>
<p>不可打断模式：在此模式下，<strong>即使它被打断，仍会驻留在 <code>AQS</code> 队列中，一直要等到获得锁后方能得知自己被打断了</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可打断模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h4><blockquote>
<p>​	看<code>AQS</code>队列中, 自己(线程) 有没有前驱节点(线程), (该节点不是占位的哨兵节点); 如果有就不去竞争锁. 如果没有, 才会去<code>CAS</code>操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                        <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">                        (s = h.next) == <span class="literal">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><h5 id="图解流程-1"><a href="#图解流程-1" class="headerlink" title="图解流程"></a>图解流程</h5><blockquote>
<p>每个条件变量其实就对应着一个等待队列，其实现类是 <code>ConditionObject</code></p>
<ul>
<li><code>await</code> 流程 开始 <code>Thread-0</code> 持有锁，<code>conditionObject</code>对象调用 <code>await</code>，进入 <code>ConditionObject</code> 的 <code>addConditionWaiter</code> 流程 创建新的 <code>Node</code> 状态为 <code>-2``（Node.CONDITION）</code>，关联 <code>Thread-0</code>，加入等待队列尾部</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/09246ff55afe135799cd51abc4986653.png"></p>
<blockquote>
<p>接下来进入 <code>AQS</code> 的 <code>fullyRelease</code> 流程，释放同步器上的所有的锁 (因为可能线程发生可重入, 锁有很多层)</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2195e5eaae4a475239669598553df5db.png"></p>
<blockquote>
<p><code>unparkSuccessor(h); —&gt; unpark</code>唤醒 <code>AQS</code> 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 <code>Thread-1</code> 竞争成功</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e792aec6dc7581bb2dc160ede42c9e46.png"></p>
<blockquote>
<p><code>LockSupport.park(this); —&gt; park</code> 阻塞 <code>Thread-0</code></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/7917fb349c6c2af1cd40575968f829da.png"></p>
<ul>
<li><code>signal 流程</code><ul>
<li>假设 <code>Thread-1</code> 要来唤醒 <code>Thread-0</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有持有锁，会抛出异常 --&gt; 这里表示Thread-1要持有锁, </span></span><br><span class="line">	<span class="comment">//才可以去条件变量中去唤醒等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) </span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aca67cba0461a01aca2ba48fbf04203c.png"></p>
<blockquote>
<p>进入 <code>ConditionObject</code> 的 <code>doSignal</code> 流程，取得等待队列中第一个 <code>Node</code>，即 <code>Thread-0</code> 所在 <code>Node</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="comment">// 去firstWaiter条件变量中将等待的线程拿出来.</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转移到AQS的队列中, 等待竞争锁</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/a0d8ac2c5ea30e856db42691f2eb1a2b.png"></p>
<blockquote>
<p>​	执行 <code>transferForSignal</code> 流程，<strong>将该 <code>Node</code> 加入 <code>AQS</code> 队列尾部，将 <code>Thread-0</code> 的 <code>waitStatus</code> 改为 <code>0</code>，<code>Thread-3 的waitStatus</code> 改为 <code>-1</code></strong> , 改为<code>-1</code>就有责任去唤醒自己的后继节点</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c9e2f0c07b88d0dcd7b4b9a49238a50a.png"></p>
<p><code>Thread-1</code> 释放锁，进入 <code>unlock</code> 流程，略</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">                !transferForSignal(first) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 队列还有节点</span></span><br><span class="line">                        (first = firstWaiter) != <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 插入节点的上一个节点被取消</span></span><br><span class="line">                ws &gt; <span class="number">0</span> ||</span><br><span class="line">                        <span class="comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有持有锁，会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 唤醒等待队列队列中的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞              </span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><blockquote>
<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！</p>
<p>提供一个数据容器类内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法  </p>
</blockquote>
<p>注意事项</p>
<blockquote>
<ol>
<li><p>读锁不支持条件变量</p>
</li>
<li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     w.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">         w.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">     r.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h4><ol>
<li>缓存更新策略</li>
</ol>
<p>更新时，是先清缓存还是先更新数据库？先清缓存</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120911022.png"></p>
<p>先更新数据库</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120924901.png"></p>
<p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询：这种情况的出现几率非常小</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120940992.png"></p>
<h4 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h4><h5 id="图解流程-2"><a href="#图解流程-2" class="headerlink" title="图解流程"></a>图解流程</h5><p>读写锁用的是同一个 <code>Sycn</code> 同步器，因此等待队列、<code>state</code> 等也是同一个   下面执行：<code>t1 w.lock</code>，<code>t2 r.lock</code></p>
<p>1） <code>t1</code> 成功上锁，流程与 <code>ReentrantLock</code> 加锁相比没有特殊之处，不同是写锁状态占了 <code>state</code> 的低 <code>16</code> 位，而读锁<br>使用的是 <code>state</code> 的高 <code>16</code> 位</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149666861.png"></p>
<p>2）<code>t2</code> 执行 <code>r.lock</code>，这时进入读锁的 <code>sync.acquireShared(1)</code> 流程，首先会进入 <code>tryAcquireShared</code> 流程。如果有写锁占据，那么 <code>tryAcquireShared</code> 返回 <code>-1</code> 表示失败</p>
<blockquote>
<p><code>tryAcquireShared</code> 返回值表示</p>
<ol>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，我们这里的读写锁返回 <code>1</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149816131.png"></p>
<p>3）这时会进入 <code>sync.doAcquireShared(1)</code> 流程，首先也是调用 <code>addWaiter</code> 添加节点，不同之处在于节点被设置为<code>Node.SHARED</code> 模式而非 <code>Node.EXCLUSIVE</code> 模式，注意此时 <code>t2</code> 仍处于活跃状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149862569.png"></p>
<p>4）<code>t2</code> 会看看自己的节点是不是老二，如果是，还会再次调用 <code>tryAcquireShared(1)</code> 来尝试获取锁</p>
<p>5）如果没有成功，在 <code>doAcquireShared</code> 内 <code>for (;;)</code> 循环一次，把前驱节点的 <code>waitStatus</code> 改为<code> -1</code>，再 <code>for (;;)</code> 循环一次尝试 <code>tryAcquireShared(1)</code> 如果还不成功，那么在 <code>parkAndCheckInterrupt()</code> 处 <code>park</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595150020844.png"></p>
<p><strong>又继续执行：<code>t3 r.lock</code>，<code>t4 w.lock</code></strong><br>这种状态下，假设又有 <code>t3</code> 加读锁和 <code>t4</code> 加写锁，这期间 <code>t1</code> 仍然持有锁，就变成了下面的样子</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595150111679.png"></p>
<p><strong>继续执行<code>t1 w.unlock</code></strong><br>这时会走到写锁的 <code>sync.release(1)</code> 流程，调用 <code>sync.tryRelease(1)</code> 成功，变成下面的样子</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152703040.png"></p>
<p>接下来执行唤醒流程 <code>sync.unparkSuccessor</code>，即让老二恢复运行，这时 <code>t2</code> 在 <code>doAcquireShared</code> 内<code>parkAndCheckInterrupt()</code> 处恢复运行，图中的<code>t2</code>从黑色变成了蓝色（注意这里只是恢复运行而已，并没有获取到锁！）<br>这回再来一次 <code>for (;;)</code> 执行 <code>tryAcquireShared</code> 成功则让读锁计数加一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152000565.png"></p>
<p>这时 <code>t2</code> 已经恢复运行，接下来 <code>t2</code> 调用 <code>setHeadAndPropagate(node, 1)</code>，它原本所在节点被置为头节点</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152203229.png"></p>
<p>​	事情还没完，在 <code>setHeadAndPropagate</code> 方法内还会检查下一个节点是否是 <code>shared</code>，如果是则调用<code>doReleaseShared()</code> 将 <code>head</code> 的状态从 <code>-1</code> 改为 <code>0</code> 并唤醒老二，这时 <code>t3</code> 在 <code>doAcquireShared</code> 内<code>parkAndCheckInterrupt()</code> 处恢复运行</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152506026.png"></p>
<p>​	这回再来一次 <code>for (;;)</code> 执行 <code>tryAcquireShared</code> 成功则让读锁计数加一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152518613.png"></p>
<p>这时 <code>t3</code> 已经恢复运行，接下来 <code>t3</code> 调用 <code>setHeadAndPropagate(node, 1)</code>，它原本所在节点被置为头节点</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152534234.png"></p>
<p>下一个节点不是 <code>shared</code> 了，因此不会继续唤醒 <code>t4</code> 所在节点</p>
<p><strong>再继续执行<code>t2 r.unlock</code>，<code>t3 r.unlock</code></strong><br><code>t2</code> 进入 <code>sync.releaseShared(1)</code> 中，调用 <code>tryReleaseShared(1)</code> 让计数减一，但由于计数还不为零</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153460990.png"></p>
<p><code>t3</code> 进入 <code>sync.releaseShared(1)</code> 中，调用 <code>tryReleaseShared(1)</code> 让计数减一，这回计数为零了，进入<code>doReleaseShared()</code> 将头节点从 <code>-1</code> 改为 <code>0 </code>并唤醒老二，即</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153473005.png"></p>
<p>之后 <code>t4</code> 在 <code>acquireQueued</code> 中 <code>parkAndCheckInterrupt</code> 处恢复运行，再次 <code>for (;;)</code> 这次自己是老二，并且没有其他竞争，<code>tryAcquire(1)</code> 成功，修改头结点，流程结束</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153528383.png"></p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>写锁上锁流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">                        <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span></span><br><span class="line">                    w == <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                            current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞这里返回false, 或者</span></span><br><span class="line">                writerShouldBlock() ||</span><br><span class="line">                        <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">                        !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写锁释放流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读锁上锁流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">                !readerShouldBlock() &amp;&amp;</span><br><span class="line">                        <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">                        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                        <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">                        compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line">						<span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                <span class="comment">// park 当前线程</span></span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">                (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析，参考这里：http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#5propagate-%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读锁释放流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><blockquote>
<p>​	<code>Semaphore</code>是<code>JDK</code>提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。 如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。 <code>Semaphore</code>所维护的许可证数量就是允许访问共享资源的最大线程数量。 所以，线程想要访问共享资源必须从<code>Semaphore</code>中获取到许可证。</p>
</blockquote>
<h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Semaphore</code>实现了<code>Serializable</code>接口，即可以进行序列化。</p>
</blockquote>
<h3 id="类的内部类"><a href="#类的内部类" class="headerlink" title="类的内部类"></a>类的内部类</h3><blockquote>
<p><code>Semaphore</code>总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-1.png"></p>
<blockquote>
<p>说明: <code>Semaphore</code>与<code>ReentrantLock</code>的内部类的结构相同，类内部总共存在<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code>三个类，<code>NonfairSync</code>与<code>FairSync</code>类继承自<code>Sync</code>类，<code>Sync</code>类继承自<code>AbstractQueuedSynchronizer</code>抽象类。下面逐个进行分析。</p>
</blockquote>
<h4 id="类的内部类-Sync类"><a href="#类的内部类-Sync类" class="headerlink" title="类的内部类 - Sync类"></a>类的内部类 - Sync类</h4><p><code>Sync</code>类的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        setState(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPermits</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reducePermits</span><span class="params">(<span class="type">int</span> reductions)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">drainPermits</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Sync</code>类的属性相对简单，只有一个版本号，<code>Sync</code>类存在如下方法和作用如下。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getPermits</code></td>
<td align="center">获取许可</td>
</tr>
<tr>
<td align="center"><code>nonfairTryAcquireShared</code></td>
<td align="center">共享模式下非公平策略获取</td>
</tr>
<tr>
<td align="center"><code>tryReleaseShared</code></td>
<td align="center">共享模式下进行释放</td>
</tr>
<tr>
<td align="center"><code>reducePermits</code></td>
<td align="center">根据指定的缩减量减小可用许可的数目</td>
</tr>
<tr>
<td align="center"><code>drainPermits</code></td>
<td align="center">获取并返回立即可用的所有许可</td>
</tr>
</tbody></table>
<h4 id="类的内部类-NonfairSync类"><a href="#类的内部类-NonfairSync类" class="headerlink" title="类的内部类 - NonfairSync类"></a>类的内部类 - NonfairSync类</h4><blockquote>
<p><code>NonfairSync</code>类继承了<code>Sync</code>类，表示采用非公平策略获取资源，其只有一个<code>tryAcquireShared</code>方法，重写了<code>AQS</code>的该方法，其源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 从<code>tryAcquireShared</code>方法的源码可知，其会调用父类<code>Sync</code>的<code>nonfairTryAcquireShared</code>方法，表示按照非公平策略进行资源的获取。</p>
</blockquote>
<h4 id="类的内部类-FairSync类"><a href="#类的内部类-FairSync类" class="headerlink" title="类的内部类 - FairSync类"></a>类的内部类 - FairSync类</h4><blockquote>
<p><code>FairSync</code>类继承了<code>Sync</code>类，表示采用公平策略获取资源，其只有一个<code>tryAcquireShared</code>方法，重写了<code>AQS</code>的该方法，其源码如下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 同步队列中存在其他节点</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 剩余的许可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余的许可小于0或者比较设置成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 从<code>tryAcquireShared</code>方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。</p>
</blockquote>
<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Semaphore</code>自身只有两个属性，最重要的是<code>sync</code>属性，基于<code>Semaphore</code>对象的操作绝大多数都转移到了对<code>sync</code>的操作。</p>
</blockquote>
<h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul>
<li><code>Semaphore(int)</code>型构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 该构造函数会创建具有给定的许可数和非公平的公平设置的<code>Semaphore</code>。</p>
</blockquote>
<ul>
<li><code>Semaphore(int, boolean)</code>型构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 该构造函数会创建具有给定的许可数和给定的公平设置的<code>Semaphore</code>。</p>
</blockquote>
<h3 id="Semaphore有哪些常用的方法？"><a href="#Semaphore有哪些常用的方法？" class="headerlink" title="Semaphore有哪些常用的方法？"></a>Semaphore有哪些常用的方法？</h3><blockquote>
<p>​	有<code>acquire</code>方法和<code>release</code>方法。 当调用<code>acquire</code>方法时线程就会被阻塞，直到<code>Semaphore</code>中可以获得到许可证为止，然后线程再获取这个许可证。 当调用<code>release</code>方法时将向<code>Semaphore</code>中添加一个许可证，如果有线程因为获取许可证被阻塞时，它将获取到许可证并被释放；如果没有获取许可证的线程， <code>Semaphore</code>只是记录许可证的可用数量。</p>
</blockquote>
<h3 id="可以举一个使用Semaphore的例子吗？"><a href="#可以举一个使用Semaphore的例子吗？" class="headerlink" title="可以举一个使用Semaphore的例子吗？"></a>可以举一个使用<code>Semaphore</code>的例子吗？</h3><blockquote>
<p>​	张三、李四和王五和赵六<code>4</code>个人一起去饭店吃饭，不过在特殊时期洗手很重要，饭前洗手也是必须的，可是饭店只有<code>2</code>个洗手池，洗手池就是不能被同时使用的公共资源，这种场景就可以用到<code>Semaphore</code>。</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>当然可以，这是张三、李四、王五和赵六的顾客类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore washbasin;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Semaphore washbasin, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.washbasin = washbasin;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">            washbasin.acquire();</span><br><span class="line">            System.out.println(</span><br><span class="line">            	sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; 开始洗手...&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (random.nextDouble() * <span class="number">5000</span>) + <span class="number">2000</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">            	sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; 洗手完毕!&quot;</span>);</span><br><span class="line">            washbasin.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，写一个测试类模拟一下他们洗手的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//饭店里只用两个洗手池，所以初始化许可证的总数为2。</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">washbasin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;张三&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;李四&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;王五&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;赵六&quot;</span>)));</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以后的结果应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">54.416</span> 李四 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">54.416</span> 张三 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">57.251</span> 张三 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">57.251</span> 王五 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">59.418</span> 李四 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">59.418</span> 赵六 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">52</span>:<span class="number">02.496</span> 王五 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">52</span>:<span class="number">06.162</span> 赵六 洗手完毕!</span><br></pre></td></tr></table></figure>

<p>可以看到，当已经有两个人在洗手的时候，其他人就被阻塞，直到有人洗手完毕才是开始洗手。</p>
<h4 id="这4个人会按照线程启动的顺序洗手嘛？"><a href="#这4个人会按照线程启动的顺序洗手嘛？" class="headerlink" title="这4个人会按照线程启动的顺序洗手嘛？"></a>这4个人会按照线程启动的顺序洗手嘛？</h4><blockquote>
<p>​	不会按照线程启动的顺序洗手，有可能赵六比王五先洗手。</p>
</blockquote>
<p>因为在我的代码中，使用<code>Semaphore</code>的构造函数是这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在这个构造函数中，使用的是<code>NonfairSync</code>（非公平锁），这个类不保证线程获得许可证的顺序，调用<code>acquire</code>方法的线程可以在一直等待的线程之前获得一个许可证。</p>
</blockquote>
<p>15.6.3 有没有什么方法可保证他们的顺序？</p>
<blockquote>
<p>​	可以使用Semaphore的另一个构造函数：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用构造方法时，<code>fair</code>参数传入<code>true</code>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">washbasin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这样使用的是<code>FairSync</code>（公平锁），可以确保按照各个线程调用<code>acquire</code>方法的顺序获得许可证。</p>
<h3 id="对Semaphore的内部原理有没有了解？"><a href="#对Semaphore的内部原理有没有了解？" class="headerlink" title="对Semaphore的内部原理有没有了解？"></a>对Semaphore的内部原理有没有了解？</h3><blockquote>
<p>​	<code>Semaphore</code>内部主要通过<code>AQS（AbstractQueuedSynchronizer）</code>实现线程的管理。<code>Semaphore</code>在构造时，需要传入许可证的数量，它最后传递给了<code>AQS</code>的<code>state</code>值。线程在调用<code>acquire</code>方法获取许可证时，如果<code>Semaphore</code>中许可证的数量大于<code>0</code>，许可证的数量就减<code>1</code>，线程继续运行，当线程运行结束调用<code>release</code>方法时释放许可证时，许可证的数量就加<code>1</code>。如果获取许可证时，<code>Semaphore</code>中许可证的数量为<code>0</code>，则获取失败，线程进入<code>AQS</code>的等待队列中，等待被其它释放许可证的线程唤醒。</p>
</blockquote>
<h3 id="NonfairSync和FairSync有什么区别？为什么会造成这样的效果？"><a href="#NonfairSync和FairSync有什么区别？为什么会造成这样的效果？" class="headerlink" title="NonfairSync和FairSync有什么区别？为什么会造成这样的效果？"></a>NonfairSync和FairSync有什么区别？为什么会造成这样的效果？</h3><p>这就涉及到<code>NonfairSync</code>和<code>FairSync</code>的内部实现了，在<code>NonfairSync</code>中，<code>acquire</code>方法核心源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">	<span class="comment">//acquires参数默认为1，表示尝试获取1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//remaining是剩余的许可数数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//剩余的许可数数量小于0时，</span></span><br><span class="line">        <span class="comment">//当前线程进入AQS中的doAcquireSharedInterruptibly方法</span></span><br><span class="line">        <span class="comment">//等待可用许可证并挂起，直到被唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>release</code>方法核心源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">	<span class="comment">//releases参数默认为1，表示尝试释放1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//next是如果许可证释放成功，可用许可证的数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//如果许可证释放成功，</span></span><br><span class="line">        <span class="comment">//当前线程进入到AQS的doReleaseShared方法，</span></span><br><span class="line">        <span class="comment">//唤醒队列中等待许可的线程。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	当一个线程<code>A</code>调用<code>acquire</code>方法时，会直接尝试获取许可证，而不管同一时刻阻塞队列中是否有线程也在等待许可证，如果恰好有线程<code>C</code>调用<code>release</code>方法释放许可证，并唤醒阻塞队列中第一个等待的线程<code>B</code>，此时线程<code>A</code>和线程<code>B</code>是共同竞争可用许可证，不公平性就体现在：线程<code>A</code>没任何等待就和线程<code>B</code>一起竞争许可证了。</p>
</blockquote>
<blockquote>
<p>​	而在<code>FairSync</code>中，<code>acquire</code>方法核心源码是：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">	<span class="comment">//acquires参数默认为1，表示尝试获取1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//检查阻塞队列中是否有等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//remaining是剩余的许可数数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	和非公平策略相比，<code>FairSync</code>中多一个对阻塞队列是否有等待的线程的检查，如果没有，就可以参与许可证的竞争；如果有，线程直接被插入到阻塞队列尾节点并挂起，等待被唤醒。</p>
</blockquote>
<h2 id="Semaphore示例"><a href="#Semaphore示例" class="headerlink" title="Semaphore示例"></a>Semaphore示例</h2><p>下面给出了一个使用<code>Semaphore</code>的示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name, Semaphore semaphore)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SEM_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(SEM_SIZE);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;t1&quot;</span>, semaphore);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;t2&quot;</span>, semaphore);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(<span class="keyword">permits</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main trying to acquire</span><br><span class="line">main acquire successfully</span><br><span class="line">t1 trying to acquire</span><br><span class="line">t1 acquire successfully</span><br><span class="line">t2 trying to acquire</span><br><span class="line">t1 release successfully</span><br><span class="line">main release successfully</span><br><span class="line">t2 acquire successfully</span><br><span class="line">t2 release successfully</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 首先，生成一个信号量，信号量有<code>10</code>个许可，然后，<code>main</code>，<code>t1</code>，<code>t2</code>三个线程获取许可运行，根据结果，可能存在如下的一种时序。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-5.png"></p>
<blockquote>
<p>​	说明: 如上图所示，首先，<code>main</code>线程执行<code>acquire</code>操作，并且成功获得许可，之后<code>t1</code>线程执行<code>acquire</code>操作，成功获得许可，之后<code>t2</code>执行<code>acquire</code>操作，由于此时许可数量不够，<code>t2</code>线程将会阻塞，直到许可可用。之后<code>t1</code>线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时<code>t2</code>线程会成功获得许可运行，<code>t2</code>运行完成后释放许可。下面进行详细分析。</p>
</blockquote>
<ul>
<li><code>main</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-6.png"></p>
<blockquote>
<p>说明: 此时，可以看到只是<code>AQS</code>的<code>state</code>变为了<code>5</code>，<code>main</code>线程并没有被阻塞，可以继续运行。</p>
</blockquote>
<ul>
<li><code>t1</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-7.png"></p>
<blockquote>
<p>说明: 此时，可以看到只是<code>AQS</code>的<code>state</code>变为了<code>2</code>，<code>t1</code>线程并没有被阻塞，可以继续运行。</p>
</blockquote>
<ul>
<li><code>t2</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-8.png"></p>
<blockquote>
<p>说明: 此时，<code>t2</code>线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，<code>AQS</code>的<code>state</code>还是为<code>2</code>。</p>
</blockquote>
<ul>
<li><code>t1</code>执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-9.png"></p>
<p>说明: 此时，<code>t2</code>线程将会被<code>unpark</code>，并且<code>AQS</code>的<code>state</code>为<code>5</code>，<code>t2</code>获取<code>cpu</code>资源后可以继续运行。</p>
<ul>
<li><code>main</code>线程执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-10.png"></p>
<p>说明: 此时，<code>t2</code>线程还会被<code>unpark</code>，但是不会产生影响，此时，只要<code>t2</code>线程获得<code>CPU</code>资源就可以运行了。此时，<code>AQS</code>的<code>state</code>为<code>10</code>。</p>
<ul>
<li><code>t2</code>获取<code>CPU</code>资源，继续运行，此时<code>t2</code>需要恢复现场，回到<code>parkAndCheckInterrupt</code>函数中，也是在<code>should</code>继续运行。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-11.png"></p>
<p>说明: 此时，可以看到，<code>Sync queue</code>中只有一个结点，头节点与尾节点都指向该结点，在<code>setHeadAndPropagate</code>的函数中会设置头节点并且会<code>unpark</code>队列中的其他结点。</p>
<ul>
<li><code>t2</code>线程执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-12.png"></p>
<p>说明: <code>t2</code>线程经过<code>release</code>后，此时信号量的许可又变为<code>10</code>个了，此时<code>Sync queue</code>中的结点还是没有变化。</p>
<h3 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h3><h4 id="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</h4><blockquote>
<p>答案：拿不到令牌的线程阻塞，不会继续往下运行。</p>
</blockquote>
<h4 id="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</h4><blockquote>
<p>答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次<code>acquire</code>方法，就需要有一个令牌才能继续运行。</p>
</blockquote>
<h4 id="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗"><a href="#semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗" class="headerlink" title="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?"></a>semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</h4><blockquote>
<p>答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p>
</blockquote>
<h4 id="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a>semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h4><blockquote>
<p>答案：能，原因是<code>release</code>会添加令牌，并不会以初始化的大小为准。<code>Semaphore</code>中<code>release</code>方法的调用并没有限制要在<code>acquire</code>后调用。</p>
</blockquote>
<p>具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSemaphore2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">permitsNum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permitsNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p><code>CountDownLatch</code>是<code>JDK</code>提供的一个同步工具，它可以让一个或多个线程等待，一直等到其他线程中执行完成一组操作。</p>
</blockquote>
<h3 id="CountDownLatch有哪些常用的方法？"><a href="#CountDownLatch有哪些常用的方法？" class="headerlink" title="CountDownLatch有哪些常用的方法？"></a>CountDownLatch有哪些常用的方法？</h3><blockquote>
<p>​	有<code>countDown</code>方法和<code>await</code>方法，<code>CountDownLatch</code>在初始化时，需要指定用给定一个整数作为计数器。当调用<code>countDown</code>方法时，计数器会被减<code>1</code>；当调用<code>await</code>方法时，如果计数器大于<code>0</code>时，线程会被阻塞，一直到计数器被<code>countDown</code>方法减到<code>0</code>时，线程才会继续执行。计数器是无法重置的，当计数器被减到<code>0</code>时，调用<code>await</code>方法都会直接返回。</p>
</blockquote>
<h3 id="调用countDown方法时，线程也会阻塞嘛？"><a href="#调用countDown方法时，线程也会阻塞嘛？" class="headerlink" title="调用countDown方法时，线程也会阻塞嘛？"></a>调用<code>countDown</code>方法时，线程也会阻塞嘛？</h3><blockquote>
<p>不会的，调用<code>countDown</code>的线程可以继续执行，不需要等待计数器被减到<code>0</code>，只是调用<code>await</code>方法的线程需要等待。</p>
</blockquote>
<h3 id="可以举一个使用CountDownLatch的例子吗？"><a href="#可以举一个使用CountDownLatch的例子吗？" class="headerlink" title="可以举一个使用CountDownLatch的例子吗？"></a>可以举一个使用CountDownLatch的例子吗？</h3><blockquote>
<p>比如张三、李四和王五几个人约好去饭店一起去吃饭，这几个人都是比较绅士，要等到所有人都到齐以后才让服务员上菜。这种场景就可以用到<code>CountDownLatch</code>。</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>当然可以，这是张三、李四和王五的顾客类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(CountDownLatch latch, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;出发去饭店&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (random.nextDouble() * <span class="number">3000</span>) + <span class="number">1000</span>);</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;到了饭店&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是服务员类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitress</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitress</span><span class="params">(CountDownLatch latch, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name  + <span class="string">&quot;等待顾客&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name  + <span class="string">&quot;开始上菜&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，再写一个测试类，用于模拟上面所说的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;张三&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;李四&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;王五&quot;</span>)));</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Waitress</span>(latch, <span class="string">&quot;♥小芳♥&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以后的结果应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 王五出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 李四出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 张三出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.062</span> ♥小芳♥等待顾客</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">54.341</span> 张三到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">54.358</span> 李四到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">56.784</span> 王五到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">56.784</span> ♥小芳♥开始上菜</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，服务员小芳在调用<code>await</code>方法时一直阻塞着，一直等到三个顾客都调用了<code>countDown</code>方法才继续执行。</p>
</blockquote>
<h4 id="如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？"><a href="#如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？" class="headerlink" title="如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？"></a>如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？</h4><blockquote>
<p>可以使用<code>await</code>方法的另一个重载，传入等待的超时时间，比如服务员只等<code>3</code>秒钟，可以把服务员类中的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latch.await();</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>运行结果可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 张三出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 李四出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 王五出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.948</span> ♥小芳♥等待顾客</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.376</span> 李四到了饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.544</span> 王五到了饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.951</span> ♥小芳♥开始上菜</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">44.762</span> 张三到了饭店</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，服务员小芳在调用<code>await</code>方法时虽然被阻塞了，但是时间超过3秒后，没等顾客张三调用<code>countDown</code>方法就继续执行开始上菜了。</p>
</blockquote>
<h3 id="CountDownLatch的实现原理是什么？"><a href="#CountDownLatch的实现原理是什么？" class="headerlink" title="CountDownLatch的实现原理是什么？"></a>CountDownLatch的实现原理是什么？</h3><blockquote>
<p><code>CountDownLatch</code>有一个内部类叫做<code>Sync</code>，它继承了<code>AbstractQueuedSynchronizer</code>类，其中维护了一个整数<code>state</code>，并且保证了修改<code>state</code>的可见性和原子性。</p>
</blockquote>
<blockquote>
<p>创建<code>CountDownLatch</code>实例时，也会创建一个<code>Sync</code>的实例，同时把计数器的值传给<code>Sync</code>实例，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>countDown</code>方法中，只调用了<code>Sync</code>实例的<code>releaseShared</code>方法，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<code>releaseShared</code>方法，先对计数器进行减<code>1</code>操作，如果减<code>1</code>后的计数器为<code>0</code>，唤醒被<code>await</code>方法阻塞的所有线程，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">//对计数器进行减一操作</span></span><br><span class="line">        doReleaseShared();<span class="comment">//如果计数器为0，唤醒被await方法阻塞的所有线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<code>tryReleaseShared</code>方法，先获取当前计数器的值，如果计数器为0时，就直接返回；如果不为0时，使用CAS方法对计数器进行减1操作，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环，如果CAS操作失败就会不断继续尝试。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">//获取当前计数器的值。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">// 计数器为0时，就直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))<span class="comment">// 使用CAS方法对计数器进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;<span class="comment">//如果操作成功，返回计数器是否为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>await</code>方法中，只调用了Sync实例的<code>acquireSharedInterruptibly</code>方法，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>acquireSharedInterruptibly</code>方法，判断计数器是否为<code>0</code>，如果不为<code>0</code>则阻塞当前线程，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//判断计数器是否为0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);<span class="comment">//如果不为0则阻塞当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>tryAcquireShared</code>方法，是<code>AbstractQueuedSynchronizer</code>中的一个模板方法，其具体实现在<code>Sync</code>类中，其主要是判断计数器是否为零，如果为零则返回<code>1</code>，如果不为零则返回<code>-1</code>，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：王者荣耀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏加载中!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                        all[temp] = i + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">250</span>));</span><br><span class="line"><span class="comment">//                    后面的打印覆盖前面的打印</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏开始运行！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">游戏加载中!!!</span><br><span class="line">[<span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%]</span><br><span class="line">游戏开始运行！！！</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><blockquote>
<p>​	栅栏类似于闭锁，它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。</p>
<p>​	<code>CyclicBarrier</code>可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用<code>await</code>方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。</p>
</blockquote>
<blockquote>
<p>​	在<code>JUC</code>包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是<code>CyclicBarrier</code>类。利用<code>CyclicBarrier</code>类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。下图演示了这一过程。</p>
</blockquote>
<p>![](<a target="_blank" rel="noopener" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20181218144511688">https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20181218144511688</a> (1).gif)</p>
<blockquote>
<p> ​	<code>CyclicBarrier</code>字面意思是“可重复使用的栅栏”，<code>CyclicBarrier</code> 相比 <code>CountDownLatch</code> 来说，要简单很多，其源码没有什么高深的地方，它是 <code>ReentrantLock</code> 和 <code>Condition</code> 的组合使用。</p>
</blockquote>
<blockquote>
<p>看如下示意图，<code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 是不是很像，只是 <code>CyclicBarrier </code>可以有不止一个栅栏，因为它的栅栏<code>（Barrier）</code>可以重复使用（Cyclic）。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/fa4d24955103ee1c8c0564ab45eebe26.png"></p>
<h3 id="CyclicBarrier源码解析"><a href="#CyclicBarrier源码解析" class="headerlink" title="CyclicBarrier源码解析"></a>CyclicBarrier源码解析</h3><p><code>CyclicBarrier</code>的类图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20180603173118965.png"></p>
<p>通过类图我们可以看到，<code>CyclicBarrier</code>内部使用了<code>ReentrantLock</code>和<code>Condition</code>两个类。它有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程使用<code>await()</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p>
</blockquote>
<blockquote>
<p>​	<code>CyclicBarrier</code>的另一个构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。</p>
</blockquote>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><blockquote>
<p>​	调用<code>await</code>方法的线程告诉<code>CyclicBarrier</code>自己已经到达同步点，然后当前线程被阻塞。直到<code>parties</code>个参与线程调用了<code>await</code>方法，<code>CyclicBarrier</code>同样提供带超时时间的<code>await</code>和不带超时时间的<code>await</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不超时等待</span></span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">            BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法最终都会调用<code>dowait(boolean, long)</code>方法，它也是<code>CyclicBarrier</code>的核心方法，该方法定义如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前代</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 如果这代损坏了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将损坏状态设置为true</span></span><br><span class="line">            <span class="comment">// 并通知其他阻塞在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 如果是 0，说明最后一个线程调用了该方法</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="comment">// 执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新一代，将count重置，将generation重置</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果执行栅栏任务的时候失败了，就将损坏状态设置为true</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果没有时间限制，则直接等待，直到被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 如果有时间限制，则等待指定时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 当前代没有损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面条件不满足，说明这个线程不是这代的</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏的执行，所以，就打个中断标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 当有任何一个线程中断了，就会调用breakBarrier方法</span></span><br><span class="line">            <span class="comment">// 就会唤醒其他的线程，其他线程醒来后，也要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// g != generation表示正常换代了，返回当前线程所在栅栏的下标</span></span><br><span class="line">            <span class="comment">// 如果 g == generation，说明还没有换代，那为什么会醒了？</span></span><br><span class="line">            <span class="comment">// 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span></span><br><span class="line">            <span class="comment">// 正是因为这个原因，才需要generation来保证正确。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>dowait(boolean, long)</code>方法的主要逻辑处理比较简单，如果该线程不是最后一个调用<code>await</code>方法的线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ul>
<li><p>最后一个线程到达，即<code>index == 0</code></p>
</li>
<li><p>某个参与线程等待超时</p>
</li>
<li><p>某个参与线程被中断</p>
</li>
<li><p>调用了<code>CyclicBarrier</code>的<code>reset()</code>方法。该方法会将屏障重置为初始状态</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>​	在上面的源代码中，我们可能需要注意<code>Generation</code> 对象，在上述代码中我们总是可以看到抛出<code>BrokenBarrierException</code>异常，那么什么时候抛出异常呢？如果一个线程处于等待状态时，如果其他线程调用<code>reset()</code>，或者调用的<code>barrier</code>原本就是被损坏的，则抛出<code>BrokenBarrierException</code>异常。同时，任何线程在等待时被中断了，则其他所有线程都将抛出<code>BrokenBarrierException</code>异常，并将<code>barrier</code>置于损坏状态。</p>
</blockquote>
<blockquote>
<p>​	同时，<code>Generation</code>描述着<code>CyclicBarrier</code>的更新换代。在<code>CyclicBarrier</code>中，同一批线程属于同一代。当有<code>parties</code>个线程到达<code>barrier</code>之后，<code>generation</code>就会被更新换代。其中<code>broken</code>标识该当前<code>CyclicBarrier</code>是否已经处于中断状态。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认<code>barrier</code>是没有损坏的。当<code>barrier</code>损坏了或者有一个线程中断了，则通过<code>breakBarrier()</code>来终止所有的线程：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>breakBarrier()</code>中除了将<code>broken</code>设置为<code>true</code>，还会调用<code>signalAll</code>将在<code>CyclicBarrier</code>处于等待状态的线程全部唤醒。</p>
</blockquote>
<blockquote>
<p>当所有线程都已经到达<code>barrier</code>处（<code>index == 0</code>），则会通过<code>nextGeneration()</code>进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置<code>count</code>，<code>generation</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了上面讲到的栅栏更新换代以及损坏状态，我们在使用<code>CyclicBarrier</code>时还要要注意以下几点：</p>
<ul>
<li><code>CyclicBarrier</code>使用独占锁来执行<code>await</code>方法，并发性可能不是很高</li>
<li>如果在等待过程中，线程被中断了，就抛出异常。但如果中断的线程所对应的<code>CyclicBarrier</code>不是这代的，比如，在最后一次线程执行<code>signalAll</code>后，并且更新了这个“代”对象。在这个区间，这个线程被中断了，那么，<code>JDK</code>认为任务已经完成了，就不必在乎中断了，只需要打个标记。该部分源码已在<code>dowait(boolean, long)</code>方法中进行了注释。</li>
<li>如果线程被其他的<code>CyclicBarrier</code>唤醒了，那么<code>g</code>肯定等于<code>generation</code>，这个事件就不能<code>return</code>了，而是继续循环阻塞。反之，如果是当前<code>CyclicBarrier</code>唤醒的，就返回线程在<code>CyclicBarrier</code>的下标。完成了一次冲过栅栏的过程。该部分源码已在<code>dowait(boolean, long)</code>方法中进行了注释。</li>
</ul>
</blockquote>
<h3 id="应用程序示例"><a href="#应用程序示例" class="headerlink" title="应用程序示例"></a>应用程序示例</h3><p>我们看一个<code>CyclicBarrier</code>的应用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">	<span class="comment">// 自定义工作线程</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.run();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始等待其他线程&quot;</span>);</span><br><span class="line">				cyclicBarrier.await();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">				<span class="comment">// 工作线程开始处理，这里用Thread.sleep()来模拟业务处理</span></span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;创建工作线程&quot;</span> + i);</span><br><span class="line">			<span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(cyclicBarrier);</span><br><span class="line">			worker.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（不唯一）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建工作线程<span class="number">0</span></span><br><span class="line">创建工作线程<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>开始等待其他线程</span><br><span class="line">创建工作线程<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">2</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">2</span>开始执行</span><br><span class="line">Thread-<span class="number">0</span>开始执行</span><br><span class="line">Thread-<span class="number">1</span>开始执行</span><br><span class="line">Thread-<span class="number">1</span>执行完毕</span><br><span class="line">Thread-<span class="number">0</span>执行完毕</span><br><span class="line">Thread-<span class="number">2</span>执行完毕</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在上述代码中，我们自定义的工作线程必须要等所有参与线程开始之后才可以执行，我们可以使用<code>CyclicBarrier</code>类来帮助我们完成。从程序的执行结果中也可以看出，所有的工作线程都运行<code>await()</code>方法之后都到达了栅栏位置，然后，<code>3</code>个工作线程才开始执行业务处理。</p>
<p><strong><code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</strong></p>
<ul>
<li><p><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置，可以使用多次，所以<code>CyclicBarrier</code>能够处理更为复杂的场景；</p>
</li>
<li><p><code>CyclicBarrier</code>还提供了一些其他有用的方法，比如<code>getNumberWaiting()</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量，<code>isBroken()</code>方法用来了解阻塞的线程是否被中断；</p>
</li>
<li><p><code>CountDownLatch</code>允许一个或多个线程等待一组事件的产生，而<code>CyclicBarrier</code>用于等待其他线程运行到栅栏位置。</p>
</li>
</ul>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><blockquote>
<p>定义：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 新建了5个SimpleDateFormat对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里<code>10</code>个线程即便使用了线程池，但是每个线程都会在执行过程中创建一个<code>SimpleDateFormat</code>对象，这比较耗费内存资源。</p>
</blockquote>
<blockquote>
<p>改进一：将<code>SimpleDateFormat</code>提出来用<code>static</code>修饰，这样每个线程都可以公用一个<code>SimpleDateFormat</code>对象，减少内存消耗，但是这样会打印出相同的时间，所有线程都在争夺这个资源，我们需要一个锁去控制，避免出现线程安全问题。</p>
</blockquote>
<blockquote>
<p>改进二：在改进一的基础上添加锁控制，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadLocalTest.class) &#123;</span><br><span class="line">            s = dateFormat.format(date);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这虽然能够满足要求，但是在高并发场景下，所有线程需要一个个的去获取锁，需要排队等待，这显然性能损耗太大。</p>
</blockquote>
<blockquote>
<p>改进三：使用<code>ThreadLocal</code>（不仅线程安全，而且也没有<code>synchronized</code>带来的性能问题，每个线程内有自己独享的<code>SimpleDateFormat</code>对象）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> ThreadSafeFormatter.dateFormatThreadLocal.get(); <span class="comment">// 拿到initialValue返回对象</span></span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeFormatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda表达式写法，和上面写法效果完全一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal2 = ThreadLocal</span><br><span class="line">            .withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br></pre></td></tr></table></figure>

<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><blockquote>
<p>​	当一个请求进来了，一个线程负责处理该请求，该请求会依次调用<code>service-1()</code>,<code> service-2(),</code> <code>service-3()</code>, <code>service-4()</code>，同时，每个<code>service()</code>都需要获得调用方用户<code>user</code>的信息，也就是需要拿到<code>user</code>对象。</p>
<p>​	一个比较繁琐的解决方案是把<code>user</code>作为参数层层传递，从<code>service-1()</code>传到<code>service-2()</code>,再从<code>service-2()</code>传到<code>service-3()</code>，以此类推，但是这样做会导致代码冗余且不易维护。</p>
<p>​	在此基础上可以演进，使用<code>UserMap</code>，就是每个用户的信息都存在一个<code>Map</code>中，当多线程同时工作时，我们需要保证线程安全，可以用<code>synchronized</code>也可以用<code>ConcurrentHashMap</code>，但这两者无论用什么，都会对性能有所影响。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service1</span>().process(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        UserContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service3</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service3拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        UserContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); <span class="comment">// 对比上一个例子，这里没有重写initialValue方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service2拿到用户名：张三</span><br><span class="line">Service3拿到用户名：张三</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这样，不管哪个<code>Service</code>都能拿到<code>User</code>对象，能获取<code>User</code>对象内的所有信息。并且假如有多个请求，一个张三，一个李四，因为他们并没有直接共享<code>User</code>对象，所以他们之间不会有线程安全问题。</p>
<p>​	使用<code>ThreadLocal</code>后无需<code>synchronized</code>，可以在不影响性能的情况下，也无需层层传递参数，就可以达到保存当前线程对应的用户信息的目的。</p>
</blockquote>
<h3 id="ThreadLocal的作用和好处"><a href="#ThreadLocal的作用和好处" class="headerlink" title="ThreadLocal的作用和好处"></a>ThreadLocal的作用和好处</h3><h4 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h4><blockquote>
<ul>
<li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li>
<li>在任何方法中都可以轻松获取到该对象</li>
</ul>
</blockquote>
<h4 id="ThreadLocal两种用法"><a href="#ThreadLocal两种用法" class="headerlink" title="ThreadLocal两种用法"></a>ThreadLocal两种用法</h4><blockquote>
<p>根据共享对象的生成时机不同，选择<code>initialValue</code>或<code>set</code>来保存对象</p>
<ul>
<li>不受外界传参影响的时候，可以选择重写<code>initialValue()</code>方法来初始化保存对象，会在<code>ThreadLocal</code>第一次调用<code>get()</code>方法的时候初始化对象，对象的初始化时机可以由我们控制，比如上面第一个例子工具类。</li>
<li>如果需要保存到<code>ThreadLocal</code>里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息，用<code>ThreadLocal.set()</code>直接放到我们的<code>ThreadLocal</code>中去，以便后续使用，对应代码就是上面第二个例子。</li>
</ul>
</blockquote>
<h4 id="使用ThreadLocal带来的四个好处"><a href="#使用ThreadLocal带来的四个好处" class="headerlink" title="使用ThreadLocal带来的四个好处"></a>使用ThreadLocal带来的四个好处</h4><blockquote>
<ul>
<li>达到线程安全</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效地利用内存节省开销，上面例子中，相比于成千上万个任务，每个任务都新建一个<code>SimpleDateFormat</code>，显然用<code>ThreadLocal</code>可以节省内存和开销。</li>
<li>免去传参的繁琐，不需要每次都传同样的参数，<code>ThreadLocal</code>使得代码耦合度更低，更优雅</li>
</ul>
</blockquote>
<h3 id="ThreadLocal主要方法介绍"><a href="#ThreadLocal主要方法介绍" class="headerlink" title="ThreadLocal主要方法介绍"></a>ThreadLocal主要方法介绍</h3><p>主要是<code>initialValue</code>、<code>set</code>、<code>get</code>、<code>remove</code>这几个方法，关于源码分析，后面介绍</p>
<blockquote>
<ul>
<li><p><code>initialValue</code>方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，<strong>只有在调用<code>get</code>的时候，才会触发</strong>。</p>
</li>
<li><p>当线程第一次使用<code>get</code>方法访问变量时，将调用<code>initialValue</code>方法，除非线程先前调用了<code>set</code>方法，在这种情况下，不会为线程调用本<code>initialValue</code>方法。</p>
</li>
<li><p>通常，每个线程最多调用一次<code>initialValue()</code>方法，但如果已经调用了一次<code>remove()</code>后，再调用<code>get()</code>，则可以再次调用<code>initialValue()</code>，相当于第一次调用<code>get()</code>。</p>
</li>
<li><p>如果不重写<code>initialValue()</code>方法，这个方法会返回<code>null</code>。一般使用匿名内部类的方法来重写<code>initialValue()</code>方法，以便在后续使用中可以初始化副本对象。</p>
</li>
</ul>
</blockquote>
<h3 id="ThreadLocal原理源码分析"><a href="#ThreadLocal原理源码分析" class="headerlink" title="ThreadLocal原理源码分析"></a>ThreadLocal原理源码分析</h3><h4 id="Thread、ThreadLocal、ThreadLocalMap三者的关系"><a href="#Thread、ThreadLocal、ThreadLocalMap三者的关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap三者的关系"></a>Thread、ThreadLocal、ThreadLocalMap三者的关系</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njhuvtcyre5rydtufyiguohi.png"></p>
<blockquote>
<p><font color='red'>从图中可以看出，每个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>，每个<code>ThreadLocalMap</code>可以存储多个<code>ThreadLocal</code>。</font></p>
</blockquote>
<h4 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法没有默认实现，如果要用<code>initialValue</code>方法，需要自己实现，通常使用匿名内部类的方式实现（可以回顾上面代码）</p>
</blockquote>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">    	第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">    	第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong><code>get</code>方法是先取出当前线程的<code>ThreadLocalMap</code>，然后调用<code>map.getEntry()</code>方法，把本<code>ThreadLocal</code>的引用作为参数传入，取出<code>map</code>中属于本<code>ThreadLocal</code>的<code>value</code></p>
<p><strong>注意：</strong>这个<code>map</code>以及<code>map</code>中的<code>key</code>和<code>value</code>都是保存在线程中<code>ThreadLocalMap</code>的，而不是保存在<code>ThreadLocal</code>中</p>
<p><code>getMap</code>方法：获取到当前线程内的<code>ThreadLocalMap</code>对象<br>每个线程内都有<code>ThreadLocalMap</code>对象，名为<code>threadLocals</code>，初始值为<code>null</code></p>
</blockquote>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">       <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h4><p><code>ThreadLocalMap</code>类，也就是<code>Thread.threadLocals</code></p>
<blockquote>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，没有实现<code>Map</code>接口，用独立的方式实现了<code>Map</code>的功能，其内部的<code>Entry</code>也是独立实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此行声明在Thread类中，创建ThreadLocalMap就是对Thread类的这个成员变量赋值</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/monubyutvyctxerdtcyvgbhijnomkl.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment"> */</span>        <span class="number">0.75</span> * length</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在<code>ThreadLocalMap</code>中，也是用<code>Entry</code>来保存<code>K-V</code>结构数据的。不过<code>Entry</code>中的<code>key</code>只能是<code>ThreadLocal</code>对象，这点在构造方法中已经限定死了。</p>
</blockquote>
<blockquote>
<p>​	<font color='red'>另外，<code>Entry</code>继承<code>WeakReference</code>，也就是<code>key</code>（<code>ThreadLocal</code>）是弱引用，其目的是将<code>ThreadLocal</code>对象的生命周期和线程生命周期解绑。</font>&gt;</p>
</blockquote>
<h3 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h3><blockquote>
<ul>
<li><code>ThreadLocalMap</code>中的<code>Entry</code>继承自 <code>WeakReference</code>，是弱引用</li>
<li>弱引用：通过<code>WeakReference</code>类实现的，在<code>GC</code>的时候，不管内存空间足不足都会回收这个对象，适用于内存敏感的缓存，<code>ThreadLocal</code>中的<code>key</code>就用到了弱引用，有利于内存回收。</li>
<li>强引用：我们平日里面的用到的<code>new</code>了一个对象就是强引用，例如 <code>Object obj = new Object()</code>;当<code>JVM</code>的内存空间不足时，宁愿抛出<code>OutOfMemoryError</code>使得程序异常终止也不愿意回收具有强引用的存活着的对象。</li>
</ul>
</blockquote>
<p><font color='red'><code>ThreadLocalMap</code> 的每个 <code>Entry</code> 都是一个对<code>key</code>的弱引用，同时，每个 <code>Entry</code> 都包含了一个对<code>value</code>的强引用，如下：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">         <span class="built_in">super</span>(k); <span class="comment">// key值给WeakReference处理</span></span><br><span class="line">         value = v; <span class="comment">// value直接用变量保存，是强引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	正常情况下，当线程终止，保存在<code>ThreadLocalMap</code>里的<code>value</code>会被垃圾回收，因为没有任何强引用了。但如果线程不终止（比如线程需要保持很久），那么<code>key</code>对应的<code>value</code>就不能被回收，因为有以下的调用链：</p>
<p><code>CurrentThread----&gt;ThreadLocalMap----&gt;Entry(key为null，弱引用被回收)----&gt;value</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ljnbhugvyctxercytbium.png"></p>
<p>​	因为<code>value</code>和<code>Thread</code>之间还存在这个强引用链路，所以导致<code>value</code>无法回收，就可能会出现<code>OOM</code></p>
<p>​	<code>JDK</code>已经考虑到了这个问题，所以在<code>set</code>, <code>remove</code>, <code>rehash</code>方法中会扫描<code>key</code>为<code>null</code>的<code>Entry</code>，并把对应的<code>value</code>设置为<code>null</code>，这样<code>value</code>对象就可以被回收&#96;</p>
<p>比如<code>rehash</code>里面调用<code>resize</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">          ......省略代码</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">          <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">              e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">          &#125; </span><br><span class="line">          ......</span><br></pre></td></tr></table></figure>

<p>​	如果<code>key</code>回收了，那么<code>value</code>也设置为<code>null</code>，断开强引用链路，便于垃圾回收。</p>
<p>​	<strong>但是如果一个<code>ThreadLocal</code>不被使用，那么实际上<code>set</code>, <code>remove</code>, <code>rehash</code>方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了<code>value</code>的内存泄漏</strong>。</p>
</blockquote>
<h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><blockquote>
<p>​	及时调用<code>remove</code>方法，就会删除对应的<code>Entry</code>对象，可以避免内存<code>remove</code>泄漏，所以使用完<code>ThreadLocal</code>之后，应该调用<code>remove</code>方法。</p>
<p>​	比如拦截器获取到用户信息，用户信息存在<code>ThreadLocalMap</code>中，线程请求结束之前拦住它，并用<code>remove</code>清除<code>User</code>对象，这样就能稳妥的保证不会内存泄漏。</p>
</blockquote>
<h3 id="ThreadLocalMap的hash冲突的解决"><a href="#ThreadLocalMap的hash冲突的解决" class="headerlink" title="ThreadLocalMap的hash冲突的解决"></a>ThreadLocalMap的hash冲突的解决</h3><blockquote>
<p>​	构造函数首先创建一个长度为<code>16</code>的<code>Entry</code>数组，然后计算出<code>firstKey</code>对应的索引，然后存储到<code>table</code>中，并设置<code>size</code>和<code>threshold</code>。</p>
</blockquote>
<h4 id="ThreadLocalMap中的set方法"><a href="#ThreadLocalMap中的set方法" class="headerlink" title="ThreadLocalMap中的set方法"></a>ThreadLocalMap中的set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">        <span class="comment">//计算索引(重点代码，刚才分析过了）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用线性探测法查找元素（重点代码）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//ThreadLocal 对应的 key 存在，直接覆盖之前的值</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，</span></span><br><span class="line">           <span class="comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。</span></span><br><span class="line"><span class="comment">             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行				 * rehash（执行一次全表的扫描清理工作）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码执行流程：</strong></p>
<ol>
<li>首先还是根据<code>key</code>计算出索引 <code>i</code>，然后查找<code>i</code>位置上的<code>Entry</code></li>
<li>若是<code>Entry</code>已经存在并且<code>key</code>等于传入的<code>key</code>，那么这时候直接给这个<code>Entry</code>赋新的<code>value</code>值</li>
<li>若是<code>Entry</code>存在，但是<code>key</code>为<code>null</code>，则调用<code>replaceStaleEntry</code>来更换这个<code>key</code>为空的<code>Entry</code></li>
<li>不断循环检测，直到遇到为<code>null</code>的地方，这时候要是还没在循环过程中<code>return</code>，那么就在这个<code>null</code>的位置新建一个<code>Entry</code>，并且插入，同时<code>size</code>增加<code>1</code></li>
</ol>
<p>​	最后调用<code>cleanSomeSlots</code>，清理<code>key</code>为<code>null</code>的<code>Entry</code>，最后返回是否清理了<code>Entry</code>，接下来再判断<code>sz</code> 是否<code>&gt;= thresgold</code>达到了<code>rehash</code>的条件，达到的话就会调用<code>rehash</code>函数执行一次全表的扫描清理。</p>
<p>​	如果遇到空<code>Entry</code>，则直接设置<code>Key</code>，<code>Value</code>值，并判断<code>Entry</code>数组是否需要扩容；因为此处<code>Entry</code>数组新增了一个<code>Entry</code>，所以首先执行一次启发式擦除过程，如果成功擦除了元素，表明<code>Entry</code>数组并无变大，不需要扩容，否则，新增一个元素后，如果<code>Entry</code>数组大小大于阈值，则进行扩容。</p>
</blockquote>
<blockquote>
<p>重点分析：<code>ThreadLocalMap</code>使用<strong>线性探测法</strong>来解决哈希冲突的。（<code>HashMap</code>使用<strong>拉链法</strong>）</p>
<p>​	举个例子，假设当前table长度为<code>16</code>，也就是说如果计算出来<code>key</code>的<code>hash</code>值为<code>14</code>，如果<code>table[14]</code>上已经有值，并且其<code>key</code>与当前<code>key</code>不一致，那么就发生了<code>hash</code>冲突，这个时候将<code>14</code>加<code>1</code>得到<code>15</code>，取<code>table[15]</code>进行判断，这个时候如果还是冲突会回到<code>0</code>，取<code>table[0]</code>,以此类推，直到可以插入。</p>
<p>​	按照上面的描述，可以把<code>Entry[] table</code>看成一个环形数组。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="clpsh979g001rxgvs6sxdesud" data-title="并发编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SQL复习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-07-26T10:04:19.000Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL/">SQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/">SQL复习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>说明：本文主要借鉴尚硅谷的MySQL底层原理课程资料与<a target="_blank" rel="noopener" href="https://www.runoob.com/sql/sql-intro.html">https://www.runoob.com/sql/sql-intro.html</a></p>
<h2 id="结构化查询语言包含6个部分"><a href="#结构化查询语言包含6个部分" class="headerlink" title="结构化查询语言包含6个部分"></a>结构化查询语言包含6个部分</h2><blockquote>
<p><strong><code>DDL</code>：</strong>数据定义语言</p>
<p>关键字：<code>create</code>、<code>drop</code>、<code>truncate</code>、<code>alter</code></p>
<p><strong><code>DQL</code>：</strong>数据查询语言</p>
<p>关键字：<code>select</code></p>
<p><strong><code>DML</code>：</strong>数据操作语言</p>
<p>关键字：<code>insert</code>、<code>update</code>、<code>delete</code></p>
<p><strong><code>DCL</code>：</strong>数据控制语言</p>
<p>关键字：<code>grant</code>、<code>revoke</code>、<code>deny</code></p>
<p><strong><code>TCL</code>：</strong>事务控制语言</p>
<p>关键字：<code>commit</code>、<code>savepoint</code>、<code>rollback</code></p>
<p><strong><code>CCL</code>：</strong>指针控制语言</p>
</blockquote>
<h2 id="提交数据有三种类型"><a href="#提交数据有三种类型" class="headerlink" title="提交数据有三种类型"></a>提交数据有三种类型</h2><blockquote>
<p><strong>显式提交：</strong>用<code>COMMIT</code>命令直接完成的提交为显式提交。其格式为：</p>
<p>​	<code>SQL&gt;commit</code>；</p>
<p><strong>隐式提交：</strong>用<code>SQL</code>命令间接完成的提交为隐式提交。这些命令是：</p>
<p>​	<code>alter</code>，<code>audit</code>，<code>comment</code>，<code>connect</code>，<code>create</code>，<code>disconnext</code>，<code>drop</code>，<code>exit</code>，<code>grant</code>，<code>noaudit</code>，<code>quit</code>，<code>revoke</code>，<code>rename</code>；</p>
<p><strong>自动提交：</strong>若把<code>AUTOCOMMIT</code>设置为<code>ON</code>，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：</p>
<p>​	<code>SQL&gt;set autocommit on</code>；</p>
</blockquote>
<h2 id="SQL基础教程"><a href="#SQL基础教程" class="headerlink" title="SQL基础教程"></a><code>SQL</code>基础教程</h2><h3 id="select：查询"><a href="#select：查询" class="headerlink" title="select：查询"></a><code>select</code>：查询</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称`;   #查询出所有的列</span><br></pre></td></tr></table></figure>

<h3 id="distinct：返回唯一不同的值"><a href="#distinct：返回唯一不同的值" class="headerlink" title="distinct：返回唯一不同的值"></a><code>distinct</code>：返回唯一不同的值</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `列名称` <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p><code>order</code>表</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
</tbody></table>
<p><code>persons</code>表</p>
<table>
<thead>
<tr>
<th align="center">id_p</th>
<th align="center">lastName</th>
<th align="center">firstName</th>
<th align="center">address</th>
<th align="center">city</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Adams</td>
<td align="center">John</td>
<td align="center">Oxford Street</td>
<td align="center">London</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Bush</td>
<td align="center">George</td>
<td align="center">Fifth Avenue</td>
<td align="center">New York</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Carter</td>
<td align="center">Thomas</td>
<td align="center">Changan Street</td>
<td align="center">Beijing</td>
</tr>
</tbody></table>
<p><code>orders</code>表</p>
<table>
<thead>
<tr>
<th align="center">id_o</th>
<th align="center">orderNo</th>
<th align="center">id_p</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">77895</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">44678</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">22456</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">24562</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">34764</td>
<td align="center">65</td>
</tr>
</tbody></table>
<p><code>employees_China</code>表</p>
<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Zhang, Hua</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Wang, Wei</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Yang, Ming</td>
</tr>
</tbody></table>
<p><code>employees_USA</code>表</p>
<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Adams, John</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Bush, George</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Gates, Bill</td>
</tr>
</tbody></table>
<p><strong>执行：</strong><code>select distinct company from order;</code></p>
<table>
<thead>
<tr>
<th align="center">company</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IBM</td>
</tr>
<tr>
<td align="center">Apple</td>
</tr>
<tr>
<td align="center">W3School</td>
</tr>
</tbody></table>
<h3 id="where：规定选择的标准"><a href="#where：规定选择的标准" class="headerlink" title="where：规定选择的标准"></a><code>where</code>：规定选择的标准</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> `表名称` <span class="keyword">where</span> 列 运算符 值;</span><br></pre></td></tr></table></figure>

<p><strong>运算符：</strong></p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;     在某些版本SQL，可以写成 !&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在某个范围内</td>
</tr>
<tr>
<td align="center">LIKE</td>
<td align="center">搜索某种模式</td>
</tr>
</tbody></table>
<h4 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h4><p>1、空值判断：<code>is null</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 company 列中的空值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `company` <span class="keyword">is</span> <span class="keyword">null</span>;   </span><br></pre></td></tr></table></figure>

<p>2、<code>between and</code> (在 之间的值)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 orderNumber 列中在 <span class="number">199</span> 到 <span class="number">699</span> 之间的值，包括 <span class="number">199</span> 与 <span class="number">699</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `orderNumber` <span class="keyword">between</span> <span class="number">199</span> <span class="keyword">and</span> <span class="number">699</span>;</span><br></pre></td></tr></table></figure>

<p>3、<code>in</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 orderNumber 列中等于 <span class="number">100</span>、<span class="number">200</span>、<span class="number">300</span>的值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `orderNumber` <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>4、<code>like</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">like</span> 规则：</span><br><span class="line">#    <span class="operator">%</span> 表示多个字值</span><br><span class="line">#    _ 表示一个字值</span><br><span class="line">#    M<span class="operator">%</span> 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的</span><br><span class="line">#    <span class="operator">%</span>M<span class="operator">%</span> 表示查询包含 M 的所有内容</span><br><span class="line"></span><br><span class="line"># 查询 <span class="keyword">order</span> 表中 company 列中包含小写字符的值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `company` <span class="keyword">like</span> <span class="string">&#x27;%[a-z]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>5、不带比较运算符的<code>where</code>子句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">where</span> 子句并不一定带比较运算符，当不带运算符时，会执行一个隐式转换。</span><br><span class="line"># 当 <span class="number">0</span> 时转化为 <span class="literal">false</span>，<span class="number">1</span> 转化为 <span class="literal">true</span>。例如：</span><br><span class="line"></span><br><span class="line"># 会返回一个空集，因为每一行记录 <span class="keyword">where</span> 都返回 <span class="literal">false</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> <span class="number">0</span></span><br><span class="line"># 会返回一个全集，因为每一行记录 <span class="keyword">where</span> 都返回 <span class="literal">true</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="and-or：作为过滤的运算符"><a href="#and-or：作为过滤的运算符" class="headerlink" title="and &amp; or：作为过滤的运算符"></a><code>and &amp; or</code>：作为过滤的运算符</h4><h3 id="Order-by：用于对结果集进行排序"><a href="#Order-by：用于对结果集进行排序" class="headerlink" title="Order by：用于对结果集进行排序"></a><code>Order by</code>：用于对结果集进行排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 默认按照升序 <span class="keyword">asc</span> 对记录进行排序</span><br><span class="line">关键字 <span class="keyword">desc</span> 降序         <span class="keyword">asc</span> 升序</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对 company 降序，对 orderNumber 降序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `company`,`orderNmuber`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对 company 降序，对 orderNumber 升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `company` <span class="keyword">desc</span> , `orderNmuber` <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询 company 为 W3School ，对 orderNumber 升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">where</span> `company` <span class="operator">=</span> <span class="string">&#x27;W3School&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> `orderNmuber`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<h3 id="insert：插入"><a href="#insert：插入" class="headerlink" title="insert：插入"></a><code>insert</code>：插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `表名称` <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `表名称`(列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....);</span><br></pre></td></tr></table></figure>

<h3 id="update：修改"><a href="#update：修改" class="headerlink" title="update：修改"></a><code>update</code>：修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> `表名称` <span class="keyword">set</span> `列名称` <span class="operator">=</span> 新值 <span class="keyword">where</span> `列名称` <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>

<h3 id="delete：删除"><a href="#delete：删除" class="headerlink" title="delete：删除"></a><code>delete</code>：删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除某行</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `表名称` <span class="keyword">where</span> `列名称` <span class="operator">=</span> 值;</span><br><span class="line"># 删除所有行</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `表名称`;      </span><br><span class="line"><span class="keyword">delete</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<h3 id="top：返回指定的记录"><a href="#top：返回指定的记录" class="headerlink" title="top：返回指定的记录"></a><code>top</code>：返回指定的记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># limit 子句可以被用于强制 <span class="keyword">select</span> 语句返回指定的记录数。</span><br><span class="line"># limit 可以接受一个或两个数字参数。参数必须是一个整数常量。</span><br><span class="line"># 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</span><br><span class="line"># 初始记录行的偏移量是 <span class="number">0</span>(而不是 <span class="number">1</span>)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # <span class="keyword">OFFSET</span> #。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称` LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回最上面的 <span class="number">2</span> 条记录</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回 从 <span class="number">2</span> 条开始之后的 <span class="number">2</span> 条记录</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` limit <span class="number">1</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<h3 id="Alias：别名"><a href="#Alias：别名" class="headerlink" title="Alias：别名"></a><code>Alias</code>：别名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">as</span> `列的别名` <span class="keyword">from</span> `表名称` <span class="keyword">as</span> `表的别名`;</span><br><span class="line"><span class="keyword">select</span> `列名称` `列的别名` <span class="keyword">from</span> `表名称` `表的别名`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `company` <span class="keyword">as</span> `com`, `orderNmuber` `number`</span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">as</span> `<span class="keyword">or</span>`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">com</th>
<th align="center">number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
</tbody></table>
<h3 id="join：连接"><a href="#join：连接" class="headerlink" title="join：连接"></a><code>join</code>：连接</h3><p><code>JOIN</code> 按照功能可分为如下三类：</p>
<blockquote>
<p><code>INNER JOIN</code>（内连接，或等值连接）：获取两个表中字段匹配关系的记录；<br><code>LEFT JOIN</code>（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；<br><code>RIGHT JOIN</code>（右连接）：与 <code>LEFT JOIN</code> 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/sql-join.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `persons`.lastName, `persons`.address, `persons`.id_p</span><br><span class="line"><span class="keyword">from</span> persons</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> `orders`</span><br><span class="line">                    <span class="keyword">on</span> persons.id_p <span class="operator">=</span> orders.id_p</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id_p <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">lastName</th>
<th align="center">address</th>
<th align="center">id_p</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Carter</td>
<td align="center">Changan Street</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Carter</td>
<td align="center">Changan Street</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Adams</td>
<td align="center">Oxford Street</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Adams</td>
<td align="center">Oxford Street</td>
<td align="center">1</td>
</tr>
</tbody></table>
<h3 id="union：合并"><a href="#union：合并" class="headerlink" title="union：合并"></a><code>union</code>：合并</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 会把重复的列删除，只留一个</span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 允许重复的列</span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e_id,e_name <span class="keyword">from</span> employees_china</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> e_id,e_name <span class="keyword">from</span> employees_USA;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Zhang, Hua</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Wang, Wei</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Yang, Ming</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">Adams, John</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Bush, George</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Gates, Bill</td>
</tr>
</tbody></table>
<h3 id="select-into：从一个表复制数据，然后把数据插入到另一个新表中"><a href="#select-into：从一个表复制数据，然后把数据插入到另一个新表中" class="headerlink" title="select into：从一个表复制数据，然后把数据插入到另一个新表中"></a><code>select into</code>：从一个表复制数据，然后把数据插入到另一个新表中</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MySql 不支持 select...into 语句，但支持<span class="keyword">insert</span> <span class="keyword">into</span>...<span class="keyword">select</span></span><br><span class="line"># 可以使用以下语句进行表格复制：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `新表名称`</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `旧表名称`;</span><br></pre></td></tr></table></figure>

<h3 id="insert-into-select：插入"><a href="#insert-into-select：插入" class="headerlink" title="insert into select：插入"></a><code>insert into select</code>：插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 向 table1 中拆入一些 table2 的数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `table1` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `table2`;</span><br></pre></td></tr></table></figure>

<h3 id="create-datbase：创建数据库"><a href="#create-datbase：创建数据库" class="headerlink" title="create datbase：创建数据库"></a><code>create datbase</code>：创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database `库名称`;</span><br></pre></td></tr></table></figure>

<h3 id="create-table：创建表"><a href="#create-table：创建表" class="headerlink" title="create table：创建表"></a><code>create table</code>：创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名称`</span><br><span class="line">(</span><br><span class="line">     `列名称<span class="number">1</span>` 数据类型,</span><br><span class="line">     `列名称<span class="number">2</span>` 数据类型,</span><br><span class="line">     `列名称<span class="number">3</span>` 数据类型,</span><br><span class="line">     ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>数据类型：</p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">integer(size) <br/> int(size)  <br/>smallint(size)<br/>  tinyint(size)</td>
<td align="center">仅容纳整数。在括号内规定数字的最大位数。</td>
</tr>
<tr>
<td align="center">decimal(size,d)<br/>    numeric(size,d)</td>
<td align="center">容纳带有小数的数字。  “size”  规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td align="center">char(size)</td>
<td align="center">容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。  在括号中规定字符串的长度。</td>
</tr>
<tr>
<td align="center">varchar(size)</td>
<td align="center">容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。  在括号中规定字符串的最大长度。</td>
</tr>
<tr>
<td align="center">date(yyyymmdd)</td>
<td align="center">容纳日期。</td>
</tr>
</tbody></table>
<h3 id="constraints：约束"><a href="#constraints：约束" class="headerlink" title="constraints：约束"></a><code>constraints</code>：约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">not</span> <span class="keyword">null</span> : 指示某列不能存储 <span class="keyword">null</span> 值。</span><br><span class="line"># <span class="keyword">unique</span> : 保证某列的每行必须有唯一的值。</span><br><span class="line"># <span class="keyword">primary</span> key : <span class="keyword">not</span> <span class="keyword">null</span> 和 <span class="keyword">unique</span> 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</span><br><span class="line"># <span class="keyword">foreign</span> key : 保证一个表中的数据匹配另一个表中的值的参照完整性。</span><br><span class="line"># <span class="keyword">check</span> : 保证列中的值符合指定的条件。</span><br><span class="line"># <span class="keyword">default</span> : 规定没有给列赋值时的默认值。</span><br></pre></td></tr></table></figure>

<h4 id="not-null：不为空值"><a href="#not-null：不为空值" class="headerlink" title="not null：不为空值"></a><code>not null</code>：不为空值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加 <span class="keyword">not</span> <span class="keyword">null</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` modify `age` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"># 删除 <span class="keyword">not</span> <span class="keyword">null</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` modify `age` <span class="type">int</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="unique：唯一标识数据库表中的每条记录"><a href="#unique：唯一标识数据库表中的每条记录" class="headerlink" title="unique：唯一标识数据库表中的每条记录"></a><code>unique</code>：唯一标识数据库表中的每条记录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">primary</span> key 拥有自动定义 <span class="keyword">unique</span> 约束</span><br><span class="line"># 添加 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">unique</span>(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加多个 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">constraint</span> <span class="keyword">unique</span>(`id`,`age`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">add</span> <span class="keyword">unique</span> (`age`);</span><br><span class="line"></span><br><span class="line"># 撤销 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">drop</span> index (`age`);</span><br></pre></td></tr></table></figure>

<h4 id="primary-key：主键"><a href="#primary-key：主键" class="headerlink" title="primary key：主键"></a><code>primary key</code>：主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `age` <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 撤销主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"># 添加主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">add</span> <span class="keyword">primary</span> key (`id`);</span><br></pre></td></tr></table></figure>

<h4 id="foreign-key：外键"><a href="#foreign-key：外键" class="headerlink" title="foreign key：外键"></a><code>foreign key</code>：外键</h4> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `orders`(</span><br><span class="line">	`id_o` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `orderNo` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `id_p` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`id_o`),</span><br><span class="line">    <span class="keyword">foreign</span> key (`id_p`) <span class="keyword">references</span> `persons`(`id_p`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 撤销外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `orders` <span class="keyword">drop</span> <span class="keyword">foreign</span> key</span><br><span class="line"></span><br><span class="line"># 添加外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `orders` <span class="keyword">add</span> <span class="keyword">foreign</span> key (`id_p`) <span class="keyword">references</span> `persons`(`id_p`);</span><br></pre></td></tr></table></figure>

<h4 id="check：限制列中的值的范围"><a href="#check：限制列中的值的范围" class="headerlink" title="check：限制列中的值的范围"></a><code>check</code>：限制列中的值的范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如果对单个列定义 <span class="keyword">check</span> 约束，那么该列只允许特定的值</span><br><span class="line"># 如果对一个表定义 <span class="keyword">check</span> 约束，那么此约束在特定的列中对值进行限制</span><br><span class="line"># mysql不同的版本，有的支持，有的不支持</span><br><span class="line"># 对单列进行约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    <span class="keyword">check</span> (`id` <span class="operator">&gt;</span> <span class="number">0</span>)   #规定 id 必须要大于 <span class="number">0</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 对多列进行约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    <span class="keyword">constraint</span> ch_aa <span class="keyword">check</span> ( id <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;wang&#x27;</span>)  #规定 id 必须要大于 <span class="number">0</span>，且 name 为 wang</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aa <span class="keyword">add</span> <span class="keyword">check</span> (id <span class="operator">&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"># 撤销约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aa <span class="keyword">drop</span> <span class="keyword">check</span> ch_aa;</span><br></pre></td></tr></table></figure>

<h4 id="default：默认值"><a href="#default：默认值" class="headerlink" title="default：默认值"></a><code>default</code>：默认值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 用于向列中插入默认值</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `aa` <span class="keyword">alter</span> `name` <span class="keyword">set</span> <span class="keyword">default</span> <span class="string">&#x27;yu&#x27;</span>; # 将 name 默认值改为 yu</span><br><span class="line"></span><br><span class="line"># 撤销默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `aa` <span class="keyword">alter</span> `name` <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL高级教程"><a href="#MySQL高级教程" class="headerlink" title="MySQL高级教程"></a>MySQL高级教程</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>说明：树的知识点来自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></p>
<h4 id="BST树-—-二叉搜索树"><a href="#BST树-—-二叉搜索树" class="headerlink" title="BST树 — 二叉搜索树"></a>BST树 — 二叉搜索树</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111144689465326549652342955.png"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li><p>根节点的值大于其左子树中任意一个节点的值</p>
</li>
<li><p>根结点的值小于其右节点中任意一节点的值</p>
</li>
<li><p>这一规则适用于二叉查找树中的每一个节点</p>
</li>
</ol>
</blockquote>
<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><blockquote>
<p>​	查询的时间复杂度比链表快，链表的查询时间复杂度是O(n)，二叉排序树平均是O(logn)。二叉排序树越平衡，越能模拟二分法，所以越能想二分法的查询的时间复杂度O(logn)。</p>
</blockquote>
<h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><blockquote>
<p>​	但是BST树有一个不足的地方，就是如果插入的结点的值的顺序，是越来越小或者越来越大的，那么BST就会退化为一条链表，那么其查询的时间复杂度就会降为O(n)。</p>
<p>如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111145211189fadsvasvadsz.png"></p>
</blockquote>
<h4 id="AVL树-—-平衡二叉树"><a href="#AVL树-—-平衡二叉树" class="headerlink" title="AVL树 — 平衡二叉树"></a>AVL树 — 平衡二叉树</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111yuntbrvcwverbytunrter145654356.png"></p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li><p>拥有BST树的特点：根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p>
</li>
<li><p>AVL树上任意结点的左、右子树的高度差最大为1。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>​	由于AVL树的第二个特点，使得，AVL树的形状肯定不会退化成一条链表的，而是“矮胖”型的树。所以能确保AVL的查找、添加、删除的时间复杂度都是O(logn)。</p>
</blockquote>
<h4 id="B树-—-平衡多路查找树"><a href="#B树-—-平衡多路查找树" class="headerlink" title="B树 — 平衡多路查找树"></a>B树 — 平衡多路查找树</h4><blockquote>
<p>​	B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。数据库索引技术里大量使用者B树和B+树的数据结构。一个结点存储多个值(索引)。</p>
</blockquote>
<blockquote>
<p>​	B树的阶数：M阶表示 一个B树的结最多有多少个查找路径(即这个结点有多少个子节点)。M&#x3D;M路，M&#x3D;2是二叉树，M&#x3D;3则是三叉树。</p>
</blockquote>
<h5 id="一棵M阶B树有以下特点"><a href="#一棵M阶B树有以下特点" class="headerlink" title="一棵M阶B树有以下特点"></a>一棵M阶B树有以下特点</h5><blockquote>
<ol>
<li><p>每个结点的值(索引) 都是按递增次序排列存放的，并遵循左小右大原则。</p>
</li>
<li><p>根结点 的 子节点 个数为 [2，M]。</p>
</li>
<li><p>除 根结点 以外 的 非叶子结点 的子节点个数 为[ Math.ceil(M&#x2F;2)，M]。 Math.ceil() 为向上取整。</p>
</li>
<li><p>每个 非叶子结点 的值(索引) 个数 &#x3D; 子节点个数 -1 。最小为 Math.ceil(M&#x2F;2)-1   最大为 M-1 个。</p>
</li>
<li><p>B树的所有叶子结点都位于同一层。</p>
</li>
</ol>
</blockquote>
<p>下图是一个 3阶B树：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101111747xrdcftvgbhjyvbuijnkmlnkml22874.png"></p>
<p>可以看到：</p>
<blockquote>
<ol>
<li><p>除 根结点 外，所有 非叶子结点 都至少有 M&#x2F;2 &#x3D; 1.5 取整 &#x3D; 2 个结点。</p>
</li>
<li><p>每个 结点中 的索引值 都是从小到大排序的。</p>
</li>
<li><p>所有叶子结点都在同一层中。</p>
</li>
</ol>
</blockquote>
<h5 id="B树的查找结点过程"><a href="#B树的查找结点过程" class="headerlink" title="B树的查找结点过程"></a>B树的查找结点过程</h5><p>从上述的 3阶B树 中，查找 结点5 的过程：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101111imyunthbgrvfcd74041912.png"></p>
<blockquote>
<p>（1）第一次读IO，把9的结点读到内存，再与目标数5比较，5是小于9的，因此往9的左边走。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011tybgrfvbrnthgdd1175002129.png"></p>
<blockquote>
<p>（2） 第二次读IO，还是把结点读到内存中，然后比较结点中的2和6与目标值5。发现5是大于2小于6的，因此往中间路径走。</p>
</blockquote>
<blockquote>
<p>（3）第三次读IO，还是把结点读到内存中，然后发现结点中有5，因此找到目标值。</p>
</blockquote>
<h6 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h6><blockquote>
<ol>
<li><p>在数据库查询中，以树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。（众所周知，读IO是一件费事的操作）当数据量大的时候，用AVL树存的话，就算AVL是平衡树，但是也扛不住数据量大，数据量大，AVL树的树高肯定很高，那么读取数据的IO次数也会多。那么有没有办法能压缩AVL树的树高呢？这时候B树就出来了。B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p>
</li>
<li><p>B树的每一个结点都包含key(索引值) 和 value(对应数据)，因此方位离根结点近的元素会更快速。（相对于B+树）</p>
</li>
</ol>
</blockquote>
<h5 id="B树的添加结点过程（和结点分裂过程）"><a href="#B树的添加结点过程（和结点分裂过程）" class="headerlink" title="B树的添加结点过程（和结点分裂过程）"></a>B树的添加结点过程（和结点分裂过程）</h5><p>下面以 5阶B树为例：</p>
<p>（a）在空树中插入39，此时根结点只有一个索引值。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011120211uyjtygbvfsvbntbgvfd2856.png"></p>
<p>（b）继续插入22，97和41，根结点此时有4个索引值。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011yuntbrtvecevgrbhtnb1202239618.png"></p>
<p>（c）继续插入53。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111%E5%85%8Biuynegtrvefc202358865.png"></p>
<p>此时已经超过了最大允许的索引个数4，即4个。所以以其中心（41）分裂。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101uiyntbgrfvd11202537763.png"></p>
<p>（d）然后在上图的基础上，再依次插入13，21，40，那么41所在结点的左子结点里的值就为13、21、22、39、40，一共五个，所以会以22为中心进行分裂。分裂的中心22会进位到上一层的结点中。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112042246(%E2%8A%99%EF%B9%8F%E2%8A%99)%E7%8E%87scefrsdc632.png"></p>
<p>（e）再在上图的基础上，插入30，27，33，那么其中有一个结点内的值为27、30、33、39、40，那么就会以33为中心引起一次分裂。然后再插入36，35，34，那么就又会有一个结点内的值为34、35、36、39、40，那么就会以36为中心分裂。然后再插入24、29。<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112050465164656518240.png"></p>
<p>（f）此时拥有24、27、29、30的结点只要再插入一个索引值，就又会发生分裂，插入26。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111785132649861205152145.png"></p>
<p>（g）27进位到父节点后，父节点里的索引值也超过了4个，因此也要分裂。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210drxcfgvhbjnkl111205424884.png"></p>
<p>根结点分裂后的B树：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112486512305548682.png"></p>
<h5 id="B树的删除结点过程"><a href="#B树的删除结点过程" class="headerlink" title="B树的删除结点过程"></a>B树的删除结点过程</h5><p>（a）原始状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011148652205748179.png"></p>
<p>（b）在上图的树中，删除21，由于删除21后的结点的索引值个数仍然大于2（Math.ceil( 5&#x2F;2 ) -1 &#x3D;2），因此删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111465154986155485210437440.png"></p>
<p>（c）接着删除27，从上图可知，由于27是非叶子结点，所以要删除27的话，需要用27的后继替代它。从上图可以看出，27的后继是28，因此我们用28来替代27，再删除原来的28，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210486515648651485111210759920.png"></p>
<p>删除后发现，当前结点(当前结点如上图所示)的索引值个数小于2个，而它的兄弟结点有3个索引值（当前结点还有一个右兄弟，选择右兄弟的话，会出现合并结点的情况，不论选哪一个都可以，只是最后的B树形态会不一样而已），那么就向左兄弟借一个索引值，注意这里的借并非直接从左兄弟结点处拿一个索引值过来，如果是这样的话，就破坏了B树父节点左子树比根结点小，右子树比根结点大的特性了。借是 把当前结点的父节点的28下移，然后把左兄弟结点的26上移到父节点，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112124865564865150254.png"></p>
<p>（d）在上述情况接着删除32</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011124652354862312347403.png"></p>
<p>在删除32后，当前结点剩下31，即索引值数目小于2。这时候，它的兄弟结点，也仅仅有2个索引值，所以不能向兄弟结点借。</p>
<p>那只能够让父结点下移一个值(30)，并和兄弟结合合并成一个新的结点，如下图：当前结点的索引值个数不小于2 （Math.ceil( 5&#x2F;2 ) -1 &#x3D;2），满足条件，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112%E5%8F%91v%E6%90%9E%E7%8E%AF%E4%BF%9D%E8%8A%82%E8%83%BD%E5%96%80%E9%BA%A6%E9%9A%86%EF%BC%8C%EF%BC%9B12640720.png"></p>
<p>（e）接着删除 40：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/xrectbujnmonhbuvctfvygu.png"></p>
<p>当前结点由于索引值小于2，因此需要像父结点借，父结点下移36到当前结点，然后和兄弟结点合并(选择左兄弟或右兄弟都可以，这里我选择了左兄弟)，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210114651321213700457.png"></p>
<p>但这时候发现，新的当前结点的索引值个数又小于2了，那么只能向其父结点借了，所以其父结点下移33，然后当前结点和其兄弟结点合并，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111213485249865825743.png"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote>
<p>关键字个数和孩子结点个数相同。即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。</p>
</blockquote>
<p>一颗阶数为4的B+树。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232854940-1019144331.png"></p>
<h5 id="一棵M阶B-树有以下特点"><a href="#一棵M阶B-树有以下特点" class="headerlink" title="一棵M阶B+树有以下特点"></a>一棵M阶B+树有以下特点</h5><blockquote>
<ol>
<li><p>B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</p>
</li>
<li><p>B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</p>
</li>
<li><p>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</p>
</li>
<li><p>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</p>
</li>
<li><p>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
</ol>
</blockquote>
<h5 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h5><blockquote>
<ol>
<li><p>若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p>
</li>
<li><p>针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m&#x2F;2个记录，右结点包含剩下的记录，将第m&#x2F;2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p>
</li>
<li><p>针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)&#x2F;2个key，右结点包含m-(m-1)&#x2F;2个key，将第m&#x2F;2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p>
</li>
</ol>
</blockquote>
<p>下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。</p>
<p>（a）空树中插入5</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018040sss6232858129-694616618.png"></p>
<p>（b）依次插入8，10，15</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018040623290139ss1-1401289774.png"></p>
<p>（c）插入16</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/xtcfybipoiouvyctfgbhjnlk.png"></p>
<p>​	插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232909712-1807724284.png"></p>
<p>当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。</p>
<p>（d）插入17</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232913379-576202883.png"></p>
<p>（e）插入18，插入后如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232917817-12405736a30.png"></p>
<p>​	当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018s0406232921679-618565224.png"></p>
<p>当前结点的关键字个数满足条件，插入结束。</p>
<p>（f）插入若干数据后</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232926305-8126505003.png"></p>
<p>（g）在上图中插入7，结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232935105-10019482143.png"></p>
<p>​	当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232940557-12047242223.png"></p>
<p>当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-201804306232945267-543224744.png"></p>
<p>当前结点的关键字个数满足条件，插入结束。</p>
<h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5><blockquote>
<p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p>
<ol>
<li><p>删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)&#x2F;2 – 1，删除操作结束,否则执行第2步。</p>
</li>
<li><p>若兄弟结点key有富余（大于Math.ceil(m-1)&#x2F;2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p>
</li>
<li><p>若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p>
</li>
<li><p>若索引结点的key的个数大于等于Math.ceil(m-1)&#x2F;2 – 1，则删除操作结束。否则执行第5步</p>
</li>
<li><p>若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p>
</li>
<li><p>当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p>
</li>
</ol>
<p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p>
</blockquote>
<p>下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。</p>
<p>（a）初始状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232951603-28451095664521.png"></p>
<p>（b）删除22,删除后结果如下图</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/83448452168-20180406232956857-909502342.png"></p>
<p>删除后叶子结点中key的个数大于等于2，删除结束</p>
<p>（c）删除15，删除后的结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/83446852sss8-20180406233002074-155906598.png"></p>
<p>​	删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834gdrvs468-20180406233008129-433585803.png"></p>
<p>（d）删除7，删除后的结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834imyunhgfbd468-20180406233017339-92051658.png"></p>
<p>​	当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/8344yimutnybtdf68-20180406233022828-172757536.png"></p>
<p>此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834imyuntytrb468-20180406233027773-1578264573.png"></p>
<h4 id="b树与b-树区别"><a href="#b树与b-树区别" class="headerlink" title="b树与b+树区别"></a>b树与b+树区别</h4><blockquote>
<ol>
<li>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li>
<li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历；</li>
<li>b+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低</li>
</ol>
</blockquote>
<h3 id="MyISAM存储引擎与InnoDB存储引擎对比"><a href="#MyISAM存储引擎与InnoDB存储引擎对比" class="headerlink" title="MyISAM存储引擎与InnoDB存储引擎对比"></a>MyISAM存储引擎与InnoDB存储引擎对比</h3><blockquote>
<ol>
<li><p><strong>事务支持：</strong>innodb支持事务，事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；而myisam强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p>
</li>
<li><p><strong>外键支持：</strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败。</p>
</li>
<li><p><strong>聚集索引</strong>：InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p>MyISAM是非<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020">聚集索引</a>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
<p>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p>
<p>InnoDB的结构：</p>
</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/urinofmkonubvjndklcsmnovdk.jpg"></p>
<p>MyISAM的结构：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/src=http___blog.zhuzi.net.cn_zb_users_upload_2020_02_20200229004600_11595.png&refer=http___blog.zhuzi.net.png"></p>
<ol start="4">
<li><p><strong>count(*)：</strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件，但是在加了wehre条件后，myisam和innodb处理的方式都一样。）；</p>
<p>那么为什么InnoDB没有了这个变量呢？</p>
<p> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。</p>
</li>
<li><p><strong>全文索引：</strong>MyISAM支持 FULLTEXT类型的全文索引；InnoDB的不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好，而且自从mysql5.6版本开始innodb就已经开始支持全文索引，mysql8.0则完全抛弃MyISAM存储引擎了，所以淡化MyISAM吧，已经逐渐成为历史产品，innoDB引擎对FULLTEXT索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持FULLTEXT索引。</p>
</li>
<li><p><strong>表锁差异：</strong>myisam只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁；innodb支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。<strong>但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</strong></p>
</li>
<li><p><strong>主键差异：</strong>MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址；而InnoDB如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
</li>
<li><p><strong>存储结构：</strong>每个MyISAM表在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。而innodb是由.frm文件、表空间（分为独立表空间或者共享表空间，如果在配置文件中配置了innodb_file_per_table&#x3D;true或者不配置就会使用独立表空间）和日志文件（redo log）组成。</p>
</li>
<li><p><strong>都是B+树索引：</strong>Innodb是索引组织表，myisam是堆表</p>
</li>
</ol>
</blockquote>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><h4 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h4><h5 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h5><blockquote>
<p>​	InnoDB 将数据划分为若干个页，InnoDB中页的大小默认为 16KB 。</p>
</blockquote>
<blockquote>
<p>​	以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库 I&#x2F;O 操作的最小单位是页。一个页中可以存储多个行记录。</p>
</blockquote>
<h5 id="页结构概述"><a href="#页结构概述" class="headerlink" title="页结构概述"></a>页结构概述</h5><blockquote>
<p>​	页a、页b、页c … 页n <strong>这些页可以不在物理结构上相连，只要通过双向链表相关联即可</strong>。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
</blockquote>
<h5 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h5><blockquote>
<p>​	另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/rtfyuijnibuvyctxrectuvybhjnmklmji.jpg"></p>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><blockquote>
<p>​	数据页的16KB 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum+supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>
</blockquote>
<p>页结构的示意图如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrectvbuhjnnhbgvfdxrszexrdfvbhnjk.jpg"></p>
<h5 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/dxrcfvgbhjnkmjnbufct.jpg"></h5><h5 id="File-Tailer"><a href="#File-Tailer" class="headerlink" title="File Tailer"></a>File Tailer</h5><blockquote>
<ul>
<li><p>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</p>
</li>
<li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p>
</li>
</ul>
</blockquote>
<h5 id="Free-Space"><a href="#Free-Space" class="headerlink" title="Free Space"></a>Free Space</h5><blockquote>
<p>​	我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjnhgbfvdcvbrytuymutny.png"></p>
<h5 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h5><blockquote>
<p>User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。</p>
</blockquote>
<h6 id="compact行格式"><a href="#compact行格式" class="headerlink" title="compact行格式"></a>compact行格式</h6><blockquote>
<p>​	在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-22_13-41-43.png"></p>
<p><strong>记录头信息：</strong></p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>这个表中记录的行格式示意图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctrybuinonyutycfgbhj.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/tybuhnjihbugvyfgbhjnk.png"></p>
<p>插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>), </span><br><span class="line">    (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>), </span><br><span class="line">    (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>), </span><br><span class="line">    (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>图示如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/trcyuboiomoiuiyty.png"></p>
<h5 id="Infimum-supremum"><a href="#Infimum-supremum" class="headerlink" title="Infimum + supremum"></a>Infimum + supremum</h5><blockquote>
<p>记录可以比较大小吗？<br>    是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p>
</blockquote>
<blockquote>
<p>​	InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nhtgbdsdvbdfx.png"></p>
</blockquote>
<blockquote>
<p>​	这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/unthgbdfvdsbtnmhnb.png"></p>
</blockquote>
<h5 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h5><blockquote>
<p>为什么需要页目录？<br>    在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</p>
</blockquote>
<blockquote>
<p>使用页目录，二分法查找</p>
<ol>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br> 最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br> 其余的组记录数量在 4-8 条之间。<br> 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
</blockquote>
<p>举例1：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/yujegwedxs.png"></p>
<p>举例2：</p>
<blockquote>
<p>​	现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctfuvygibjnmk,l;..png"></p>
</blockquote>
<blockquote>
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li>
<li>注意最小和最大记录的头信息中的n_owned属性<ul>
<li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li>
<li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li>
</ul>
</li>
</ul>
<p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/tfcvgbhjnmkjnibuvyct.png"></p>
<p>再换个角度看一下：（单纯从逻辑上看一下这些记录和页目录的关系）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fghjbklmjnibyuty.png"></p>
</blockquote>
<h5 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h5><blockquote>
<p>​	为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/utyetwercwwrvt.png"></p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><blockquote>
<p>​	B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I&#x2F;O 。再一次强调，磁盘的速度和内存的速度差了好几个数量级， 随机I&#x2F;O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I&#x2F;O 。</p>
<p>引入区的概念，一个区就是在物理位置上连续的64个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D; 1MB 。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O， 功大于过！</p>
</blockquote>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><blockquote>
<p>​	对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>​	除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。<br>​	在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。<br>​	段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
</blockquote>
<h4 id="碎片区"><a href="#碎片区" class="headerlink" title="碎片区"></a>碎片区</h4><blockquote>
<p>​	默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64 * 16Kb &#x3D; 1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。<br>​	为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p>
</blockquote>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><blockquote>
<p>​	表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。<br>​	表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间（System tablespace）、独立表空间（File-per-table tablespace）、撤销表空间（Undo Tablespace）和临时表空间（Temporary Tablespace）等。</p>
</blockquote>
<h5 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h5><blockquote>
<p>​	独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即：单表）可以在不同的数据库之间进行迁移。<br>​	空间可以回收（DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收）。如果对于统计分析或是日志表，删除大量数据后可以通过： alter table TableName engine&#x3D;innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
</blockquote>
<h6 id="真实表空间对应的文件大小"><a href="#真实表空间对应的文件大小" class="headerlink" title="真实表空间对应的文件大小"></a>真实表空间对应的文件大小</h6><blockquote>
<p>​	我们到数据目录里看，会发现一个新建的表对应的.ibd 文件只占用了96K ，才6个页面大小（MySQL5.7中），这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些.ibd文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
</blockquote>
<h5 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h5><blockquote>
<p>​	系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
</blockquote>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><blockquote>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</li>
</ol>
</blockquote>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>索引（Index）：是帮助MySQL高效获取数据的数据结构。</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 </p>
<p>（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，<br>可以提高查询速度。 </p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 </p>
<p>（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p>
</blockquote>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><blockquote>
<p>从功能逻辑上说，索引主要有 4 种，分别是<strong>普通索引</strong>、<strong>唯一索引</strong>、<strong>主键索引</strong>、<strong>全文索引</strong>。</p>
</blockquote>
<blockquote>
<p>按照物理实现方式，索引可以分为 2 种：<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。</p>
</blockquote>
<blockquote>
<p>按照作用字段个数进行划分，分成<strong>单列索引</strong>和<strong>联合索引</strong>。</p>
</blockquote>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h5><p><font color = 'red'>说明：在创建表的被primary key、unique、foreign key 所修饰的属性，会自动创建索引。</font></p>
<h6 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h6><p>在book表中的year_publication字段上建立普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">    book_id   <span class="type">INT</span>,</span><br><span class="line">    book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    authors   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    info      <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    comment   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">    INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line">    id   <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX uk_idx_id (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id           <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT,</span><br><span class="line">    student_no   <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h6 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(</span><br><span class="line">    id   <span class="type">INT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX single_idx_name (name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test3(</span><br><span class="line">    id   <span class="type">INT</span>(<span class="number">11</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age  <span class="type">INT</span>(<span class="number">11</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    INDEX multi_idx (id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `papers`(</span><br><span class="line">    `id`      <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `title`   <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` text,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    FULLTEXT KEY `title` (`title`, `content`)</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<p>不同于like方式的的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>

<h6 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h6><p>空间索引创建中，要求空间类型的字段必须为非空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test5(</span><br><span class="line">    geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    SPATIAL INDEX spa_idx_geo (geo)</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM;</span><br></pre></td></tr></table></figure>

<h5 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h5><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<h6 id="使用ALTER-TABLE语句创建索引"><a href="#使用ALTER-TABLE语句创建索引" class="headerlink" title="使用ALTER TABLE语句创建索引"></a>使用ALTER TABLE语句创建索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<h6 id="使用CREATE-INDEX创建索引"><a href="#使用CREATE-INDEX创建索引" class="headerlink" title="使用CREATE INDEX创建索引"></a>使用CREATE INDEX创建索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><h6 id="使用ALTER-TABLE删除索引"><a href="#使用ALTER-TABLE删除索引" class="headerlink" title="使用ALTER TABLE删除索引"></a>使用ALTER TABLE删除索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h6 id="使用DROP-INDEX语句删除索引"><a href="#使用DROP-INDEX语句删除索引" class="headerlink" title="使用DROP INDEX语句删除索引"></a>使用DROP INDEX语句删除索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a>MySQL8.0索引新特性</h4><h5 id="支持降序索引-默认索引排序是升序的"><a href="#支持降序索引-默认索引排序是升序的" class="headerlink" title="支持降序索引(默认索引排序是升序的)"></a>支持降序索引(默认索引排序是升序的)</h5><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));</span><br></pre></td></tr></table></figure>

<h5 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h5><blockquote>
<p>​	在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>​	从MySQL 8.x开始支持隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
</blockquote>
<blockquote>
<p><font color='red'>注意：</font>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<h6 id="创建表时直接创建"><a href="#创建表时直接创建" class="headerlink" title="创建表时直接创建"></a>创建表时直接创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">    propname1 type1[CONSTRAINT1],</span><br><span class="line">    propname2 type2[CONSTRAINT2],</span><br><span class="line">    ……</span><br><span class="line">    propnamen typen,</span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="在已经存在的表上创建"><a href="#在已经存在的表上创建" class="headerlink" title="在已经存在的表上创建"></a>在已经存在的表上创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<h6 id="通过ALTER-TABLE语句创建"><a href="#通过ALTER-TABLE语句创建" class="headerlink" title="通过ALTER TABLE语句创建"></a>通过ALTER TABLE语句创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<h6 id="切换索引可见状态"><a href="#切换索引可见状态" class="headerlink" title="切换索引可见状态"></a>切换索引可见状态</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><h5 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h5><h6 id="字段的数值有唯一性的限制"><a href="#字段的数值有唯一性的限制" class="headerlink" title="字段的数值有唯一性的限制"></a>字段的数值有唯一性的限制</h6><blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
</blockquote>
<h6 id="频繁作为-WHERE-查询条件的字段"><a href="#频繁作为-WHERE-查询条件的字段" class="headerlink" title="频繁作为 WHERE 查询条件的字段"></a>频繁作为 WHERE 查询条件的字段</h6><blockquote>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
</blockquote>
<h6 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h6><blockquote>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p>
</blockquote>
<h6 id="UPDATE、DELETE-的-WHERE-条件列"><a href="#UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="UPDATE、DELETE 的 WHERE 条件列"></a>UPDATE、DELETE 的 WHERE 条件列</h6><blockquote>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
</blockquote>
<h6 id="DISTINCT-字段需要创建索引"><a href="#DISTINCT-字段需要创建索引" class="headerlink" title="DISTINCT 字段需要创建索引"></a>DISTINCT 字段需要创建索引</h6><blockquote>
<p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
</blockquote>
<h6 id="多表-JOIN-连接操作时，创建索引注意事项"><a href="#多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="多表 JOIN 连接操作时，创建索引注意事项"></a>多表 JOIN 连接操作时，创建索引注意事项</h6><blockquote>
<ul>
<li>首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li>
<li>其次， 对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li>
<li>最后， 对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型，不然因为使用函数对类型转换时，会导致该索引失效。</li>
</ul>
</blockquote>
<h6 id="使用字符串前缀创建索引"><a href="#使用字符串前缀创建索引" class="headerlink" title="使用字符串前缀创建索引"></a>使用字符串前缀创建索引</h6><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？<br>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure>

<p>通过不同长度去计算，与全表的选择性对比：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p>
</blockquote>
<h6 id="使用最频繁的列放到联合索引的左侧"><a href="#使用最频繁的列放到联合索引的左侧" class="headerlink" title="使用最频繁的列放到联合索引的左侧"></a>使用最频繁的列放到联合索引的左侧</h6><h6 id="在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>在多个字段都要创建索引的情况下，联合索引优于单值索引</h6><h5 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h5><h6 id="在where中使用不到的字段，不要设置索引"><a href="#在where中使用不到的字段，不要设置索引" class="headerlink" title="在where中使用不到的字段，不要设置索引"></a>在where中使用不到的字段，不要设置索引</h6><h6 id="数据量小的表最好不要使用索引"><a href="#数据量小的表最好不要使用索引" class="headerlink" title="数据量小的表最好不要使用索引"></a>数据量小的表最好不要使用索引</h6><h6 id="有大量重复数据的列上不要建立索引"><a href="#有大量重复数据的列上不要建立索引" class="headerlink" title="有大量重复数据的列上不要建立索引"></a>有大量重复数据的列上不要建立索引</h6><blockquote>
<p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
</blockquote>
<blockquote>
<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
</blockquote>
<h6 id="避免对经常更新的表创建过多的索引"><a href="#避免对经常更新的表创建过多的索引" class="headerlink" title="避免对经常更新的表创建过多的索引"></a>避免对经常更新的表创建过多的索引</h6><h4 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h4><h5 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h5><p>在MySQL中，可以使用SHOW STATUS 语句查询一些MySQL数据库服务器的性能参数、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<blockquote>
<ul>
<li>connections：连接MySQL服务器的次数</li>
<li>uptime：MySQL服务器的上线时间</li>
<li>slow_queries：慢查询的次数</li>
<li>innodb_rows_read：Select查询返回的行数</li>
<li>innodb_rows_inserted：执行INSERT操作插入的行数</li>
<li>innodb_rows_updated：执行UPDATE操作更新的行数</li>
<li>innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>com_select：查询操作的次数</li>
<li>com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次</li>
<li>com_update：更新操作的次数</li>
<li>com_delete：删除操作的次数</li>
</ul>
</blockquote>
<h5 id="统计SQL的查询成本：last-query-cost"><a href="#统计SQL的查询成本：last-query-cost" class="headerlink" title="统计SQL的查询成本：last_query_cost"></a>统计SQL的查询成本：last_query_cost</h5><p>student_info 表为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info`(</span><br><span class="line">    `id`          <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `student_id`  <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`        <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `course_id`   <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `class_id`    <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` DATETIME    <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（1 条记录，运行时间为 0.042s ）</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（100 条记录，运行时间为 0.046s ）：</p>
<p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span>   <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取</strong>的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
</blockquote>
<h4 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h4><blockquote>
<p><font color='red'>默认情况下，不开启慢查询日志</font></p>
</blockquote>
<h5 id="开启slow-query-log"><a href="#开启slow-query-log" class="headerlink" title="开启slow_query_log"></a>开启slow_query_log</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/trvhjmkojigbytdcrcgbhjkmhubtfyu.jpg"></p>
<blockquote>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu02-slow.log 文件中。</p>
</blockquote>
<h5 id="修改long-query-time阈值"><a href="#修改long-query-time阈值" class="headerlink" title="修改long_query_time阈值"></a>修改long_query_time阈值</h5><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fcygvhbjlnbhuvyctxrdtgvbhjkml.jpg"></p>
<p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="查看慢查询数目"><a href="#查看慢查询数目" class="headerlink" title="查看慢查询数目"></a>查看慢查询数目</h5><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h5><h4 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-24-28.png"></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1(</span><br><span class="line">    id           <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">INT</span>,</span><br><span class="line">    key3         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-28-28.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2(</span><br><span class="line">    id           <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">INT</span>,</span><br><span class="line">    key3         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-30-43.png"></p>
<h5 id="explain各列作用"><a href="#explain各列作用" class="headerlink" title="explain各列作用"></a>explain各列作用</h5><h6 id="table"><a href="#table" class="headerlink" title="table"></a>table</h6><blockquote>
<p>​	不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p>
</blockquote>
<h6 id="id"><a href="#id" class="headerlink" title="id"></a>id</h6><blockquote>
<p>​	我们写的查询语句一般都以SELECT 关键字开头，比较简单的查询语句里只有一个SELECT 关键字，比如下边这个查询语句：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的连接查询中也只有一个SELECT 关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mutyhtbgvfcdfvb.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/gfbsdsvrabgddvs.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nhtgbdsdvbrtdfdsv.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field</span><br><span class="line"><span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fcghvjblkbugycfgvhbj.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/dtcfygvubhjnklm;,.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/vyighbjnklm.jpg"></p>
<p><strong>小结：</strong></p>
<blockquote>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
</blockquote>
<h6 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h6><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>SIMPLE代表单表查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrdtcfuvgbhjnkml.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrdtcfygvuijnmk;,l.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmjnhbugvfctdr.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmljnbhuvycrt.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjnbhgvyfctd.jpg"></p>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><blockquote>
<p>​	结果值从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 其中比较重要的几个提取出来（见上图中的蓝<br>色）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴<br>开发手册要求）</p>
</blockquote>
<p><strong>const：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mklnjuibyuvtf.jpg"></p>
<p><strong>eq_ref：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmjnbhugvycrt.jpg"></p>
<blockquote>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref ，表明在访问s1表的时候可以通过主键的等值匹配来进行访问。</p>
</blockquote>
<p><strong>ref：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkjhnbugvyr.jpg"></p>
<p><strong>index_merge：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jkbhuvtyc.jpg"></p>
<p><strong>ALL：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnihbugvyf.jpg"></p>
<h6 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmojnihbugvyf.jpg"></p>
<h6 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjnibhuvyct.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nibuvyfct.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbgvfctd.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbugvyftcdrx.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbugvyfctd.jpg"></p>
<p>练习：<br>key_len的长度计算公式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h6 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/hbgvfctdxr.jpg"></p>
<h4 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class`</span><br><span class="line">(</span><br><span class="line">    `id`        <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address`   <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `monitor`   <span class="type">INT</span>     <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`(</span><br><span class="line">    `id`      <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `stuno`   <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`    <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age`     <span class="type">INT</span>(<span class="number">3</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `classId` <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">#<span class="keyword">CONSTRAINT</span> `fk_class_id` <span class="keyword">FOREIGN</span> KEY (`classId`) <span class="keyword">REFERENCES</span> `t_class` (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<h5 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h5><h6 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h6><h6 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h6><h6 id="计算、函数、类型转换-自动或手动-导致索引失效"><a href="#计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="计算、函数、类型转换(自动或手动)导致索引失效"></a>计算、函数、类型转换(自动或手动)导致索引失效</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="类型转换导致索引失效"><a href="#类型转换导致索引失效" class="headerlink" title="类型转换导致索引失效"></a>类型转换导致索引失效</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）"><a href="#范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）" class="headerlink" title="范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）"></a>范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mojnihbugvyfctdr.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_age_name_classid <span class="keyword">on</span> student(age,name,classid);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjhjbgvyfctdrx.jpg"></p>
<h6 id="不等于-或者-索引失效-在覆盖索引可能会失效）"><a href="#不等于-或者-索引失效-在覆盖索引可能会失效）" class="headerlink" title="不等于(!&#x3D; 或者&lt;&gt;)索引失效(在覆盖索引可能会失效）"></a>不等于(!&#x3D; 或者&lt;&gt;)索引失效(在覆盖索引可能会失效）</h6><h6 id="is-null可以使用索引，is-not-null无法使用索引"><a href="#is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="is null可以使用索引，is not null无法使用索引"></a>is null可以使用索引，is not null无法使用索引</h6><h6 id="like以通配符-开头索引失效"><a href="#like以通配符-开头索引失效" class="headerlink" title="like以通配符%开头索引失效"></a>like以通配符%开头索引失效</h6><h6 id="OR-前后存在非索引的列，索引失效"><a href="#OR-前后存在非索引的列，索引失效" class="headerlink" title="OR 前后存在非索引的列，索引失效"></a>OR 前后存在非索引的列，索引失效</h6><blockquote>
<p> <font color='red'>建议把查询记录少的放在or的前面</font></p>
<p>用<strong>in来替换or</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">低效: </span><br><span class="line"><span class="keyword">select</span>…. <span class="keyword">from</span> location <span class="keyword">where</span> loc_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">30</span> </span><br><span class="line">高效 </span><br><span class="line"><span class="keyword">select</span>… <span class="keyword">from</span> location <span class="keyword">where</span> loc_in  <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>OR，就是从a1匹配，匹配失败，去匹配a2，直到匹配成功或者一个都匹配不上，时间复杂度O(n)</li>
<li>IN，先将a1, a2, …, an变成二叉树，通过二叉树查找，时间复杂度O(log n)</li>
</ul>
</blockquote>
<h6 id="数据库和表的字符集统一使用utf8mb4"><a href="#数据库和表的字符集统一使用utf8mb4" class="headerlink" title="数据库和表的字符集统一使用utf8mb4"></a>数据库和表的字符集统一使用utf8mb4</h6><h5 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h5><blockquote>
<ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将小结果集的表选为驱动表。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
</blockquote>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><blockquote>
<p>​	执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
</blockquote>
<blockquote>
<p>​	在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
</blockquote>
<blockquote>
<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote>
<p>​	非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> cover(</span><br><span class="line">    id      <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    age     <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">    name    <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    idcard  <span class="type">varchar</span>(<span class="number">18</span>),</span><br><span class="line">    address <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    gender  <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index `idx_age_name_idcard` <span class="keyword">on</span> cover (age, name, idcard);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 索引 有效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">4</span> ;</span><br><span class="line"># 索引 有效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 失效</span><br><span class="line">explain <span class="keyword">select</span> gender <span class="keyword">from</span> cover <span class="keyword">where</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 有效(这是属于优化器优化的结果，是要回表的)</span><br><span class="line">explain <span class="keyword">select</span> sql_no_cache gender <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5 id="好处-2"><a href="#好处-2" class="headerlink" title="好处"></a>好处</h5><blockquote>
<ol>
<li>避免Innodb表进行索引的二次查询（回表）</li>
<li>可以把随机IO变成顺序IO加快查询效率</li>
</ol>
</blockquote>
<h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><blockquote>
<p>​	索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p>
</blockquote>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="键和相关属性的概念"><a href="#键和相关属性的概念" class="headerlink" title="键和相关属性的概念"></a>键和相关属性的概念</h4><blockquote>
<p><strong>超键：</strong>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 </p>
<p><strong>候选键：</strong>是最小超键，即没有冗余元素的超键。 </p>
<p><strong>主键：</strong>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 </p>
<p><strong>外键：</strong>在一个表中存在的另一个表的主键称此表的外键。</p>
</blockquote>
<blockquote>
<p>这里有两个表：<br>    球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号<br>    球队表(team) ：  球队编号 | 主教练 | 球队所在地</p>
</blockquote>
<blockquote>
<p><strong>超键：</strong>对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）、（球员编号，姓名）、（身份证号，年龄）等。</p>
<p><strong>候选键：</strong>对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p><strong>主键：</strong>我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p><strong>外键：</strong>球员表中的球队编号。<br>主属性、非主属性：在球员表中，主属性是（球员编号）、（身份证号），其他的属性（姓名）、（年龄）、（球队编号）都是非主属性。</p>
</blockquote>
<h4 id="范式简介"><a href="#范式简介" class="headerlink" title="范式简介"></a>范式简介</h4><blockquote>
<p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</p>
</blockquote>
<blockquote>
<p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkjnibuytcrexzw.jpg"></p>
</blockquote>
<h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式(1st NF)"></a>第一范式(1st NF)</h4><blockquote>
<p>数据表的每一列都要保持它的原子特性，也就是列不能再被分割。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1487363-20190521195635864-1806009902.jpg"></p>
<blockquote>
<p>这张表就不符合第一范式规定的原子性，不符合关系型数据库的基本要求，在关系型数据库中创建这个表的操作就不能成功。不得不将数据表设计为如下形式。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1487363-20190521195649651-325732847.jpg"></p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><blockquote>
<p>非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p>
</blockquote>
<blockquote>
<p>比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p>
</blockquote>
<blockquote>
<ol>
<li>数据冗余：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</li>
</ol>
</blockquote>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><blockquote>
<p>任何非主<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7">属性</a>不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211311408-1364899740.png"></p>
<blockquote>
<p>上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，而不是主键“学号”，所以需做如下调整：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211539242-1391100354.png" alt="5"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211602202-1069383439.png"></p>
<h4 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h4><blockquote>
<p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。</p>
</blockquote>
<h4 id="BCFN-巴斯-科德范式"><a href="#BCFN-巴斯-科德范式" class="headerlink" title="BCFN(巴斯-科德范式)"></a>BCFN(巴斯-科德范式)</h4><blockquote>
<p>它在 3NF 的基础上消除了主属性对候选键的部分函数依赖或者传递依赖关系。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><h5 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h5><blockquote>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
</blockquote>
<h5 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h5><blockquote>
<p>一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。</p>
<p>举例说明：张三向李四转100元，转账前和转账后的数据是正确的状态，这就叫一致性，如果出现张三转出100元，李四账号没有增加100元这就出现了数据错误，就没有达到一致性。</p>
</blockquote>
<h5 id="隔离型（isolation）"><a href="#隔离型（isolation）" class="headerlink" title="隔离型（isolation）"></a>隔离型（isolation）</h5><blockquote>
<p>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</blockquote>
<h5 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h5><blockquote>
<p>一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</blockquote>
<blockquote>
<p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
</blockquote>
<h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><h5 id="活动的（active）"><a href="#活动的（active）" class="headerlink" title="活动的（active）"></a>活动的（active）</h5><blockquote>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</p>
</blockquote>
<h5 id="部分提交的（partially-committed）"><a href="#部分提交的（partially-committed）" class="headerlink" title="部分提交的（partially committed）"></a>部分提交的（partially committed）</h5><blockquote>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
</blockquote>
<h5 id="失败的（failed）"><a href="#失败的（failed）" class="headerlink" title="失败的（failed）"></a>失败的（failed）</h5><blockquote>
<p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p>
</blockquote>
<h5 id="中止的（aborted）"><a href="#中止的（aborted）" class="headerlink" title="中止的（aborted）"></a>中止的（aborted）</h5><blockquote>
<p>如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
</blockquote>
<h5 id="提交的（committed）"><a href="#提交的（committed）" class="headerlink" title="提交的（committed）"></a>提交的（committed）</h5><blockquote>
<p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/lkmjnibyutv6rf5de4.jpg"></p>
<h4 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h4><blockquote>
<p>使用事务有两种方式，分别为显式事务和隐式事务。</p>
</blockquote>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h5><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"># 或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于BEGIN 特别之处在于，后边能跟随几个修饰符：</p>
<blockquote>
<p>① READ ONLY ：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<p>② READ WRITE ：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
<p>③ WITH CONSISTENT SNAPSHOT ：启动一致性读。</p>
</blockquote>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL）</p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure>

<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><p>MySQL中有一个系统变量autocommit ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span>   <span class="keyword">ON</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p>
<ul>
<li>显式的的使用START TRANSACTION 或者BEGIN 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li>
<li>把系统变量autocommit 的值设置为OFF ，就像这样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h6><blockquote>
<ul>
<li>数据定义语言（Data definition language，缩写为：DDL）</li>
<li>隐式使用或修改mysql数据库中的表</li>
<li>事务控制或关于锁定的语句</li>
</ul>
<p>① 当我们在一个事务还没提交或者回滚时就又使用START TRANSACTION 或者BEGIN 语句开启了<br>另一个事务时，会隐式的提交上一个事务。</p>
<p>② 当前的autocommit 系统变量的值为OFF ，我们手动把它调为ON 时，也会隐式的提交前边语<br>句所属的事务。</p>
<p>③ 使用LOCK TABLES 、UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事<br>务。</p>
</blockquote>
<blockquote>
<ul>
<li>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</li>
<li>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</li>
</ul>
</blockquote>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    studentno <span class="type">INT</span>,</span><br><span class="line">    name      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    class     <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) Engine <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小谷&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> studentno <span class="operator">|</span>   name <span class="operator">|</span> class <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span>      <span class="operator">|</span>  小谷   <span class="operator">|</span>  <span class="number">1</span>班 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h5><h6 id="脏写（-Dirty-Write-）"><a href="#脏写（-Dirty-Write-）" class="headerlink" title="脏写（ Dirty Write ）"></a>脏写（ Dirty Write ）</h6><blockquote>
<p>对于两个事务 Session A、Session B，如果事务Session A 修改了另一个未提交事务Session B 修改过的数据，那就意味着发生了脏写。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-24_19-40-26.png"></p>
<blockquote>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p>
</blockquote>
<h6 id="脏读（-Dirty-Read-）"><a href="#脏读（-Dirty-Read-）" class="headerlink" title="脏读（ Dirty Read ）"></a>脏读（ Dirty Read ）</h6><blockquote>
<p>对于两个事务 Session A、Session B，Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctyubiomkjnitrctu.png"></p>
<blockquote>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
</blockquote>
<h6 id="不可重复读（-Non-Repeatable-Read-）"><a href="#不可重复读（-Non-Repeatable-Read-）" class="headerlink" title="不可重复读（ Non-Repeatable Read ）"></a>不可重复读（ Non-Repeatable Read ）</h6><blockquote>
<p>假设缓存页里一条数据原来的值是 A 值，此时事务 A 开启之后，第一次查询这条数据，读取到的就是 A 值。接着事务 B 更新了那行数据的值为 B 值，同时事务 B 立马提交了，然后事务 A 此时还没提交。大家注意，此时事务 A 是没提交的，它在事务执行期间第二次查询数据，此时查到的是事务 B 修改过的值，B 值，因为事务 B 已经提交了，所以事务 A 是可以读到的，紧接着事务 C 再次更新数据为 C 值，并且提交事务了，此时事务 A 在还没提交的情况下，第三次查询数据，查到的值为 C 值。</p>
</blockquote>
<h6 id="幻读（-Phantom-）"><a href="#幻读（-Phantom-）" class="headerlink" title="幻读（ Phantom ）"></a>幻读（ Phantom ）</h6><blockquote>
<p>对于两个事务Session A、Session B, Session A 从一个表中读取了一个字段, 然后 Session B 在该表中插入了一些新的行。 之后, 如果 Session A 再次读取同一个表, 就会多出几行。那就意味着发生了幻读。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjniohbyutrc.png"></p>
<blockquote>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
</blockquote>
<h5 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h5><blockquote>
<p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：<strong>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</strong></p>
</blockquote>
<blockquote>
<p><strong>READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</p>
<p><strong>READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</p>
<p><strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnibuyctrxezwxrctbyu.jpg"></p>
<h5 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h5><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br></pre></td></tr></table></figure>

<p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响：</p>
<ul>
<li><p>使用GLOBAL 关键字（在全局范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用SESSION 关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事务之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<h5 id="不同隔离级别举例"><a href="#不同隔离级别举例" class="headerlink" title="不同隔离级别举例"></a>不同隔离级别举例</h5><h6 id="演示1-读未提交之脏读"><a href="#演示1-读未提交之脏读" class="headerlink" title="演示1. 读未提交之脏读"></a>演示1. 读未提交之脏读</h6><p>设置隔离级别为未提交读：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmnjibuyvctrxezw.jpg"></p>
<p>事务1和事务2的执行流程如下：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkljnihbuytcrxe.jpg"></p>
<h6 id="演示2：读已提交"><a href="#演示2：读已提交" class="headerlink" title="演示2：读已提交"></a>演示2：读已提交</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjnibhyvucrtxe.jpg"></p>
<h6 id="演示3：可重复读"><a href="#演示3：可重复读" class="headerlink" title="演示3：可重复读"></a>演示3：可重复读</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnbhgvyfctxerzewrx.jpg"></p>
<h6 id="演示4：幻读"><a href="#演示4：幻读" class="headerlink" title="演示4：幻读"></a>演示4：幻读</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ojnibhuyvtcrex5rctyvubyino.jpg"></p>
<h4 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h4><blockquote>
<p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由锁机制实现。</li>
<li>事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul>
<li>REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>有的DBA或许会认为UNDO是REDo的逆过程，其实不然。REDO和UNDO都可以视为是一种恢复操作，但是:</p>
<ul>
<li>REDO LOG：是存储引擎层(innodb)生成的日志，记录的是”物理级别”上的页修改操作，比如页号xx、偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性;</li>
<li>UNDO LOG；是存储引擎层(innodb)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚(undo log记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)。</li>
</ul>
</blockquote>
<h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><h6 id="好处-3"><a href="#好处-3" class="headerlink" title="好处"></a>好处</h6><blockquote>
<ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
</blockquote>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><blockquote>
<ul>
<li>redo日志是顺序写入磁盘的</li>
<li>事务执行过程中，redo log不断记录</li>
</ul>
</blockquote>
<h6 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h6><p>Redo log可以简单分为以下两个部分：</p>
<ul>
<li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li>
</ul>
<p>参数设置：innodb_log_buffer_size：<br>redo log buffer 大小，<strong>默认16M</strong> ，最大值是4096M，最小值为1M。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</li>
</ul>
<h6 id="redo-log的整体流程"><a href="#redo-log的整体流程" class="headerlink" title="redo log的整体流程"></a>redo log的整体流程</h6><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njbhugvyctryvubijnokm.jpg"></p>
<blockquote>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
</blockquote>
<h6 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h6><blockquote>
<p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定的频率刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibyutyrtertcryubi.jpg"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>针对这种情况，InnoDB给出innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li>
<li>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值）</li>
<li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li>
</ul>
<h6 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h6><p><strong>补充概念：Mini-Transaction</strong></p>
<p>MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr 组成，每一个mtr 又可以包含若干条redo日志，画个图表示它们的关系就是这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/ouiygt7fr6de5rftyioipo.jpg"></p>
<p><strong>redo 日志写入log buffer</strong></p>
<p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block(512字节)中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示:</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibuvyctexrze.jpg"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。我们现在假设有两个名为T1、T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下:</p>
<ul>
<li><p>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</p>
</li>
<li><p>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2。</p>
</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkhbjgvyfcdtxrzea.jpg"></p>
<p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kmjnihbugvyfctdxrs.jpg"></p>
<p><strong>redo log block的结构图</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kjnhbugvyfctdxrjhbugvy.jpg"></p>
<h6 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h6><p>MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。</p>
<p>单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p>
<p><strong>日志文件组</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/khbjgvyfctdxrze.jpg"></p>
<p>总共的redo日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。<br>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p>
<p><strong>checkpoint</strong></p>
<p>在整个日志文件组中还有两个重要的属性，分别是write pos、checkplointo </p>
<ul>
<li>write pos是当前记录的位置，一边写一边后移</li>
<li>checkpoint是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MysQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把 checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbugvyfctdxrszerxdfgbhinj.jpg"></p>
<p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mkojnihbugvyfctdx.jpg"></p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><blockquote>
<p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log 。</p>
</blockquote>
<blockquote>
<p><strong>保存了事务发生之前的数据的一个版本</strong>，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
</blockquote>
<blockquote>
<p>​	事务发生异常需要回滚，这时就需要回滚日志。回滚日志不同于重做日志，它是<strong>逻辑日志</strong>，<strong>对数据库的修改都逻辑的取消</strong>了。<strong>当事务回滚时，它实际上做的是与先前相反的工作。对于每个INSERT，InnoDB存储引擎都会完成一个DELETE；对于每个UPDATE，InnoDB存储引擎都会执行一个相反的UPDATE。</strong></p>
<p>　　未提交的事务和回滚了的事务也会产生重做日志。InnoDB存储引擎会重做所有事务包括未提交的事务和回滚了的事务，然后通过回滚日志回滚那些未提交的事务。使用这种策略需要回滚日志在重做日志之前写入磁盘，使得持久化变得复杂起来。为了降低复杂度，InnoDB存储引擎将回滚日志作数据，记录回滚日志的操作也会记录到重做日志中。这样回滚日志就可以像数据一样缓存起来，而不用在重写日志之前写入磁盘了。</p>
</blockquote>
<h6 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h6><p><strong>回滚段与undo页</strong></p>
<blockquote>
<p>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment） 。每个回滚段记录了1024 个undo log segment ，而在每个undo log segment段中进行undo页的申请。</p>
<ul>
<li>在InnoDB1.1版本之前（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为1024 。虽然对绝大多数的应用来说都已经够用。</li>
<li>从1.1版本开始InnoDB支持最大128个rollback segment ，故其支持同时在线的事务限制提高到了128*1024 。</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong>回滚段与事务</strong></p>
<blockquote>
<ol>
<li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p>
</li>
<li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p>
</li>
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
</li>
<li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p>
</li>
<li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>​	<strong>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间</strong>。</p>
</blockquote>
<p><strong>undo log 可重用</strong></p>
<blockquote>
<p>​	当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。</p>
<p>​	为每一个事务分配一个页，是非常浪费的，于是undo页就被设计的可以重用了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3&#x2F;4，如果小于3&#x2F;4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。</p>
</blockquote>
<p><strong>undo log的类型</strong></p>
<blockquote>
<p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li><p><strong>insert undo log</strong>是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
</li>
<li><p><strong>update undo log</strong>记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
</li>
</ul>
</blockquote>
<p><strong>undo log的生命周期</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/nibyuvtcr6x5ctvyubio.jpg"></p>
<p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p>
<ul>
<li><p>DB_ROW_ID:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</p>
</li>
<li><p>DB_TRX_ID:每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。I</p>
</li>
<li><p>DB_ROLL_PTR:回滚指针，本质上就是指向undo log的指针。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbyutrcex4wexrctyuio.jpg"></p>
<p>当我们执行INSERT时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jonihbugvfydxrctfybhnjiom.jpg"></p>
<p>当我们执行UPDATE时：</p>
<p>对于更新的操作会产生update undo log，并且会分更新主键的和不更新主键的，假设现在执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span>&quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkbhugvfctdxrtcfygujnmk.jpg"></p>
<p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no&#x3D;0) 。<br>假设现在执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kjnibhugtycrxetcybyuij.jpg"></p>
<p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增</p>
<p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p>
<p><strong>undo log是如何回滚的</strong></p>
<blockquote>
<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ol>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbvgyctxcryvuybimk.jpg"></p>
<h5 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h5><h6 id="锁所在的事务信息"><a href="#锁所在的事务信息" class="headerlink" title="锁所在的事务信息"></a>锁所在的事务信息</h6><blockquote>
<p>​	不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个事务的信息。此锁所在的事务信息在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
</blockquote>
<h6 id="索引信息"><a href="#索引信息" class="headerlink" title="索引信息"></a>索引信息</h6><blockquote>
<p>​	对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
</blockquote>
<h6 id="表锁／行锁信息"><a href="#表锁／行锁信息" class="headerlink" title="表锁／行锁信息"></a>表锁／行锁信息</h6><p>表锁结构和行锁结构在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li>Space ID ：记录所在表空间。</li>
<li>Page Number ：记录所在页号。</li>
<li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li>
</ul>
</li>
</ul>
<h6 id="type-mode"><a href="#type-mode" class="headerlink" title="type_mode"></a>type_mode</h6><p>​	这是一个32位的数，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkbhugvycrtxercytvuybinokl,';.jpg"></p>
<ul>
<li>锁的模式（ lock_mode ），占用低4位，可选的值如下：<ul>
<li>LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。</li>
<li>LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。</li>
<li>LOCK_S （十进制的2 ）：表示共享锁，也就是S锁。</li>
<li>LOCK_X （十进制的3 ）：表示独占锁，也就是X锁。</li>
<li>LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。</li>
</ul>
</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<ul>
<li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li>LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为</p>
<ul>
<li>LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li>
<li>LOCK_ORDINARY （十进制的0 ）：表示next-key锁。</li>
<li>LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示gap锁。</li>
<li>LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经记录锁。</li>
<li>LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting 属性呢？基于内存空间的节省，所以把is_waiting 属性放到了type_mode 这个32位的数字中：</p>
<ul>
<li>LOCK_WAIT （十进制的256 ） ：当第9个比特位置为1 时，表示is_waiting 为true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<h6 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h6><p>​	为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
<h6 id="一堆比特位"><a href="#一堆比特位" class="headerlink" title="一堆比特位"></a>一堆比特位</h6><p>​	如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no 属性，伪记录Infimum 的heap_no 值为0 ， Supremum 的heap_no 值为1 ，之后每插入一条记录， heap_no 值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no ，即一个比特位映射到页内的一条记录。</p>
<h4 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h4><h5 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h5><blockquote>
<p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
</blockquote>
<h5 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h5><p>写-写情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibugvexrctybyuiom.jpg"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jinhbugvyctrybyuinimp,l.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hjbgvyfctdxrszxdtcfgbhijn.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvyctrxetcyubiomk.jpg"></p>
<p>小结几种说法：</p>
<ul>
<li><p>不加锁</p>
<ul>
<li>意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。</li>
</ul>
</li>
<li><p>获取锁成功，或者加锁成功</p>
<ul>
<li>意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务可以继续执行操作。</li>
</ul>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p>
<ul>
<li>意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务需要等待，不可以继续执行操作。</li>
</ul>
</li>
</ul>
<h5 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h5><ul>
<li><p>读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p>
</li>
<li><p>各个数据库厂商对SQL标准的支持都可能不一样。比如MySQL在REPEATABLE READ 隔离级别上就已经解决了幻读问题。</p>
</li>
</ul>
<h4 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行加锁。</li>
</ul>
<p>所谓的WVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本〔历史版本由undo log构建)。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</li>
<li>在REPEATABLE READ 隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
<ul>
<li>方案二：读、写操作都采用加锁的方式。</li>
</ul>
<p>小结对比发现：</p>
<ul>
<li>采用MVCC 方式的话， 读-写操作彼此并不冲突， 性能更高。</li>
<li>采用加锁方式的话， 读-写操作彼此需要排队执行，影响性能。</li>
</ul>
<p>一般情况下我们当然愿意采用MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行</p>
<h4 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibhutv6c5excr6tvunomp.jpg"></p>
<h5 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h5><ul>
<li>读锁：也称为共享锁、英文用S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li>写锁：也称为排他锁、英文用X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li>
</ul>
<p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<h6 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h6><p>对读取的记录加 <code>S</code> 锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name lock <span class="keyword">in</span> share mode;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">for</span> share;</span><br></pre></td></tr></table></figure>

<p>对读取的记录加 <code>X</code> 锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL8.o新特性:</strong><br>在5.7及之前的版本，SELECT …FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout 超时。在8.o版本中，SELECT…FOR UPDATE，SELEC . FOR SHARE 添加NOWAIT、SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p>
<ul>
<li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:<ul>
<li>那么NOWAIT会立即报错返回</li>
<li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (i) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line">#初始化 <span class="number">3</span> 条数据就行了，多了数不过来。#session1</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"># Session <span class="number">2</span>:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> i<span class="operator">=</span><span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line"># 从上面可以看到 <span class="keyword">for</span> <span class="keyword">update</span> 执行需要等待锁超时才能退出。接下来我们看一下 <span class="keyword">for</span> <span class="keyword">update</span> nowait 执行：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> NOWAIT;</span><br><span class="line">ERROR <span class="number">3572</span> (HY000): Statement aborted because lock(s) could <span class="keyword">not</span> be acquired immediately <span class="keyword">and</span> NOWAIT <span class="keyword">is</span> set.</span><br><span class="line"># 从这里可以看到在 <span class="keyword">for</span> <span class="keyword">update</span> nowait 直接执行返回，从错误提示上可以出来因为设置了 nowait 因为获取不到锁直接退出了。# Session <span class="number">2</span>:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"># Query 直接执行返回，但从结果上可以看出来少了一条记录：<span class="number">2</span>， 原因是 <span class="number">2</span> 这条记录正处在锁 X 锁状态下，因为使用了 <span class="keyword">skip</span> locked,直接跳过该条记录。</span><br></pre></td></tr></table></figure>

<h6 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h6><p>平常所用到的写操作无非是 DELETE、UPDATE、INSERT这三种:</p>
<ul>
<li><p>DELETE：对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p>
</li>
<li><p>UPDATE：在对一条记录做UPDATE操作时分为三种情况:</p>
<ul>
<li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</li>
<li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。</li>
<li>情况3：修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。</li>
</ul>
</li>
<li><p>INSERT：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p>
</li>
</ul>
<h4 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h4><h5 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h5><blockquote>
<p>​	该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎（不管你是MysQL的什么存储引擎对于表锁的策略都是一样的)，并且表锁是开销最小的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p>
</blockquote>
<h6 id="表级别的S锁、X锁"><a href="#表级别的S锁、X锁" class="headerlink" title="表级别的S锁、X锁"></a>表级别的S锁、X锁</h6><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名： Metadata Locks ，简称MDL ）结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量autocommit&#x3D;0，innodb_table_locks &#x3D; 1 时，手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ ：  #InnoDB存储引擎会对表t 加表级别的S锁。</span><br><span class="line">LOCK TABLES t WRITE ： #InnoDB存储引擎会对表t 加表级别的X锁。</span><br><span class="line">UNLOCK TABLES;         #解锁</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/csfvrdbtrnytumyuntbyrtv.png"></p>
<h5 id="意向锁-（intention-lock）"><a href="#意向锁-（intention-lock）" class="headerlink" title="意向锁 （intention lock）"></a>意向锁 （intention lock）</h5><h6 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h6><blockquote>
<p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p>
</blockquote>
<p>需要强调一下，意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。意向锁分为两种：</p>
<ul>
<li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>即：<code>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁</code>，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p><strong>举例1：</strong></p>
<p>设想这样一张 <code>users</code> 表： <strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：users（id PK，name）</p>
<p>事务 A 获取了某一行的排他锁，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>事务 B 想要获取 <code>users</code> 表的表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<p>因为共享锁与排他锁<code>互斥</code>，所以事务 B 在视图对 <code>users</code> 表加共享锁的时候，必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁。</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁  。</li>
</ul>
<p>为了检测是否满足第二个条件，事务 B 必须在确保 <code>users</code>表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了<strong>意向锁</strong>之后，情况就不一样了：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvyfctdxrsdtcfyvgbhijno.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mknhjbugvyfdtxrtcfyubhiomk.png"></p>
<p><strong><font color='red'>注意：这里的排他 &#x2F; 共享锁指的都是表锁！！！意向锁不会与行级的共享 &#x2F; 排他锁互斥！！！</font></strong></p>
<p><strong>举例2：</strong></p>
<p><code>事务 A</code> 获取了某一行的排他锁，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>此时 <code>users</code> 表存在两把锁：<code>users</code> 表上的<strong>意向排他锁</strong>与 id 为 6 的数据行上的<strong>排他锁</strong>。</p>
<p>事务 B 想要获取 users 表的共享锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<p>此时<code>事务 B</code> 检测事务 A 持有 <code>users</code> 表的<strong>意向排他锁</strong>，就可以得知<code>事务 A</code> 必然持有该表中某些数据行的<strong>排他锁</strong>，那么<code>事务 B</code> 对 <code>users</code> 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p>
<p><strong>举例3：</strong></p>
<p><code>事务 A</code> 先获取了某一行的<strong>排他锁</strong>，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 A</code> 获取了 <code>users</code> 表上的<strong>意向排他锁</strong>。</li>
<li><code>事务 A</code> 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>之后<code>事务 B</code> 想要获取 <code>users</code> 表的<strong>共享锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 B</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 B</code> 对 <code>users</code> 表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后<code>事务 C</code> 也想获取 <code>users</code> 表中某一行的<strong>排他锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><code>事务 C</code> 申请 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p><code>事务 C</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p>因为意向锁之间并不互斥，所以<code>事务 C</code> 获取到了 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终<code>事务 C</code> 成功获取到了该数据行上的<strong>排他锁</strong>。</p>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><blockquote>
<ul>
<li><p>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</p>
</li>
<li><p>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</p>
</li>
<li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</p>
</li>
<li><p>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</p>
</li>
</ul>
</blockquote>
<h5 id="自增锁（AUTO-INC锁）"><a href="#自增锁（AUTO-INC锁）" class="headerlink" title="自增锁（AUTO-INC锁）"></a>自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT 属性。举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight plaintext"><figcaption><span>select * from teacher;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| id |   name   |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | zhangsan |</span><br><span class="line">| 2  |   lisi   |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。</p>
</blockquote>
<h6 id="Simple-inserts-（简单插入）"><a href="#Simple-inserts-（简单插入）" class="headerlink" title="Simple inserts （简单插入）"></a>Simple inserts （简单插入）</h6><blockquote>
<p>​	可以预先确定要插入的行数（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES() 和REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p>
</blockquote>
<h6 id="Bulk-inserts-（批量插入）"><a href="#Bulk-inserts-（批量插入）" class="headerlink" title="Bulk inserts （批量插入）"></a>Bulk inserts （批量插入）</h6><blockquote>
<p>​	事先不知道要插入的行数（和所需自动递增值的数量）的语句。比如INSERT … SELECT ， REPLACE… SELECT 和LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>
</blockquote>
<h6 id="Mixed-mode-inserts-（混合模式插入）"><a href="#Mixed-mode-inserts-（混合模式插入）" class="headerlink" title="Mixed-mode inserts （混合模式插入）"></a>Mixed-mode inserts （混合模式插入）</h6><blockquote>
<p>​	这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INTO teacher (id,name)VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</p>
</blockquote>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<blockquote>
<ol>
<li><p>innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p>
<p>​	在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会限制并发能力。</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)</p>
<p>​	在 MySQL 8.0 之前，连续锁定模式是默认的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECTREPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。对于“Simple inserts”（要插入的行数事先已知），则通过在mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple<br>inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)</p>
<p>从 MySQL 8.0 开始，交错锁模式是默认设置。在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。</p>
</li>
</ol>
</blockquote>
<h5 id="元数据锁-meta-data-lock"><a href="#元数据锁-meta-data-lock" class="headerlink" title="元数据锁(meta data lock)"></a>元数据锁(meta data lock)</h5><blockquote>
<p>​	MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>
</blockquote>
<p><strong><font color='red'>当对一张表进行增删改查的时候，加MDL读锁(共享);当对表结构进行变更操作的时候，加MDL写锁(排他)。</font></strong></p>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbugvyfctdfvybhnjomk,l.;.png"></p>
<h6 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h6><blockquote>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njbihugcfxdtcfygvubhim;l,';.jpg"></p>
<p>举例如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/onubyutr6cybuimp,l[.jpg"></p>
<h6 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h6><blockquote>
<p>​	MySQL 在REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC 方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为gap锁。比如，把id值为8的那条记录加一个gap锁的示意图如下。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/lkjhgvyfcdtfygbhijnom.jpg"></p>
<blockquote>
<p>​	图中id值为8的记录加了gap锁，意味着不允许别的事务在id值为8的记录前边的间隙插入新记录，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
</blockquote>
<blockquote>
<p>​	<strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁(不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hubgvyfctexrctyui.png"></p>
<p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此session 1加的是间隙锁(3,8)。而session2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<p>注意，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是student表中id值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加 gap锁才能阻止其他事务插入id值在(20，+∞)这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了:</p>
<ul>
<li>Infimum记录，表示该页面中最小的记录。</li>
<li>Supremum记录，表示该页面中最大的记录。|</li>
</ul>
<p>为了实现阻止其他事务插入id值在(20, +co)这个区间的新记录，我们可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的Supremum记录加上一个gap锁，如图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnhbugvyfctfygubiomk.png"></p>
<h6 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h6><blockquote>
<p>​	有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为:LOCK_ORDINARY，我们也可以简称为next-key锁。Next-KeyLocks是在存储引擎innodb、事务级别在可重复读的情况下使用的数据库锁，<strong>innodb默认的锁就是Next-Key locks</strong>。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下:</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hbugvyfdxrdcfygbhnj.png"></p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p>
</li>
<li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p>
</li>
</ol>
<h6 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h6><blockquote>
<p>​	我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（ next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert<br>操作时产生。</p>
<p>​	插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。</p>
<p>​	事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
</blockquote>
<h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><blockquote>
<p>​	页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。<br>​	每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
</blockquote>
<h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><blockquote>
<p>​	全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句</p>
<p>​	全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本</p>
<p>但是让整个库都只读，可能出现以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</li>
</ul>
</blockquote>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><blockquote>
<p>​	MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</p>
</blockquote>
<h5 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h5><blockquote>
<p>​	MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁， 非阻塞并发读，而<strong>这个读指的就是快照读, 而非当前读</strong>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
</blockquote>
<h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h6><blockquote>
<p>​	快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读；比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>​	之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>​	既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>​	快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
</blockquote>
<h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h6><blockquote>
<p>​	当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE; # 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... # 排他锁</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... # 排他锁</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... # 排他锁</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/nibugvyfdxrtfgubhjnmk.jpg"></p>
<p>另图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/ljkhbgvfctyvgujnmkl;.jpg"></p>
<h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><blockquote>
<p>对于使用InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</li>
<li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhufctdxcfygbhjk.jpg"></p>
<blockquote>
<p>​	insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<h5 id="Undo-Log版本链"><a href="#Undo-Log版本链" class="headerlink" title="Undo Log版本链"></a>Undo Log版本链</h5><p>假设之后两个事务id分别为10 、20 的事务对这条记录进行UPDATE 操作，操作流程如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/dcfvgebtrntuiuyntb.png"></p>
<blockquote>
<p>​	每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhugvfdxrtvgunjomk.jpg"></p>
<blockquote>
<p>​	对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。每个版本中还包含生成该版本时对应的事务id 。</p>
</blockquote>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><blockquote>
<ul>
<li>使用READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</li>
<li>使用SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</li>
<li>使用READ COMMITTED 和REPEATABLE READ 隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</li>
</ul>
</blockquote>
<blockquote>
<p>ReadView中主要包含4个比较重要的内容，分别如下：</p>
<ol>
<li>creator_trx_id ，创建这个 Read View 的事务 ID。<br>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</li>
<li>trx_ids ，表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>up_limit_id ，活跃的事务中最小的事务 ID。</li>
<li>low_limit_id ，表示生成ReadView时系统中应该分配给下一个事务的id 值。low_limit_id 是系<br>统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。<br>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</li>
</ol>
</blockquote>
<h6 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h6><blockquote>
<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的up_limit_id 和low_limit_id 之间，那就需要判断一下trx_id属性值是不是在trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h5><ul>
<li><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p>
</li>
<li><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View</p>
</li>
</ul>
<h6 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h6><p><strong>READ COMMITTED隔离级别下</strong></p>
<p>现在有两个事务id 分别为10 、20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录得到的版本链表如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvycttcrvubhnjmk.jpg"></p>
<p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下:</p>
<blockquote>
<p><strong>步骤1∶</strong>在执行SELECT语句时会先生成一个ReadView ，ReadView的trx_ids列表的内容就是 {10, 20} ,up_limit_id为10, low_limit_id为21, creator_trx_id为0。</p>
<p><strong>步骤2：</strong>从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p><strong>步骤3：</strong>下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p><strong>步骤4：</strong>下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p>
</blockquote>
<p>之后，我们把事务id 为10 的事务提交一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中id 为1 的记录的版本链就长这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jihbuvctdfvbhnjmk.jpg"></p>
<p>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个id 为1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下:</p>
<blockquote>
<p><strong>步骤1：</strong>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的trx_ids列表的内容就是{20}，up_limit_id为20,low_limit_id为21, creator_trx_id为日。</p>
<p><strong>步骤2：</strong>从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p><strong>步骤3：</strong>下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p><strong>步骤4：</strong>下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</p>
</blockquote>
<p><strong>REPEATABLE READ隔离级别下</strong></p>
<p>比如，系统里有两个事务id 分别为10 、20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录得到的版本链表如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkhgfdsxrdcfvbyuno,l..jpg"></p>
<p>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之后，我们把事务id 为10 的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录的版本链长这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibuvctcrubhjmk,l.jpg"></p>
<p>然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个id 为1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibufrtedtrfybhnjmk,l.jpg"></p>
<p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。</p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids&#x3D;[20,30] ， up_limit_id&#x3D;20 ， low_limit_id&#x3D;31 ， creator_trx_id&#x3D;20 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibugvfcdxrsdvgubhjo,l;.jpg"></p>
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<ol>
<li>id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</li>
<li>然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</li>
<li>同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbutrcexrectybuiomp,[.;'.jpg"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h3 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h3><h4 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h4><blockquote>
<p>​	MySQL有不同类型的日志文件，用来存储不同类型的日志，分为二进制日志、错误日志、通用查询日志和慢查询日志，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志和数据定义语句日志。使用这些日志文件，可以查看MySQL内部发生的事情。</p>
</blockquote>
<p>这6类日志分别为：</p>
<ul>
<li><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li>
<li><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li>
<li><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li>
<li><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li>
<li><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</li>
</ul>
<p>除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。</p>
<h4 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h4><blockquote>
<p>​	查询日志分为一般查询日志和慢查询日志，它们是通过查询是否超出变量 long_query_time 指定时间的值来判定的。在超时时间内完成的查询是一般查询，可以将其记录到一般查询日志中，<strong>但是建议关闭这种日志（默认是关闭的）</strong>，超出时间的查询是慢查询，可以将其记录到慢查询日志中。</p>
</blockquote>
<blockquote>
<p>​	通用查询日志用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。<strong>默认关闭</strong></p>
</blockquote>
<blockquote>
<p><strong>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</strong></p>
</blockquote>
<h5 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span>            <span class="keyword">Value</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span>            OFF               <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01.log <span class="operator">|</span> #通用查询日志文件的名称是atguigu01.log</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h4><blockquote>
<p>在MySQL数据库中，错误日志功能是默认开启的。而且，错误日志无法被禁止。</p>
</blockquote>
<blockquote>
<p>​	默认情况，错误日志存储在mysql数据库的数据文件中。错误日志文件通常的名称为hostname.err（hostname表示服务器的主机名）。</p>
<p>​	错误日志可以自己配置，错误日志可以通过log-error和log-warnings来定义，其中log-error：配置是否启用错误日志功能和错误日志的存储位置？log-warning：配置是否将警告信息也定义至错误日志中？</p>
<p>​	错误日志记录信息：服务器启动关闭信息、运行错误信息、时间调度器运行一个事件时产生的信息、在服务器上启动进程产生的信息。</p>
</blockquote>
<h4 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h4><blockquote>
<p>​	binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL 和DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p>
</blockquote>
<blockquote>
<p>binlog主要应用场景：</p>
<ul>
<li>一是用于<strong>数据恢复</strong>，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作,对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li>
<li>二是用于<strong>数据复制</strong>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/tmtnrbvcwevtrbyujikol.jpg"></p>
<h5 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h5><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><blockquote>
<p>​	当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>​	MySQL服务重新启动一次，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。</p>
</blockquote>
<p>查看当前的二进制日志文件列表及大小。指令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span>       <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure>

<h5 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h5><p>格式1： <strong><code>STATEMENT</code>模式</strong>（基于SQL语句的复制(statement-based replication, SBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span>STATEMENT</span><br></pre></td></tr></table></figure>

<p>每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。</p>
<ul>
<li><p>SBR 的优点：</p>
<ul>
<li>历史悠久，技术成熟</li>
<li><strong>不需要记录每一行的变化，减少了binlog日志量，文件较小</strong></li>
<li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li>
<li><strong>binlog可以用于实时的还原，而不仅仅用于复制</strong></li>
<li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
</ul>
</li>
<li><p>SBR 的缺点：</p>
<ul>
<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li>
<li><strong>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()</strong></li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li>
</ul>
</li>
</ul>
<p>格式2： <strong><code>ROW</code>模式</strong>（基于行的复制(row-based replication, RBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span><span class="type">ROW</span></span><br></pre></td></tr></table></figure>

<p>不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了。</p>
<ul>
<li><p>RBR 的优点：</p>
<ul>
<li>任何情况都可以被复制，这对复制来说是最安全可靠的。（比如：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li>
<li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li>
</ul>
</li>
<li><p>RBR 的缺点：</p>
<ul>
<li><strong>binlog 大了很多</strong></li>
<li><strong>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</strong></li>
<li><strong>无法从 binlog 中看到都复制了些什么语句</strong></li>
</ul>
</li>
</ul>
<p>格式2： <strong><code>MIXED</code>模式</strong>（混合模式复制(mixed-based replication, MBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span>MIXED</span><br></pre></td></tr></table></figure>

<p>实际上就是Statement与Row的结合。</p>
<p>​	在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。<br>​	MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>
<h5 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h5><p>​	binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kojibuvycrtxercytvubinoipo[.jpg"></p>
<p>​	write和fsync的时机，可以由参数sync_binlog 控制，默认是0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/uhigutfrdeswasertgyhuoi.jpg"></p>
<p>​	为了安全起见，可以设置为1 ，表示每次提交事务都会执行fsync，就如同redo log 刷盘流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnkbugtfrde5sdrfguyijiop.jpg"></p>
<p>​	在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h5 id="redo-log-与-binlog-的不同"><a href="#redo-log-与-binlog-的不同" class="headerlink" title="redo log 与 binlog 的不同"></a>redo log 与 binlog 的不同</h5><blockquote>
<p>1）<strong>适用对象不同</strong>：</p>
<ul>
<li>bin log 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li>
<li>而 redo log 是 InnoDB 引擎特有的</li>
</ul>
<p>2）<strong>写入内容不同</strong>：</p>
<ul>
<li>bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 id &#x3D; 1 这一行的 age 字段加 1”</li>
<li>redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”</li>
</ul>
<p>3）<strong>写入方式不同</strong>：</p>
<ul>
<li>bin log 是可以追加写入的。“追加写” 是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</li>
<li>redo log 是循环写的，空间固定会被用完</li>
</ul>
</blockquote>
<h5 id="redo-log-两阶段提交"><a href="#redo-log-两阶段提交" class="headerlink" title="redo log 两阶段提交"></a>redo log 两阶段提交</h5><p>以下面这条简单的 SQL 语句为例，我们来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行器：找存储引擎取到 id &#x3D; 1 这一行记录</p>
</li>
<li><p>存储引擎：根据主键索引树找到这一行，如果 id &#x3D; 1 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回</p>
</li>
<li><p>执行器：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</p>
</li>
<li><p>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务</p>
<blockquote>
<p>注意不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。</p>
</blockquote>
</li>
<li><p>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</p>
</li>
<li><p>执行器：调用存储引擎的提交事务接口</p>
</li>
<li><p>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p>
</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kjnbhugvyfdtxrsdtcfy.png"></p>
<p>可以看到，<strong>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit</strong>。</p>
<p>所以，为什么要这样设计呢？这样设计怎么就能够实现崩溃恢复呢？</p>
<p>根据两阶段提交，<strong>崩溃恢复时的判断规则</strong>是这样的：</p>
<ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</li>
<li>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整</li>
</ol>
<ul>
<li>a. 如果 binlog 存在并完整，则提交事务；</li>
<li>b. 否则，回滚事务。</li>
</ul>
<p>当然，这样说小伙伴们肯定没法理解，下面来看几个实际的例子：</p>
<p>如下图所示，假设数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。</p>
<blockquote>
<p>Why？</p>
<p>因为 binlog 还没有写入，之后从库进行同步的时候，无法执行这个操作，那如果我们主库上继续执行这个操作的话显然就会导致主备不一致，所以在主库上需要回滚这个事务</p>
</blockquote>
<p>并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnhbugvyfctdxrtcfygub.png"></p>
<p>​	而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。</p>
<blockquote>
<p>Why？</p>
<p>​	因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在主库上需要提交这个事务。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnihbuvyctrxerctfbyhijnomk.png"></p>
<p>所以，其实可以看出来，<strong>处于 prepare 阶段的 redo log 加上完整的 bin log，就能保证数据库的崩溃恢复了</strong>。</p>
<p>可能有同学就会问了，MySQL 咋知道 bin log 是不是完整的？</p>
<p>简单来说，一个事务的 binlog 是有完整格式的（这个我们在后面的文章中会详细解释）：</p>
<ul>
<li>statement 格式的 bin log，最后会有 COMMIT</li>
<li>row 格式的 bin log，最后会有 XID event</li>
</ul>
<p>而对于 bin log 可能会在中间出错的情况，MySQL 5.6.2 版本以后引入了 <code>binlog-checksum</code> 参数，用来验证 bin log 内容的正确性。</p>
<p>思考一个问题，<strong>两阶段提交是必要的吗？可不可以先 redo log 写完，再写 bin log 或者反过来？</strong></p>
<p>1）对于先写完 redo log 后写 bin log 的情况：</p>
<p>​	假设在 redo log 写完，bin log 还没有写完的时候，MySQL 崩溃。主库中的数据确实已经被修改了，但是这时候 bin log 里面并没有记录这个语句。因此，从库同步的时候，就会丢失这个更新，和主库不一致。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibhugvyfcdtxrsdtcfygbhij.png"></p>
<p>2）对于先写完 binlog 后写 redo log 的情况：</p>
<p>​	如果在 bin log 写完，redo log 还没写的时候，MySQL 崩溃。因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上 redo log 还没写，主库并没有完成这个操作，所以从库相比主库就会多执行一个事务，导致主备不一致</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibyutctrxecrtuiomp,l;.png"></p>
<h5 id="中继日志-relay-log"><a href="#中继日志-relay-log" class="headerlink" title="中继日志(relay log)"></a>中继日志(relay log)</h5><blockquote>
<p>​	中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhgcftdxrtgbhijn.jpg"></p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote>
<p>​	如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<strong>优化SQL和索引</strong>，这种方式简单有效；其次才是<strong>采用缓存的策略</strong>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<strong>主从架构</strong>，进行读写分离。</p>
</blockquote>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/mjnbhgvyfdxrszrxdtvgbhjlk.jpg"></p>
<blockquote>
<p>其中一个是Master主库，负责写入数据，我们称之为：<strong>写库</strong>。</p>
<p>其它都是Slave从库，负责读取数据，我们称之为：<strong>读库</strong>。</p>
<p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。</p>
<p>面对“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器.上,让读取更加顺畅。读取顺畅的另-一个原因,就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p>
</blockquote>
<h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><blockquote>
<p>​	我们通过主从复制将主库上的数据复制到了从库上,相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份,不会影响到服务。</p>
</blockquote>
<h5 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h5><blockquote>
<p>​	数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p>
</blockquote>
<h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><h5 id="三个线程"><a href="#三个线程" class="headerlink" title="三个线程"></a>三个线程</h5><blockquote>
<p>​	实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程来操作，一个主库线程，两个从库线程。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ohygutfrdfyguinio.jpg"></p>
<blockquote>
<p><strong>二进制日志转储线程（Binlog dump thread）</strong>：是一个主库线程。当从库线程连接的时候，主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。 负责将主服务器上的数据更改写入二进制日志中。</p>
<p><strong>从库 I&#x2F;O 线程</strong>：会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p>
<p><strong>从库 SQL 线程</strong>：会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jhghfcdxrzeasrdcfgbhij.jpg"></p>
<h5 id="复制三步骤"><a href="#复制三步骤" class="headerlink" title="复制三步骤"></a>复制三步骤</h5><blockquote>
<p>步骤1： Master 将写操作记录到二进制日志（ binlog ）。</p>
<p>步骤2： Slave 将Master 的binary log events拷贝到它的中继日志（ relay log ）。</p>
<p>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化<br>的，而且重启后从接入点开始复制。</p>
</blockquote>
<h5 id="复制的问题"><a href="#复制的问题" class="headerlink" title="复制的问题"></a>复制的问题</h5><blockquote>
<p><strong>延时</strong></p>
</blockquote>
<h4 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h4><blockquote>
<ul>
<li><p>每个Slave 只有一个Master</p>
</li>
<li><p>每个Slave 只能有一个唯一的服务器ID</p>
</li>
<li><p>每个Master 可以有多个Slave</p>
</li>
</ul>
</blockquote>
<h4 id="同步数据一致性问题"><a href="#同步数据一致性问题" class="headerlink" title="同步数据一致性问题"></a>同步数据一致性问题</h4><h5 id="主从同步的要求"><a href="#主从同步的要求" class="headerlink" title="主从同步的要求"></a>主从同步的要求</h5><blockquote>
<ul>
<li>读库和写库的数据一致(最终一致)；</li>
<li>写数据必须写到写库；</li>
<li>读数据必须到读库(不一定)；</li>
</ul>
</blockquote>
<h5 id="主从延迟问题原因"><a href="#主从延迟问题原因" class="headerlink" title="主从延迟问题原因"></a>主从延迟问题原因</h5><blockquote>
<p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</p>
<p>造成原因：</p>
<ul>
<li>从库的机器性能比主库要差</li>
<li>从库的压力大</li>
<li>大事务的执行</li>
</ul>
</blockquote>
<h5 id="如何减少主从延迟"><a href="#如何减少主从延迟" class="headerlink" title="如何减少主从延迟"></a>如何减少主从延迟</h5><blockquote>
<p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<ol>
<li>降低多线程大事务并发的概率，优化业务逻辑</li>
<li>优化SQL，避免慢SQL， 减少批量操作，建议写脚本以update-sleep这样的形式完成。</li>
<li><strong>提高从库机器的配置，减少主库写binlog和从库读binlog的效率差。</strong></li>
<li>尽量采用短的链路，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输<br>的网络延时。</li>
<li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li>
</ol>
</blockquote>
<h5 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h5><blockquote>
<p>​	如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份，并没有起到读写分离，分担主库读压力的作用。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kmjnibyutvyrterytyuiomp.jpg"></p>
<p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间数据复制方式的问题，如果按照数据一致性从弱到强来进行划分，有以下 3 种复制方式。</p>
<h6 id="方法-1：异步复制"><a href="#方法-1：异步复制" class="headerlink" title="方法 1：异步复制"></a>方法 1：异步复制</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jkhbjgvfyctdxcfyvgujnlk;.jpg"></p>
<blockquote>
<p>​	异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主， 那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。|</p>
</blockquote>
<h6 id="方法-2：半同步复制"><a href="#方法-2：半同步复制" class="headerlink" title="方法 2：半同步复制"></a>方法 2：半同步复制</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kjhbjgvcfdxrzsxdtybhijnm;l.jpg"></p>
<blockquote>
<p>​	MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一一个从库接收到了Binlog,并且写入到中继日志中，再返回给客户端。<br>​	这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。<br>​	在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大,可以提升数据一致性的强度,但也会增加主库等待从库响应的时间。</p>
</blockquote>
<h6 id="方法-3：组复制"><a href="#方法-3：组复制" class="headerlink" title="方法 3：组复制"></a>方法 3：组复制</h6><blockquote>
<p>​	异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。<br>​	组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p>
</blockquote>
<p><strong>MGR 是如何工作</strong></p>
<blockquote>
<p>​	首先我们将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接 COMMIT 即可。<br>​	在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
</blockquote>
<h3 id="MySQL组成部分"><a href="#MySQL组成部分" class="headerlink" title="MySQL组成部分"></a>MySQL组成部分</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jiyutyrctexrtcybujomkl.png"></p>
<p>可以大致把 MySQL 的逻辑架构分成 Server 层和存储引擎层：</p>
<p>​	1）大多数 MySQL 的核心服务功能都在 Server 层，包括连接，查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
<p>​	值得一提的是，Server 最上面的服务也就是连接器，拥有管理 MySQL 连接、权限验证的功能。显然这并非 MySQL 所独有，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。</p>
<p>​	2）第二层就是存储引擎（支持 InnoDB、MyISAM、Memory 等多个存储引擎）。存储引擎负责 MySQL 中数据的存储和提取，响应上层服务器的请求。每个存储引擎自然是有它的优势和劣势，不同的存储引擎之间无法相互通信，所以我们需要根据不同的场景来选择合适的存储引擎。</p>
<p>​	服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎 API 包含几十个底层函数，用于执行诸如 “开始一个事务” 或者 “根据主键提取一行记录” 等操作。</p>
<p>​	需要注意的是，在 MySQL 5.1 及之前的版本，MyISAM 是默认的存储引擎，而在 MySQL 5.5.5 后，InnoDB 成为了默认的存储引擎。</p>
<h4 id="连接器（Connector）"><a href="#连接器（Connector）" class="headerlink" title="连接器（Connector）"></a>连接器（Connector）</h4><p>MySQL 5.7 的官方文档中，是这样描述连接器的：</p>
<blockquote>
<p>MySQL Connectors provide connectivity to the MySQL server for client programs.</p>
</blockquote>
<p>​	<strong>MySQL 连接器为客户端程序提供到 MySQL 服务器的连接</strong>。 说得更细节一点的话，连接器其实会做两个事情，一个是管理 MySQL 连接，一个是权限验证。我们依次来解释下。</p>
<p>​	首先，要连接到 MySQL 服务器，我们通常需要提供 MySQL 用户名和密码，并且如果服务器运行在我们登录的机器以外的机器上，还需要指定一个主机名比如 host。 所以连接命令一般是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell<span class="operator">&gt;</span> mysql <span class="operator">-</span>h host <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p</span><br><span class="line">Enter password: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果在运行 MySQL 的同一台机器上登录，就可以省略主机名，只需使用以下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell<span class="operator">&gt;</span> mysql <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>

<p>上面这个命令各位应该都很熟悉。</p>
<p>OK，通过上述命令完成经典的 TCP 三次握手建立连接后，连接器就会根据你输入的用户名和密码来认证你的身份：</p>
<p>1）如果用户名或密码不对，你就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。</p>
<p>2）如果用户名密码认证通过，你会看到下面这一串内容：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibyutrfdetrcyvubinio.png"></p>
<p><code>mysql&gt;</code> 就是在提示你 MySQL 已准备好了，你可以开始输入 SQL 语句了！</p>
<p>​	当然，连接器做的事情不仅仅是比对一下用户名和密码，它还会验证该用户是否具有执行某个特定查询的权限（例如，是否允许该用户对 world 数据库的 Country 表执行 SELECT 语句）。之后，这个连接里面的所有权限判断逻辑，都将依赖于此时读到的权限。</p>
<p>​	这意味着，当一个用户成功建立连接后，即使你在另一个终端用管理员账号对这个用户的权限做了修改，对当前已经存在连接的权限不会造成任何影响。</p>
<p>​	也就是说，当修改了用户权限后，只有再新建的连接才会使用新的权限设置。</p>
<p>​	当一个连接建立起来后，如果你没有后续的动作，那么这个连接就处于空闲状态（Sleep）。</p>
<p>​	事实上，对于一个 MySQL 连接来说（或者说一个线程），任何时刻都有一个状态，<strong>该状态表示了 MySQL 当前正在做什么</strong>。有很多种方式能查看当前的状态，最简单的是使用 <code>SHOW FULL PROCESSLIST</code> 命令（该命令返回结果中的 Command 列就表示当前的状态）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhiugvctrxercytvbuikml.png"></p>
<p>​	在一个查询的生命周期中，状态会变化很多次。这里就不详细列出来了，上图中的 <code>Sleep</code> 状态就是说当前连接正在等待客户端发送新的请求，<code>Query</code> 状态表示当前连接正在执行查询或者正在将结果发送给客户端。</p>
<p>​	在 MyQL 的默认设置中，如果一个连接处在 Sleep 状态 8 小时（就是超过 8 小时没有使用），服务器将断开这条连接，后续在该连接上进行的所有操作都将失败。这个时间是由参数 <code>wait_timeout</code> 控制的：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhugfcdxrsdtcfybhj.png"></p>
<h4 id="查询缓存（Query-Cache）"><a href="#查询缓存（Query-Cache）" class="headerlink" title="查询缓存（Query Cache）"></a>查询缓存（Query Cache）</h4><p>OK，连接建立完成后，我们就可以输入 select 语句进行查询了。执行逻辑就来到了第二步：查询缓存。</p>
<p>官方文档是这样解释 Query Cache 的：</p>
<blockquote>
<p>The query cache stores the text of a SELECT statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client.</p>
</blockquote>
<p>​	就是说查询缓存存储了 SELECT 语句的文本以及响应给客户端的相应结果。这样，如果服务器稍后接收到相同的 SELECT 语句，服务器会先从查询缓存中检索结果，而不是再次解析和执行该语句。查询缓存在 session 之间共享，因此可以发送一个客户端生成的结果集以响应另一个客户端发出的相同查询。</p>
<p>​	如果当前的查询恰好命中了查询缓存，那么<strong>在返回查询结果之前 MySQL 会检查一次用户权限</strong>。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。</p>
<p>​	那么既然涉及到缓存，就必然绕不开缓存一致性问题了。值得庆幸的是，不需要我们进行额外操作，查询缓存并不会返回陈旧数据！</p>
<blockquote>
<p>The query cache does not return stale data. When tables are modified, any relevant entries in the query cache are flushed.</p>
</blockquote>
<p>当表被修改时，查询缓存中的任何相关条目都会被 flushed，注意，这里的 flushed 翻译为<strong>清空</strong>而不是刷新。</p>
<p>看起来好像还不错？不用我们手动操作，失效缓存就能够被自动清空。</p>
<p>然而，很不幸的是，正是由于这个特性，<strong>从 MySQL 5.7.20 开始，官方不再推荐使用查询缓存，并在 MySQL 8.0 中直接删除了查询缓存！</strong></p>
<blockquote>
<p>The query cache is deprecated as of MySQL 5.7.20, and is removed in MySQL 8.0.</p>
</blockquote>
<p>​	其实不难理解，举个例子，对于一个流量很大的论坛项目来说，查询帖子表的需求每时每刻都存在，帖子也几乎每时每刻都在增加，那只要这个表一更新，这个表上所有的查询缓存都会被清空，这对于 MySQL 数据库的压力之大，可想而知了吧。费个劲把查询结果存起来，还没来得及使用呢，就被一个更新全清空了。</p>
<p>​	对于 MySQL 8.0 之前的版本来说，你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样所有的 SQL 语句都不会再使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from t1 where id = 1;</span><br></pre></td></tr></table></figure>

<h4 id="解析器（Parser）"><a href="#解析器（Parser）" class="headerlink" title="解析器（Parser）"></a>解析器（Parser）</h4><p>​	如果没有命中或者没有开启查询缓存，MySQL 服务器接下来要做的就是将一条 SQL 语句转换成一个执行计划，再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析 SQL、预处理、优化 SQL 执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。</p>
<p>其中<strong>解析 SQL 和预处理</strong>就是解析器做的事情，优化 SQL 执行计划就是优化器做的事情。这里我们先说解析器。</p>
<p>​	所谓解析 SQL 就是说，MySQL 通过关键字对 SQL 语句进行解析，并生成一棵对应的 “<strong>解析树</strong>”，用于根据语法规则来验证语句是否正确。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。</p>
<p>​	而预处理则会进一步检查解析树是否合法，例如，检查数据表和数据列是否存在，检查表名和字段名是否正确等。</p>
<h4 id="优化器（Optimizer）"><a href="#优化器（Optimizer）" class="headerlink" title="优化器（Optimizer）"></a>优化器（Optimizer）</h4><p>​	现在，解析树是合法的了，MySQL 已经知道你要做什么了。不过，一条查询可以有很多种执行计划，最后都返回相同的结果，那到底该选择哪种执行计划呢？</p>
<p>举个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id = 10 and name = &quot;good&quot;;</span><br></pre></td></tr></table></figure>

<p>​	对于上面这个语句，可以先查找 name &#x3D; good 再查找 id &#x3D; 10，也可以先查找  id &#x3D; 10 再查找 name &#x3D; good，这两种不同的执行计划可能耗费的时间成本是不一样的。</p>
<p>​	那么<strong>优化器的作用就是找到这其中最好的执行计划</strong>。需要注意的是，这里的执行计划是一个数据结构，而不是和很多其他的关系型数据库那样会生成对应的字节码。</p>
<p>​	另外，优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。</p>
<p>​	当优化器阶段完成后，这个语句的执行计划就确定下来了，就可以进入执行器阶段了。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>​	和命中查询缓存一样，在开始执行 SQL 语句之前，执行器会先判断一下当前用户对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p>
<p>​	权限认证完成后，MySQL 就会根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是我们称为 “handler API” 的接口。</p>
<p>​	查询中的每一个表由一个 handler 的实例表示。实际上，MySQL 在优化阶段就为每个表创建了一个 handler 实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名、索引统计信息，等等。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id = 10;</span><br></pre></td></tr></table></figure>

<p>假设我们使用默认的 InnoDB 引擎，则执行器的执行流程大概是这样的（注意，如果 id 不是索引则会进行全表扫描，一行一行的查找，如果是索引则会在索引组织表中查询，比较负责。这里以非索引举例）：</p>
<p>1）调用 InnoDB 引擎接口获取这个表的第一行记录，判断 id 值是不是 10，如果是则将这行记录存在一个集合中；如果不是则进入下一行的判断，直到取到这个表的最后一行</p>
<p>2）执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果返回给客户端</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhugvycdxrszxdtvguij.png"></p>
<ol>
<li>MySQL 客户端与服务器间建立连接，客户端发送一条查询给服务器；</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果；否则进入下一阶段；</li>
<li>服务器端进行 SQL 解析、预处理，生成合法的解析树；</li>
<li>再由优化器生成对应的执行计划；</li>
<li>MySQL 根据优化器生成的执行计划，调用相应的存储引擎的 API 来执行，并将执行结果返回给客户端。</li>
</ol>
<h3 id="一条-SQL-的执行过程"><a href="#一条-SQL-的执行过程" class="headerlink" title="一条 SQL 的执行过程"></a>一条 SQL 的执行过程</h3><p>这个需要分成两种，查询（select）和修改（delete、update、insert）</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>连接器 —-&gt; 查询缓存（命中直接返回，未命中进行后面操作） —-&gt; 解析器 —-&gt; 优化器 —-&gt; 执行器与存储引擎配合操作</p>
<h4 id="delete、update、insert"><a href="#delete、update、insert" class="headerlink" title="delete、update、insert"></a>delete、update、insert</h4><p>连接器 —-&gt; 解析器 —-&gt; 优化器 —-&gt; 执行器与存储引擎配合操作（这里有对binlog、与redo log的写入操作）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/" data-id="clpsh979c0016xgvs1xmg0bwx" data-title="SQL复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/19/Redis/" class="article-date">
  <time class="dt-published" datetime="2021-07-19T11:33:52.000Z" itemprop="datePublished">2021-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL/">SQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/19/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<blockquote>
<p>​	<strong><code>Redis(Remote Dictionary Server)</code> ：</strong>是一个使用 <strong><code>C</code> 语言</strong>编写的，开源的（<code>BSD</code>许可）<strong>高性能非关系型</strong>（<code>NoSQL</code>）的<strong>键值对</strong>数据库。</p>
<p>​	与传统数据库不同的是 <code>Redis</code> 的数据是存在<strong>内存</strong>中的，所以读写速度非常快，因此 <code>redis</code> 被广泛应用于缓存方向，每秒可以处理超过 <code>10</code> 万次读写操作，是已知性能最快的 <code>Key-Value DB</code>。另外，<code>Redis</code> 也经常用来做分布式锁。除此之外，<code>Redis</code> 支持事务 、持久化、<code>LUA</code>脚本、<code>LRU</code>驱动事件、多种集群方案。</p>
</blockquote>
<h2 id="redis文件的一些说明"><a href="#redis文件的一些说明" class="headerlink" title="redis文件的一些说明"></a>redis文件的一些说明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark     //用于进行redis性能测试的工具</span><br><span class="line">redis-check-dump    //用于修复出问题的dump.rdb文件</span><br><span class="line">redis-cli           //redis的客户端</span><br><span class="line">redis-server        //redis的服务端</span><br><span class="line">redis-check-aof     //用于修复出问题的AOF文件</span><br><span class="line">redis-sentinel      //用于集群管理</span><br></pre></td></tr></table></figure>

<h2 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h2><h3 id="八大数据类型"><a href="#八大数据类型" class="headerlink" title="八大数据类型"></a>八大数据类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string：最基本的数据类型，二进制安全的字符串，最大512M。</span><br><span class="line">list：按照添加顺序保持顺序的字符串列表。</span><br><span class="line">set：无序的字符串集合，不存在重复的元素。</span><br><span class="line">sorted set：已排序的字符串集合。</span><br><span class="line">hash：key-value对的一种集合。</span><br><span class="line">bitmap：更细化的一种操作，以bit为单位。</span><br><span class="line">hyperloglog：基于概率的数据结构。</span><br><span class="line">Geo：地理位置信息储存起来，并对这些信息进行操作</span><br></pre></td></tr></table></figure>

<h3 id="常见的五种数据类型"><a href="#常见的五种数据类型" class="headerlink" title="常见的五种数据类型"></a>常见的五种数据类型</h3><h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h4><blockquote>
<ul>
<li><code>string</code>是<code>redis</code>最基本的类型，一个<code>key</code>对应一个<code>value</code>。</li>
<li><code>string</code>类型是二进制安全的。意思是<code>redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</li>
<li><code>string</code>类型是<code>Redis</code>最基本的数据类型，一个键最大能存储<code>512MB</code>。</li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-strings.html">String类型的操作参考</a></li>
</ul>
</blockquote>
<h4 id="List-链表"><a href="#List-链表" class="headerlink" title="List 链表"></a>List 链表</h4><blockquote>
<ul>
<li><code>redis</code>列表是简单的字符串列表，排序为插入的顺序。列表的最大长度为<code>2^32 - 1</code>。</li>
<li><code>redis</code>的列表是使用链表实现的，这意味着，即使列表中有上百万个元素，增加一个元素到列表的头部或尾部的操作都是在常量的时间完成。</li>
<li>可以用列表获取最新的内容（像帖子，微博等），用<code>ltrim</code>很容易就会获取最新的内容，并移除旧的内容。</li>
<li>用列表可以实现生产者消费者模式，生产者调用<code>lpush</code>添加项到列表中，消费者调用<code>rpop</code>从列表中提取，如果没有元素，则轮询去获取，或者使用<code>brpop</code>等待生产者添加项到列表中。</li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-lists.html">List类型的操作参考</a></li>
</ul>
</blockquote>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><blockquote>
<ul>
<li><code>redis</code>集合是无序的字符串集合，集合中的值是唯一的，无序的。可以对集合执行很多操作，例如，测试元素是否存在，对多个集合执行交集、并集和差集等等。</li>
<li>我们通常可以用集合存储一些无关顺序的，表达对象间关系的数据，例如用户的角色，可以用<code>sismember</code>很容易就判断用户是否拥有某个角色。</li>
<li>在一些用到随机值的场合是非常适合的，可以用 <code>srandmember/spop</code> 获取&#x2F;弹出一个随机元素。<br>同时，使用<code>@EnableCaching</code>开启声明式缓存支持，这样就可以使用基于注解的缓存技术。注解缓存是一个对缓存使用的抽象，通过在代码中添加下面的一些注解，达到缓存的效果。</li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-sets.html">Set类型的操作参考</a></li>
</ul>
</blockquote>
<h4 id="ZSet-有序集合"><a href="#ZSet-有序集合" class="headerlink" title="ZSet 有序集合"></a>ZSet 有序集合</h4><blockquote>
<ul>
<li>有序集合由唯一的，不重复的字符串元素组成。有序集合中的每个元素都关联了一个浮点值，称为分数。可以把有序看成<code>hash</code>和集合的混合体，分数即为<code>hash</code>的<code>key</code>。</li>
<li>有序集合中的元素是按序存储的，不是请求时才排序的。</li>
<li>有序集合的成员是唯一的,但分数(score，一个 double 类型的分数)却可以重复。</li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-sorted-sets.html">ZSet类型的操作类型</a></li>
</ul>
</blockquote>
<blockquote>
<p>有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用<code>ziplist</code>编码：</p>
<ul>
<li>元素数量小于128个</li>
<li>所有member的长度都小于64字节</li>
</ul>
</blockquote>
<blockquote>
<p>​		ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同，<code>每个节点可以用来存储一个整数或者一个字符串</code>。</p>
<p>​		<code>ziplist类似于双向链表，但是它不存储上一个节点和下一个节点的指针，而是存储上一个节点长度和当前节点长度</code>，通过牺牲部分读写性能，来换取高效的内存空间利用率，节约内存。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/dcfvdsfvdsfvdvervsadcsdvcdsvdcs70201254.png"></p>
<ul>
<li>zlbytes：记录了压缩列表占用的内存字节数，在对压缩列表进行内存重分配，或者计算zlend的位置时使用。它本身占了4个字节。</li>
<li>zltail：记录了尾节点（entry）至起始节点（entry）的偏移量。通过这个偏移量，可以快速确定最后一个entry节点的地址。</li>
<li>zllen：记录了entry节点的数量。当zllen的值小于65535时，这个值就表示节点的数量。当zllen的值大于65535时，节点的真实数量需要遍历整个压缩列表才能得出。</li>
<li>entry：压缩列表中所包含的每个节点。每个节点的长度根据该节点的内容来决定。</li>
<li>zlend：特殊值0XFF，标记了压缩列表的末端。表示该压缩列表到此为止。</li>
<li>prelen：记录<strong>前驱节点的长度。</strong></li>
<li>encoding：记录<strong>当前节点</strong>的value成员的<strong>数据类型以及长度。</strong></li>
<li>entry-data：根据encoding来保存<strong>字节数组或整数</strong>。</li>
</ul>
<p>​		压缩列表ziplist结构本身就是一个连续的内存块，由表头、若干个entry节点和压缩列表尾部标识符zlend组成，通过一系列编码规则，提高内存的利用率，使用于存储整数和短字符串。</p>
<p>​		压缩列表ziplist结构的缺点是：每次插入或删除一个元素时，都需要进行频繁的进行内存的扩展或减小，然后进行数据”搬移”，甚至可能引发连锁更新，造成严重效率的损失。</p>
</blockquote>
<h5 id="skiplist介绍"><a href="#skiplist介绍" class="headerlink" title="skiplist介绍"></a>skiplist介绍</h5><h6 id="跳表具有如下性质"><a href="#跳表具有如下性质" class="headerlink" title="跳表具有如下性质"></a>跳表具有如下性质</h6><blockquote>
<p><strong>(1) 由很多层结构组成</strong></p>
<p><strong>(2) 每一层都是一个有序的链表</strong></p>
<p><strong>(3) 最底层(Level 1)的链表包含所有元素</strong></p>
<p><strong>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</strong></p>
<p><strong>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</strong></p>
</blockquote>
<p>(skiplist介绍来源于<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38008100/article/details/94629753?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164491716916780271587899%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164491716916780271587899&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-94629753.pc_search_result_cache&utm_term=zset&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_38008100/article/details/94629753?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164491716916780271587899%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164491716916780271587899&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-94629753.pc_search_result_cache&amp;utm_term=zset&amp;spm=1018.2226.3001.4187</a>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> keyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> valueType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    keyType key;	<span class="comment">// 即“键”，起到索引作用</span></span><br><span class="line">    valueType value;	<span class="comment">// 即“值”，用于存储数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next[<span class="number">1</span>];	<span class="comment">// 后继指针数组，柔性数组</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>

<p style="text-indent:2em;">跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</p>

<p style="text-indent:2em;">先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）</p>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnibhugvycftdxredtcyvub.png"></p>
<p>​		在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p>
<p>​		假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/njhbuvgtycrtxetrcyvybiun.png"></p>
<p>​		这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnkbhgfcdxtcfygbhjn.png"></p>
<ul>
<li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li>
<li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li>
<li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li>
</ul>
<p>​		在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p>
<p>​		利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnibhugvyfctdfygbhjnom.png"></p>
<p>​		在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p>
<p>​		skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>​		skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnhbugvfycdtxrtcfybh.png"></p>
<p>​		从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p>
<p>​		skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
<p>​	刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnbhugvyctdxcfygbhijn.png"></p>
<p>​		需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p>
<p>​		实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p>
<p>​		执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ul>
<li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li>
<li>如果一个节点有第i层(i&gt;&#x3D;1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li>
<li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li>
</ul>
<h5 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h5><blockquote>
<ul>
<li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p>
</li>
<li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p>
</li>
<li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>
</li>
<li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1&#x2F;(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p&#x3D;1&#x2F;4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
</li>
<li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p>
</li>
<li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>
</li>
</ul>
</blockquote>
<h4 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash 哈希"></a>Hash 哈希</h4><blockquote>
<ul>
<li><code>redis</code>的哈希值是字符串字段和字符串之间的映射，是表示对象的完美数据类型。</li>
<li>哈希中的字段数量没有限制，所以可以在你的应用程序以不同的方式来使用哈希。</li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-hashes.html">Hash类型的操作参考</a></li>
</ul>
</blockquote>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>​		<code>Redis</code> 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>　　总结说：<code>redis</code>事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　</p>
</blockquote>
<h3 id="Redis事务没有隔离级别的概念"><a href="#Redis事务没有隔离级别的概念" class="headerlink" title="Redis事务没有隔离级别的概念"></a>Redis事务没有隔离级别的概念</h3><blockquote>
<p>​		批量操作在发送 <code>exec</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
</blockquote>
<h3 id="Redis不保证原子性"><a href="#Redis不保证原子性" class="headerlink" title="Redis不保证原子性"></a>Redis不保证原子性</h3><blockquote>
<p>​		<code>Redis</code>中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
</blockquote>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><blockquote>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
</blockquote>
<h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><blockquote>
<ul>
<li><code>watch key1 key2 ...</code> : 监视一或多个<code>key</code>,如果在事务执行之前，被监视的<code>key</code>被其他命令改动，则事务被打断 （ 类似乐观锁 ）</li>
<li><code>multi</code> : 标记一个事务块的开始（ <code>queued</code> ）</li>
<li><code>exec</code> : 执行所有事务块的命令 （ 一旦执行<code>exec</code>后，之前加的监控锁都会被取消掉 ）　</li>
<li><code>discard</code> : 取消事务，放弃事务块中的所有命令</li>
<li><code>unwatch</code> : 取消<code>watch</code>对所有<code>key</code>的监控</li>
<li><strong><code>Redis</code> 禁止在 <code>multi</code> 和 <code>exec</code> 之间执行 <code>watch</code> 指令，而必须在 <code>multi</code> 之前做好盯住关键变量，否则会出错。</strong></li>
</ul>
</blockquote>
<h3 id="Redis事务使用案例"><a href="#Redis事务使用案例" class="headerlink" title="Redis事务使用案例"></a>Redis事务使用案例</h3><blockquote>
<p>正常执行</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/uygbhjgsuiadsbjdvaduhjbd4234.png"></p>
<blockquote>
<p>放弃事务</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/hgfvdsathyjukltku6y5t456u7uy.png"></p>
<blockquote>
<p>​	若在事务队列中存在命令性错误（类似于<code>java</code>编译性错误），则执行<code>EXEC</code>命令时，所有命令都不会执行</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/o877jtehtbfvfbgnhj7u6y5t3q4wfesdvfb.png"></p>
<blockquote>
<p>​	若在事务队列中存在语法性错误（类似于<code>java</code>的<code>1/0</code>的运行时异常），则执行<code>EXEC</code>命令时，其他正确命令会被执行，错误命令抛出异常。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/o9678iruteyhtsbdfavr4t.png"></p>
<blockquote>
<p> 使用<code>watch</code></p>
</blockquote>
<blockquote>
<p>案例一：使用<code>watch</code>检测<code>balance</code>，事务期间<code>balance</code>数据未变动，事务执行成功</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/o78rutysgbavdsef4t325y46h.png"></p>
<blockquote>
<p>案例二：使用<code>watch</code>检测<code>balance</code>，在开启事务后（标注<code>1</code>处），在新窗口执行标注<code>2</code>中的操作，更改<code>balance</code>的值，模拟其他客户端在事务执行期间更改<code>watch</code>监控的数据，然后再执行标注<code>1</code>后命令，执行<code>EXEC</code>后，事务未成功执行。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/7u6eyhtsbdfvrgt4325y4.png"></p>
<blockquote>
<p>​			一但执行 <code>EXEC</code> 开启事务的执行后，无论事务使用执行成功， <code>WARCH</code> 对变量的监控都将被取消。</p>
<p>​			故当事务执行失败后，需重新执行<code>WATCH</code>命令对变量进行监控，并开启新的事务进行操作。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>​		<code>watch</code>指令类似于乐观锁，在事务提交时，如果<code>watch</code>监控的多个<code>KEY</code>中任何<code>KEY</code>的值已经被其他客户端更改，则使用<code>EXEC</code>执行事务时，事务队列将不会被执行，同时返回<code>Nullmulti-bulk</code>应答以通知调用者事务执行失败。</p>
</blockquote>
<h2 id="Redis优缺点"><a href="#Redis优缺点" class="headerlink" title="Redis优缺点"></a>Redis优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ul>
<li>读写性能优异，<code>Redis</code>能读的速度是<code>110000次/s</code>，写的速度是<code>81000次/s</code>。</li>
<li>支持数据持久化，支持<code>AOF</code>和<code>RDB</code>两种持久化方式。</li>
<li>支持事务，<code>Redis</code>的所有操作都是原子性的，同时<code>Redis</code>还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持<code>string</code>类型的<code>value</code>外还支持<code>hash</code>、<code>set</code>、<code>zset</code>、<code>list</code>等数据结构。</li>
<li>支持主从复制、主机会自动将数据同步到从机，可以进行读写分离。</li>
<li>支持集群、分布式锁</li>
</ul>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此<code>Redis</code>适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li><code>Redis</code> 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的<code>IP</code>才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换<code>IP</code>后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
</blockquote>
<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><blockquote>
<ul>
<li><p><strong>计数器</strong>：可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 </p>
</li>
<li><p><strong>缓存</strong>：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 </p>
</li>
<li><p><strong>会话缓存</strong>：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 </p>
</li>
<li><p><strong>全页缓存（FPC）</strong>：除基本的会话 token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 </p>
</li>
<li><p><strong>查找表</strong>：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 </p>
</li>
<li><p><strong>消息队列</strong>：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 </p>
</li>
<li><p><strong>分布式锁实现</strong>：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 </p>
</li>
<li><p><strong>其它</strong>：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
</li>
</ul>
</blockquote>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快?"></a>Redis为什么这么快?</h2><blockquote>
<ol>
<li><p>绝大部分请求是纯粹的内存操作（非常快速）</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
</li>
<li><p>非阻塞IO - IO多路复用，Redis采用epoll做为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I&#x2F;O上浪费过多的时间。</p>
</li>
<li><p>高效的数据结构</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/hgvfcdxszaesdxcbhk.png"></p>
</li>
</ol>
</blockquote>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/hjghfgdfsaeszrgvbhk.png"></p>
<blockquote>
<p>多路I&#x2F;O复用技术可以让单个线程高效的处理多个连接请求，而Redis使用用epoll作为I&#x2F;O多路复用技术的实现。并且，Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。 </p>
<p> 什么是I&#x2F;O多路复用？ </p>
<ul>
<li><p>I&#x2F;O ：网络 I&#x2F;O </p>
</li>
<li><p>多路 ：多个网络连接 </p>
</li>
<li><p>复用：复用同一个线程。 </p>
</li>
<li><p>IO多路复用其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；而没有文件句柄就绪时,就会阻塞应用程序，交出cpu。</p>
</li>
</ul>
</blockquote>
<h3 id="虚拟内存机制"><a href="#虚拟内存机制" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h3><blockquote>
<p> Redis直接自己构建了VM机制 ，不会像一般的系统会调用系统函数处理，会浪费一定的时间去移动和请求。 </p>
<p> <strong>Redis的虚拟内存机制是啥呢？</strong> </p>
<p> 虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p>
</blockquote>
<h2 id="redis的内部实现"><a href="#redis的内部实现" class="headerlink" title="redis的内部实现"></a>redis的内部实现</h2><blockquote>
<p>​	redis分客户端和服务端，一次完整的redis请求事件有多个阶段（客户端到服务器的网络连接–&gt;redis读写事件发生–&gt;redis服务端的数据处理（单线程）–&gt;数据返回）。</p>
<p>​	平时所说的redis单线程模型，本质上指的是服务端的数据处理阶段，不牵扯网络连接和数据返回，这是理解redis单线程的第一步。</p>
</blockquote>
<h3 id="客户端到服务器的网络连接"><a href="#客户端到服务器的网络连接" class="headerlink" title="客户端到服务器的网络连接"></a>客户端到服务器的网络连接</h3><blockquote>
<p>​	首先，客户端和服务器是socket通信方式，socket服务端监听可同时接受多个客户端请求，这点很重要，如果不理解可先记住。注意这里可以理解为本质上与redis无关，这里仅仅做网络连接，或者可以理解为，为redis服务端提供网络交互api。</p>
<p>​	假设建立网络连接需要30秒（为了更容易理解，所以时间上扩大了N倍）</p>
</blockquote>
<h3 id="redis读写事件发生并向服务端发送请求数据"><a href="#redis读写事件发生并向服务端发送请求数据" class="headerlink" title="redis读写事件发生并向服务端发送请求数据"></a>redis读写事件发生并向服务端发送请求数据</h3><blockquote>
<p>​    首先确定一点，redis的客户端与服务器端通信是基于TCP连接（不懂去看，基础很重要），第一阶段仅仅是建立了客户端到服务器的网络连接，然后才是发生第二阶段的读写事件。</p>
<p>​    完成了上一个阶段的网络连接，redis客户端开始真正向服务器发起读写事件，假设是set（写）事件，此时redis客户端开始向建立的网络流中送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。</p>
<p>​    假设从客户端发数据，到服务端接收完数据需要10秒。</p>
</blockquote>
<h3 id="redis服务端的数据处理"><a href="#redis服务端的数据处理" class="headerlink" title="redis服务端的数据处理"></a>redis服务端的数据处理</h3><blockquote>
<p>​    服务端完成了第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。数据处理可以理解为一次方法调用，带参调用方法，最终得到方法返回值。不要想复杂，重在理解流程。</p>
<p>​    假设redis服务端处理数据需要0.1秒</p>
</blockquote>
<h3 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h3><blockquote>
<p>​    这一阶段很简单，当reids服务端数据处理完后 就会立即返回处理后的数据，没什么特别需要强调的。</p>
<p>​    假设服务端把处理后的数据回送给客户端需要5秒。</p>
</blockquote>
<blockquote>
<p>​		第一阶段说过，redis是以socket方式通信，socket服务端可同时接受多个客户端请求连接，也就是说，redis服务同时面对多个redis客户端连接请求，而redis服务本身是单线程运行。<font color='red'>客户端与服务端建立连接交由socket，可以同时建立多个连接（这里应该是多线程&#x2F;多进程），建立的连接redis是知道的，然后redis会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（<strong>注意：不是探测哪个连接建立好了，而是探测哪个接收完了请求数据</strong>），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。<strong>注意，从探测到数据处理再到数据返回，全程单线程。</strong>这应该就是所谓的redis单线程。</font></p>
</blockquote>
<h2 id="Redis关于线程安全问题"><a href="#Redis关于线程安全问题" class="headerlink" title="Redis关于线程安全问题"></a>Redis关于线程安全问题</h2><blockquote>
<p>​	redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。</p>
</blockquote>
<h2 id="Redis6-0为何引入多线程？"><a href="#Redis6-0为何引入多线程？" class="headerlink" title="Redis6.0为何引入多线程？"></a>Redis6.0为何引入多线程？</h2><blockquote>
<ul>
<li>Redis6.0之前，Redis在处理客户端的请求时，包括读socket、解析、执行、写socket等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。 </li>
<li>Redis6.0之前为什么一直不使用多线程？使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。</li>
</ul>
<p>​		redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。 </p>
<p>​		这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p>
</blockquote>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h3><p>既然redis的数据可以保存在磁盘上，那么这个流程是什么样的呢？</p>
<p>要有下面五个过程：</p>
<blockquote>
<ol>
<li>客户端向服务端发送写操作(数据在客户端的内存中)。</li>
<li>数据库服务端接收到写请求的数据(数据在服务端的内存中)。</li>
<li>服务端调用write这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。</li>
<li>操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。</li>
<li>磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。</li>
</ol>
</blockquote>
<blockquote>
<p>这5个过程是在理想条件下一个正常的保存流程，但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：</p>
<p>（1）Redis数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。</p>
<p>（2）操作系统发生故障，必须上面5步都完成才可以。</p>
<p>在这里只考虑了保存的过程可能发生的故障，其实保存的数据也有可能发生损坏，需要一定的恢复机制，不过在这里就不再延伸了。现在主要考虑的是redis如何来实现上面5个保存磁盘的步骤。它提供了两种策略机制，也就是RDB和AOF。</p>
</blockquote>
<h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><blockquote>
<p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到<strong>二进制文件</strong>中，默认的文件名为dump.rdb。</p>
</blockquote>
<blockquote>
<p>​	<code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p>
</blockquote>
<p><code>bgsave</code>是主流的触发 RDB 持久化的方式，执行过程如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png"></p>
<blockquote>
<ul>
<li>执行<code>BGSAVE</code>命令</li>
</ul>
<ul>
<li>Redis 父进程判断当前<strong>是否存在正在执行的子进程</strong>，如果存在，<code>BGSAVE</code>命令直接返回。 </li>
<li>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。 </li>
<li>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>； </li>
<li>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</li>
</ul>
<p>Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。</p>
</blockquote>
<blockquote>
<p>既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化。我们分别来看一下</p>
</blockquote>
<h4 id="save触发方式"><a href="#save触发方式" class="headerlink" title="save触发方式"></a>save触发方式</h4><blockquote>
<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg"></p>
<blockquote>
<p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
</blockquote>
<h4 id="bgsave触发方式"><a href="#bgsave触发方式" class="headerlink" title="bgsave触发方式"></a>bgsave触发方式</h4><blockquote>
<p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg"></p>
<blockquote>
<p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jkbhjgvfctdxgvbhjlk.png"></p>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p>
<blockquote>
<ol>
<li><strong>save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li>
</ol>
</blockquote>
<p>默认如下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1       #表示900 秒内如果至少有 1 个 key 的值变化</span><br><span class="line">save 300 10      #表示300 秒内如果至少有 10 个 key 的值变化</span><br><span class="line">save 60 10000    #表示60 秒内如果至少有 10000 个 key 的值变化</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p>
</blockquote>
<blockquote>
<ol start="2">
<li><p><strong>stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p>
</li>
<li><p><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p>
</li>
<li><p><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
</li>
<li><p><strong>dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p>
</li>
<li><p><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p>
</li>
</ol>
</blockquote>
<h4 id="RDB-的优势和劣势"><a href="#RDB-的优势和劣势" class="headerlink" title="RDB 的优势和劣势"></a>RDB 的优势和劣势</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><blockquote>
<ol>
<li><strong>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</strong>。 </li>
<li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li>
</ol>
</blockquote>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><blockquote>
<ol>
<li><strong>RDB方式数据无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。 </li>
<li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li>
</ol>
</blockquote>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><blockquote>
<p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p>
</blockquote>
<h4 id="AOF-持久化执行流程"><a href="#AOF-持久化执行流程" class="headerlink" title="AOF 持久化执行流程"></a>AOF 持久化执行流程</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B0.png"></p>
<blockquote>
<ol>
<li>所有的写入命令会追加到 AOF 缓冲区中。 </li>
<li>AOF 缓冲区根据对应的策略向硬盘同步。 </li>
<li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。 </li>
<li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
</blockquote>
<h4 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h4><blockquote>
<p>每当有一个写命令过来时，就直接保存在我们的AOF文件中。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg"></p>
<h4 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h4><blockquote>
<p>​		因为 AOF 持久化是通过保存被执行的写命令来记录 Redis 状态的，所以随着 Redis 长时间运行，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 甚至宿主计算机造成影响。</p>
<p>​		为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写( rewrite) 功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的荣誉命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/623378-f4a19a6b0e3532de.png"></p>
<blockquote>
<p>​		如上图所示，重写前要记录名为 <code>list</code>的键的状态，AOF 文件要保存五条命令，而重写后，则只需要保存一条命令。</p>
<p>​		<strong>AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。</strong></p>
<p>​		在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超过 REDISAOFREWRITEITEMSPER_CMD ( 一般为64 )常量，则使用多条命令记录该键的值，而不是一条命令。</p>
<p>rewrite的触发机制主要有一下三个：</p>
<ul>
<li>手动调用 bgrewriteaof 命令，如果当前有正在运行的 rewrite 子进程，则本次rewrite 会推迟执行，否则，直接触发一次 rewrite。</li>
<li>通过配置指令手动开启 AOF 功能，如果没有 RDB 子进程的情况下，会触发一次 rewrite，将当前数据库中的数据写入 rewrite 文件。</li>
<li>在 Redis 定时器中，如果有需要退出执行的 rewrite 并且没有正在运行的 RDB 或者 rewrite 子进程时，触发一次或者 AOF 文件大小已经到达配置的 rewrite 条件也会自动触发一次。</li>
</ul>
</blockquote>
<h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><blockquote>
<p>AOF 重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以 Redis 在子进程中执行 AOF 重写操作。</p>
<ul>
<li>子进程进行 AOF 重写期间，Redis 进程可以继续处理客户端命令请求。</li>
<li>子进程带有父进程的内存数据拷贝副本，在不适用锁的情况下，也可以保证数据的安全性。</li>
</ul>
<p>​		但是，在子进程进行 AOF 重启期间，Redis接收客户端命令，会对现有数据库状态进行修改，从而导致数据当前状态和 重写后的 AOF 文件所保存的数据库状态不一致。</p>
<p>​		为此，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/623378-fc2a68fc8c8ec78b.png"></p>
<blockquote>
<p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接收到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容写入到新的 AOF 文件中，保证新 AOF 文件保存的数据库状态和服务器当前状态一致。</li>
<li>对新的 AOF 文件进行改名，原子地覆盖现有 AOF 文件，完成新旧文件的替换</li>
<li>继续处理客户端请求命令。</li>
</ul>
<p>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对 Redis 主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/623378-6c78b84c7c03cd57.png"></p>
<h4 id="AOF触发机制"><a href="#AOF触发机制" class="headerlink" title="AOF触发机制"></a>AOF触发机制</h4><blockquote>
<ol>
<li>每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>
<li>每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>
<li>不同no：从不同步</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/b17eca8065380cd7df69859ba056a5325982816c.jpeg"></p>
<h4 id="AOF-的优势和劣势"><a href="#AOF-的优势和劣势" class="headerlink" title="AOF 的优势和劣势"></a>AOF 的优势和劣势</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><blockquote>
<ol>
<li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。 </li>
<li>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高。</li>
</ol>
</blockquote>
<h5 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h5><blockquote>
<ol>
<li>对于同一份文件AOF文件比RDB数据快照要大。 </li>
<li>数据恢复比较慢。</li>
</ol>
</blockquote>
<h3 id="RDB和AOF到底该如何选择"><a href="#RDB和AOF到底该如何选择" class="headerlink" title="RDB和AOF到底该如何选择"></a>RDB和AOF到底该如何选择</h3><blockquote>
<ol>
<li><p>不要仅仅使用RDB，因为那样会导致你丢失很多数据；</p>
</li>
<li><p>也不要仅仅使用AOF，因为那样有两个问题：</p>
<p>你通过AOF做冷备，没有RDB做冷备，恢复速度更快;<br>第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug；</p>
</li>
<li><p>综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择;</p>
</li>
</ol>
<p>用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复；</p>
<p><strong>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</strong></p>
</blockquote>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
</blockquote>
<blockquote>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/2020050416202957.png"></p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><blockquote>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
</blockquote>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote>
<ol>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ol>
</blockquote>
<h4 id="建立连接阶段"><a href="#建立连接阶段" class="headerlink" title="建立连接阶段"></a>建立连接阶段</h4><blockquote>
<p>建立slave到master的链接，使master能够识别slave，并保存slave端口号</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20200504194755674.png"></p>
<blockquote>
<ol>
<li>设置master的地址和端口，保存master信息</li>
<li>建立socket链接</li>
<li>发送ping命令（定时器任务）</li>
<li>身份验证</li>
<li>发送slave端口信息<br>至此，主从链接成功！<br>状态：<br>slave：保存master的地址和端口<br>master：保存slave的端口<br>总体：之间创建了链接的socket</li>
</ol>
</blockquote>
<h5 id="步骤1：保存主节点信息"><a href="#步骤1：保存主节点信息" class="headerlink" title="步骤1：保存主节点信息"></a>步骤1：保存主节点信息</h5><blockquote>
<p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p>
</blockquote>
<blockquote>
<p>需要注意的是，**slaveof是异步命令，从节点完成主节点 ip 和 port **的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p>
</blockquote>
<h5 id="步骤2：建立socket连接"><a href="#步骤2：建立socket连接" class="headerlink" title="步骤2：建立socket连接"></a>步骤2：建立socket连接</h5><blockquote>
<p>​	从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p>
<p>如果连接成功，则：</p>
<p>​	从节点：为该socket建立一个专门处理复制工作的<strong>文件事件处理器</strong>，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p>
<p>​	主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的<strong>客户端状态</strong>，<strong>并将从节点看作是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></p>
</blockquote>
<h5 id="步骤3：发送ping命令"><a href="#步骤3：发送ping命令" class="headerlink" title="步骤3：发送ping命令"></a>步骤3：发送ping命令</h5><blockquote>
<p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p>
<p>从节点发送ping命令后，可能出现3种情况：</p>
<p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
<p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
</blockquote>
<h5 id="步骤4：身份验证"><a href="#步骤4：身份验证" class="headerlink" title="步骤4：身份验证"></a>步骤4：身份验证</h5><blockquote>
<p>​	如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p>
<p>​	如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p>
</blockquote>
<h5 id="步骤5：发送从节点端口信息"><a href="#步骤5：发送从节点端口信息" class="headerlink" title="步骤5：发送从节点端口信息"></a>步骤5：发送从节点端口信息</h5><blockquote>
<p>​	身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</p>
</blockquote>
<h4 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20200504212431656.png"></p>
<h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><blockquote>
<p>Redis通过psync命令进行全量复制的过程如下：</p>
<ol>
<li>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</li>
<li>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</li>
<li>主节点的bgsave执行完成后，将RDB文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的RDB文件</strong>，将数据库状态更新至主节点执行bgsave时的数据库状态</li>
<li>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</li>
<li>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</li>
</ol>
</blockquote>
<h5 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h5><p>增量复制的实现，依赖于三个重要的概念：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20200505103448789.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20200505103438212.png"></p>
<h6 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h6><blockquote>
<p>​	主节点和从节点分别维护一个复制偏移量（offset），代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>
</blockquote>
<blockquote>
<p>​	offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
</blockquote>
<h6 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h6><blockquote>
<p>​	复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>​	在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>
<p>​	由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p>
<ul>
<li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li>
<li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li>
</ul>
</blockquote>
<h6 id="服务器运行ID-runid"><a href="#服务器运行ID-runid" class="headerlink" title="服务器运行ID(runid)"></a>服务器运行ID(runid)</h6><blockquote>
<p>​	每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/1174710-20180628011537662-712436367.png"></p>
<p>​	主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
</blockquote>
<h4 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h4><blockquote>
<p>​	数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p>
<p><strong>延迟与不一致</strong></p>
<p>​	需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p>
<p>​	repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
<p>​	一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
</blockquote>
<h5 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h5><blockquote>
<p>​	心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
</blockquote>
<h6 id="主-从：PING"><a href="#主-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h6><blockquote>
<p>每隔指定的时间，主节点会向从节点发送 PING 命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p>
</blockquote>
<h6 id="从-主：REPLCONF-ACK"><a href="#从-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h6><blockquote>
<p>在命令传播阶段，从节点会向主节点发送 REPLCONF ACK 命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p>
<ol>
<li><p>实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p>
</li>
<li><p>检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<strong>注意，offset 和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></p>
</li>
</ol>
</blockquote>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><blockquote>
<p>​	哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote>
<ul>
<li><p>集群监控：负责监控 redis master 和 slave 进程是否正常工作。 </p>
</li>
<li><p>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 </p>
</li>
<li><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 </p>
</li>
<li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p>
</li>
</ul>
</blockquote>
<h3 id="哨兵的三个定时任务"><a href="#哨兵的三个定时任务" class="headerlink" title="哨兵的三个定时任务"></a>哨兵的三个定时任务</h3><blockquote>
<ol>
<li>每个哨兵每10秒会向主节点和从节点发送info命令获取最新的拓扑结构图，哨兵配置时只需要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知。</li>
<li>每个Sentinel节点每隔2秒会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断，所以这个定时任务可以完成以下两个工作：发现新的Sentinel节点：通过订阅主节点的__sentinel__：hello了解其他的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接。Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</li>
<li>每隔1秒每个哨兵会向主节点、从节点、其他哨兵发送ping命令，做心跳检测。</li>
</ol>
</blockquote>
<h3 id="主观下线（SDOWN）和客观下线（ODOWN）"><a href="#主观下线（SDOWN）和客观下线（ODOWN）" class="headerlink" title="主观下线（SDOWN）和客观下线（ODOWN）"></a>主观下线（SDOWN）和客观下线（ODOWN）</h3><blockquote>
<ul>
<li><strong>主观下线</strong>：根据定时任务3对没有有效回复的节点做主观下线处理。</li>
<li><strong>客观下线</strong>：若主观下线的是主节点，会联系其他哨兵对此主节点进行判断，一定数量（一半以上吧）的哨兵达成一致意见才认为一个master客观上已经宕机掉，各个哨兵之间通过命令SENTINELis_master_down_by_addr来获得其它哨兵对master的检测结果。</li>
</ul>
</blockquote>
<h3 id="哨兵进程的工作方式"><a href="#哨兵进程的工作方式" class="headerlink" title="哨兵进程的工作方式"></a>哨兵进程的工作方式</h3><blockquote>
<ol>
<li>每个Sentinel（哨兵）进程以<strong>每秒钟一次</strong>的频率向整个集群中的<strong>Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程</strong>发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel（哨兵）进程标记为<strong>主观下线</strong>（<strong>SDOWN</strong>）。</li>
<li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<strong>所有<br>Sentinel（哨兵）</strong>进程要以每秒一次的频率<strong>确认Master主服务器</strong>的确<strong>进入了主观下线状态</strong>。</li>
<li>当<strong>有足够数量的 Sentinel（哨兵）</strong>进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线（ODOWN）</strong>。</li>
<li>在一般情况下， 每个Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li>
<li>当Master主服务器被 Sentinel（哨兵）进程标记为<strong>客观下线（ODOWN）</strong>时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li>
</ol>
</blockquote>
<h3 id="哨兵在进行主从切换过程中经历三个阶段"><a href="#哨兵在进行主从切换过程中经历三个阶段" class="headerlink" title="哨兵在进行主从切换过程中经历三个阶段"></a>哨兵在进行主从切换过程中经历三个阶段</h3><blockquote>
<ol>
<li>监控阶段</li>
<li>通知阶段</li>
<li>故障转移阶段</li>
</ol>
</blockquote>
<h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><blockquote>
<p>用于同步各个节点的状态信息</p>
<ol>
<li><p>获取各个sentinel的状态（是否在线）(info命令)</p>
</li>
<li><p>获取master的状态（info命令，来获取master节点的状态，并可以从master中获取到slave状态，之后就可以通过这里拿到的slave，一个一个去访问slave了）</p>
</li>
</ol>
<ul>
<li>master属性</li>
<li>runid</li>
<li>role：master</li>
<li>各个slave的详细信息</li>
</ul>
<ol start="3">
<li>获取所有slave的状态（根据master中的slave信息）(info命令)</li>
</ol>
<ul>
<li>slave属性</li>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/QQ%E6%88%AA%E5%9B%BE20220217123143.png"></p>
<h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/image-20220114221405409.png"></p>
<h4 id="故障转移阶段"><a href="#故障转移阶段" class="headerlink" title="故障转移阶段"></a>故障转移阶段</h4><h5 id="Sentinel节点领导者选举"><a href="#Sentinel节点领导者选举" class="headerlink" title="Sentinel节点领导者选举"></a>Sentinel节点领导者选举</h5><blockquote>
<p>Sentinel节点对于主节点已经做了客观下线，Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。</p>
<p>Redis Sentinel进行领导者选举的大致思路：</p>
<ol>
<li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。</li>
<li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</li>
<li>如果该Sentinel节点发现自己的票数已经大于等于max（quorum，num（sentinels）&#x2F;2+1），那么它将成为领导者。</li>
<li>如果此过程没有选举出领导者，将进入下一次选举。</li>
</ol>
</blockquote>
<h5 id="故障转移具体步骤"><a href="#故障转移具体步骤" class="headerlink" title="故障转移具体步骤"></a>故障转移具体步骤</h5><blockquote>
<ol>
<li><p>在从节点列表中选出一个节点作为新的主节点，选择方法如下：</p>
<p>1.1 过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。</p>
<p>1.2 选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</p>
<p>1.3 选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</p>
<p>1.4 选择runid最小的从节点。</p>
</li>
<li><p>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点。</p>
</li>
<li><p>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和parallel-syncs参数有关。</p>
</li>
<li><p>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</p>
</li>
</ol>
</blockquote>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="分布式缓存寻址算法"><a href="#分布式缓存寻址算法" class="headerlink" title="分布式缓存寻址算法"></a>分布式缓存寻址算法</h3><blockquote>
<ul>
<li>hash 算法</li>
<li>一致性 hash 算法</li>
<li>hash slot 算法</li>
</ul>
</blockquote>
<h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><blockquote>
<p>根据key进行hash函数运算，结果对分片数取模，确定分片适合固定分片数的场景</p>
</blockquote>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>计算简单，适合固定分片数的场景。</p>
</blockquote>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<p>扩展分片或者减少分片时，所有数据都需要重新计算分片，存储</p>
</blockquote>
<h4 id="一致性-hash-算法"><a href="#一致性-hash-算法" class="headerlink" title="一致性 hash 算法"></a>一致性 hash 算法</h4><blockquote>
<p>​	一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0 ~ 2^32 - 1（即哈希值是一个32位无符号整形）。</p>
</blockquote>
<p>整个哈希环如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20180313200908214.png"></p>
<blockquote>
<p>​	整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32 - 1，也就是说0点左侧的第一个点代表2^32 - 1， 0和2^32 - 1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
</blockquote>
<blockquote>
<p>​	下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20180313201032423.png"></p>
<blockquote>
<p>​	接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
</blockquote>
<blockquote>
<p>​	例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20180313201103575.png"></p>
<blockquote>
<p>​	根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
</blockquote>
<h5 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h5><blockquote>
<p>​	现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/20180313201103575.png"></p>
<blockquote>
<p>​	下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/2018031wefsdcz3201131189.png"></p>
<blockquote>
<p>​	此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
</blockquote>
<blockquote>
<p>​	综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
</blockquote>
<h5 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h5><blockquote>
<p>​	一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/2018safsdcz0313205220384.png"></p>
<blockquote>
<p>​	此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了<strong>虚拟节点机制</strong>，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p>
</blockquote>
<blockquote>
<p>​	例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/201803132dasdasfsd01223343.png"></p>
<blockquote>
<p>​	同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
</blockquote>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>​	在一致性哈希算法中，如果一个结点挂了，受影响的数据仅仅是此节点到环空间前一个结点（沿着逆时针方向行走遇到的第一个结点）之间的数据，其它不受影响。增加一个节点也同理。</p>
</blockquote>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<p>​	一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。</p>
</blockquote>
<h4 id="hash-slot-算法"><a href="#hash-slot-算法" class="headerlink" title="hash slot 算法"></a>hash slot 算法</h4><blockquote>
<p>​	redis cluster有固定的16384个hash slot，对每个key计算CRC16(循环冗余检验码)，然后对16384取模，可以获取key对应的hash slot。</p>
</blockquote>
<blockquote>
<p>redis cluster中每个master都会持有部分slot，比如有3个master的话，那么可能每个master持有5000多个hash slot，而有了hash slot之后让node的增加和移出很简单：</p>
<ul>
<li>增加一个master，就让其他master的hash slot移动部分过去；</li>
<li>减少一个master，就将它的hash slot移动到其他master上去；</li>
</ul>
</blockquote>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote>
<ol>
<li><p>把16384槽按照节点数量进行平均分配，由节点进行管理 </p>
</li>
<li><p>对每个key按照CRC16规则进行hash运算 </p>
</li>
<li><p>把hash结果对16384进行取余 </p>
</li>
<li><p>把余数发送给Redis节点 </p>
</li>
<li><p>节点接收到数据，验证是否在自己管理的槽编号的范围</p>
</li>
</ol>
<ul>
<li><p>如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果    </p>
</li>
<li><p>如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中</p>
</li>
</ul>
</blockquote>
<h3 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640264545850-953b15e7-9dc4-47da-84ea-bb747ed01e3a.png"></p>
<h4 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h4><blockquote>
<ol>
<li>图中描述的是六个redis实例构成的集群，6379端口为客户端通讯端口，16379端口为集群总线端口 </li>
<li>集群内部划分为16384个数据分槽，分布在三个主redis中。 </li>
<li>从redis中没有分槽，不会参与集群投票，也不会帮忙加快读取数据，仅仅作为主机的备份。 </li>
<li>三个主节点中平均分布着16384数据分槽的三分之一，每个节点中不会存有有重复数据，仅仅有自己的从机帮忙冗余。 </li>
<li>所有的redis主节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。 </li>
<li>客户端与redis节点直连，不需要中间proxy层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。 </li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效。</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640264572550-718bc1f7-fe31-4700-a14d-12dbd76f0f5e.png"></p>
<blockquote>
<p>​	Redis 集群中内置了 16384(2^14) 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis先对 key使用 CRC16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>
</blockquote>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><blockquote>
<ul>
<li><p>无中心架构，支持动态扩容，对业务透明 </p>
</li>
<li><p>具备Sentinel的监控和自动Failover(故障转移)能力 </p>
</li>
<li><p>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可 </p>
</li>
<li><p>高性能，客户端直连redis服务，免去了proxy代理的损耗</p>
</li>
</ul>
</blockquote>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<ul>
<li><p>运维也很复杂，数据迁移需要人工干预 </p>
</li>
<li><p>只能使用0号数据库 </p>
</li>
<li><p>不支持批量操作(pipeline管道操作) </p>
</li>
<li><p>分布式逻辑和存储模块耦合等</p>
</li>
</ul>
</blockquote>
<h4 id="Cluster集群节点的通讯"><a href="#Cluster集群节点的通讯" class="headerlink" title="Cluster集群节点的通讯"></a>Cluster集群节点的通讯</h4><blockquote>
<p>​	一个Redis集群由多个节点组成，<strong>各个节点之间是怎么通信的呢</strong>？通过<strong>Gossip协议</strong>！ </p>
<p>​	Redis Cluster集群通过Gossip协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640265551713-9c8f74ef-c958-4d26-b9da-37d8ad8f6ba4.png"></p>
<blockquote>
<ul>
<li>meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li>
</ul>
<ul>
<li><p>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。 </p>
</li>
<li><p>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。 </p>
</li>
<li><p>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</p>
</li>
</ul>
<p>​    特别的，每个节点是通过<strong>集群总线(cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p>
</blockquote>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><blockquote>
<p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁；</li>
<li>基于Redis的分布式锁；</li>
<li>基于ZooKeeper的分布式锁；</li>
</ol>
</blockquote>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><blockquote>
<p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h4><p>首先我们要通过Maven引入<code>Jedis</code>开源组件，在<code>pom.xml</code>文件加入下面的代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="加锁代码"><a href="#加锁代码" class="headerlink" title="加锁代码"></a>加锁代码</h4><h5 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SUCCESS</span> <span class="operator">=</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_IF_NOT_EXIST</span> <span class="operator">=</span> <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_WITH_EXPIRE_TIME</span> <span class="operator">=</span> <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p>
<ul>
<li>第一个为key，我们使用key来当锁，因为key是唯一的。</li>
<li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li>
<li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
</blockquote>
<h5 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h5><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
</blockquote>
<h5 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line">    <span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程：1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p>
<p>​	那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p>
</blockquote>
<h4 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h4><h5 id="正确姿势-1"><a href="#正确姿势-1" class="headerlink" title="正确姿势"></a>正确姿势</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">RELEASE_SUCCESS</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。	</p>
<p>​	那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读<a target="_blank" rel="noopener" href="http://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#releaseLock-wrongDemo2">【解锁代码-错误示例2】</a> 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>
</blockquote>
<h5 id="错误示例1-1"><a href="#错误示例1-1" class="headerlink" title="错误示例1"></a>错误示例1</h5><blockquote>
<p>​	最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> &#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="错误示例2-1"><a href="#错误示例2-1" class="headerlink" title="错误示例2"></a>错误示例2</h5><blockquote>
<p>​	这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p>
</blockquote>
<h3 id="分布式锁的7种方案"><a href="#分布式锁的7种方案" class="headerlink" title="分布式锁的7种方案"></a>分布式锁的7种方案</h3><p>(此部分来源于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">https://www.cnblogs.com/wangyingshuo/p/14510524.html</a>)</p>
<blockquote>
<ul>
<li>方案一：SETNX + EXPIRE</li>
<li>方案二：SETNX + value值是（系统时间+过期时间）</li>
<li>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</li>
<li>方案四：SET的扩展命令（SET EX PX NX）</li>
<li>方案五：SET EX PX NX  + 校验唯一随机值,再释放锁</li>
<li>方案六: 开源框架~Redisson</li>
<li>方案七：多机实现的分布式锁Redlock</li>
</ul>
</blockquote>
<blockquote>
<p>​	分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnibhugvyctdrzwerxtcyub.png"></p>
<h4 id="方案一：SETNX-EXPIRE"><a href="#方案一：SETNX-EXPIRE" class="headerlink" title="方案一：SETNX + EXPIRE"></a>方案一：SETNX + EXPIRE</h4><blockquote>
<p>先用<code>setnx</code>来抢锁，如果抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.setnx(key_resource_id,lock_value) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    expire（key_resource_id，<span class="number">100</span>）; <span class="comment">//设置过期时间</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务请求</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这个方案中，<code>setnx</code>和<code>expire</code>两个命令分开了，<strong>「不是原子操作」</strong>。如果执行完<code>setnx</code>加锁，正要执行<code>expire</code>设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了，<strong>「别的线程永远获取不到锁啦」</strong>。</p>
</blockquote>
<h4 id="方案二：SETNX-value值是-系统时间-过期时间"><a href="#方案二：SETNX-value值是-系统时间-过期时间" class="headerlink" title="方案二：SETNX + value值是(系统时间+过期时间)"></a>方案二：SETNX + value值是(系统时间+过期时间)</h4><blockquote>
<p>把过期时间放到<code>setnx</code>的value值里面。如果加锁失败，再拿出value值校验一下即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime; <span class="comment">//系统时间+设置的过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key_resource_id, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(key_resource_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(key_resource_id, expiresStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">         <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>过期时间是客户端自己生成的（System.currentTimeMillis()是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。</li>
<li>如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖</li>
<li>该锁没有保存持有者的唯一标识，可能被别的客户端释放&#x2F;解锁。</li>
</ul>
</blockquote>
<h4 id="方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令"><a href="#方案三：使用Lua脚本-包含SETNX-EXPIRE两条指令" class="headerlink" title="方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)"></a>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h4><p>使用Lua脚本来保证原子性（包含setnx和expire两条指令），lua脚本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> then</span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>加锁代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">lua_scripts</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line"><span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p>这个方案与方案二缺点差不多</p>
<h4 id="方案四：SET的扩展命令（SET-EX-PX-NX）"><a href="#方案四：SET的扩展命令（SET-EX-PX-NX）" class="headerlink" title="方案四：SET的扩展命令（SET EX PX NX）"></a>方案四：SET的扩展命令（SET EX PX NX）</h4><blockquote>
<p>巧用Redis的SET指令扩展参数！（<code>SET key value[EX seconds][PX milliseconds][NX|XX]</code>），它也是原子性的！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET key value[EX seconds][PX milliseconds][NX|XX]</span><br><span class="line"></span><br><span class="line">    NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。</span><br><span class="line">    EX seconds :设定key的过期时间，时间单位是秒。</span><br><span class="line">    PX milliseconds: 设定key的过期时间，单位为毫秒</span><br><span class="line">    XX: 仅当key存在时设置值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key_resource_id, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>问题一：<strong>「锁过期释放了，业务还没执行完」</strong>。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。</li>
<li>问题二：<strong>「锁被别的线程误删」</strong>。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。</li>
</ul>
</blockquote>
<h4 id="方案五：SET-EX-PX-NX-校验唯一随机值-再删除"><a href="#方案五：SET-EX-PX-NX-校验唯一随机值-再删除" class="headerlink" title="方案五：SET EX PX NX  + 校验唯一随机值,再删除"></a>方案五：SET EX PX NX  + 校验唯一随机值,再删除</h4><blockquote>
<p>锁可能被别的线程误删，那我们给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key_resource_id, uni_request_id, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//判断是不是当前线程加的锁,是才释放</span></span><br><span class="line">       <span class="keyword">if</span> (uni_request_id.equals(jedis.get(key_resource_id))) &#123;</span><br><span class="line">        jedis.del(lockKey); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>「判断是不是当前线程加的锁」</strong>和<strong>「释放锁」</strong>不是一个原子操作。如果调用jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jnihbugvfydxrszaeZsrdc.png"></p>
<p>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="方案六：Redisson"><a href="#方案六：Redisson" class="headerlink" title="方案六：Redisson"></a>方案六：Redisson</h4><p>方案五可能存在<strong>锁过期释放，业务没执行完的问题</strong>。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。 </p>
<p> 当前<strong>开源框架Redisson</strong>就解决了这个分布式锁问题。我们一起来看下Redisson底层原理是怎样的吧：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640265815800-c2b5b440-acc6-47f8-a63f-f824b270a6d8.png"></p>
<blockquote>
<p>只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了<strong>锁过期释放，业务没执行完</strong>问题。</p>
</blockquote>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Create config object</span></span><br><span class="line">Config = ...</span><br><span class="line"><span class="comment">// 2. Create Redisson instance</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="comment">// 3. Get Redis based object or service you need</span></span><br><span class="line">RMap&lt;MyKey, MyValue&gt; map = redisson.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>)</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:5379&quot;</span>).setPassword(<span class="string">&quot;123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><br><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rLock.tryLock((<span class="type">long</span>)waitTimeout, (<span class="type">long</span>)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;aquire lock fail&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><font color='red'>	前面六种方案的弊端：它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：1、在Redis的master节点上拿到了锁；2、但是这个加锁的key还没有同步到slave节点；3、master故障，发生故障转移，slave节点升级为master节点；4、导致锁丢失。</font>&gt;</strong></p>
</blockquote>
<h4 id="方案七：Redlock"><a href="#方案七：Redlock" class="headerlink" title="方案七：Redlock"></a>方案七：Redlock</h4><blockquote>
<p><strong>redlock的前提是每个master节点都独立，并且不存在主从复制</strong></p>
</blockquote>
<blockquote>
<p>​	Redis一般都是集群部署的，假设数据在主从同步过程，主节点挂了，Redis分布式锁可能会有<strong>哪些问题</strong>呢？一起来看些这个流程图：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640265833139-3f78ea2b-ca37-4b14-92ab-6d53b78534b9.png"></p>
<blockquote>
<p>​	如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。 </p>
</blockquote>
<blockquote>
<p>​	<strong>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：</strong>Redlock**。Redlock核心思想是这样的：搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。 **</p>
</blockquote>
<p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1640265851444-b6419493-f510-43e2-9c45-1a3a81e59e3c.png"></p>
<p>RedLock的实现步骤:如下 </p>
<blockquote>
<ol>
<li><strong>获取当前时间（毫秒数）。</strong></li>
<li><strong>按顺序依次向N个Redis节点执行获取锁的操作。</strong>这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</li>
<li><strong>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间</strong>。如果客户端从大多数Redis节点（&gt;&#x3D; N&#x2F;2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li>
<li><strong>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算</strong>，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</li>
<li><strong>如果最终获取锁失败了</strong>（可能由于获取到锁的Redis节点个数少于N&#x2F;2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</li>
</ol>
</blockquote>
<blockquote>
<p>​	上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p>
</blockquote>
<h5 id="Redlock存在的问题"><a href="#Redlock存在的问题" class="headerlink" title="Redlock存在的问题"></a>Redlock存在的问题</h5><p><strong>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</strong></p>
<ol>
<li>客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</li>
<li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li>
<li>节点C重启后，客户端2锁住了C, D, E，获取锁成功。</li>
</ol>
<p><strong>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</strong></p>
<blockquote>
<p>​	在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了<strong>延迟重启</strong>(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，<strong>这段时间应该大于锁的有效时间</strong>(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p>
</blockquote>
<p><strong>关于Redlock还有一点细节值得拿出来分析一下：</strong></p>
<p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。</p>
<p>这是为什么呢？设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p>
<h5 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h5><blockquote>
<p><strong>１、仍然存在开篇我们提到的第２个问题：客户端长时间阻塞，导致获得的锁释放，访问的共享资源不受保护的问题。</strong></p>
<p>２、在Redlock的算法中，我们可以看到第３步，当获取锁耗时太多，留给客户端的访问共享资源的时间很短，这种情况若来不及操作，是不是要释放锁呢？且到底剩下多少时间才算短？这又是一个选择难题。</p>
<p>３、Redlock算法对时钟依赖性太强， 若Ｎ个节点中的某个节点发生 <strong>时间跳跃</strong> ，也可能会引此而引发锁安全性问题。</p>
</blockquote>
<h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><blockquote>
<p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 </p>
<p><strong>过期策略通常有以下三种：</strong> </p>
<ul>
<li>立即删除<ul>
<li>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</li>
<li>优点：保证内存被尽快释放</li>
<li>缺点：<ul>
<li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li>
<li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li>
<li>没人用</li>
</ul>
</li>
</ul>
</li>
<li><strong>惰性删除</strong><ul>
<li>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</li>
<li>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</li>
<li>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</li>
</ul>
</li>
<li><strong>定期删除</strong><ul>
<li>含义：每隔一段时间执行一次删除过期key操作，默认每隔 100ms 就 随机抽取 一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删除。</li>
<li>优点：<ul>
<li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li>
<li>定期删除过期key–处理”惰性删除”的缺点</li>
</ul>
</li>
<li>缺点<ul>
<li>在内存友好方面，不如”定时删除”</li>
<li>在CPU时间友好方面，不如”惰性删除”</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h3><blockquote>
<p><strong>惰性删除+定期删除</strong></p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="RDB对过期key的处理"><a href="#RDB对过期key的处理" class="headerlink" title="RDB对过期key的处理"></a>RDB对过期key的处理</h3><blockquote>
<p>过期key对RDB没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到RDB文件<ul>
<li>持久化key之前，会检查是否过期，过期的key不进入RDB文件</li>
</ul>
</li>
<li>从RDB文件恢复数据到内存数据库<ul>
<li>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="AOF对过期key的处理"><a href="#AOF对过期key的处理" class="headerlink" title="AOF对过期key的处理"></a>AOF对过期key的处理</h3><blockquote>
<p>过期key对AOF没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到AOF文件：<ul>
<li>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）</li>
<li>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</li>
</ul>
</li>
<li>AOF重写<ul>
<li>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><blockquote>
<ul>
<li>volatile为前缀的策略都是从已过期的数据集中进行淘汰。</li>
<li>allkeys为前缀的策略都是面向所有key进行淘汰。</li>
<li>LRU（least recently used）最近最少用到的。</li>
<li>LFU（Least Frequently Used）最不常用的。</li>
<li>它们的触发条件都是Redis使用的内存达到阈值时。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jbhgvcfdxrsxdtcfybh.png"></p>
<h2 id="数据库与缓存数据不一致问题"><a href="#数据库与缓存数据不一致问题" class="headerlink" title="数据库与缓存数据不一致问题"></a>数据库与缓存数据不一致问题</h2><blockquote>
<p><strong>由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题</strong>：</p>
<ul>
<li>先更新数据库，再更新缓存；</li>
<li>先更新缓存，再更新数据库；</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jbhgvcftdxrdtgvubhjn.png"></p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p>举个例子，比如「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/jbhugvytxrzesrxdtyguj.png"></p>
<blockquote>
<p>​	A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
</blockquote>
<h3 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h3><p>依然还是存在并发的问题，分析思路也是一样。</p>
<p>假设「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/bhugvycfdxrzeasrxdcfg.png"></p>
<blockquote>
<p>​	A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
</blockquote>
<p><strong><font color='red'>所以，无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</font></strong></p>
<blockquote>
<p>​	<strong>不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</strong>叫 <strong>Cache Aside 策略</strong>，中文是叫旁路缓存策略。该策略又可以细分为「读策略」和「写策略」</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/hbgvycftdxrzeazsrdcf.png"></p>
<p><strong>写策略的步骤：</strong></p>
<ul>
<li>更新数据库中的数据；</li>
<li>删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p>假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/bhugvyctxrzesrxdcubik.png"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p>
<p>可以看到，<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><p>继续用「读 + 写」请求的并发的场景来分析。</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img9/kbhugyctxrzwexctybiu.png"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</p>
<p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p>
<p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p>
<p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p>
<h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><ol>
<li>删除 redis 主库数据。</li>
<li>修改 mysql 主库数据。</li>
<li>等待一段时间，等 redis 和 mysql 主从节点数据同步成功。</li>
<li>删除 redis 主库数据。</li>
<li>读取 redis 从库数据，发现 redis 从库没有数据，从 mysql 从库读取数据，并写入 redis 主库。</li>
</ol>
<h4 id="为什么要延迟"><a href="#为什么要延迟" class="headerlink" title="为什么要延迟"></a>为什么要延迟</h4><p>​		因为 mysql 和 redis 主从节点数据不是实时同步的，同步数据需要时间。</p>
<h4 id="为什么要删除两次"><a href="#为什么要删除两次" class="headerlink" title="为什么要删除两次"></a>为什么要删除两次</h4><p>​		先删缓存的话，当我们在清除缓存和更新数据库间有事务查询缓存，此时没有缓存，数据库还没更新，所以缓存又更新为旧数据了，后删缓存的话，在删除缓存之前读到的数据都是旧数据，将两者综合起来的话，在更新前和更新后都进行删除，就可以很大程度上避免读到脏数据</p>
<h3 id="异步更新缓存"><a href="#异步更新缓存" class="headerlink" title="异步更新缓存"></a>异步更新缓存</h3><p>数据库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由Redis自己去消费更新数据，消息队列可以保证数据操作顺序一致性，确保缓存系统的数据正常。</p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>​	缓存雪崩是指缓存同一时间大面积的失效（例如<code>key</code>的存活时间在同一时间过期），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/image-20220110163232729.png"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。(这里的加锁就是让那些访问请求排队，一个一个来查询数据)</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
</blockquote>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/image-20220110163824673.png"></p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<ol>
<li>接口层增加校验，如用户鉴权校验，<code>id</code>做基础校验，<code>id&lt;=0</code>的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将<code>key-value</code>对写为<code>key-null</code>，缓存有效时间可以设置短点，如<code>30</code>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 <code>bitmap</code> 中，一个一定不存在的数据会被这个 <code>bitmap</code> 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
</blockquote>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><blockquote>
<p>​	它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p>
<p>​	布隆过滤器可以告诉我们 <strong>“某样东西 一定不存在 或者 可能存在 ”，也就是说布隆过滤器说这个数 不存在 则 一定不存在 ，布隆过滤器说这个数 存在 则 可能不存在</strong>。</p>
</blockquote>
<h5 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h5><blockquote>
<p>​	布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以<code>Redis</code>中的布隆过滤器实现为例，<code>Redis</code>中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏<code>hash</code>函数。</strong></p>
</blockquote>
<h6 id="一个大型位数组（二进制数组）"><a href="#一个大型位数组（二进制数组）" class="headerlink" title="一个大型位数组（二进制数组）"></a>一个大型位数组（二进制数组）</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/e94e504adc5a75a2d7f562dc44166511.png"></p>
<h6 id="多个无偏hash函数"><a href="#多个无偏hash函数" class="headerlink" title="多个无偏hash函数"></a>多个无偏hash函数</h6><blockquote>
<p>​	无偏<code>hash</code>函数就是能把元素的<code>hash</code>值计算的比较均匀的<code>hash</code>函数，能使得计算后的元素下标比较均匀的映射到位数组中。</p>
</blockquote>
<blockquote>
<p>​	如下就是一个简单的布隆过滤器示意图，其中<code>k1</code>、<code>k2</code>代表增加的元素，<code>a</code>、<code>b</code>、<code>c</code>即为无偏<code>hash</code>函数，最下层则为二进制数组。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/9ebde5c11ad69447314c216acf188fc8.png"></p>
<h6 id="空间计算"><a href="#空间计算" class="headerlink" title="空间计算"></a>空间计算</h6><blockquote>
<p>​	在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏<code>hash</code>函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小<code>n</code>，运行的错误率<code>f</code>。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小<code>l</code>，以及无偏<code>hash</code>函数的个数<code>k</code>。<br>它们之间的关系比较简单：</p>
<ul>
<li>错误率越低，位数组越长，控件占用较大</li>
<li>错误率越低，无偏<code>hash</code>函数越多，计算耗时较长</li>
</ul>
</blockquote>
<h5 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h5><h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><blockquote>
<ol>
<li>时间复杂度低，增加和查询元素的时间复杂为<code>O(N)</code>，（<code>N</code>为哈希函数的个数，通常情况比较小）</li>
<li>保密性强，布隆过滤器不存储元素本身</li>
<li>存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如<code>Set</code>集合）</li>
</ol>
</blockquote>
<h6 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h6><blockquote>
<ol>
<li>有点一定的误判率，但是可以通过调整参数来降低</li>
<li>无法获取元素本身</li>
<li>很难删除元素</li>
</ol>
</blockquote>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>​	缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/image-20220110165805383.png"></p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
</blockquote>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><blockquote>
<p>​	缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
</blockquote>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
</blockquote>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><blockquote>
<p>​	当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
</blockquote>
<blockquote>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
</blockquote>
<blockquote>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在<code>95% ~ 100%</code>之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于<code>90%</code>，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
</blockquote>
<blockquote>
<p>​	服务降级的目的，是为了防止<code>Redis</code>服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，<code>Redis</code>出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
</blockquote>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><blockquote>
<p>​	热点数据，缓存才有价值</p>
</blockquote>
<blockquote>
<p>​	对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
</blockquote>
<blockquote>
<p>​	对于热点数据，比如我们的某产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
</blockquote>
<blockquote>
<p>​	数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
</blockquote>
<blockquote>
<p>​	那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到<code>Redis</code>缓存，减少数据库压力。</p>
</blockquote>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><blockquote>
<p>​	缓存中的一个<code>Key</code>(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个<code>Key</code>有大量的并发请求过来，这些请求发现缓存过期一般都会从后端<code>DB</code>加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端<code>DB</code>压垮。</p>
</blockquote>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<ul>
<li><p>Redis集群扩容：增加分片副本，均衡读流量；</p>
</li>
<li><p>将热key分散到不同的服务器中；</p>
</li>
<li><p>使用二级缓存，即JVM本地缓存,减少Redis的读请求。</p>
</li>
</ul>
</blockquote>
<h2 id="关于spring-redis"><a href="#关于spring-redis" class="headerlink" title="关于spring-redis"></a>关于spring-redis</h2><blockquote>
<p>​	<code>Spring-data-redis</code>是<code>Spring</code>大家族的一部分，提供了在<code>Spring</code>应用中通过简单的配置访问<code>redis</code>服务，对<code>redis</code>底层开发包<code>(Jedis, JRedis, and RJC)</code>进行了高度封装，<code>RedisTemplate</code>提供了<code>redis</code>各种操作、异常处理及序列化，支持发布订阅，并对<code>spring 3.1 cache</code>进行了实现。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 连接池自动管理，提供了一个高度封装的“RedisTemplate”类</span><br><span class="line"></span><br><span class="line">2. 针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</span><br><span class="line">    ValueOperations：简单K-V操作</span><br><span class="line">    SetOperations：set类型数据操作</span><br><span class="line">    ZSetOperations：zset类型数据操作</span><br><span class="line">    HashOperations：针对map类型的数据操作</span><br><span class="line">    ListOperations：针对list类型的数据操作</span><br><span class="line"></span><br><span class="line">3. 提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：</span><br><span class="line">    BoundValueOperations</span><br><span class="line">    BoundSetOperations</span><br><span class="line">    BoundListOperations</span><br><span class="line">    BoundSetOperations</span><br><span class="line">    BoundHashOperations</span><br><span class="line"></span><br><span class="line">4. 将事务操作封装，有容器控制。</span><br><span class="line"></span><br><span class="line">5. 针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)</span><br><span class="line"></span><br><span class="line">JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。</span><br><span class="line"></span><br><span class="line">StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。</span><br><span class="line"></span><br><span class="line">JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】</span><br><span class="line"></span><br><span class="line">OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】</span><br></pre></td></tr></table></figure>

<h3 id="redis在SpringBoot中的使用"><a href="#redis在SpringBoot中的使用" class="headerlink" title="redis在SpringBoot中的使用"></a>redis在SpringBoot中的使用</h3><h4 id="配置文件application-yml配置"><a href="#配置文件application-yml配置" class="headerlink" title="配置文件application.yml配置"></a>配置文件application.yml配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.jedis.pool.max-wait=-1ms</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.jedis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.jedis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=5000ms</span><br></pre></td></tr></table></figure>

<h4 id="配置中心的配置"><a href="#配置中心的配置" class="headerlink" title="配置中心的配置"></a>配置中心的配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> janti</span></span><br><span class="line"><span class="comment"> * reids 相关bean的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择redis作为默认缓存工具</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">rcm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisTemplate);</span><br><span class="line">        <span class="keyword">return</span> rcm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retemplate相关配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对hash类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HashOperations&lt;String, String, Object&gt; <span class="title function_">hashOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对redis字符串类型数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="title function_">valueOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对链表类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ListOperations&lt;String, Object&gt; <span class="title function_">listOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对无序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SetOperations&lt;String, Object&gt; <span class="title function_">setOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="title function_">zSetOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以使用简单的配置，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json 序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 序列化配置</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key 采用 String 的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash 的 key 采用 String 的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value 采用 jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash 的 value 采用 jackson 的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redis工具类配置"><a href="#redis工具类配置" class="headerlink" title="redis工具类配置"></a>redis工具类配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/19/Redis/" data-id="clpsh9799000kxgvsh17ih0u6" data-title="Redis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/30/Java%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2021-12-30T02:57:33.000Z" itemprop="datePublished">2021-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/30/Java%E9%9B%86%E5%90%88/">Java集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>说明：本篇博客主要内容来自网上的资料，我只是做个总结。</p>
<h2 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2243690-9cd9c896e0d512ed.gif"></p>
<h2 id="常用集合的分类"><a href="#常用集合的分类" class="headerlink" title="常用集合的分类"></a>常用集合的分类</h2><blockquote>
<p><code>Collection</code> 接口的接口 对象的集合（单列集合）<br>├——-├ <code>List</code> 接口：元素按进入先后有序保存，可重复<br>│—————-├ <code>LinkedList</code> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ <code>ArrayList</code> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-├ <code>Vector</code> 接口实现类 数组， 同步， 线程安全<br>│ ———————├ <code>Stack</code> 是<code>Vector</code>类的实现类<br>└——-├ <code>Set</code> 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-├ <code>HashSet</code> 使用<code>hash</code>表（数组）存储元素<br>│————————├ <code>LinkedHashSet</code> 链表维护元素的插入次序<br>└ —————-├ <code>TreeSet</code> 底层实现为二叉树，元素排好序</p>
<p><code>Map</code> 接口 键值对的集合 （双列集合）<br>├———-├ <code>Hashtable</code> 接口实现类， 同步， 线程安全<br>├———-├ <code>HashMap</code> 接口实现类 ，没有同步， 线程不安全-<br>│—————–├ <code>LinkedHashMap</code> 双向链表和哈希表实现<br>│—————-├ <code>WeakHashMap</code><br>├ ——-├ <code>TreeMap</code> 红黑树对所有的<code>key</code>进行排序<br>└———-├ <code>IdentifyHashMap</code></p>
</blockquote>
<h2 id="List、Set、Map的区别是什么？"><a href="#List、Set、Map的区别是什么？" class="headerlink" title="List、Set、Map的区别是什么？"></a>List、Set、Map的区别是什么？</h2><blockquote>
<ul>
<li><code>List</code>是一个继承于<code>Collection</code>的接口，即<code>List</code>是集合中的一种。**<code>List</code>是有序的队列<strong>，<code>List</code>中的每一个元素都有一个索引。和<code>Set</code>不同，</strong><code>List</code>中允许有重复的元素，可以插入多个<code>null</code>元素**。实现<code>List</code>接口的集合主要有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>、<code>Stack</code>。 </li>
<li><code>Set</code>是一个继承于<code>Collection</code>的接口，<code>Set</code>是一种不包括重复元素的<code>Collection</code>。 <strong>它是一个无序容器</strong>，你无法保证每个元素的存储顺序。与<code>List</code>一样，<strong>它同样允许<code>null</code>的存在但是仅有一个</strong>。由于<code>Set</code>接口的特殊性，所有传入<code>Set</code>集合中的元素都必须不同，关于<code>API</code>方面。<code>Set</code>的<code>API</code>和<code>Collection</code>完全一样。实现了<code>Set</code>接口的集合有：<code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>、<code>EnumSet</code>。 </li>
<li><code>Map</code>与<code>List</code>、<code>Set</code>接口不同，它是由一系列键值对组成的集合，提供了<code>key</code>到<code>Value</code>的映射。在<code>Map</code>中它保证了<code>key</code>与<code>value</code>之间的一一对应关系。也就是说一个<code>key</code>对应一个<code>value</code>，所以它不能存在相同的<code>key</code>值，当然<code>value</code>值可以相同。实现<code>map</code>的集合有：<code>HashMap</code>、<code>HashTable</code>、<code>TreeMap</code>、<code>WeakHashMap</code>。 </li>
<li>总结：   </li>
<li><code>List</code>、<code>Set</code>都是继承自<code>Collection</code>接口，<code>Map</code>则不是 </li>
<li><code>List</code>特点：元素有放入顺序，元素可重复 ，<code>Set</code>特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在<code>set</code>中的位置是有该元素的<code>HashCode</code>决定的，其位置其实是固定的，加入<code>Set</code> 的<code>Object</code>必须定义<code>equals()</code>方法 ，另外<code>list</code>支持<code>for</code>循环，也就是通过下标来遍历，也可以用迭代器，但是<code>set</code>只能用迭代，因为他无序，无法用下标来取得想要的值。） </li>
<li><code>Set</code>和<code>List</code>对比：<br>-  <code>Set</code>：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>-  <code>List</code>：和数组类似，<code>List</code>可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 </li>
<li><code>Map</code>适合储存键值对的数据 </li>
<li>线程安全集合类与非线程安全集合类 :<br>-  <code>LinkedList</code>、<code>ArrayList</code>、<code>HashSet</code>是非线程安全的，<code>Vector</code>是线程安全的;<br>- <code> HashMap</code>是非线程安全的，<code>HashTable</code>是线程安全的;<br>-  <code>StringBuilder</code>是非线程安全的，<code>StringBuffer</code>是线程安全的。</li>
</ul>
</blockquote>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>​	<code>ArrayList</code>实现了<code>List</code>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<code>Vector</code>大致相同。每个<code>ArrayList</code>都有一个容量<code>(capacity)</code>，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，<code>Java</code>泛型只是编译器提供的语法糖，所以这里的数组是一个<code>Object</code>数组，以便能够容纳任何类型的对象。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList_base.png"></p>
<blockquote>
<p>​	<code>size()</code>, <code>isEmpty()</code>, <code>get()</code>, <code>set()</code>方法均能在常数时间内完成，<code>add()</code>方法的时间开销跟插入位置有关，<code>addAll()</code>方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>
<p>​	为追求效率，<code>ArrayList</code>没有实现同步<code>(synchronized)</code>，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>
</blockquote>
<h3 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Serializable标记性接口"><a href="#Serializable标记性接口" class="headerlink" title="Serializable标记性接口"></a>Serializable标记性接口</h4><blockquote>
<p><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化。<br><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>​	当我们想把内存中的对象状态保存到一个文件中或者数据库中时候，就需要使用序列化。</p>
</blockquote>
<h4 id="Cloneable-标记性接口"><a href="#Cloneable-标记性接口" class="headerlink" title="Cloneable 标记性接口"></a>Cloneable 标记性接口</h4><blockquote>
<p>​	一个类实现<code>Cloneable</code> 接口来指示<code>Object.clone()</code> 方法，该方法对于该类的实例进行字段的复制是合法的。在不实现<code>Cloneable</code> 接口的实例上调用对象的克隆方法会导致异常<code>CloneNotSupportedException</code> 被抛出。简言之:克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝</p>
</blockquote>
<h4 id="RandomAccess标记性接口"><a href="#RandomAccess标记性接口" class="headerlink" title="RandomAccess标记性接口"></a>RandomAccess标记性接口</h4><blockquote>
<p>​	标记接口由<code>List</code>实现使用，以表明它们支持快速（通常为恒定时间）随机访问。此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。<br>​	用于操纵随机访问列表的最佳算法（例如<code>ArrayList</code>）可以在应用于顺序访问列表时产生二次行为（如<code>LinkedList</code>）。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，检查给定列表是否为<code>instanceof</code>，并在必要时更改其行为以保证可接受的性能。</p>
</blockquote>
<blockquote>
<p>根据经验，<code>List</code>实现应实现此接口，如果对于类的典型实例，此循环：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对返回的集合进行判断,如果返回的集合实现了 RandomAccess 就使用 普通for</span></span><br><span class="line"><span class="comment">//否则使用迭代器(增强for)    增强for本质上也是迭代器</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = list.size(); i &lt; n; i++) &#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 真正保存数据的数组   </span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 序列化id    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始容量大小为 10</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于空实例的共享空数组实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于默认大小的空实例的共享空数组实例。我们将其与空元素数据区分开，以知道何时充气添加第一个元素。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// size 是指 elementData 中实际有多少个元素，而 elementData.length 为集合容量，表示最多可以容纳多少个元素。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个变量是定义在 AbstractList 中的。记录对 List 操作的次数。主要使用是在 Iterator，是防止在迭代的过程中集合被修改。</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ArrayList()</code></td>
<td align="center">构造一个初始容量为<code>10</code>的空列表。</td>
</tr>
<tr>
<td align="center"><code>ArrayList(int initialCapacity)</code></td>
<td align="center">构造具有指定初始容量的空列表。</td>
</tr>
<tr>
<td align="center"><code>ArrayList(Collection&lt;? extends&lt;E&gt; c)</code></td>
<td align="center">构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</td>
</tr>
</tbody></table>
<h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="空参构造ArrayList"><a href="#空参构造ArrayList" class="headerlink" title="空参构造ArrayList()"></a>空参构造<code>ArrayList()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这行代码做了什么?</span></span><br><span class="line">        <span class="comment">//真的构造一个初始容量为十的空列表?</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 默认初始容量</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 空数组</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 默认容量的空数组</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 集合真正存储数组元素的数组</span></span><br><span class="line">       <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 集合的大小</span></span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>两个空数组的区别：</p>
<blockquote>
<ol>
<li><p><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 该数组为空数组，用来记录<code>ArrayList</code>在生成时没有进行传参数，随后在操作过程中将<code>elementData</code>（底层数组）的大小设置为默认值<code>10</code>。</p>
</li>
<li><p><code>EMPTY_ELEMENTDATA</code>用来记录<code>ArrayList</code>在生成时传参为<code>0</code>的情况。而为了与没传参数的情况分开所以重新用了一个空数组。</p>
</li>
</ol>
</blockquote>
<p>结论：</p>
<blockquote>
<p>​	通过空参构造方法创建集合对象并未构造一个初始容量为十的空列表，仅仅将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的地址赋值给<code>elementData</code></p>
</blockquote>
<h6 id="指定容量ArrayList-int-initialCapacity"><a href="#指定容量ArrayList-int-initialCapacity" class="headerlink" title="指定容量ArrayList(int initialCapacity)"></a>指定容量<code>ArrayList(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这行代码ArrayList底层做了什么?</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123; <span class="comment">//initialCapacity = 5</span></span><br><span class="line">        <span class="comment">//判断初始容量initialCapacity是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个数组,且指定长度为initialCapacity</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果initialCapacity容量为0，把EMPTY_ELEMENTDATA的地址赋值给elementData</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//以上两个条件都不满足报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +  initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论</p>
<blockquote>
<p>根据<code>ArrayList</code> 构造方法参数创建指定长度的数组</p>
</blockquote>
<h6 id="ArrayList-Collection-c"><a href="#ArrayList-Collection-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a><code>ArrayList(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">//这行代码做了什么?</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// 将集合构造中的集合对象转成数组,且将数组的地址赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 将elementData的长度赋值给 集合长度size,且判断是否不等于 0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断elementData 和 Object[] 是否为不一样的类型</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//如果不一样,使用Arrays的copyOf方法进行元素的拷贝</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合转数组的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="comment">//调用数组工具类方法进行拷贝</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">        <span class="comment">//再次调用方法进行拷贝</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;</span><br><span class="line">            newType) &#123;</span><br><span class="line">        <span class="comment">//用三元运算符进行判断,不管结果如何都是创建一个新数组</span></span><br><span class="line">        T[] copy = ((Object) newType == (Object) Object[].class)</span><br><span class="line">                ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">                : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        <span class="comment">//将数组的内容拷贝到 copy 该数组中</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                Math.min(original.length, newLength));</span><br><span class="line">        <span class="comment">//返回拷贝元素成功后的数组</span></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean add(E e)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public void add(int index, E element)</code></td>
<td>在此列表中的指定位置插入指定的元素。</td>
</tr>
<tr>
<td><code>public boolean addAll(Collection&lt;?extends E&gt; c)</code></td>
<td>按指定集合的<code>Iterator</code>返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public boolean addAll(int index,Collection&lt;? extends E&gt; c)</code></td>
<td>将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td>
</tr>
</tbody></table>
<h5 id="public-boolean-add-E-e-添加单个元素"><a href="#public-boolean-add-E-e-添加单个元素" class="headerlink" title="public boolean add(E e) 添加单个元素"></a><code>public boolean add(E e)</code> 添加单个元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//将添加的数据传入给 e</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法对内部容量进行校验</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//判断集合存数据的数组是否等于空容量的数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//通过最小容量和默认容量 求出较大值 (用于第一次扩容)</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将if中计算出来的容量传递给下一个方法,继续校验</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//实际修改集合次数++ (在扩容的过程中没用,主要是用于迭代器中)</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//判断最小容量 - 数组长度是否大于 0</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//将第一次计算出来的容量传递给 核心扩容方法</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//记录数组的实际长度,此时由于木有存储元素,长度为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//核心扩容算法 原容量的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断新容量 - 最小容量 是否小于 0, 如果是第一次调用add方法必然小于</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//还是将最小容量赋值给新容量</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//判断新容量-最大数组大小 是否&gt;0,如果条件满足就计算出一个超大容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 调用数组工具类方法,创建一个新数组,将新数组的地址赋值给elementData</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element-在指定索引处添加元素"><a href="#public-void-add-int-index-E-element-在指定索引处添加元素" class="headerlink" title="public void add(int index, E element) 在指定索引处添加元素"></a><code>public void add(int index, E element)</code> 在指定索引处添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;长沙校区&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//添加范围检查</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//超出指定范围就报错</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确保明确的能力</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//增量++ (也就是实际修改集合的次数)</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//如果再调用 add(index,element) 方法之前已经扩容,那么源码跟踪到此结束</span></span><br><span class="line">        <span class="comment">//不会进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-addAll-Collection-c-将集合的所有元素一次性添加到集合"><a href="#public-boolean-addAll-Collection-c-将集合的所有元素一次性添加到集合" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c) 将集合的所有元素一次性添加到集合"></a><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code> 将集合的所有元素一次性添加到集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.addAll(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//把集合的元素转存到Object类型的数组中</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//记录数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//调用方法将a数组的元素拷贝到elementData数组中</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        <span class="comment">//集合的长度+=a数组的长度</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//只要a数组的长度不等于0,即说明添加成功</span></span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-addAll-int-index-Collection-c-在指定的索引位置添加集合"><a href="#public-boolean-addAll-int-index-Collection-c-在指定的索引位置添加集合" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的索引位置添加集合"></a><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</code> 在指定的索引位置添加集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;酷丁鱼&quot;</span>);</span><br><span class="line">        <span class="comment">//在指定索引处添加一个集合</span></span><br><span class="line">        list1.addAll(<span class="number">1</span>,list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//校验索引</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//将数据源转成数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//记录数据源的长度 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//目的就是为了给集合存储数据的数组进行扩容</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//numMoved:代表要移动元素的个数 --&gt; 1个</span></span><br><span class="line">        <span class="comment">//numMoved: 数据目的(集合list1)的长度-调用addAll的第一个参数 (索引1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="comment">//判断需要移动的个数是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//使用System中的方法arraycopy进行移动</span></span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//才是真正将数据源(list)中的所有数据添加到数据目的(lsit1)</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    参数</span><br><span class="line">        src -源数组。</span><br><span class="line">        srcPos -源数组中的起始位置。</span><br><span class="line">        dest -目标数组。</span><br><span class="line">        destPos -目的地数据中的起始位置。</span><br><span class="line">        length -要复制的数组元素的数量。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-E-remove-int-index-根据索引删除元素"><a href="#public-E-remove-int-index-根据索引删除元素" class="headerlink" title="public E remove(int index) 根据索引删除元素"></a><code>public E remove(int index)</code> 根据索引删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引删除元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的元素为: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//增量++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//将index对应的元素赋值给 oldValue</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        <span class="comment">//计算集合需要移动元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果需要移动元素个数大于0,就使用arrayCopy方法进行拷贝</span></span><br><span class="line">        <span class="comment">//注意:数据源和数据目的就是elementData</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//将源集合最后一个元素置为null,尽早让垃圾回收机制对其进行回收</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-remove-Object-o-根据元素删除元素"><a href="#public-boolean-remove-Object-o-根据元素删除元素" class="headerlink" title="public boolean remove(Object o) 根据元素删除元素"></a><code>public boolean remove(Object o)</code> 根据元素删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引删除元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> list.remove(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功: &quot;</span>+flag);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//判断要删除的元素是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">//判断集合的元素是否为null</span></span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">//用o对象的equals方法和集合每一个元素进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    <span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果集合没有o该元素,那么就会返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//增量++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//计算集合需要移动元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果需要移动的个数大于0,调用arrayCopy方法进行拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//将集合最后一个元素置为null,尽早被释放</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><h5 id="public-E-set-int-index-E-element-根据索引修改集合元素"><a href="#public-E-set-int-index-E-element-根据索引修改集合元素" class="headerlink" title="public E set(int index, E element) 根据索引修改集合元素"></a><code>public E set(int index, E element)</code> 根据索引修改集合元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引修改集合元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.set(<span class="number">3</span>, <span class="string">&quot;花和尚鲁智深&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set方法返回值: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//先取出index对应的元素,且赋值给oldValue</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        <span class="comment">//将element直接覆盖index对应的元素</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回被覆盖的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-E-get-int-index-根据索引获取元素"><a href="#public-E-get-int-index-根据索引获取元素" class="headerlink" title="public E get(int index) 根据索引获取元素"></a><code>public E get(int index)</code> 根据索引获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引获取集合元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;get方法返回值: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//直接根据索引取出集合元素</span></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><h5 id="public-String-toString-把集合所有数据转换成字符串"><a href="#public-String-toString-把集合所有数据转换成字符串" class="headerlink" title="public String toString() 把集合所有数据转换成字符串"></a><code>public String toString()</code> 把集合所有数据转换成字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">        <span class="comment">//将集合的元素转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList集合内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;    <span class="comment">//当前光标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将实际修改集合次数赋值给预期修改次数 ,注意只会赋值一次</span></span><br><span class="line">        <span class="comment">//以后在迭代器获取元素的时候,每次都会判断集合实际修改次数是否和预期修改次数一致</span></span><br><span class="line">        <span class="comment">//如果不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断光标 和 集合的大小 是否不相等</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList亲爹</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList亲爷爷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意:此时相当于用ArrayList对象在调用iterator()方法 获取迭代器</span></span><br><span class="line">        <span class="comment">//那么这个时候需要先看看ArrayList中的iterator()方法</span></span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="comment">//调用ArrayList中hasNext方法判断是否有元素,如果hasNext()方法返回false</span></span><br><span class="line">        <span class="comment">//那么就toString方法就返回一个 &quot;[]&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="comment">//创建StringBuilder,对集合的内容进行拼接,避免字符串频繁拼接产生很多无效对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//调用ArrayList中next方法取出元素</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (!it.hasNext())</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="public-Iterator-iterator-普通迭代器"><a href="#public-Iterator-iterator-普通迭代器" class="headerlink" title="public Iterator&lt;E&gt; iterator() 普通迭代器"></a><code>public Iterator&lt;E&gt; iterator()</code> 普通迭代器</h5><p>案例一: 已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;Java&quot;、&quot;PHP&quot;</code>，使用迭代器遍历获取集合的每一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二: 已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;Java&quot;、&quot;PHP&quot;</code>，使用迭代器遍历集合看有没有<code>&quot;PHP&quot;</code>这个元素，如果有，就使用集合对象删除该元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果:并发修改异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException at</span><br><span class="line">java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>) at</span><br><span class="line">java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>) at cn.itheima.method.Test01.main(Test01.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p>源码分析:(应该从获取迭代器的时候就进入到源代码中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line">        <span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line">        <span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line">        <span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的方法</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//每次获取元素,会先调用该方法校验 预期修改次数是否 == 实际修改次数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            tips:</span></span><br><span class="line"><span class="comment">            if(s.equals(&quot;hello&quot;)) &#123;</span></span><br><span class="line"><span class="comment">            list.remove(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            当if表达式的结果为true,那么集合就会调用remove方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//把下一个元素的索引赋值给i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="comment">//判断是否有元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//将集合底层存储数据的数组赋值给迭代器的局部变量 elementData</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//再次判断,如果下一个元素的索引大于集合底层存储元素的长度 并发修改异常</span></span><br><span class="line">            <span class="comment">//注意,尽管会产生并发修改异常,但是这里显示不是我们要的结果</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="comment">//每次成功获取到元素,下一个元素的索引都是当前索引+1</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回元素</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的remove方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速删除方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//最最最关键的一个操作,集合实际修改次数++,那么这个时候由原来的3变成4</span></span><br><span class="line">        <span class="comment">//but迭代器的预期修改次数还是3!!!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//还有一个很关键的操作,集合的长度也发生了改变</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例三:已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;PHP&quot;、&quot;JavaSE&quot;</code>，使用迭代器遍历集合看有没有<code>&quot;PHP&quot;</code>这个元素，如果有，就使用集合对象删除该元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F333%E7%90%86.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F%E7%90%862222.jpg"></p>
<h5 id="default-void-remove-迭代器中的remove方法-删除集合中的元素"><a href="#default-void-remove-迭代器中的remove方法-删除集合中的元素" class="headerlink" title="default void remove() 迭代器中的remove方法,删除集合中的元素"></a><code>default void remove() </code>迭代器中的<code>remove</code>方法,删除集合中的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F%E7%90%86111.jpg"></p>
<p>源码分析(应该从获取迭代器的时候就进入到源代码中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line">        <span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line">        <span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line">        <span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的方法</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//把下一个元素的索引赋值给i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="comment">//判断是否有元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//将集合底层存储数据的数组赋值给迭代器的局部变量 elementDat</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//再次判断,如果下一个元素的索引大于集合底层存储元素的长度 并发修改异常</span></span><br><span class="line">            <span class="comment">//注意,尽管会产生并发修改异常,但是这里显示不是我们要的结果</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="comment">//每次成功获取到元素,下一个元素的索引都是当前索引+1</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回元素,且将i的值 赋值给 lastRet /*0*/</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器删除元素方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//判断最后返回元素的索引是否小于0,满足条件就产生 非法状态异常</span></span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="comment">//校验是否会产生并发修改异常,第一次调用不会,因为与其修改次数和实际修改次数一致</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正删除集合元素的方法,调用方法为ArrayList的方法remove,且将0作为参数进行传递</span></span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                <span class="comment">//将lastRet赋值给cursor</span></span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                <span class="comment">//再次等于-1</span></span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//再次将集合实际修改次数赋值给预期修改次数,那么这个时候不管集合自身是否删除成功</span></span><br><span class="line">                <span class="comment">//那么实际修改次数和预期修改次数又一致了,所以并不会产生并发修改异常</span></span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的remove方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速删除方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//最最最关键的一个操作,集合实际修改次数++,那么这个时候由原来的3变成4</span></span><br><span class="line">        <span class="comment">//but迭代器的预期修改次数还是3!!!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//还有一个很关键的操作,集合的长度也发生了改变</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="public-void-clear-清空集合所有数据"><a href="#public-void-clear-清空集合所有数据" class="headerlink" title="public void clear() 清空集合所有数据"></a><code>public void clear()</code> 清空集合所有数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;清空前的集合: &quot;</span>+list);</span><br><span class="line">        <span class="comment">//清空集合所有元素</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后的集合: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实际修改集合次数++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//遍历集合,将集合每一个索引对应位置上的元素都置为null,尽早让其释放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//集合长度更改为0</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="public-boolean-contains-Object-o-判断集合是否包含指定元素"><a href="#public-boolean-contains-Object-o-判断集合是否包含指定元素" class="headerlink" title="public boolean contains(Object o) 判断集合是否包含指定元素"></a><code>public boolean contains(Object o)</code> 判断集合是否包含指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断之前集合的元素: &quot;</span> + list);</span><br><span class="line">        <span class="comment">//需求:如果集合中没有JavaSE该元素,请添加一个JavaSE元素</span></span><br><span class="line">        <span class="comment">//解决方式一:循环遍历集合,判断集合是否包含JavaSE,如果没有包含就调用集合的add方法进行添加操作</span></span><br><span class="line">        <span class="comment">//解决方式二:使用集合contains方法判断,根据判断的结果决定是否要添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (!list.contains(<span class="string">&quot;JavaSE&quot;</span>)) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;判断之后集合的元素: &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//源码contains方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//调用indexOf方法进行查找</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//如果元素是null,也进行遍历操作</span></span><br><span class="line">        <span class="comment">//因为集合中有可能够会存储null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有走if,也没有走else,那么就说明o该元素在集合中不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h4><h5 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a><code>public boolean isEmpty()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> list.isEmpty();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h4><p>​    阿里开发规范里有一条：不要在<code>foreach</code>循环里进行元素的<code>remove/add</code>操作。<code>remove</code>元素请使用<code>Iterator</code>方式，如果并发操作，需要对<code>Iterator</code>对象加锁。这是为什么呢？看下面一个<code>Demo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(item)) &#123;</span><br><span class="line">            list.remove(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jbiuvtyrtuyiuoimponubiyvtu.png"></p>
<p>​	当我们使用<code>foreach</code>去遍历集合的同时执行<code>remove</code>（或者<code>add</code>）时，我们可以看到控制台抛出<code>ConcurrentModificationException</code>异常（在删除集合中倒数第二个元素的时候不会抛出此异常，这个问题先埋个坑，我们下面会解释），而我们使用迭代器去<code>remove</code>的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(item))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njbhuvtyctrcytvybuimp.png"></p>
<p>​	使用迭代器删除的时候就不会抛出<code>ConcurrentModificationException</code>异常，这是因为如果使用增强<code>for</code>遍历集合时，尝试对集合结构进行改变会触发<code>Java</code>集合的错误检测机制：<code>fail-fast</code> 。</p>
<h4 id="什么是fail-fast机制"><a href="#什么是fail-fast机制" class="headerlink" title="什么是fail-fast机制"></a>什么是fail-fast机制</h4><p>​	<code>fail-fast</code>即快速失败，它是<code>Java</code>集合的一种错误检测机制。当多个线程对集合（非<code>fail-safe</code>的集合类）进行结构上的改变的操作时，有可能会触发<code>fail-fast</code>机制，这时就会抛出<code>ConcurrentModificationException</code>（当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。注：即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。我们再仔细分析一下上面<code>foreach</code>控制台打印的堆栈信息：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/klmjnibyutycrxetrcytvubhi.png"></p>
<p>   两个报错是在<code>ArrayList</code>内部类<code>Itr</code>的<code>next()</code>和<code>checkForComodification()</code>方法，还有一个是笔者的测试类可忽略。我们进入<code>next</code>方法看一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/hjbgvycftxerxtrcytvyubino.png"></p>
<p>可以看到第一行就是这个<code>checkForComodification()</code>方法，我们点进去看一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/nibyuvtfr6dft7gyhuop.png"></p>
<p>​    找到抛出异常的位置了，**<code>modCount != expectedModCount</code>**时，就会抛出<code>ConcurrentModificationException</code>。想搞清楚为什么这两个值会不相等，我们首先要了解这两个变量都是什么，翻阅源码可知：</p>
<pre><code>（1）modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。

（2）expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator方法被调用的时候初始化的。只有通过迭代器对集合进行操作，该值才会改变。
</code></pre>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhuvyctxetrcfybhijn.png"></p>
<p>​    可以看到<code>ArrayList</code>的<code>remove()</code>只修改了<code>modCount</code>，并没有对<code>expectedModCount</code>做任何操作，<code>add</code>方法同理，在<code>ensureExplicitCapacity()</code>中对<code>modCount</code>进行了修改：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ljnbhugvycftxrcytvbiuo.png"></p>
<p><font color='red'> 	 总结：之所以会抛出<code>ConcurrentModificationException</code>异常，是因为我们的代码中使用了增强<code>for</code>去遍历集合，而在增强<code>for</code>底层是通过<code>iterator</code>进行遍历的，但是元素的<code>add()/remove()</code>却是直接使用的集合类自己的方法。这就导致<code>iterator</code>在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被添加或删除了，就会抛出此异常来提示用户，可能产生了并发修改。</font></p>
<h4 id="为什么使用foreach遍历集合删除倒数第二个元素不会报错"><a href="#为什么使用foreach遍历集合删除倒数第二个元素不会报错" class="headerlink" title="为什么使用foreach遍历集合删除倒数第二个元素不会报错"></a>为什么使用foreach遍历集合删除倒数第二个元素不会报错</h4><p>上面<code>foreach</code>遍历集合的那段代码改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(item)) &#123;</span><br><span class="line">            list.remove(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njbhuvcyrytvubinoi.png"></p>
<p>​	发现竟然不抛异常了，其实这个问题出在迭代器内部类的<code>hasNext()</code>方法上，先看一下迭代器的三个属性：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhugvyfcdtxcfygvubhikml.png"></p>
<p>（1）<code>cursor</code> –迭代器的游标，元素的索引值，初始值为<code>0</code></p>
<p>（2）<code>lastRet</code> –返回最后一个元素的索引值、如果没有找到则返回<code>-1</code></p>
<p>（3）<code>expectedModCount</code> –修改次数的期望值，可以看到在迭代器初始化时，这个属性就被赋值为当前修改次数的值了。</p>
<p>   在迭代过程中，每一次迭代<code>cursor</code>都会<code>+1</code>，而<code>itr.hasNext()</code>会判断是否存在下一个元素、<code>itr.next()</code>获取下一个元素的值，最终直到不存在下一个元素，则迭代结束。跟进源码发现，<code>itr.hasNext()</code>判断方法并不会调用<code>checkForComodification</code>方法来检查<code>list</code>在迭代中是否有被修改，只是判断游标和长度是否相等，不等时则认为存在下一个元素，只有在调用<code>next()</code>方法才会尝试抛出<code>checkForComodification</code>异常：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njihbutvycrtytvubyimpo.png"></p>
<p>   现在我们带入删除集合中倒数第二个元素的场景，当倒数第二个元素迭代完成，开始迭代最后一个元素时，此时<code>cursor</code>是<code>2</code>，<code>size</code>由于在迭代过程倒数第二个元素移除了，所以<code>size-1</code>也是<code>2</code>, 此时<code>cursor</code>和<code>size</code>相等，不会再进入下一个迭代，也就不会进入<code>next()</code>方法，因此不会触发<code>checkForComodification</code>方法的<code>fail-fast</code>机制。</p>
<h4 id="如何避免出现fail-fast"><a href="#如何避免出现fail-fast" class="headerlink" title="如何避免出现fail-fast"></a>如何避免出现fail-fast</h4><p>  （1）直接使用普通<code>for</code>循环进行操作</p>
<p>  （2）使用<code>Iterator</code>提供的<code>remove</code>方法进行操作</p>
<p>  （3）使用一些<code>fail-safe</code>的集合类，例如<code>CopyOnWriteArrayList</code></p>
<h3 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h3><p>​	<code>fail-safe</code>（安全失败）机制是指任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出<code>ConcurrentModificationException</code>。<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<p>但是<code>fail-safe</code>机制有两个问题：</p>
<ul>
<li>需要复制集合，产生大量的无效对象，开销大</li>
<li>无法保证读取的数据是目前原始数据结构中的数据，因为复制操作执行后，集合可能会发生改变</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Forlogen&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Kobe&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    map.put(<span class="string">&quot;James&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(map.get(iterator.next()));</span><br><span class="line">        map.put(<span class="string">&quot;Yao&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>fail-safe</code>的具体体现可见<code>java.util.concurrentx</code>中类的实现，例如使用 <code>CopyOnWriterArrayList</code>代替<code>ArrayList，CopyOnWriterArrayList</code>在是使用上跟<code>ArrayList</code>几乎一样，<code>CopyOnWriter</code>是写时复制的容器(<code>COW</code>)，在读写时是线程安全的。该容器在对<code>add</code>和<code>remove</code>等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于CopyOnWriterArrayList在迭代过程并不会发生<code>fail-fast</code>现象。但 <code>CopyOnWrite</code>容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><blockquote>
<ul>
<li>提供随机访问的功能：实现<code>RandomAcess</code>接口，这个接口主要是为<code>List</code>提供快速访问的功能，也就是通过元素的索引，可以快速访问到。</li>
<li>可克隆：实现了<code>Cloneable</code>接口</li>
<li>是一个支持新增，删除，修改，查询，遍历等功能。</li>
<li>可序列化和反序列化</li>
<li>容量不够，可以触发自动扩容</li>
<li>最大的特点是：线程安全的，相当于线程安全的<code>ArrayList</code>。</li>
</ul>
</blockquote>
<h3 id="Vector继承关系"><a href="#Vector继承关系" class="headerlink" title="Vector继承关系"></a>Vector继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	从上面的继承关系和实现的接口，可以看出和<code>ArrayList</code>一样。</p>
</blockquote>
<h3 id="Vector源码分析"><a href="#Vector源码分析" class="headerlink" title="Vector源码分析"></a>Vector源码分析</h3><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正保存数据的数组</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量增加系数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Vector()</code></td>
<td align="center">构造一个初始容量为<code>10</code>的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(int initialCapacity)</code></td>
<td align="center">构造具有指定初始容量的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(int initialCapacity, int capacityIncrement)</code></td>
<td align="center">构造具有指定初始容量和增长系数的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</td>
</tr>
</tbody></table>
<h5 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-Vector"><a href="#public-Vector" class="headerlink" title="public Vector()"></a><code>public Vector()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>this(10)</code> 这个本质上是调用 <code>Vector(int initialCapacity)</code>，然后<code>this(initialCapacity, 0)</code> 这个本质上是调用 <code>Vector(int initialCapacity, int capacityIncrement)</code></p>
</blockquote>
<blockquote>
<p><font color='red'><strong>重点：</strong>从上面的构造方法可知，<code>vector</code>在运行构造方法时，就已经指定的了容量，而<code>ArrayList</code>是在使用<code>add()</code>方法才指定容量</font></p>
</blockquote>
<h6 id="public-Vector-int-initialCapacity"><a href="#public-Vector-int-initialCapacity" class="headerlink" title="public Vector(int initialCapacity)"></a><code>public Vector(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>this(initialCapacity, 0)</code> 这个本质上是调用 <code>Vector(int initialCapacity, int capacityIncrement)</code></p>
</blockquote>
<h6 id="public-Vector-int-initialCapacity-int-capacityIncrement"><a href="#public-Vector-int-initialCapacity-int-capacityIncrement" class="headerlink" title="public Vector(int initialCapacity, int capacityIncrement)"></a><code>public Vector(int initialCapacity, int capacityIncrement)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 非法判断</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="comment">// 指定增长系数</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-Vector-Collection-c"><a href="#public-Vector-Collection-c" class="headerlink" title="public Vector(Collection&lt;? extends E&gt; c)"></a><code>public Vector(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 转换成为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 大小为数组的大小</span></span><br><span class="line">    elementCount = a.length;</span><br><span class="line">    <span class="comment">// 如果是ArrayList，则直接复制</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">        elementData = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则需要进行拷贝</span></span><br><span class="line">        elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public synchronized void addElement(E obj)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public synchronized boolean add(E e)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public void add(int index, E element)</code></td>
<td>在此列表中的指定位置插入指定的元素。</td>
</tr>
<tr>
<td><code>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</code></td>
<td>按指定集合的<code>Iterator</code>返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td>
</tr>
</tbody></table>
<h5 id="public-synchronized-void-addElement-E-obj"><a href="#public-synchronized-void-addElement-E-obj" class="headerlink" title="public synchronized void addElement(E obj)"></a><code>public synchronized void addElement(E obj)</code></h5><blockquote>
<p>​	增加元素，默认是在最后添加，如果容量不够的时候会触发扩容机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 确保容量足够（如果需要，里面会有扩容，复制操作）</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新元素放在最后一个元素，个数增加</span></span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	那么它是如何确保容量的呢？可以看到<code>ensureCapacityHelper()</code>里面判断增加后的元素个数是否大于现在数组的长度，如果不满足，就需要扩容。调用<code>grow()</code>函数扩容。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容，传入的是需要最小的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 以前的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 现在的容量，是以前的容量加上扩展系数，如果扩展系数小于等于0，那么，就是以前的容量的两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="comment">// 如果新的容量大于最小需要容量，就满足了</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新的容量比最大的容量还要大（虚拟机的数组大小是有最大值的）</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 需要处理把最大的容量降低一些</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 拷贝数据</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-add-E-e"><a href="#public-synchronized-boolean-add-E-e" class="headerlink" title="public synchronized boolean add(E e)"></a><code>public synchronized boolean add(E e)</code></h5><blockquote>
<p>​	这个方法与<code>addElement(E obj)</code>几乎一样，只是返回值不同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 确保容量足够（如果需要，里面会有扩容，复制操作）</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新元素放在最后一个元素，个数增加</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a><code>public void add(int index, E element)</code></h5><blockquote>
<p>在指定的索引<code>index</code>，插入数据，实际上调用的是<code>insertElementAt(element, index)</code>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用插入元素的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insertElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断索引是否非法</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index</span><br><span class="line">                                                 + <span class="string">&quot; &gt; &quot;</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保容量足够</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 拷贝数据，将后面的元素，往后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    <span class="comment">// 将实际的数据插入</span></span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    <span class="comment">// 个数增加</span></span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-addAll-Collection-c"><a href="#public-synchronized-boolean-addAll-Collection-c" class="headerlink" title="public synchronized boolean addAll(Collection&lt;? extends E&gt; c)"></a><code>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</code></h5><blockquote>
<p>​	将一个集合所有元素添加进去</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 转成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 确保容量足够</span></span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="comment">// 返回添加的数组是不是有数据</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-addAll-int-index-Collection-c"><a href="#public-synchronized-boolean-addAll-int-index-Collection-c" class="headerlink" title="public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a><code>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></h5><blockquote>
<p>​	指定<code>index</code>，插入一个集合，和前面不一样的地方在于复制之前，需要计算往后面移动多少位，不是用<code>for</code>循环去插入，而是一次性移动和写入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 合法判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 转换数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 插入数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 确保数组的长度是否合法</span></span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    <span class="comment">// 移动的步长计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动后面的元素，腾出位置给插入的元素</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="comment">// 插入元素个数是否为0</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o) "></a><code>public boolean remove(Object o) </code></h5><blockquote>
<p>删除指定的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的是removeElement()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取第一个满足条件的元素缩影</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">// 索引如果满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将索引为i的元素从数组中移除</span></span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作数组删除元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index后面的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 往前面移动一位（复制，覆盖）</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">// 原来最后一个元素的位置置空</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-remove-int-index"><a href="#public-synchronized-E-remove-int-index" class="headerlink" title="public synchronized E remove(int index)"></a><code>public synchronized E remove(int index)</code></h5><blockquote>
<p>按照索引删除元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 保存原来的数据</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 移动的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果移动个数大于0</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 后面的元素往前面移动一位，赋值，覆盖</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 最后一个元素置空</span></span><br><span class="line">    elementData[--elementCount] = <span class="literal">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="comment">// 返回旧的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改方法-1"><a href="#修改方法-1" class="headerlink" title="修改方法"></a>修改方法</h4><blockquote>
<p>​	下面两个<code>set</code>函数都是，修改索引为<code>index</code>的元素，区别就是一个会返回旧的元素，一个不会返回旧的元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 取出旧的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法哦性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接更新</span></span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-synchronized-E-get-int-index"><a href="#public-synchronized-E-get-int-index" class="headerlink" title="public synchronized E get(int index)"></a><code>public synchronized E get(int index)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 返回数组的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-firstElement"><a href="#public-synchronized-E-firstElement" class="headerlink" title="public synchronized E firstElement()"></a><code>public synchronized E firstElement()</code></h5><blockquote>
<p>获取第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">firstElement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-lastElement"><a href="#public-synchronized-E-lastElement" class="headerlink" title="public synchronized E lastElement()"></a><code>public synchronized E lastElement()</code></h5><blockquote>
<p>获取最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">lastElement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法-1"><a href="#包含方法-1" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a><code>public boolean contains(Object o)</code></h5><blockquote>
<p>​	是否包含某一个元素，其实里面是获取对象的索引，如果索引大于等于<code>0</code>，证明元素在里面，否则元素不在里面。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	返回元素的索引,分为两种情况，一种是元素是<code>null</code>的情况，不能使用<code>equals()</code>方法，另一种是非<code>null</code>，可以直接使用<code>equals()</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取索引位置"><a href="#获取索引位置" class="headerlink" title="获取索引位置"></a>获取索引位置</h4><h5 id="public-synchronized-int-lastIndexOf-Object-o"><a href="#public-synchronized-int-lastIndexOf-Object-o" class="headerlink" title="public synchronized int lastIndexOf(Object o)"></a><code>public synchronized int lastIndexOf(Object o)</code></h5><blockquote>
<p>​	获取元素最后出现的索引位置,和前面一个不一样的是，这个需要从最后一个元素往前面查找</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<p>​	<code>LinkedList</code>同时实现了<code>List</code>接口和<code>Deque</code>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<code>Queue</code>)，同时又可以看作一个栈(<code>Stack</code>)。这样看来，<code>LinkedList</code>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<code>LinkedList</code>，一方面是因为<code>Java</code>官方已经声明不建议使用<code>Stack</code>类，更遗憾的是，<code>Java</code>里根本没有一个叫做<code>Queue</code>的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比<code>LinkedList</code>(当作栈或队列使用时)有着更好的性能。</p>
</blockquote>
<h3 id="LinkedList构造方法"><a href="#LinkedList构造方法" class="headerlink" title="LinkedList构造方法"></a>LinkedList构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	继承了<code>AbstractSequentialList</code>，实现了<code>List</code>,<code>Queue</code>,<code>Cloneable</code>,<code>Serializable</code>，既可以当成列表使用，也可以当成队列，堆栈使用。主要特点有：</p>
<ul>
<li>线程不安全，不同步，如果需要同步需要使用<code>List list = Collections.synchronizedList(new LinkedList());</code></li>
<li>实现<code>List</code>接口，可以对它进行队列操作</li>
<li>实现<code>Queue</code>接口，可以当成堆栈或者双向队列使用</li>
<li>实现Cloneable接口，可以被克隆，浅拷贝</li>
<li>实现<code>Serializable</code>，可以被序列化和反序列化</li>
</ul>
</blockquote>
<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 最后一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">// 序列化uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	成员变量相对比较简单，因为不像<code>ArrayList</code>一样，需要使用数组保存元素，<code>LinkedList</code>是靠引用来关联前后节点，所以这里只有大小，第一个节点，最后一个节点,以及序列化的<code>uid</code>。</p>
</blockquote>
<p>Node作为内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 节点里面的数据</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 上一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数，重写之后，无参数构造器已经被覆盖，三个参数分别对应三个属性</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/229127715_1621003494347_5A9F6A51E994577B680762E995D412F0.png"></p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public LinkedList()</code></td>
<td align="center">无参构造器，构造一个空集合。</td>
</tr>
<tr>
<td align="center"><code>public LinkedList(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定集合元素的集合，其顺序由集合的迭代器返回。</td>
</tr>
</tbody></table>
<h5 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-LinkedList"><a href="#public-LinkedList" class="headerlink" title="public LinkedList()"></a><code>public LinkedList()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-LinkedList-Collection-c"><a href="#public-LinkedList-Collection-c" class="headerlink" title="public LinkedList(Collection&lt;? extends E&gt; c)"></a><code>public LinkedList(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用无参构造函数进行初始化</span></span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    <span class="comment">// 将集合 c 添加进集合</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用addAll(size,c)方法</span></span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入集合中的所有元素方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">   	<span class="comment">//检查位置是否合法</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//将集合c转换为数组</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="comment">//计算元素的个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="comment">//如果集合为空，就直接不进行插入</span></span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//创建前驱节点pred和当前节点succ</span></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//如果要插入的位置是最末尾</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">       	<span class="comment">//则当前节点为空</span></span><br><span class="line">           succ = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//前驱节点就是最末尾的元素</span></span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//否则，获取index上的元素</span></span><br><span class="line">           succ = node(index);</span><br><span class="line">           <span class="comment">//根据succ，获得index-1上的节点</span></span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//遍历数组中的元素</span></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">       	<span class="comment">//进行强制类型转化</span></span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">           <span class="comment">//创建一个节点</span></span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">           <span class="comment">//如果没有前驱节点，表明是一个空链表，就设置为头节点</span></span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           	<span class="comment">//否则设置pred的后继节点为newNode</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//如果当前节点为null，说明是要在末尾插值</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">       	<span class="comment">//设置为尾节点</span></span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//反之，将新加上的链表连上后面的链表，形成双向链表</span></span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//链表的长度需要修改</span></span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="comment">//修改次数+1</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查插入的位置是否合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//调用方法</span></span><br><span class="line">       <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">       	<span class="comment">//如果位置符合法，就抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查位置是否符合要求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//要求index必须&gt;=0或者&lt;=size</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取<code>index</code>位置上的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//通过移位操作，判断index位置离左端点近，还是右端点近</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       	<span class="comment">//如果是离左端点近，就从左向右遍历，首先获取头节点</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="comment">//通过for循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="comment">//返回index位置上的值</span></span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//如果是离右端点近，就从右向左遍历，首先获取尾节点的值</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="comment">//铜鼓for循环循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>首先是调用了<code>addAll (c)</code>方法，将集合c作为参数进行传递</li>
<li>然后又调用<code>addAll(size, c)</code>方法，将链表的长度和集合c作为参数进行传递</li>
<li>进入到<code>addAll()</code>方法中，又马上调用了<code>checkPositionIndex(index)</code>，这个方法主要是用来检查要插入的位置index是否合法。</li>
<li>紧接着，先将集合<code>c</code>转换为数组<code>a</code>。然后判断<code>index</code>位置的位置，获得当前节点<code>succ</code>以及前驱节点<code>pred</code></li>
<li>然后使用增强<code>for</code>循环从数组中取出元素，逐一创建一个新节点，然后将节点插入到链表中。</li>
<li><code>for</code>循环完了之后，判断<code>pred</code>节点是否已经是尾节点，如果是，就设置为尾节点。否则，将后续的链表连上。</li>
<li>最后，要记得把链表的长度增加，并且修改次数<code>+1</code></li>
</ol>
</blockquote>
<h4 id="增加方法-1"><a href="#增加方法-1" class="headerlink" title="增加方法"></a>增加方法</h4><h5 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a><code>public boolean add(E e)</code></h5><blockquote>
<p>在末尾添加单个元素的<code>add</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//调用linkLast在末尾添加上元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在最后一个位置插入元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点newNode</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//设置尾节点为newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原先的last为null,则说明是第一次添加，将first也指向这个新Node</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">//设置头节点为newNode</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则设置尾节点的后继为newNode</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//数目+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element-1"><a href="#public-void-add-int-index-E-element-1" class="headerlink" title="public void add(int index, E element)"></a><code>public void add(int index, E element)</code></h5><blockquote>
<p>在指定位置添加上元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">      <span class="comment">//查看index位置是否合法</span></span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line"><span class="comment">//查看想插入的位置是否为最末尾</span></span><br><span class="line">      <span class="keyword">if</span> (index == size)</span><br><span class="line">      	<span class="comment">//调用linkLast在最末尾插入元素</span></span><br><span class="line">          linkLast(element);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      	<span class="comment">//调用linlBefore在index位置上插入元素</span></span><br><span class="line">          linkBefore(element, node(index));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查插入的位置是否合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//调用方法</span></span><br><span class="line">       <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">       	<span class="comment">//如果位置符合法，就抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查位置是否符合要求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//要求index必须&gt;=0或者&lt;=size</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>index</code>位置上插入元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">//通过当前节点succ蝴蝶前驱节点pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点newNode</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//设置newNode为succ的前驱节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果前驱节点为null，那么newNode就作为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则设置pred的后继节点为newNode</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">//数目加1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-addFirst-E-e"><a href="#public-void-addFirst-E-e" class="headerlink" title="public void addFirst(E e)"></a><code>public void addFirst(E e)</code></h5><blockquote>
<p>插入元素成为头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//在第一个位置插入元素</span></span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//获取头节点的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">//设置头节点为newNode</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果f==null，代表原本是一个空链表</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">//同样设置尾节点为newNode</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则，设置f的前驱节点为newNode</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">//数目+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-addLast-E-e"><a href="#public-void-addLast-E-e" class="headerlink" title="public void addLast(E e)"></a><code>public void addLast(E e)</code></h5><blockquote>
<p>插入元素成为尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//在最后一个位置插入元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offer-E-e"><a href="#public-boolean-offer-E-e" class="headerlink" title="public boolean offer(E e)"></a><code>public boolean offer(E e)</code></h5><blockquote>
<p>将指定的元素添加到集合的尾部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offerLast-E-e"><a href="#public-boolean-offerLast-E-e" class="headerlink" title="public boolean offerLast(E e)"></a><code>public boolean offerLast(E e)</code></h5><blockquote>
<p>插入特定元素到集合末尾，该方法和 addLast 作用一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offerFirst-E-e"><a href="#public-boolean-offerFirst-E-e" class="headerlink" title="public boolean offerFirst(E e)"></a><code>public boolean offerFirst(E e)</code></h5><blockquote>
<p>将元素插入到集合的头部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>add</code>方法返回值为 <code>void</code>, <code>offer</code>返回值为 <code>boolean</code></li>
<li>将指定的元素添加到集合的尾部，该方法的作用和 <code>add(E e)</code> ，<code>addLast(E e)</code> 一样。当使用容量受限的双端队列时，此方法通常比 <code>add</code> 方法更可取，当超出队列容量时，该方法返回 <code>false</code>，而 <code>add</code> 方法则会抛出异常。</li>
</ul>
</blockquote>
<h4 id="删除方法-2"><a href="#删除方法-2" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-E-remove"><a href="#public-E-remove" class="headerlink" title="public E remove()"></a><code>public E remove()</code></h5><blockquote>
<p>删除集合的第一个节点，并返回该元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除集合的第一个节点，并返回该元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 没有首节点抛出 NoSuchElementException</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 删除首节点</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除不为 <code>null</code> 的首节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧首节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="comment">// 获取旧首节点的下一个节点 next，next 为新首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 将旧首节点的值和下一个节点的指向赋为 null，帮助 GC</span></span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    f.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用新首节点 next 更新首节点 first</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果 next 节点为空，则代表原集合只有一个节点，将尾节点也指向 null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// next 不为空的话，将该新首节点的上一个节点指向 null</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的首节点元素</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a><code>public E remove(int index)</code></h5><blockquote>
<p>删除指定的<code>index</code>位置的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 删除指定下标所在的节点</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除指定不为 <code>null</code> 的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定节点的值，用于最后返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取该节点的下一个节点 next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取该节点的上一个节点 prev</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 prev 节点为 null，表示该节点为首节点，将 next 节点指向首节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prev 节点不为 null，则将 prev 的下一个节点指向 next</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将该节点的上一个节点置为 null，帮助 GC</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 next 节点为 null，表示该节点为尾节点，将 prev 节点指向尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// next 节点不为 null，将 next 的上一个节点指向 prev</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将该节点的下一个节点置为 null，帮助 GC</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该节点的值置为 null</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的元素的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-remove-Object-o-1"><a href="#public-boolean-remove-Object-o-1" class="headerlink" title="public boolean remove(Object o)"></a><code>public boolean remove(Object o)</code></h5><blockquote>
<p>删除指定元素的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="comment">//查看对象是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//for循环遍历每一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//如果为null</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//删除该节点</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//遍历每一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//如果节点的元素和o相等</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">            	<span class="comment">//删除该节点</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除失败，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-removeFirst"><a href="#public-E-removeFirst" class="headerlink" title="public E removeFirst()"></a><code>public E removeFirst()</code></h5><blockquote>
<p>删除头节点元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//获得头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//查看头节点是否为空，为空则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//否则，调用方法删除头节点</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-removeLast"><a href="#public-E-removeLast" class="headerlink" title="public E removeLast()"></a><code>public E removeLast()</code></h5><blockquote>
<p>删除尾节点的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 尾节点为 null 抛出 NoSuchElementException</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除不为 <code>null</code> 的尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧尾节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="comment">// 获取旧尾节点的上一个节点 prev，prev 为新尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 将旧尾节点的值和下一个节点的指向置为 null，帮助 GC</span></span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用新尾节点 prev 更新尾节点 last</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果新尾节点节点为空，则代表该集合只有一个节点，将首节点指向 null</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 新尾节点不为空，将新尾节点的下一个节点指向 null</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的尾节点的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>unlink()</code>方法：</strong></p>
<ol>
<li>首先，获取<code>x</code>节点中的元素，并且获取<code>x</code>节点的后继节点<code>next</code>以及<code>x</code>节点的前驱节点<code>prev</code></li>
<li>然后，如果前驱节点为<code>null</code>，那就将后继节点<code>next</code>设置为头节点。否则，让前驱节点的后继节点指向<code>next</code></li>
<li>如果后继节点为<code>null</code>，设置前驱节点<code>prev</code>为尾节点。否则设置<code>next</code>的前驱节点为<code>prev</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
<p><strong><code>unlinkFirst()</code>方法：</strong></p>
<ol>
<li>因为这个节点是<code>private</code>修饰的，所以我们外部无法直接调用。它是有限制传入的节点必须为头节点的。</li>
<li>首先获得头节点中的元素，然后获得第二个位置上的元素<code>next</code>，设置<code>next</code>节点为头节点</li>
<li>然后判断是否删除了原来节点之后成为了空链表，如果是，将<code>last</code>也置为<code>null</code>。否则设置<code>next</code>的前驱节点为<code>null</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
<p><strong><code>unlinkLast()</code>方法：</strong></p>
<ol>
<li>因为这个节点是<code>private</code>修饰的，所以我们外部无法直接调用。它是有限制传入的节点必须为尾节点的。</li>
<li>首先获得尾节点中的元素，然后获得倒数第二个位置上的元素<code>pred</code>，设置<code>pred</code>节点为尾节点</li>
<li>然后判断是否删除了原来节点之后成为了空链表，如果是，将<code>first</code>也置为<code>null</code>。否则设置pred的后继节点为<code>null</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
</blockquote>
<h5 id="public-E-poll"><a href="#public-E-poll" class="headerlink" title="public E poll()"></a><code>public E poll()</code></h5><blockquote>
<p>删除集合的头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-pollFirst"><a href="#public-E-pollFirst" class="headerlink" title="public E pollFirst()"></a><code>public E pollFirst()</code></h5><blockquote>
<p>删除集合头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 如果该集合没有元素则返回 null，否则删除首节点</span></span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-pollLast"><a href="#public-E-pollLast" class="headerlink" title="public E pollLast()"></a><code>public E pollLast()</code></h5><blockquote>
<p>检删除链表的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 如果该集合没有元素则返回 null，否则删除尾节点</span></span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>删除集合的头节点，该方法的作用和 <code>remove()</code>一样，不过当两个方法对空集合使用时，<code>remove()</code> 方抛出异常，而 <code>poll()</code> 方返回 <code>null</code>。</li>
<li><code>pollFirst()</code> 方法和 <code>poll()</code> 方法的作用一样，当集合为空时返回 <code>null</code>。</li>
<li><code>pollLast()</code> 方法和 <code>removeLast()</code> 方法的作用一样，不过当集合为空时，<code>pollLast()</code> 方法回<code>null</code>，<code>removeLast()</code> 方法抛出异常。</li>
</ul>
</blockquote>
<h4 id="获取方法-2"><a href="#获取方法-2" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a><code>public E get(int index)</code></h5><blockquote>
<p>返回集合中指定位置的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// node(index) 返回节点</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取<code>index</code>位置上的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//通过移位操作，判断index位置离左端点近，还是右端点近</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       	<span class="comment">//如果是离左端点近，就从左向右遍历，首先获取头节点</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="comment">//通过for循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="comment">//返回index位置上的值</span></span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//如果是离右端点近，就从右向左遍历，首先获取尾节点的值</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="comment">//铜鼓for循环循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-getFirst"><a href="#public-E-getFirst" class="headerlink" title="public E getFirst()"></a><code>public E getFirst()</code></h5><blockquote>
<p>返回集合中的第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-getLast"><a href="#public-E-getLast" class="headerlink" title="public E getLast()"></a><code>public E getLast()</code></h5><blockquote>
<p>返回集合中的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peek"><a href="#public-E-peek" class="headerlink" title="public E peek()"></a><code>public E peek()</code></h5><blockquote>
<p>返回集合的第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peekFirst"><a href="#public-E-peekFirst" class="headerlink" title="public E peekFirst()"></a><code>public E peekFirst()</code></h5><blockquote>
<p>返回集合的第一个元素，作用和 peek() 一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peekLast"><a href="#public-E-peekLast" class="headerlink" title="public E peekLast()"></a><code>public E peekLast()</code></h5><blockquote>
<p>返回集合的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>get</code>方法返回首节点和尾节点的时候，如果为<code>null</code>，则会抛出异常。而</li>
<li><code>peek</code>方法返回首节点和尾节点的时候不会抛出异常。</li>
</ul>
</blockquote>
<h4 id="清空方法-1"><a href="#清空方法-1" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a><code>public void clear()</code></h5><blockquote>
<p>移除里面所有的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">          <span class="comment">// 保存下一个</span></span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">          <span class="comment">// 当前元素置空</span></span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 首节点和尾节点全部置null</span></span><br><span class="line">    first = last = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<ul>
<li><p><code>HashMap</code> 基于哈希表的 <code>Map</code> 接口实现，是以 <code>key-value</code> 存储形式存在，即主要用来存放键值对。<code>HashMap</code> 的实现不是同步的，这意味着它不是线程安全的。它的 <code>key</code>、<code>value</code> 都可以为 <code>null</code>，此外，<code>HashMap</code> 中的映射不是有序的。</p>
</li>
<li><p><code>jdk1.8</code> 之前 <code>HashMap</code> 由 <strong>数组 + 链表</strong> 组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 <code>hashCode</code> 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）而存在的（“拉链法”解决冲突）。<code>jdk1.8</code> 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 <code>8</code> ）并且当前数组的长度大于 <code>64</code> 时，此时此索引位置上的所有数据改为使用红黑树存储。</p>
</li>
<li><p>补充：将链表转换成红黑树前会判断，即便阈值大于 <code>8</code>，但是数组长度小于 <code>64</code>，此时并不会将链表变为红黑树，而是选择逬行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要逬行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于<code>64</code>时，搜索时间相对要快些。所以结上所述为了提高性能和减少搜索时间，<strong>底层阈值大于<code>8</code>并且数组长度大于<code>64</code>时</strong>，链表才转换为红黑树，具体可以参考 <code>treeifyBin()</code> 方法。</p>
</li>
<li><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于 <code>8</code> 并且数组长度大于<code>64</code>时，链表转换为红黑树时，效率也变的更高效。</p>
</li>
</ul>
</blockquote>
<h3 id="HashMap-特点"><a href="#HashMap-特点" class="headerlink" title="HashMap 特点"></a>HashMap 特点</h3><blockquote>
<ul>
<li>存储无序的。</li>
<li>键和值位置都可以是 <code>null</code>，但是键位置只能存在一个 <code>null</code>。</li>
<li>键位置是唯一的，是底层的数据结构控制的。</li>
<li><code>jdk1.8</code> 前数据结构是<strong>链表+数组</strong>，<code>jdk1.8</code> 之后是<strong>链表+数组+红黑树</strong>。</li>
<li>阈值（边界值）&gt; <code>8</code> 并且数组长度大于 <code>64</code>，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>说明：<code>HashMap</code>在未变成红黑树前，采用的单向链表，然后在即将变成红黑树时，先转化为双向链表，双向链表转化为红黑树</font></p>
</blockquote>
<h3 id="JDK1-7和JDK1-8区别"><a href="#JDK1-7和JDK1-8区别" class="headerlink" title="JDK1.7和JDK1.8区别"></a>JDK1.7和JDK1.8区别</h3><blockquote>
<ul>
<li><code>JDK1.7</code>用的是头插法，而<code>JDK1.8</code>及之后使用的都是尾插法，那么他们为什么要这样做呢？因为<code>JDK1.7</code>是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在<code>JDK1.8</code>之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</li>
<li>扩容后数据存储位置的计算方式也不一样：1. 在<code>JDK1.7</code>的时候是直接用<code>hash</code>值和需要扩容的二进制数进行<code>&amp;</code>（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是<code>1</code>，这样能最大程度减少<code>hash</code>碰撞）（<code>hash值 &amp; length-1</code>）</li>
<li>在<code>JDK1.7</code>的时候是<strong>先扩容后插入</strong>的，这样就会导致无论这一次插入是不是发生<code>hash</code>冲突都需要进行扩容，如果这次插入的并没有发生<code>Hash</code>冲突的话，那么就会造成一次无效扩容，但是在<code>JDK1.8</code>的时候是<strong>先插入再扩容</strong>的，优点其实是因为为了减少这一次无效的扩容，原因就是如果这次插入没有发生<code>Hash</code>冲突的话，那么其实就不会造成扩容，但是在<code>JDK1.7</code>的时候就会急造成扩容。（JDK1.7扩容条件：1、存放新值的时候当前已有元素的个数必须大于等于阈值；2、存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</li>
<li>而在<code>JDK1.8</code>的时候直接用了<code>JDK1.7</code>的时候计算的规律，也就是<code>扩容前的原始位置+扩容的大小值=JDK1.8</code>的计算方式，而不再是<code>JDK1.7</code>的那种异或的方法。但是这种方式就相当于只需要判断<code>Hash</code>值的新增参与运算的位是<code>0</code>还是<code>1</code>就直接迅速计算出了扩容后的储存方式。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20180905105129591.png"></p>
<h4 id="为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢？"><a href="#为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢？" class="headerlink" title="为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？"></a>为什么在<code>JDK1.7</code>的时候是先进行扩容后进行插入，而在<code>JDK1.8</code>的时候则是先插入后进行扩容的呢？</h4><blockquote>
<ul>
<li>在<code>JDK1.7</code>中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，如果不为空说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用</li>
</ul>
</blockquote>
<h3 id="HashMap-继承关系"><a href="#HashMap-继承关系" class="headerlink" title="HashMap 继承关系"></a>HashMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap-源码分析-JDK1-8"><a href="#HashMap-源码分析-JDK1-8" class="headerlink" title="HashMap 源码分析(JDK1.8)"></a>HashMap 源码分析(JDK1.8)</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628085432352.png"></p>
<h4 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的数组初始容量为16</span></span><br><span class="line"><span class="comment">    * 1&lt;&lt;4代表移位操作，左移动4位，相当于1*2*2*2*2=16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组的最大容量</span></span><br><span class="line"><span class="comment">    * 也就相当于最大容量为2的30次方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  默认的负载因子为0.75</span></span><br><span class="line"><span class="comment">    *  例如，默认的数组容量为16，默认的负载因子为0.75</span></span><br><span class="line"><span class="comment">    *  因此，当所有链表节点个数的 总合 &gt; 容量*负载因子 的时候，就需要进行扩容</span></span><br><span class="line"><span class="comment">    *  因为如果节点的个数过多的话，会造成大量的哈希冲突，链表过长，导致插入和查询效率低下</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当某个链表上的节点个数超过8的时候，就会将该链表转换为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当某个链表上的节点个数小于6的时候，又会将红黑树转化为链表。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当桶的容量最少为MIN_TREEIFY_CAPACITY，也就是64的时候，才会转换为红黑树</span></span><br><span class="line"><span class="comment">    * 如果没有达到64的话，优先选择是将桶扩容，而不是转换为红黑树</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里的table也就是相当于上面提到的桶，永远都是2的幂次方个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储具体元素的集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存放元素的个数，这个不是等于桶的个数，而是所有节点的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  阈值，元素的个数不能超过阈值</span></span><br><span class="line"><span class="comment">    * threshold = Capacity(容量)*loadFactor（负载因子）</span></span><br><span class="line"><span class="comment">    * 当实际个数超过threshold的时候，就会进行扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对应于上面的DEFAULT_LOAD_FACTOR，这个是实际的负载因子。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="Node节点类"><a href="#Node节点类" class="headerlink" title="Node节点类"></a>Node节点类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node节点类，继承自Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写hashCode()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equal方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public HashMap()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public HashMap(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public HashMap(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传入一个<code>Map</code>类型的<code>m</code>，将<code>m</code>中的所有元素放进<code>HashMap</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-HashMap"><a href="#public-HashMap" class="headerlink" title="public HashMap()"></a><code>public HashMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法</span></span><br><span class="line"><span class="comment"> * 使用默认的负载因子0.75</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-int-initialCapacity"><a href="#public-HashMap-int-initialCapacity" class="headerlink" title="public HashMap(int initialCapacity)"></a><code>public HashMap(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个参数的构造函数</span></span><br><span class="line"><span class="comment"> * 参数为初始容量initialCapacity</span></span><br><span class="line"><span class="comment"> * 调用上面的两个参数的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-int-initialCapacity-float-loadFactor"><a href="#public-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashMap(int initialCapacity, float loadFactor)"></a><code>public HashMap(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"><span class="comment">	 initialCapacity：指定的容量</span></span><br><span class="line"><span class="comment">	 loadFactor:指定的负载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    	<span class="comment">// 判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    	<span class="comment">// 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    	<span class="comment">// 判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">// 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     	<span class="comment">// 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 最后调用了tableSizeFor，来看一下方法实现：</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     	返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-Map-m"><a href="#public-HashMap-Map-m" class="headerlink" title="public HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传入一个Map类型的m，将m中的所有元素放进HashMap中</span></span><br><span class="line"><span class="comment">    * 因为没有设置负载因子，所以设置负载因子为默认的负载因子</span></span><br><span class="line"><span class="comment">    * 这里先假设putMapEntries(m, false)是将m中的元素方式HashMap中的方法</span></span><br><span class="line"><span class="comment">    * 下面会具体解释这个方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这个方法相当于是将m中的元素添加到HashMap中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">   	<span class="comment">//获取m中实际有多少个元素</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">       <span class="comment">//如果个数大于0</span></span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       	<span class="comment">//如果table数组不是null，就是已经初始化过了</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">           	<span class="comment">//使用s/loadFactor计算出需要的数组容量是多少</span></span><br><span class="line">               <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">//查看ft是否超过了最大数组容量MAXIMUM_CAPACITY</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//查看t是否超过了最大装载量</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">               	<span class="comment">//如果超过了阈值，就初始化阈值</span></span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//table没有进行初始化过，就进行初始化</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">           	<span class="comment">//这里可以理解为一个扩容的方法，下面会解释</span></span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">//foreach循环遍历m中的每一个元素</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">               <span class="comment">//将m中的元素添加到HashMap中</span></span><br><span class="line">               putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>float ft = ((float)s / loadFactor) + 1.0F</code>; 这一行代码中为什么要加 <code>1.0F</code> ？</p>
<p>​	<code>s/loadFactor</code> 的结果是小数，加 <code>1.0F</code> 与 <code>(int)ft</code> 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 <code>resize</code> 的调用次数。所以 <code>+ 1.0F</code> 是为了获取更大的容量。</p>
<p>​	例如：原来集合的元素个数是 <code>6</code> 个，那么 <code>6/0.75</code> 是 <code>8</code>，是 <code>2</code> 的 <code>n</code>次幂，那么新的数组大小就是 <code>8</code> 了。然后原来数组的数据就会存储到长度是 <code>8</code> 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 <code>+1</code> 呢，数组长度直接变为<code>16</code>了，这样可以减少数组的扩容。</p>
</blockquote>
<h4 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a><code>tableSizeFor(int cap)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将参数cap转换为2的幂次方的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这个方法主要是用来规范初始化容量的，因为构造方法中传入的<code>initialCapacity</code>可能并不是<code>2</code>的幂次方，但是规定了数组的容量必须是<code>2</code>的幂次方，所以需要此方法来找到大于或等于<code>initialCapacity</code>的<code>2</code>的幂次方。</p>
</blockquote>
<p>分析：</p>
<blockquote>
<ol>
<li><p><code>int n = cap - 1</code>;<br>防止 <code>cap</code> 已经是 <code>2</code> 的幂。如果 <code>cap</code> 已经是 <code>2</code> 的幂，又没有这个减 <code>1</code> 操作，则执行完后面的几条无符号操作之后，返回的 <code>capacity</code> 将是这个 <code>cap</code> 的 <code>2</code> 倍。</p>
</li>
<li><p>如果 <code>n</code> 这时为 <code>0</code> 了（经过了<code>cap - 1</code>后），则经过后面的几次无符号右移依然是 <code>0</code>，最后返回的 <code>capacity</code> 是<code>1</code>（最后有个 <code>n + 1</code> 的操作）。</p>
</li>
<li><p>注意：容量最大也就是 <code>32bit</code> 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>; 最多也就 <code>32</code> 个 <code>1</code>（但是这已经是负数了，在执行 <code>tableSizeFor</code> 之前，对 <code>initialCapacity</code> 做了判断，如果大于<code>MAXIMUM_CAPACITY(2 ^ 30)</code>，则取 <code>MAXIMUM_CAPACITY</code>。如果等于<code>MAXIMUM_CAPACITY</code>，会执行位移操作。所以这里面的位移操作之后，最大 <code>30</code> 个 <code>1</code>，不会大于等于 <code>MAXIMUM_CAPACITY</code>。<code>30</code> 个 <code>1</code>，加<code>1</code>后得 <code>2 ^ 30</code>）。</p>
</li>
</ol>
</blockquote>
<p>完整例子：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628085716417.png"></p>
<h4 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a><code>hash(Object key)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>这是一个根据<code>key</code>来返回哈希值的方法</li>
<li>这个方法是传入一个<code>key</code>值，然后判断<code>key</code>是否为<code>null</code>，如果为<code>null</code>的话，就直接返回<code>0</code></li>
<li>如果不为<code>null</code>，先通过<code>hashCode()</code>方法获取哈希值，然后将<code>h</code>右移<code>16</code>位，并进行计算结果并返回，这样做的目的是尽量减少哈希冲突。</li>
</ol>
</blockquote>
<h4 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h4><h5 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a><code>put(K key, V value)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a><code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash  由key计算出来的 hash值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要存储的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  要存储的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent  如果当前位置已存在一个值，是否替换，false是替换，true是不替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict  表是否在创建模式，如果为false，则表是在创建模式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    	2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。</span></span><br><span class="line"><span class="comment">    	3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，</span></span><br><span class="line"><span class="comment">    	满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。</span></span><br><span class="line"><span class="comment">    	4）执行完n = (tab = resize()).length，数组tab每个空间都是null。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。</span></span><br><span class="line"><span class="comment">    	2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给结点p。</span></span><br><span class="line"><span class="comment">    	3) (p = tab[i = (n - 1) &amp; hash]) == null 判断结点位置是否等于null，</span></span><br><span class="line"><span class="comment">    	如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 创建一个新的结点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        	1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等。</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的。</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key比较两个key的地址值是否相等。</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，</span></span><br><span class="line"><span class="comment">             那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	1)如果是链表的话需要遍历到最后结点然后插入</span></span><br><span class="line"><span class="comment">            	2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	1)e = p.next 获取p的下一个元素赋值给e。</span></span><br><span class="line"><span class="comment">                	2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	1）创建一个新的结点插入到尾部</span></span><br><span class="line"><span class="comment">                    	 p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                    	 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。</span></span><br><span class="line"><span class="comment">                    	2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    	如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 尝试转换为红黑树，不一定会成功，因为还需要满足table的长度大于64</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                		要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                		直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                	*/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明新添加的元素和当前结点不相等，继续查找下一个结点。</span></span><br><span class="line"><span class="comment">                	用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        	也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        	这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 用新值替换旧值</span></span><br><span class="line">                <span class="comment">// e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="treeifyBin-Node-tab-int-hash"><a href="#treeifyBin-Node-tab-int-hash" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab, int hash) "></a><code>treeifyBin(Node&lt;K,V&gt;[] tab, int hash) </code></h4><blockquote>
<p>​	将链表转换为红黑树，结点添加完成之后判断此时结点个数是否大于 <code>TREEIFY_THRESHOLD</code> 临界值<code> 8</code>，如果大于则将链表转换为红黑树，转换红黑树的方法 <code>treeifyBin</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">	Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">	int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。</span></span><br><span class="line"><span class="comment">    	目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//扩容方法</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">        	2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// hd：红黑树的头结点   tl：红黑树的尾结点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 新创建一个树的结点，内容和当前链表结点e一致</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p; <span class="comment">// 将新创键的p结点赋值给红黑树的头结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl; <span class="comment">// 将上一个结点p赋值给现在的p的前一个结点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 将现在结点p作为树的尾结点的下一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null</span></span><br><span class="line"><span class="comment">            	则回到上面继续取出链表中结点转换为红黑树</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">        	而不是链表数据结构了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：上述操作一共做了如下几件事：</p>
<blockquote>
<ol>
<li>根据哈希表中元素个数确定是扩容还是树形化。</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。</li>
<li>然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。</li>
</ol>
</blockquote>
<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h4><h5 id="扩容时机："><a href="#扩容时机：" class="headerlink" title="扩容时机："></a>扩容时机：</h5><blockquote>
<ol>
<li><code>HashMap</code>实行了懒加载, 新建<code>HashMap</code>时不会对<code>table</code>进行赋值, 而是到第一次插入时, 进行<code>resize</code>时构建<code>table</code>;</li>
<li>当<code>HashMap.size</code> 大于 <code>threshold</code>时, 会进行<code>resize</code>；<code>threshold</code>的值我们在上一次分享中提到过: 当第一次构建时, 如果没有指定<code>HashMap.table</code>的初始长度, 就用默认值<code>16</code>, 否则就是指定的值; 然后不管是第一次构建还是后续扩容, <code>threshold = table.length * loadFactor</code></li>
</ol>
</blockquote>
<p>如何扩容：</p>
<blockquote>
<ul>
<li><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
</li>
<li><p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) &amp; hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。</p>
</li>
</ul>
</blockquote>
<p>例如我们从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628214503128.png"></p>
<p>因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628215948256.png"></p>
<p>说明：</p>
<blockquote>
<p>​	5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。</p>
<p>​	因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” 。</p>
</blockquote>
<p>可以看看下图为 16 扩充为 32 的 resize 示意图：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628220517981.png"></p>
<blockquote>
<p>​	正是因为这样巧妙的 <code>rehash</code> 方式，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 <code>1bit</code> 是 <code>0</code> 还是 <code>1</code> 可以认为是随机的，在 <code>resize</code> 的过程中保证了 <code>rehash</code> 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 <code>rehash</code> 之后不会出现更严重的 <code>hash</code> 冲突，均匀的把之前的冲突的结点分散到新的桶中了。</p>
</blockquote>
<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">// 开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        	1) (newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        	2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">// 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 通过上述讲解的原理来计算结点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     	<span class="comment">// 这里来判断如果等于true e这个结点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>首先需要获取旧桶以及旧桶的初始容量</li>
<li>如果旧桶已经初始化过了，并且旧桶已经是最大容量了，那就不进行扩容了，直接返回。如果不是的话，就将桶扩大一倍，并且阈值也扩大一倍。</li>
<li>如果旧桶没有被初始化过，那么就根据默认值对新桶的成员变量进行初始化</li>
<li>如果阈值为<code>0</code>的话，就需要重新确定阈值</li>
<li>然后根据新桶的成员变量，对新桶进行初始化</li>
<li>因为新桶的容量和旧桶的不一样，所以位置<code>index</code>也变了，因此需要重新计算<code>index</code>位置，将旧桶中的元素搬迁到新桶中。</li>
</ol>
</blockquote>
<h4 id="删除方法-3"><a href="#删除方法-3" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a><code>remove(Object key)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定key的remove方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">//调用下面的方法删除指定的key</span></span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">          <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">	<span class="comment">// 根据hash找到位置 </span></span><br><span class="line">	<span class="comment">// 如果当前key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果桶上的结点就是要找的key，则将node指向该结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明结点存在下一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 说明是以红黑树来处理的冲突，则获取红黑树要删除的结点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的结点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 通过调用红黑树的方法来删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 链表删除</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 记录修改次数</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 变动的数量</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>首先要查看数组是否已经初始化了，如果初始化了，才能进行下面的计算</li>
<li>要删除的节点分为三种情况。位于<code>index</code>桶中的第一个节点、红黑树节点、位于<code>index</code>桶中后面的节点。这三种情况需要进行判断，是属于哪一类情况，获得要删除的节点</li>
<li>确定属于哪一类情况之后，再根据三种不同的情况进行节点的删除。</li>
</ol>
</blockquote>
<h4 id="获取方法-3"><a href="#获取方法-3" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        	判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        	根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        	注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>通过 <code>hash</code> 值获取该 <code>key</code> 映射到的桶</li>
<li>桶上的 <code>key</code> 就是要查找的 <code>key</code>，则直接找到并返回</li>
<li>桶上的 <code>key</code> 不是要找的 <code>key</code>，则查看后续的结点：<ul>
<li>如果后续结点是红黑树结点，通过调用红黑树的方法根据 <code>key</code> 获取 <code>value</code></li>
<li>如果后续结点是链表结点，则通过循环遍历链表根据 <code>key</code> 获取 <code>value</code></li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="清空方法-2"><a href="#清空方法-2" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a><code>clear()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空每个桶的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab;</span><br><span class="line">      <span class="comment">//修改次数+1</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//遍历每一个桶</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//节点个数为0</span></span><br><span class="line">          size = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//将桶的第一个元素置为null，方便gc</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">              tab[i] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法-2"><a href="#包含方法-2" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue(Object value) "></a><code>containsValue(Object value) </code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  查看HashMap中是否含有指定的balue </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">       <span class="comment">//判断桶是否已经初始化了</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       	<span class="comment">//遍历每一个桶</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">               <span class="comment">//获得桶中的每一个节点</span></span><br><span class="line">               <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                   <span class="comment">//逐个比较s</span></span><br><span class="line">                   <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                       (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<ul>
<li><code>TreeMap</code>存储<code>K-V</code>键值对，通过红黑树<code>（R-B tree）</code>实现；</li>
<li><code>TreeMap</code>继承了<code>NavigableMap</code>接口，<code>NavigableMap</code>接口继承了<code>SortedMap</code>接口，可支持一系列的导航定位以及导航操作的方法，当然只是提供了接口，需要<code>TreeMap</code>自己去实现；</li>
<li><code>TreeMap</code>实现了<code>Cloneable</code>接口，可被克隆，实现了<code>Serializable</code>接口，可序列化；</li>
<li><code>TreeMap</code>因为是通过红黑树实现，红黑树结构天然支持排序，默认情况下通过<code>Key</code>值的自然顺序进行排序；</li>
</ul>
</blockquote>
<h3 id="TreeMap-继承关系"><a href="#TreeMap-继承关系" class="headerlink" title="TreeMap 继承关系"></a>TreeMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-源码分析"><a href="#TreeMap-源码分析" class="headerlink" title="TreeMap 源码分析"></a>TreeMap 源码分析</h3><h4 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   我们前面提到TreeMap是可以自动排序的，默认情况下comparator为null，这个时候</span></span><br><span class="line"><span class="comment">   按照key的自然顺序进行排序，然而并不是所有情况下都可以直接使用key的自然顺序，</span></span><br><span class="line"><span class="comment">   有时候我们想让Map的自动排序按照我们自己的规则，这个时候你就需要传递Comparator的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   TreeMap的存储结构既然是红黑树，那么必然会有唯一的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   Map中key-val对的数量，也即是红黑树中节点Entry的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   红黑树结构的修改次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry&lt;K,V&gt;"></a><code>Entry&lt;K,V&gt;</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//key,val是存储的原始数据</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了节点的左孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了节点的右孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过该节点可以反过来往上找到自己的父亲</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认情况下为黑色节点，可调整</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> (key==<span class="literal">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">valueHash</span> <span class="operator">=</span> (value==<span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY3NzkxNC8yMDE5MDcvMTY3NzkxNC0yMDE5MDcyMTE2MjY0ODEzMS0zMjY5OTYwMzAucG5n.png"></p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public TreeMap()</code></td>
<td align="center">默认构造函数，按照key的自然顺序排列</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></td>
<td align="center">传递<code>Comparator</code>具体实现，按照该实现规则进行排序</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传递一个<code>map</code>实体构建<code>TreeMap</code>,按照默认规则排序</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></td>
<td align="center">传递一个map实体构建<code>TreeMap</code>,按照传递的map的排序规则进行排序</td>
</tr>
</tbody></table>
<h5 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-TreeMap"><a href="#public-TreeMap" class="headerlink" title="public TreeMap()"></a><code>public TreeMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数，按照key的自然顺序排列</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-Comparator-comparator"><a href="#public-TreeMap-Comparator-comparator" class="headerlink" title="public TreeMap(Comparator&lt;? super K&gt; comparator)"></a><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递Comparator具体实现，按照该实现规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-Map-m"><a href="#public-TreeMap-Map-m" class="headerlink" title="public TreeMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照默认规则排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-SortedMap-m"><a href="#public-TreeMap-SortedMap-m" class="headerlink" title="public TreeMap(SortedMap&lt;K, ? extends V&gt; m)"></a><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照传递的map的排序规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h4><p><code>put</code>方法步骤如下：</p>
<blockquote>
<ol>
<li>获取根节点，根节点为空，产生一个根节点，将其着色为黑色，退出余下流程；</li>
<li>获取比较器，如果传入的<code>Comparator</code>接口不为空，使用传入的<code>Comparator</code>接口实现类进行比较；如果传入的<code>Comparator</code>接口为空，将<code>Key</code>强转为<code>Comparable</code>接口进行比较；</li>
<li>从根节点开始逐一依照规定的排序算法进行比较，取比较值<code>cmp</code>，如果<code>cmp=0</code>，表示插入的<code>Key</code>已存在；如果<code>cmp&gt;0</code>，取当前节点的右子节点；如果<code>cmp&lt;0</code>，取当前节点的左子节点；</li>
<li>排除插入的<code>Key</code>已存在的情况，第（3）步的比较一直比较到当前节点<code>t</code>的左子节点或右子节点为<code>null</code>，此时<code>t</code>就是我们寻找到的节点，<code>cmp&gt;0</code>则准备往<code>t</code>的右子节点插入新节点，<code>cmp&lt;0</code>则准备往<code>t</code>的左子节点插入新节点；</li>
<li><code>new</code>出一个新节点，默认为黑色，根据<code>cmp</code>的值向<code>t</code>的左边或者右边进行插入；</li>
<li>插入之后进行修复，包括左旋、右旋、重新着色这些操作，让树保持平衡性；</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//用t表示二叉树的当前节点</span></span><br><span class="line">    Entry&lt;K, V&gt; t = root;</span><br><span class="line">    <span class="comment">//t为null表示一个空树，即TreeMap中没有任何元素，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">//将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//容器的size = 1，表示TreeMap集合中存在一个元素</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//修改次数 + 1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;     <span class="comment">//cmp表示key排序的返回结果</span></span><br><span class="line">    Entry&lt;K, V&gt; parent;   <span class="comment">//父节点</span></span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;    <span class="comment">//指定的排序算法</span></span><br><span class="line">    <span class="comment">//如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;      <span class="comment">//parent指向上次循环后的t</span></span><br><span class="line">            <span class="comment">//比较新增节点的key和当前节点key的大小</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">//cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">                <span class="comment">//cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">                <span class="comment">//cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cpr为空，则采用默认的排序算法进行创建TreeMap集合</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)     <span class="comment">//key值为空抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">/* 下面处理过程和上面一样 */</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新增节点当做parent的子节点</span></span><br><span class="line">    Entry&lt;K, V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="comment">//如果新增节点的key小于parent的key，则当做左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">        <span class="comment">//如果新增节点的key大于parent的key，则当做右子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置</span></span><br><span class="line"><span class="comment">     *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="comment">//TreeMap元素数量 + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//TreeMap容器修改次数 + 1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	第1~第5步都没有什么问题，红黑树最核心的应当是第6步插入数据之后进行的修复工作，对应的<code>Java</code>代码是<code>TreeMap</code>中的<code>fixAfterInsertion</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后的修复操作</span></span><br><span class="line"><span class="comment"> * x 表示新增节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K, V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;    <span class="comment">//新增节点的颜色为红色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环 直到 x不是根节点，且x的父节点不为红色</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">//如果X的父节点（P）是其父节点的父节点（G）的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">//获取X的叔节点(U)</span></span><br><span class="line">            Entry&lt;K, V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色（情况三）</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的叔节点（U）设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//右旋转</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//（情况五）</span></span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的父节点的父节点（G）为中心右旋转</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果X的父节点（P）是其父节点的父节点（G）的右节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取X的叔节点（U）</span></span><br><span class="line">            Entry&lt;K, V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色（情况三）</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的叔节点（U）设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//右旋转</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//（情况五）</span></span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的父节点的父节点（G）为中心右旋转</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将根节点G强制设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法-4"><a href="#获取方法-4" class="headerlink" title="获取方法"></a>获取方法</h4><p><code>get</code>方法步骤如下：</p>
<blockquote>
<ol>
<li>当<code>key</code>大于当前节点，把当前节点指针指向右孩子继续循环。</li>
<li>当<code>key</code>小于当前节点，把当前节点的指针指向左孩子继续循环。</li>
<li>当<code>key</code>等于当前节点，则返回当前节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从root节点开始遍历，通过二分查找逐步向下找</span></span><br><span class="line"><span class="comment"> * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过k.compareTo(p.key)比较传入的key和</span></span><br><span class="line"><span class="comment"> * 根节点的key值；</span></span><br><span class="line"><span class="comment"> * 如果传入的key&lt;root.key, 那么继续在root的左子树中找，从root的左孩子节点（root.left）开始；</span></span><br><span class="line"><span class="comment"> * 如果传入的key&gt;root.key, 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;</span></span><br><span class="line"><span class="comment"> * 如果恰好key==root.key，那么直接根据root节点的value值即可。</span></span><br><span class="line"><span class="comment"> * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//默认排序情况下的查找</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从root节点开始遍历，通过二分查找逐步向下找</span></span><br><span class="line"><span class="comment"> * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过自定义的排序算法</span></span><br><span class="line"><span class="comment"> * cpr.compare(key, t.key)比较传入的key和根节点的key值，如果传入的key&lt;root.key，那么</span></span><br><span class="line"><span class="comment"> * 继续在root的左子树中找，从root的左孩子节点（root.left）开始：如果传入的key&gt;root.key,</span></span><br><span class="line"><span class="comment"> * 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;如果恰好key==root.key，</span></span><br><span class="line"><span class="comment"> * 那么直接根据root节点的value值即可。</span></span><br><span class="line"><span class="comment"> * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//自定义排序规则下的查找</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntryUsingComparator</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> (K) key;</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<ol>
<li><p>是基于<code>HashMap</code>实现的，默认构造函数是构建一个初始容量为<code>16</code>，负载因子为<code>0.75</code> 的<code>HashMap</code>。封装了一个 <code>HashMap</code> 对象来存储所有的集合元素，所有放入 <code>HashSet</code> 中的集合元素实际上由 <code>HashMap</code> 的 <code>key</code> 来保存，而 <code>HashMap</code> 的 <code>value</code> 则存储了一个 <code>PRESENT</code>，它是一个静态的 <code>Object</code> 对象。</p>
</li>
<li><p>当我们试图把某个类的对象当成 <code>HashMap</code>的 <code>key</code>，或试图将这个类的对象放入 <code>HashSet</code>中保存时，重写该类的<code>equals(Object obj)</code>方法和 <code>hashCode()</code> 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 <code>hashCode()</code> 返回值相同时，它们通过 <code>equals()</code> 方法比较也应该返回 <code>true</code>。通常来说，所有参与计算 <code>hashCode()</code> 返回值的关键属性，都应该用于作为 <code>equals()</code> 比较的标准。</p>
</li>
<li><p><code>HashSet</code>的其他操作都是基于<code>HashMap</code>的。</p>
</li>
</ol>
</blockquote>
<h3 id="TreeMap-继承关系-1"><a href="#TreeMap-继承关系-1" class="headerlink" title="TreeMap 继承关系"></a>TreeMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-源码分析-1"><a href="#TreeMap-源码分析-1" class="headerlink" title="TreeMap 源码分析"></a>TreeMap 源码分析</h3><h4 id="成员变量-5"><a href="#成员变量-5" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br></pre></td></tr></table></figure>

<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public HashSet()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public HashSet(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public HashSet(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public HashSet(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定<code>collection</code>中的元素的新<code>set</code></td>
</tr>
</tbody></table>
<h5 id="案例演示-5"><a href="#案例演示-5" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-HashSet"><a href="#public-HashSet" class="headerlink" title="public HashSet()"></a><code>public HashSet()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 默认的无参构造器，构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-int-initialCapacity"><a href="#public-HashSet-int-initialCapacity" class="headerlink" title="public HashSet(int initialCapacity)"></a><code>public HashSet(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-int-initialCapacity-float-loadFactor"><a href="#public-HashSet-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashSet(int initialCapacity, float loadFactor)"></a><code>public HashSet(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-Collection-c"><a href="#public-HashSet-Collection-c" class="headerlink" title="public HashSet(Collection&lt;? extends E&gt; c)"></a><code>public HashSet(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造一个包含指定collection中的元素的新set。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层使用默认的加载因子0.75和足以包含指定 </span></span><br><span class="line"><span class="comment"> * collection中所有元素的初始容量来创建一个HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="添加方法-2"><a href="#添加方法-2" class="headerlink" title="添加方法"></a>添加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set中尚未包含指定元素，则添加指定元素。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </span></span><br><span class="line"><span class="comment"> * 的元素e2，则向此set 添加指定的元素e。 </span></span><br><span class="line"><span class="comment"> * 如果此set已包含该元素，则该调用不更改set并返回false。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际将将该元素作为key放入HashMap。 </span></span><br><span class="line"><span class="comment"> * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </span></span><br><span class="line"><span class="comment"> * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </span></span><br><span class="line"><span class="comment"> * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span></span><br><span class="line"><span class="comment"> * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span></span><br><span class="line"><span class="comment"> * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 将添加到此set中的元素。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-4"><a href="#删除方法-4" class="headerlink" title="删除方法"></a>删除方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果指定元素存在于此set中，则将其移除。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span></span><br><span class="line"><span class="comment"> * 则将其移除。如果此set已包含该元素，则返回true </span></span><br><span class="line"><span class="comment"> * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的remove方法删除指定Entry。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="包含方法-3"><a href="#包含方法-3" class="headerlink" title="包含方法"></a>包含方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span></span><br><span class="line"><span class="comment"> * 的e元素时，返回true。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="获取大小方法"><a href="#获取大小方法" class="headerlink" title="获取大小方法"></a>获取大小方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 返回此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.size();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="是否为空方法"><a href="#是否为空方法" class="headerlink" title="是否为空方法"></a>是否为空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.isEmpty();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote>
<ul>
<li><p><code>TreeSet</code> 是一个有序的集合，它的作用是提供有序的<code>Set</code>集合。它继承于<code>AbstractSet</code>抽象类，实现了<code>NavigableSet&lt;E&gt;</code>, <code>Cloneable</code>, <code>java.io.Serializable</code>接口。<br><code>TreeSet 继承于AbstractSet</code>，所以它是一个<code>Set</code>集合，具有<code>Set</code>的属性和方法。<br><code>TreeSet</code> 实现了<code>NavigableSet</code>接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br><code>TreeSet</code> 实现了<code>Cloneable</code>接口，意味着它能被克隆。<br><code>TreeSet</code> 实现了<code>java.io.Serializable</code>接口，意味着它支持序列化。</p>
</li>
<li><p><code>TreeSet</code>是基于<code>TreeMap</code>实现的。<code>TreeSet</code>中的元素支持<code>2</code>种排序方式：自然排序 或者 根据创建<code>TreeSet</code> 时提供的 <code>Comparator</code> 进行排序。这取决于使用的构造方法。</p>
</li>
<li><p><code>TreeSet</code>为基本操作（<code>add</code>、<code>remove</code> 和 <code>contains</code>）提供受保证的 <code>log(n)</code> 时间开销。<br>另外，<code>TreeSet</code>是非同步的。 它的<code>iterator</code> 方法返回的迭代器是<code>fail-fast</code>的。</p>
</li>
</ul>
</blockquote>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量-6"><a href="#成员变量-6" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet底层用的是NavigableMap来存储数据，而不是直接使用TreeMap</span></span><br><span class="line">   <span class="comment">// 我们知道TreeMap是实现类NavigableMap接口的，所以TreeSet默认构造了</span></span><br><span class="line">   <span class="comment">// 一个TreeMap来作为NavigableMap的一个实现类，提供给TreeSet存储数据</span></span><br><span class="line">   <span class="comment">// 注意它不一定就是TreeMap</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 虚拟元素, 用来作为value存储在map中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public TreeSet()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(SortedSet&lt;E&gt; s)</code></td>
<td align="center">将<code>SortedSet</code>中的所有元素添加到<code>TreeSet</code>中</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></td>
<td align="center">两使用带<code>comparator</code>的<code>TreeMap</code>初始化</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">将集合<code>c</code>中的所有元素添加的<code>TreeSet</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-6"><a href="#案例演示-6" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-TreeSet"><a href="#public-TreeSet" class="headerlink" title="public TreeSet()"></a><code>public TreeSet()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用TreeMap初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-SortedSet-s"><a href="#public-TreeSet-SortedSet-s" class="headerlink" title="public TreeSet(SortedSet&lt;E&gt; s)"></a><code>public TreeSet(SortedSet&lt;E&gt; s)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将SortedSet中的所有元素添加到TreeSet中</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-Comparator-comparator"><a href="#public-TreeSet-Comparator-comparator" class="headerlink" title="public TreeSet(Comparator&lt;? super E&gt; comparator)"></a><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用带comparator的TreeMap初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-Collection-c"><a href="#public-TreeSet-Collection-c" class="headerlink" title="public TreeSet(Collection&lt;? extends E&gt; c)"></a><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合c中的所有元素添加的TreeSet中</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法-2"><a href="#增加方法-2" class="headerlink" title="增加方法"></a>增加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素, 调用map的put()方法, value为PRESENT</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-5"><a href="#删除方法-5" class="headerlink" title="删除方法"></a>删除方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="是否为空方法-1"><a href="#是否为空方法-1" class="headerlink" title="是否为空方法"></a>是否为空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取大小方法-1"><a href="#获取大小方法-1" class="headerlink" title="获取大小方法"></a>获取大小方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空方法-3"><a href="#清空方法-3" class="headerlink" title="清空方法"></a>清空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap(JDK1.8)"></a>ConcurrentHashMap(JDK1.8)</h2><h3 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量-7"><a href="#成员变量-7" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 散列表数组最大限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 散列表默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发级别，jdk1.7遗留下来的，1.8只有在初始化的时候用了一用。</span></span><br><span class="line"><span class="comment"> * 不代表并发级别。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转化为链表的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容相关，计算扩容时生成的一个标识戳（虽然没有用final修饰，但是全文没有修改他，不改变）</span></span><br><span class="line"><span class="comment"> * 不管什么线程来 16扩容到32都是不变的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//node节点的hash为-1时，表示当前节点是FWD节点，已经迁移了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//node节点的hash为-2时，表示当前节点已经树化，</span></span><br><span class="line"><span class="comment">// 表示当前节点为TreeBin节点，TreeBin节点代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x7fffffff =》0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">//可以将一个负数 位与运算后得到正数，但是不是绝对值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8序列化 为了兼容jdk1.7的ConcurrentHashMap保存的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 散列表，长度一定是2次方数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 化整为零</span></span><br><span class="line"><span class="comment">  * LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">  * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">* sizeCtl 为0，代表数组未初始化， 且数组的初始容量为16</span></span><br><span class="line"><span class="comment">* sizeCtl 为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值</span></span><br><span class="line"><span class="comment">* sizeCtl 为-1，表示数组正在进行初始化</span></span><br><span class="line"><span class="comment">* sizeCtl 小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">  * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态）</span></span><br><span class="line"><span class="comment">  * 只有一个对象能持有加锁状态</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment">  * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment">  * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// views</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure>

<h5 id="sizeCtl含义解释"><a href="#sizeCtl含义解释" class="headerlink" title="sizeCtl含义解释"></a><code>sizeCtl</code>含义解释</h5><blockquote>
<p><strong>注意：以上这些构造方法中，都涉及到一个变量<code>sizeCtl</code>，这个变量是一个非常重要的变量，而且具有非常丰富的含义，它的值不同，对应的含义也不一样，这里我们先对这个变量不同的值的含义做一下说明，后续源码分析过程中，进一步解释</strong></p>
<p><code>sizeCtl</code>为<code>0</code>，代表数组未初始化， 且数组的初始容量为<code>16</code></p>
<p><code>sizeCtl</code>为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值</p>
<p><code>sizeCtl</code>为<code>-1</code>，表示数组正在进行初始化</p>
<p><code>sizeCtl</code>小于<code>0</code>，并且不是<code>-1</code>，表示数组正在扩容， <code>-(1+n)</code>，表示此时有<code>n</code>个线程正在共同完成数组的扩容操作</p>
</blockquote>
<h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public ConcurrentHashMap()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel)</code></td>
<td align="center">计算一个大于或者等于给定的容量值，该值是<code>2</code>的幂次方数作为初始容量</td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传入一个<code>Map</code>类型的<code>m</code>，将<code>m</code>中的所有元素放进<code>HashMap</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-7"><a href="#案例演示-7" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-ConcurrentHashMap"><a href="#public-ConcurrentHashMap" class="headerlink" title="public ConcurrentHashMap()"></a><code>public ConcurrentHashMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有维护任何变量的操作，如果调用该方法，数组长度默认是16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-int-initialCapacity"><a href="#public-ConcurrentHashMap-int-initialCapacity" class="headerlink" title="public ConcurrentHashMap(int initialCapacity)"></a><code>public ConcurrentHashMap(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递进来一个初始容量，ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>注意，调用这个方法，得到的初始容量和我们之前讲的<code>HashMap</code>以及<code>jdk7</code>的<code>ConcurrentHashMap</code>不同，即使你传递的是一个<code>2</code>的幂次方数，该方法计算出来的初始容量依然是比这个值大的<code>2</code>的幂次方数</font></p>
</blockquote>
<h6 id="public-ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#public-ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, float loadFactor)"></a><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用四个参数的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-int-initialCapacity-loadFactor-int-concurrencyLevel"><a href="#public-ConcurrentHashMap-int-initialCapacity-loadFactor-int-concurrencyLevel" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, loadFactor, int concurrencyLevel)"></a><code>public ConcurrentHashMap(int initialCapacity, loadFactor, int concurrencyLevel)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一个大于或者等于给定的容量值，该值是2的幂次方数作为初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-Map-m"><a href="#public-ConcurrentHashMap-Map-m" class="headerlink" title="public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于一个Map集合，构建一个ConcurrentHashMap</span></span><br><span class="line"><span class="comment">//初始容量为16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法-3"><a href="#增加方法-3" class="headerlink" title="增加方法"></a>增加方法</h4><h5 id="put-K-key-V-value-添加"><a href="#put-K-key-V-value-添加" class="headerlink" title="put(K key, V value) 添加"></a><code>put(K key, V value)</code> 添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());   <span class="comment">//返回一个正值</span></span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">	    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//普通链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树节点，将元素添加到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁图解</strong>（针对这句 <code>synchronized (f)</code> ）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/Snipaste_2020-05-16_12-04-08.jpg"></p>
<h5 id="Node-initTable-数组初始化"><a href="#Node-initTable-数组初始化" class="headerlink" title="Node&lt;K,V&gt;[] initTable() 数组初始化"></a><code>Node&lt;K,V&gt;[] initTable()</code> 数组初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="transfer-Node-tab-Node-nextTab-扩容"><a href="#transfer-Node-tab-Node-nextTab-扩容" class="headerlink" title="transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) 扩容"></a><code>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</code> 扩容</h5><h6 id="什么时候出发扩容？"><a href="#什么时候出发扩容？" class="headerlink" title="什么时候出发扩容？"></a>什么时候出发扩容？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增元素时，也就是在调用 putVal 方法后，为了通用，增加了个 check 入参，用于指定是否可能会出现扩容的情况</span></span><br><span class="line"><span class="comment">//check &gt;= 0 即为可能出现扩容的情况，例如 putVal方法中的调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">//检查当前集合元素个数 s 是否达到扩容阈值 sizeCtl ，扩容时 sizeCtl 为负数，依旧成立，同时还得满足数组非空且数组长度不能大于允许的数组最大长度这两个条件才能继续</span></span><br><span class="line">        <span class="comment">//这个 while 循环除了判断是否达到阈值从而进行扩容操作之外还有一个作用就是当一条线程完成自己的迁移任务后，如果集合还在扩容，则会继续循环，继续加入扩容大军，申请后面的迁移任务</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// sc &lt; 0 说明集合正在扩容当中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断扩容是否结束或者并发扩容线程数是否已达最大值，如果是的话直接结束while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//扩容还未结束，并且允许扩容线程加入，此时加入扩容大军中</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果集合还未处于扩容状态中，则进入扩容方法，并首先初始化 nextTab 数组，也就是新数组</span></span><br><span class="line">            <span class="comment">//(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 为首个扩容线程所设置的特定值，后面扩容时会根据线程是否为这个值来确定是否为最后一个线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容状态下其他线程对集合进行插入、修改、删除、合并、compute等操作时遇到 ForwardingNode 节点会调用该帮助扩容方法 (ForwardingNode 后面介绍)</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">//此处的 while 循环是上面 addCount 方法的简版，可以参考上面的注释</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//putAll批量插入或者插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会调用到这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//如果不满足条件，也就是 sizeCtl &lt; 0 ，说明有其他线程正在扩容当中，这里也就不需要自己去扩容了，结束该方法</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">//如果数组初始化则进行初始化，这个选项主要是为批量插入操作方法 putAll 提供的</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">//初始化时将 sizeCtl 设置为 -1 ，保证单线程初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//初始化完成后 sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会进入到下面这个 else if 分支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">//下面的内容基本跟上面 addCount 方法的 while 循环内部一致，可以参考上面的注释</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<blockquote>
<p>(1) 在调用 <code>addCount</code> 方法增加集合元素计数后发现当前集合元素个数到达扩容阈值时就会触发扩容。<br>(2) 扩容状态下其他线程对集合进行插入、修改、删除、合并、<code>compute</code> 等操作时遇到 <code>ForwardingNode</code> 节点会触发协助扩容。<br>(3) <code>putAll</code> 批量插入或者插入节点后发现存在链表长度达到 <code>8</code> 个或以上，但数组长度为 <code>64</code> 以下时会触发扩容。<br>注意：桶上链表长度达到 <code>8</code> 个或者以上，并且数组长度为 <code>64</code> 以下时只会触发扩容而不会将链表转为红黑树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该扩容方法的地方有：</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#addCount        向集合中插入新数据后更新容量计数时发现到达扩容阈值而触发的扩容</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#helpTransfer    扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode 节点时触发的扩容</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#tryPresize      putAll批量插入或者插入后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//计算每条线程处理的桶个数，每条线程处理的桶数量一样，如果CPU为单核，则使用一条线程处理所有桶</span></span><br><span class="line">    <span class="comment">//每条线程至少处理16个桶，如果计算出来的结果少于16，则一条线程处理16个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// 初始化新数组(原数组长度的2倍)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//将 transferIndex 指向最右边的桶，也就是数组索引下标最大的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">//新建一个占位对象，该占位对象的 hash 值为 -1 该占位对象存在时表示集合正在扩容状态，</span></span><br><span class="line">    <span class="comment">//key、value、next 属性均为 null ，nextTable 属性指向扩容后的数组</span></span><br><span class="line">    <span class="comment">//该占位对象主要有两个用途：</span></span><br><span class="line">    <span class="comment">//   1、占位作用，用于标识数组该位置的桶已经迁移完毕，处于扩容中的状态。</span></span><br><span class="line">    <span class="comment">//   2、作为一个转发的作用，扩容期间如果遇到查询操作，遇到转发节点，会把该查询操作转发到新的数组上去，不会阻塞查询操作。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//该标识用于控制是否继续处理下一个桶，为 true 则表示已经处理完当前桶，可以继续迁移下一个桶的数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//该标识用于控制扩容何时结束，该标识还有一个用途是最后一个扩容线程会负责重新检查一遍数组查看是否有遗漏的桶</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//这个循环用于处理一个 stride 长度的任务，i 后面会被赋值为该 stride 内最大的下标，而 bound 后面会被赋值为该 stride 内最小的下标</span></span><br><span class="line">    <span class="comment">//通过循环不断减小 i 的值，从右往左依次迁移桶上面的数据，直到 i 小于 bound 时结束该次长度为 stride 的迁移任务</span></span><br><span class="line">    <span class="comment">//结束这次的任务后会通过外层 addCount、helpTransfer、tryPresize 方法的 while 循环达到继续领取其他任务的效果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//每处理完一个hash桶就将 bound 进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明数组的hash桶已被线程分配完毕，没有了待分配的hash桶，</span></span><br><span class="line">                <span class="comment">//将 i 设置为 -1 ，后面的代码根据这个数值退出当前线的扩容操作</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有首次进入for循环才会进入这个判断里面去，设置 bound 和 i 的值，也就是领取到的迁移任务的数组区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后做后续工作，将 nextTable 设置为 null，表示扩容已结束，将 table 指向新数组，sizeCtl 设置为扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每当一条线程扩容结束就会更新一次 sizeCtl 的值，进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 成立，说明该线程不是</span></span><br><span class="line">                <span class="comment">//扩容大军里面的最后一条线程，直接return回到上层while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//(sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明这条线程是最后一条扩容线程</span></span><br><span class="line">                <span class="comment">//之所以能用这个来判断是否是最后一条线程，因为第一条扩容线程进行了如下操作：</span></span><br><span class="line">                <span class="comment">//    U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">//除了修改结束标识之外，还得设置 i = n; 以便重新检查一遍数组，防止有遗漏未成功迁移的桶</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//遇到数组上空的位置直接放置一个占位对象，以便查询操作的转发和标识当前处于扩容状态</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//数组上遇到hash值为MOVED，也就是 -1 的位置，说明该位置已经被其他线程迁移过了，</span></span><br><span class="line">            <span class="comment">//将 advance 设置为 true ，以便继续往下一个桶检查并进行迁移操作</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//该节点为链表结构</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//遍历整条链表，找出 lastRun 节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//根据 lastRun 节点的高位标识(0 或 1)，首先将 lastRun设置为 ln </span></span><br><span class="line">                        <span class="comment">//或者 hn 链的末尾部分节点，后续的节点使用头插法拼接</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//使用高位和低位两条链表进行迁移，使用头插法拼接链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，</span></span><br><span class="line">                        <span class="comment">//并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，该占位对象的用途是</span></span><br><span class="line">                        <span class="comment">//标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//该节点为红黑树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//lo 为低位链表头结点，loTail 为低位链表尾结点，hi 和 hiTail 为高位链表头尾结点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//同样也是使用高位和低位两条链表进行迁移</span></span><br><span class="line">                        <span class="comment">//使用for循环以链表方式遍历整棵红黑树，使用尾插法拼接 ln 和 hn 链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            <span class="comment">//这里面形成的是以 TreeNode 为节点的链表</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//形成中间链表后会先判断是否需要转换为红黑树：</span></span><br><span class="line">                        <span class="comment">//1、如果符合条件则直接将 TreeNode 链表转为红黑树，再设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//2、如果不符合条件则将 TreeNode 转换为普通的 Node 节点，再将该普通链表设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//(hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t 这行代码的用意在于，如果原来的红黑树</span></span><br><span class="line">                        <span class="comment">//没有被拆分成两份，那么迁移后它依旧是红黑树，可以直接使用原来的 TreeBin 对象</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，</span></span><br><span class="line">                        <span class="comment">//并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，</span></span><br><span class="line">                        <span class="comment">//该占位对象的用途是标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="扩容过程图解"><a href="#扩容过程图解" class="headerlink" title="扩容过程图解"></a>扩容过程图解</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510092825539.png"></p>
<p>小结：</p>
<blockquote>
<p>(1) 元素个数达到扩容阈值。</p>
<p>(2) 调用 <code>putAll</code> 方法，但目前容量不足以存放所有元素时。</p>
<p>(3) 某条链表长度达到<code>8</code>，但数组长度却小于<code>64</code>时。</p>
</blockquote>
<p><strong><font color ='blue'><code>CPU</code>核数与迁移任务<code>hash</code>桶数量分配的关系</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093016265.png"></p>
<p><strong><font color ='blue'>单线程下线程的任务分配与迁移操作</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093338545.png"></p>
<p><strong><font color ='blue'>多线程如何分配任务？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093435247.png"></p>
<p><strong><font color ='blue'>普通链表如何迁移？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093520878.png"></p>
<p><strong><font color ='blue'>什么是 <code>lastRun</code> 节点？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093610941.png"></p>
<p><strong><font color ='blue'>红黑树如何迁移？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093656144.png"></p>
<p><strong><font color ='blue'><code>hash</code>桶迁移中以及迁移后如何处理存取请求？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190602184408984.png"></p>
<p><strong><font color ='blue'>多线程迁移任务完成后的操作</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093843462.png"></p>
<h5 id="addCount-long-x-int-check"><a href="#addCount-long-x-int-check" class="headerlink" title="addCount(long x, int check)"></a><code>addCount(long x, int check)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 1， binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果计数盒子不是空 或者</span></span><br><span class="line">    <span class="comment">// 如果修改 baseCount 失败</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）</span></span><br><span class="line">        <span class="comment">// 如果随机取余一个数组位置为空 或者</span></span><br><span class="line">        <span class="comment">// 修改这个槽位的变量失败（出现并发了）</span></span><br><span class="line">        <span class="comment">// 执行 fullAddCount 方法。并结束</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">         <span class="comment">//上面我贴出来了介绍ThreadLocalRandom的文章，这里如果是首次获取，其实就是0</span></span><br><span class="line">         <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为0，就初始化，这里其实就是把种子和随机数设置到（Thread）线程中</span></span><br><span class="line">            ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">            h = ThreadLocalRandom.getProbe();</span><br><span class="line">            wasUncontended = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//死循环，保证计数一定成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            CounterCell[] as; CounterCell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">            <span class="comment">//说明数组已经初始化，在后面有判断数组没有初始化的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这里是不是和ConcurrentHashMap定位桶的位置很像，其实是一摸一样的</span></span><br><span class="line">               <span class="comment">//说明数组中这个位置没有元素</span></span><br><span class="line">               <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//这个字段保证数组新增节点，扩容只有一个线程在进行，防止多线程并发</span></span><br><span class="line">                    <span class="comment">//这里限制一个线程处理只是在数组新增节点和扩容的时候，修改对象的值并不需要限制这个变量</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        <span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x); <span class="comment">// Optimistic create</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果为0表示没有别的线程在修改数组，通过CAS修改为1，表示当前线程在修改数组</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                CounterCell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                                <span class="comment">//再次校验，确保数组没有变化</span></span><br><span class="line">                                <span class="comment">//rs[j = (m - 1) &amp; h] == null，再次确认该位置是否为null，防止别的线程插入了</span></span><br><span class="line">                                <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">//插入数组</span></span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="comment">//释放CAS锁</span></span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="comment">//如果新节点插入成功，表示计数已经成功，这里直接break了</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                           <span class="comment">//如果失败会一直重试</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//定位到桶中有值，然后通过CAS修改其值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">//下面的两个elseif其实是为了防止数组一直扩容使用的，数组的最大容量就是CPU的核数</span></span><br><span class="line">               <span class="comment">//因为核数就是并发数，数组太大没有意义，没有那么多线程可以同时操作</span></span><br><span class="line">               <span class="comment">//就是说上面的新建节点或者CAS修改值事变了，就会到这里，然后拦截住，不让执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                    collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//先竞争到CAS锁，然后执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">//每次扩容成原来的两倍</span></span><br><span class="line">                            CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="comment">//复制元素，看过ConcurrentHashMap的扩容，再看这个，简直就跟一个大学生看小学数学题一样，😄</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            counterCells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里是重新生成一个随机数，换个位置试试，比如上面新增节点失败了，换个位置试试，或者通过CAS修改值失败，也换个位置再试试</span></span><br><span class="line">                h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里就是判断数组没有初始化的情况，搞不明白没啥放在这里，不放在开头</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                        <span class="comment">//初始化的数组大小是2，非常小</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                        init = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果以上CAS修改，创建新节点都失败了，这里还有一道防线，通过CAS修改baseCount</span></span><br><span class="line">            <span class="comment">//这也是再addCount中，当判断数组不为空，不先修改下baseCount试试，而是直接跳到这个方法中，因为在这个方法中也会修改baseCount</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p><code>x </code>参数表示的此次需要对表中元素的个数加几。<code>check</code> 参数表示是否需要进行扩容检查，大于等于<code>0</code> 需要进行检查，而我们的 <code>putVal</code> 方法的 <code>binCount</code> 参数最小也是 <code>0</code> ，因此，每次添加元素都会进行检查。（除非是覆盖操作）</p>
<ol>
<li>判断计数盒子属性是否是空，如果是空，就尝试修改 <code>baseCount</code> 变量，对该变量进行加 <code>X</code>。</li>
<li>如果计数盒子不是空，或者修改 <code>baseCount</code> 变量失败了，则放弃对 <code>baseCount</code> 进行操作。</li>
<li>如果计数盒子是 <code>null</code> 或者计数盒子的 <code>length</code> 是 <code>0</code>，或者随机取一个位置取于数组长度是 <code>null</code>，那么就对刚刚的元素进行 <code>CAS</code> 赋值。</li>
<li>如果赋值失败，或者满足上面的条件，则调用 <code>fullAddCount</code> 方法重新死循环插入。</li>
<li>这里如果操作 <code>baseCount</code> 失败了（或者计数盒子不是 <code>Null</code>），且对计数盒子赋值成功，那么就检查 <code>check</code> 变量，如果该变量小于等于 <code>1</code>. 直接结束。否则，计算一下 <code>count</code> 变量。</li>
<li>如果 <code>check</code> 大于等于 <code>0</code> ，说明需要对是否扩容进行检查。</li>
<li>如果 <code>map</code> 的 <code>size</code> 大于 <code>sizeCtl</code>（扩容阈值），且 <code>table</code> 的长度小于 <code>1 &lt;&lt; 30</code>，那么就进行扩容。</li>
<li>根据 <code>length</code> 得到一个标识符，然后，判断 <code>sizeCtl</code> 状态，如果小于 <code>0</code> ，说明要么在初始化，要么在扩容。</li>
<li>如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，<code>break</code>。</li>
<li>如果校验数据通过了，那么将 <code>sizeCtl</code> 加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li>如果没有在扩容，但是需要扩容。那么就将 <code>sizeCtl</code> 更新，赋值为标识符左移 <code>16</code> 位 —— 一个负数。然后加 <code>2</code>。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 <code>count</code>，看看是否还需要扩容。</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/30/Java%E9%9B%86%E5%90%88/" data-id="clpsh9798000ixgvse0099igg" data-title="Java集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring-Framework" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/22/Spring-Framework/" class="article-date">
  <time class="dt-published" datetime="2022-03-22T08:08:19.000Z" itemprop="datePublished">2022-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Framework/">Spring Framework</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/22/Spring-Framework/">Spring Framework</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><blockquote>
<p><strong>IOC</strong>：Inversion of Control 即控制反转，在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
</blockquote>
<blockquote>
<p>​		理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202004201157cdscscscdscsdcsdcsdc48990.png"></p>
</blockquote>
<blockquote>
<ul>
<li><p>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而<strong>IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建以及外部资源获取（不只是对象包括比如文件等）</strong>。</p>
</li>
<li><p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而<strong>反转则是由容器来帮忙创建及注入依赖对象：由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转，依赖对象的获取被反转了</strong>。</p>
</li>
</ul>
</blockquote>
<h2 id="IoC具体做什么"><a href="#IoC具体做什么" class="headerlink" title="IoC具体做什么"></a>IoC具体做什么</h2><blockquote>
<p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</p>
<ul>
<li>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；</li>
<li>有了<strong>IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合</strong>，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</li>
<li>IoC对编程<strong>实现由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找</strong>。</li>
</ul>
</blockquote>
<h2 id="理解IoC和DI的关系"><a href="#理解IoC和DI的关系" class="headerlink" title="理解IoC和DI的关系"></a>理解IoC和DI的关系</h2><blockquote>
<p>DI—Dependency Injection，即<strong>“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中</strong>。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><p>谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
</li>
<li><p>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
</li>
<li><p>谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
</li>
<li><p>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
</li>
</ul>
<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
</blockquote>
<h2 id="对IOC容器初始化的理解"><a href="#对IOC容器初始化的理解" class="headerlink" title="对IOC容器初始化的理解"></a>对IOC容器初始化的理解</h2><blockquote>
<p>IOC容器初始化的基本步骤主要是两个方面：</p>
<ul>
<li><font color='red'><strong>初始化的入口由容器实现中的refresh()方法调用来完成。</strong></font></li>
<li><font color='red'><strong>对Bean定义载入IOC容器使用的方法是loadBeanDefinition()。</strong></font></li>
</ul>
</blockquote>
<blockquote>
<p>大致过程如下：</p>
<ul>
<li><font color='red'><strong>通过ReasourceLoader来完成资源文件的定位</strong></font>，DefaultResourceLoader是默认的实现，<font color='red'><strong>同时上下文本身就给出了ResourceLoader的实现，可以通过类路径、文件系统、URL等方式来定位资源</strong></font>。</li>
<li><font color='red'><strong>如果XmlBeanFactory作为IOC容器，那么需要为它指定Bean定义的资源，也就是说Bean定义文件是通过抽象成Resource来被IOC容器处理，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册</strong></font>，往往使用<font color='red'><strong>XmlBeanDefinitionReader</strong></font>来解析Bean的XML定义文件—实际的处理过程是委托给<font color='red'><strong>BeanDefinitionParserDelegate</strong></font>来完成的，<font color='red'><strong>从而得到Bean的定义信息，这些信息在Spring中使用BeanDefinition来表示</strong></font>（这个名字可以让我们想到<font color='red'><strong>loadBeanDefinition()</strong></font>、<font color='red'><strong>registerBeanDefinition()</strong></font>这些相关的方法，他们都是为处理BeanDefinition服务的）。</li>
<li><font color='red'><strong>解析得到BeanDefinition以后，需要在IOC容器中注册，这由IOC实现BeanDefinitionRegister接口来实现，注册过程就是在IOC容器内容维护一个HashMap来保存得到的BeanDefinition的过程，这个HashMap是IOC容器持有Bean信息的场所，以后Bean的操作都是围绕这个HashMap来实现</strong></font>。</li>
<li><font color='red'><strong>之后我们通过BeanFactory和ApplicationContext来享受Spring IOC的服务了</strong></font>，在使用IOC容器的时候我们注意到，除了少量粘合代码，绝大多数以正确IOC风格编写的应用程序代码完全不关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在了一起，基本的策略是把工厂放到已知的地方，最好放在对预期使用的上下文有意义的地方，以及代码要实际访问工厂的地方。</li>
<li><font color='red'><strong>Spring本身提供了对声明式载入Web应用程序用法的应用程序上下文，并将其存储在ServletContext的框架实现中</strong></font>。</li>
</ul>
</blockquote>
<h2 id="对DI依赖注入的理解"><a href="#对DI依赖注入的理解" class="headerlink" title="对DI依赖注入的理解"></a>对DI依赖注入的理解</h2><blockquote>
<p><font color='red'><strong>当Spring IOC容器完成了Bean定义资源的定位、载入和解析注册，IOC容器就可以管理Bean定义的相关数据了</strong></font>，但是此时IOC容器还没有对所管理的Bean进行依赖注入，<font color='red'><strong>依赖注入 在以下两种情况下发生：</strong></font></p>
<ul>
<li><font color='red'><strong>用户第一次调用getBean()方法时，IOC容器触发依赖注入。</strong></font></li>
<li><font color='red'><strong>当用户在配置文件中将<bean>元素配置了lazy-init&#x3D;false属性时，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入。</strong></font></li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'><strong>Beanfactory接口</strong></font>定义了Spring IOC容器的基本功能规范，是Spring IOC容器所应遵守的最低层和最基本的编程规范。BeanFactory接口中<font color='red'><strong>定义了几个getBean()方法</strong></font>，用于用户向IOC容器索取被管理的Bean的方法，<font color='red'><strong>通过分析其子类的具体实现来理解Spring IOC容器在用户索取Bean时如何完成依赖注入</strong></font>。</p>
<ul>
<li><font color='red'><strong>getBean方法</strong></font>肯定不陌生，必经之路，然后<font color='red'><strong>调用doGetBean</strong></font>，进来以后首先会执行transformedBeanName找别名，看你的Bean上面是否起了别名。然后进行很重要的一步，<font color='red'><strong>getSingleton，这段代码就是从你的单例缓存池中获取Bean的实例</strong></font>。那么你第一次进来肯定是没有的，缓存里肯定是拿不到的。也就是<font color='green'><strong>一级缓存</strong></font>里是没有的。那么它怎么办呢？他会尝试去<font color='green'><strong>二级缓存</strong></font>中去拿，但是去二级缓存中拿并不是无条件的，首先要判断<font color='red'><strong>isSingletonCurrentlyInCreation(beanName)他要看你这个对象是否正在创建当中</strong></font>，如果不是直接就退出该方法，如果是的话，他就会去二级缓存earlySingletonObjects里面取，如果没拿到，它还接着判断allowEarlyReference这个东西是否为true。它的意思是说，是否允许让你从单例工厂对象缓存中去拿对象。默认为true。好了，此时如果进来那么就会<font color='red'><strong>通过singletonFactory.getObject()去单例工厂缓存中去拿</strong></font>。然后将缓存级别提升至二级缓存也就早期暴露的缓存。</li>
<li><font color='red'><strong>getSingleton执行完以后会走dependsOn方法，判断是否有dependsOn标记的循环引用</strong></font>，有的话直接卡死，抛出异常。比如说A依赖于B，B依赖于A 通过dependsOn注解去指定。此时执行到这里就会抛出异常。这里所指并非是构造函数的循环依赖。</li>
<li><font color='red'><strong>beforeSingletonCreation</strong></font>在这里方法里，就把你的对象标记为了早期暴露的对象，<font color='red'><strong>提前暴露对象用于创建Bean的实例</strong></font>。</li>
<li>紧接着就走<font color='red'><strong>创建Bean的流程开始</strong></font>。在<font color='red'><strong>创建Bean之前执行了一下resolveBeforeInstantiation</strong></font>。它的意思是说，代理AOP Bean定义注册信息但是这里并不是实际去代理你的对象，因为对象还没有被创建。只是<font color='red'><strong>代理了Bean定义信息，还没有被实例化。把Bean定义信息放进缓存</strong></font>，以便我想代理真正的目标对象的时候，直接去缓存里去拿。</li>
<li>接下来就真正的走创建Bean流程，<font color='red'><strong>首先走进真正做事儿的方法doCreateBean然后找到createBeanInstance这个方法</strong></font>，在这里面它<font color='red'><strong>将为你创建你的Bean实例信息（Bean的实例）</strong></font>。如果说创建成功了，那么就把你的对象放入缓存中去（将创建好的提前曝光的对象放入singletonFactories三级缓存中）将对象从二级缓存中移除因为它已经不是提前暴露的对象了。但是。如果说在createBeanInstance这个方法中在创建Bean的时候它会去检测你的依赖关系，会去检测你的构造器。然后，如果说它在创建A对象的时候，发现了构造器里依赖了B，然后它又会重新走getBean的这个流程，当在走到这里的时候，又发现依赖了A此时就会抛出异常。为什么会抛出异常，因为，走getBean的时候他会去从你的单例缓存池中去拿，因为你这里的Bean还没有被创建好。自然不会被放进缓存中，所以它是在缓存中拿不到B对象的。反过来也是拿不到A对象的。造成了死循环故此直接抛异常。这就是<font color='red'><strong>为什么Spring IOC不能解决构造器循环依赖的原因。因为你还没来的急放入缓存你的对象是不存在的</strong></font>。所以不能创建。同理@Bean标注的循环依赖方法也是不能解决的，跟这个同理。那么多例就更不能解决了。为什么？因为在走<font color='red'><strong>createBeanInstance的时候，会判断是否是单例的Bean定义信息mbd.isSingleton()；如果是才会进来</strong></font>。所以多例的Bean压根就不会走进来，而是走了另一段逻辑，这里不做介绍。至此，构造器循环依赖和@Bean的循环依赖还有多例Bean的循环依赖为什么不能解决已经解释清楚。然后如果说，Bean创建成功了。那么会走后面的逻辑。</li>
<li><font color='red'><strong>将创建好的Bean放入缓存，addSingletonFactory方法就是将你创建好的Bean放入三级缓存中，并且移除早期暴露的对象</strong></font>。</li>
<li><font color='red'><strong>通过populateBean给属性赋值</strong></font>，我们知道，创建好的对象，并不是一个完整的对象，里面的属性还没有被赋值。所以这个方法就是<font color='red'><strong>为创建好的Bean为它的属性赋值。并且调用了我们实现的的XXXAware接口进行回调初始化，然后调用我们实现的Bean的后置处理器，给我们最后一次机会去修改Bean的属性</strong></font>。</li>
</ul>
</blockquote>
<h2 id="IoC源码解析"><a href="#IoC源码解析" class="headerlink" title="IoC源码解析"></a>IoC源码解析</h2><h3 id="Spring容器的加载流程"><a href="#Spring容器的加载流程" class="headerlink" title="Spring容器的加载流程"></a>Spring容器的加载流程</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/cdcadscsdcsdcsdcsdcsdc0762E995D412F0.png"></p>
<blockquote>
<ol>
<li>new AnnotationConfigApplicationContext实例化化容器入口</li>
<li>调用本身无参构造函数this()<ol>
<li>会调用父类的无参构造函数创建Bean工厂，然后创建读取注解的Bean定义读取器</li>
<li>在创建Bean定义读取器时，会注册一些Spring内置的原始Bean定义：<ol>
<li>ConfigurationClassPostProcessor： 解析我们配置类的处理器</li>
<li>AutowiredAnnotationBeanPostProcessor： 处理@Autowired注解的后置处理器</li>
<li>RequiredAnnotationBeanPostProcessor：处理@Required属性注解的后置处理器</li>
<li>这些Spring内置的原始Bean定义通过DefaultListableBeanFactory把这些Bean定义放入BeanDefinitionMap（一个ConcurrentHashMap，beanName作为Key，beanDefinition作为Value）中以及beanDefinitionNames（一个List，里面存放了beanName）。</li>
</ol>
</li>
<li>再创建Bean定义扫描器（仅仅是为了程序员可以手动调用）</li>
</ol>
</li>
<li>调用<code>register(annotatedClasses)</code>;<ol>
<li>会循环传进来的配置类数组执行<code>doRegisterBean</code>方法</li>
<li>把当前配置类封装成<code>Bean</code>定义</li>
<li>判断是否需要跳过注解，<code>Spring</code>中有一个<code>@Condition</code>注解，当不满足条件，这个bean就不会被解析</li>
<li>解析<code>Bean</code>的作用域，如果没有设置的话，默认为单例</li>
<li>获得BeanName</li>
<li>解析通用注解，填充到Bean定义中，解析的通用注解：<ul>
<li>Lazy</li>
<li>Primary</li>
<li>DependsOn</li>
<li>Role</li>
</ul>
</li>
<li>Description把Bean定义和beanName封装并调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册</li>
<li>此时只是实例化了一个工厂、把Spring内置的原始Bean定义，还有我们传进来的Bean定义（配置类）注册到BeanDefinitionMap、beanDefinitionNames两个变量中</li>
</ol>
</li>
<li>调用refresh();<ol>
<li>prepareRefresh()刷新前准备工作，主要是保存了容器的启动时间，启动标志等。</li>
<li>ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory(); 拿到Bean工厂</li>
<li>prepareBeanFactory(beanFactory); 对bean工厂进行填充属性<ol>
<li>设置了一个类加载器</li>
<li>设置了bean表达式解析器</li>
<li>设置了一些忽略自动装配的接口</li>
<li>设置了一些允许自动装配的接口，并且进行了赋值操作</li>
<li>注册bean工厂的内部的Bean</li>
</ol>
</li>
<li>invokeBeanFactoryPostProcessors(beanFactory);调用Bean工厂和调用addBeanFactoryPostProcessor添加的Bean工厂后置处理器</li>
<li>registerBeanPostProcessors(beanFactory); 注册和实例化Bean后置处理器。</li>
<li>finishBeanFactoryInitialization(beanFactory);<ol>
<li>实例化所有剩余的（非懒加载）单例，比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</li>
<li>实例化的过程各种BeanPostProcessor开始起作用。</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="BeanFactory、ApplicationContext区别"><a href="#BeanFactory、ApplicationContext区别" class="headerlink" title="BeanFactory、ApplicationContext区别"></a>BeanFactory、ApplicationContext区别</h4><blockquote>
<ul>
<li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口</li>
<li><code>BeanFactory</code>采用的是延迟加载形式来注入<code>bean</code>的，即只有在使用到某个<code>Bean</code>时（调用<code>getBean()</code>），才对该<code>Bean</code>进行加载实例化。<code>ApplicationContext</code>，是在容器启动时一次性创建了所有<code>Bean</code>。</li>
</ul>
</blockquote>
<h4 id="核心方法refresh"><a href="#核心方法refresh" class="headerlink" title="核心方法refresh()"></a>核心方法refresh()</h4><blockquote>
<p>​		首先需要明确，这里调用的 <code>refresh()</code> 方法是 <code>AnnotationConfigServletWebServerApplicationContext</code> 上下文， <code>obtainFreshBeanFactory()</code> 获取的 <code>beanFactory </code>实际类型是 <code>DefaultListableBeanFactory</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor)&#123;</span><br><span class="line">            StartupStep contextRefresh=<span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * prepareRefresh 上下文刷新前准备工作：</span></span><br><span class="line"><span class="comment">             * 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * (BeanDefinition：是定义 Bean 的配置元信息接口，包括 Bean 的类名、作用域、是否延迟加载、初始方法、销毁方法等)</span></span><br><span class="line"><span class="comment">             * obtainFreshBeanFactory 通知子类刷新内部bean工厂工作：</span></span><br><span class="line"><span class="comment">             * 1、创建DefaultListableBeanFactory，如果已有就销毁，没有就创建；核心工作就是解析XML 以及扫描注解</span></span><br><span class="line"><span class="comment">             * 2、设置 创建DefaultListableBeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line"><span class="comment">             * 3、调用loadBeanDefinitions(beanFactory)方法：将xml文件配置的&lt;bean&gt;&lt;bean/&gt; 内容相应的转换为了一个个 BeanDefinition，</span></span><br><span class="line"><span class="comment">             * 然后加载 BeanDefinition 到 DefaultListableBeanFactory 中</span></span><br><span class="line"><span class="comment">             * 将扫描到的Bean配置属性封装到BeanDefinition 对象中，并对它beanName(key) ,</span></span><br><span class="line"><span class="comment">             * BeanDefinition(value) 保存到一个 BeanDefinitionMap（一个ConcurrentHashMap，beanName作为Key，beanDefinition作为Value）中。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line"><span class="comment">                 *  那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"><span class="comment">                 *  这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line"><span class="comment">                 *  具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line"><span class="comment">                 * 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line"><span class="comment">                 * 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * initMessageSource 初始化消息源：MessageSource接口类用于支持信息的国际化和包含参数的信息的替换。</span></span><br><span class="line"><span class="comment">                 * ApplicationContext接口继承了MessageSource接口，应用可通过ApplicationContext来调用MessageSource接口方法</span></span><br><span class="line"><span class="comment">                 * 以实现信息的国际化和替换信息中包含的参数。所有对MessageSource接口的实现都是在AbstractApplicationContext中实现。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                initMessageSource();</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * initApplicationEventMulticaster 初始化事件广播器：</span></span><br><span class="line"><span class="comment">                 * 如果上下文中没有定义则使用默认广播器：SimpleApplicationEventMulticaster。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * onRefresh 初始化其他特定的bean，由具体子类实现。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                onRefresh();</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * registerListeners 注册监听事件：在容器中将所有项目里面的ApplicationListener注册进来，</span></span><br><span class="line"><span class="comment">                 * 大体过程如下：获取所有的事件，并添加到事件派发器中 -&gt; 监听事件进行派发广播。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                registerListeners();</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 初始化所有的 singleton beans （lazy-init 的除外）。大体过程如下：</span></span><br><span class="line"><span class="comment">                 *  -&gt; 获取bean的定义信息</span></span><br><span class="line"><span class="comment">                 *  -&gt; 判断bean 是否是抽象的、是单例的、非懒加载的</span></span><br><span class="line"><span class="comment">                 *  -&gt; 是否为 FactoryBean ,是则调用 FactoryBean 的创建方法，否则执行 getBean() 方法</span></span><br><span class="line"><span class="comment">                 *  -&gt; 调用 getBean() 方法</span></span><br><span class="line"><span class="comment">                 *  -&gt; getBean方法内部再调用 doGetBean() 方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * finishRefresh 完成BeanFactory的初始化创建工作：</span></span><br><span class="line"><span class="comment">                 *  // 初始化生命周期处理器组件</span></span><br><span class="line"><span class="comment">                 *  initLifecycleProcessor();</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *  // 首先将刷新状态传播到生命周期组件中.</span></span><br><span class="line"><span class="comment">                 *  getLifecycleProcessor().onRefresh();</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *  // 发布上下文已刷新完毕的事件.</span></span><br><span class="line"><span class="comment">                 *  publishEvent(new ContextRefreshedEvent(this));</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *  // Participate in LiveBeansView MBean, if active：</span></span><br><span class="line"><span class="comment">                 *  LiveBeansView活动beans的查看适配器，构建当前bean的快照 和</span></span><br><span class="line"><span class="comment">                 *  来自本地&#123;<span class="doctag">@code</span> ApplicationContext&#125;的依赖关系（带有本地&#123;<span class="doctag">@code</span> LiveBeansView&#125; bean定义）或</span></span><br><span class="line"><span class="comment">                 *  所有已注册的ApplicationContexts由&#123;<span class="doctag">@value</span> #MBEAN_DOMAIN_PROPERTY_NAME&#125;环境属性驱动）</span></span><br><span class="line"><span class="comment">                 *  LiveBeansView.registerApplicationContext(this);</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring生命周期"><a href="#Spring生命周期" class="headerlink" title="Spring生命周期"></a>Spring生命周期</h1><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/dcadscsaccadscadcscsacsadcsadcascasd.png"></p>
<p>1、<font color='red'><strong>实例化bean对象</strong></font></p>
<blockquote>
<p>通过反射的方式进行对象的创建，此时的创建只是在堆空间中申请空间，属性都是默认值</p>
</blockquote>
<p>2、<font color='red'><strong>设置对象属性</strong></font></p>
<blockquote>
<p>给对象中的属性进行值的设置工作</p>
</blockquote>
<p>3、<font color='red'><strong>检查Aware相关接口并设置相关依赖</strong></font></p>
<blockquote>
<p>如果对象中需要引用容器内部的对象，那么需要调用aware接口的子类方法来进行统一的设置</p>
</blockquote>
<p>4、<font color='red'><strong>BeanPostProcessor的前置处理</strong></font></p>
<blockquote>
<p>对生成的bean对象进行前置的处理工作</p>
</blockquote>
<p>5、<font color='red'><strong>检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法</strong></font></p>
<blockquote>
<p>判断当前bean对象是否设置了InitializingBean接口，然后进行属性的设置等基本工作</p>
</blockquote>
<p>6、<font color='red'><strong>检查是否配置有自定义的init-method方法</strong></font></p>
<blockquote>
<p>如果当前bean对象定义了初始化方法，那么在此处调用初始化方法</p>
</blockquote>
<p>7、<font color='red'><strong>BeanPostProcessor后置处理</strong></font></p>
<blockquote>
<p>对生成的bean对象进行后置的处理工作</p>
</blockquote>
<p>8、<font color='red'><strong>注册必要的Destruction相关回调接口</strong></font></p>
<blockquote>
<p>为了方便对象的销毁，在此处调用注销的回调接口，方便对象进行销毁操作</p>
</blockquote>
<p>9、<font color='red'><strong>获取并使用bean对象</strong></font></p>
<blockquote>
<p>通过容器来获取对象并进行使用</p>
</blockquote>
<p>10、<font color='red'><strong>是否实现DisposableBean接口</strong></font></p>
<blockquote>
<p>判断是否实现了DisposableBean接口，并调用具体的方法来进行对象的销毁工作</p>
</blockquote>
<p>11、<font color='red'><strong>是否配置有自定义的destory方法</strong></font></p>
<blockquote>
<p>如果当前bean对象定义了销毁方法，那么在此处调用销毁方法</p>
</blockquote>
</blockquote>
<h2 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h2><blockquote>
<p>Spring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、request、session 和 global session，5 种作用域说明如下： </p>
<ul>
<li><strong>singleton</strong>：单例模式（多线程下不安全）。Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为： </li>
<li><strong>prototype</strong>:原型模式每次使用时创建。每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton 作用域。 </li>
<li><strong>Request</strong>：一次 request 一个实例。在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean实例也将会被销毁。 </li>
<li><strong>session</strong>：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。 </li>
<li><strong>global Session</strong>：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。</li>
</ul>
</blockquote>
<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一种</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">       <span class="meta">@Autowired</span></span><br><span class="line">       <span class="keyword">private</span> B b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Service</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">       <span class="meta">@Autowired</span></span><br><span class="line">       <span class="keyword">private</span> A a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第二种</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		上面这两种方式都是循环依赖，应该很好理解，当然也可以是三个 Bean 甚至更多的 Bean 相互依赖，原理都是一样的，今天我们主要分析两个 Bean 的依赖。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/dcascsacsdcscscscsdcsdcscsdcdvrtvfdbfvds.png"></p>
<p>​		这种循环依赖可能会产生问题，例如 A 要依赖 B，发现 B 还没创建，于是开始创建 B ，创建的过程发现 B 要依赖 A， 而 A 还没创建好呀，因为它要等 B 创建好，就这样<strong>它们俩就搁这卡 bug 了</strong>。</p>
</blockquote>
<h2 id="Spring三级缓存机制"><a href="#Spring三级缓存机制" class="headerlink" title="Spring三级缓存机制"></a>Spring三级缓存机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一级缓存用于存放已经实例化、初始化完成的Bean,单例池-singletonObjects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级缓存用于存放已经实例化,但未初始化的Bean.保证一个类多次循环依赖时仅构建一次</span></span><br><span class="line"><span class="comment"> * 保证单例提前曝光早产bean池-earlySingletonObjects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三级缓存用于存放该Bean的BeanFactory,当加载一个Bean会先将该Bean包装为BeanFactory放入</span></span><br><span class="line"><span class="comment"> * 三级缓存早期单例bean工厂池-singletonFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/45E7E955F0B7E5144C0B69C09sacsdccsdcdsA36FDFB.png"></p>
<h2 id="创建Bean流程"><a href="#创建Bean流程" class="headerlink" title="创建Bean流程"></a>创建Bean流程</h2><blockquote>
<p>创建Bean会先将该Bean的BeanFactory放到三级缓存中,以用来防止循环依赖问题.当存在有A,B两个Bean循环依赖时,创建流程如下</p>
<ol>
<li>先创建BeanA,先实例化BeanA并包装为BeanFactory并放入三级缓存中. </li>
<li>给BeanA进行属性填充时检查依赖,发现BeanB未加载过,则先去加载BeanB </li>
<li>BeanB创建过程首先也要包装成BeanFactory放到三级缓存,填充属性时则是从三级缓存获取Bean将BeanA填充进去 </li>
<li>BeanB填充BeanA从三级缓存中的BeanAFacotry获取BeanA </li>
<li>获取主要通过ObjectFactory.getObject方法,该方法调用getEarlyBeanReference方法,他会创建Bean&#x2F;<strong>Bean的代理</strong>并删除BeanA的三级缓存,加入二级缓存 </li>
<li>BeanB初始化完毕加入一级缓存,BeanA继续执行初始化,初始化完毕比较BeanA二级缓存和一级缓存是否一致,一致则加入一级缓存删除二级缓存</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/CA0A0F6F8AEEBC0E5C5aacsdcsdc94DDEA9BBF0A4.png"></p>
<h2 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h2><blockquote>
<p>关键就是<strong>提前暴露未完全创建完毕的 Bean</strong>。</p>
<p>在 Spring 中，只有同时满足以下两点才能解决循环依赖的问题：</p>
<ol>
<li>依赖的 Bean 必须都是单例 </li>
<li>依赖注入的方式，必须<strong>不全是</strong>构造器注入，且 beanName 字母序在前的不能是构造器注入</li>
</ol>
</blockquote>
<h3 id="为什么必须都是单例"><a href="#为什么必须都是单例" class="headerlink" title="为什么必须都是单例"></a>为什么必须都是单例</h3><blockquote>
<p>​		按照理解，如果两个 Bean 都是原型模式的话，那么创建 A1 需要创建一个 B1，创建 B1 的时候要创建一个 A2，创建 A2 又要创建一个 B2，创建 B2 又要创建一个 A3，创建 A3 又要创建一个 B3…..</p>
<p>​		就又卡 BUG 了，是吧，因为原型模式都需要创建新的对象，不能跟用以前的对象。</p>
<p>​		如果是单例的话，创建 A 需要创建 B，而创建的 B 需要的是之前的个 A， 不然就不叫单例了，对吧？</p>
<p>​		具体做法就是：先创建 A，此时的 A 是不完整的（没有注入 B），用个 map 保存这个不完整的 A，再创建 B ，B 需要 A，所以从那个 map 得到“不完整”的 A，此时的 B 就完整了，然后 A 就可以注入 B，然后 A 就完整了，B 也完整了，且它们是相互依赖的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/7b1fc8d2789041bcdsddsc2b1c8d6d2d621efc4.png"></p>
</blockquote>
<h3 id="为什么不能全是构造器注入"><a href="#为什么不能全是构造器注入" class="headerlink" title="为什么不能全是构造器注入"></a>为什么不能全是构造器注入</h3><blockquote>
<p>在 Spring 中创建 Bean 分三步:</p>
<ol>
<li>实例化，createBeanInstance，就是 new 了个对象 </li>
<li>属性注入，populateBean， 就是 set 一些属性值 </li>
<li>初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等</li>
</ol>
<p>明确了上面这三点，再结合我上面说的“不完整的”，我们来理一下。</p>
<p>​		如果全是构造器注入，比如<code>A(B b)</code>，那表明在 new 的时候，就需要得到 B，此时需要 new B ，但是 B 也是要在构造的时候注入 A ，即<code>B(A a)</code>，这时候 B 需要在一个 map 中找到不完整的 A ，发现找不到。</p>
<p>​		为什么找不到？因为 A 还没 new 完呢，所以找到不完整的 A，<strong>因此如果全是构造器注入的话，那么 Spring 无法处理循环依赖</strong>。</p>
</blockquote>
<h3 id="一个set注入，一个构造器注入一定能成功"><a href="#一个set注入，一个构造器注入一定能成功" class="headerlink" title="一个set注入，一个构造器注入一定能成功"></a>一个set注入，一个构造器注入一定能成功</h3><blockquote>
<p>​		假设我们 A 是通过 set 注入 B，B 通过构造函数注入 A，此时是<strong>成功的</strong>。</p>
<p>​		我们来分析下：实例化 A 之后，此时可以在 map 中存入 A，开始为 A 进行属性注入，发现需要 B，此时 new B，发现构造器需要 A，此时从 map 中得到 A ，B 构造完毕，B 进行属性注入，初始化，然后 A 注入 B 完成属性注入，然后初始化 A。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/1c77fa358fc6447785045e879f7vfdfvfdvfdva524b.png"></p>
<p>​		假设 A 是通过构造器注入 B，B 通过 set 注入 A，此时是<strong>失败的</strong>。</p>
<p>​		我们来分析下：实例化 A，发现构造函数需要 B， 此时去实例化 B，然后进行 B 的属性注入，从 map 里面找不到 A，因为 A 还没 new 成功，所以 B 也卡住了，然后就 gg。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/9217bc3fca3fdfdfds24d879f12ecf28a66bb73.png"></p>
<p>​		看到这里，仔细思考的小伙伴可能会说，可以先实例化 B 啊，往 map 里面塞入不完整的 B，这样就能成功实例化 A 了啊。确实，思路没错<strong>但是 Spring 容器是按照字母序创建 Bean 的，A 的创建永远排在 B 前面</strong>。</p>
<p>现在我们总结一下：</p>
<ul>
<li>如果循环依赖都是构造器注入，则失败 </li>
<li>如果循环依赖不完全是构造器注入，则可能成功，可能失败，具体跟BeanName的字母序有关系。</li>
</ul>
</blockquote>
<h2 id="为什么循环依赖需要三级缓存"><a href="#为什么循环依赖需要三级缓存" class="headerlink" title="为什么循环依赖需要三级缓存"></a>为什么循环依赖需要三级缓存</h2><blockquote>
<p>​		很明显，如果仅仅只是为了破解循环依赖，二级缓存够了，压根就不必要三级。你思考一下，在实例化 Bean A 之后，我在二级 map 里面塞入这个 A，然后继续属性注入，发现 A 依赖 B 所以要创建 Bean B，这时候 B 就能从二级 map 得到 A ，完成 B 的建立之后， A 自然而然能完成。</p>
<p><strong>为什么要搞个三级缓存，且里面存的是创建 Bean 的工厂呢</strong>？</p>
<p>​		我们来看下调用工厂的 getObject 到底会做什么，实际会调用下面这个方法：\</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		重点就在中间的判断，如果 false，返回就是参数传进来的 bean，没任何变化。</p>
<p>​		如果是 true 说明有 InstantiationAwareBeanPostProcessors ，且循环的 smartInstantiationAware 类型，<strong>如有这个 BeanPostProcessor 说明 Bean 需要被 aop 代理</strong>。</p>
<p>​		我们都知道如果有代理的话，那么我们想要直接拿到的是代理对象，也就是说如果 A 需要被代理，那么 B 依赖的 A 是已经被代理的 A，所以我们不能返回 A 给 B，而是返回代理的 A 给 B。</p>
<p>​		这个工厂的作用就是判断这个对象是否需要代理，如果否则直接返回，如果是则返回代理对象。</p>
<p>​		看到这明白的小伙伴肯定会问，那跟三级缓存有什么关系，我可以在要放到二级缓存的时候判断这个 Bean 是否需要代理，如果要，直接放代理的对象不就完事儿了。</p>
<p>​		正常代理对象的生成是基于后置处理器，是<strong>在被代理的对象初始化后期调用生成的</strong>，<strong>所以如果你提早代理了其实是违背了 Bean 定义的生命周期</strong>。</p>
<p>​		看到人有些同学又说，那我二级缓存放工厂不行吗？不行，因为全局代理对象只能一个，如果你放了工厂，那么 B 依赖 A 的时候通过工厂得到一个新建的代理对象，如果此时 C 也依赖 A，通过工厂又获得一个新的代理对象，这代理A全局就不唯一了呀，这不是违背单例了吗！</p>
<p>​		所以 Spring 先在一个三级缓存放置一个工厂，如果产生循环依赖，那么就调用这个工厂提早得到代理对象，然后放到二级缓存里，并在三级缓存里删了这个工厂，这样代理对象是全局唯一的，别的 Bean 获取时候三级缓存找不到就会从二级缓存得到代理的对象然后注入。</p>
<p>​		且如果没产生依赖，这个工厂根本不会被调用，所以 Bean 的生命周期就是对的。</p>
<p>​		其实破坏循环依赖，其实只有二级缓存就够了，但是碍于生命周期的问题，提前暴露工厂延迟代理对象的生成。对了，不用担心三级缓存因为没有循环依赖，数据堆积的问题，最终单例 Bean 创建完毕都会加入一级缓存，此时会清理下面的二、三级缓存。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/370b70eef1444a94ad38a230cdsdcdsca98fc4c4.png"></p>
</blockquote>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP中的相关概念"><a href="#AOP中的相关概念" class="headerlink" title="AOP中的相关概念"></a>AOP中的相关概念</h2><blockquote>
<ul>
<li><code>Aspect（切面）</code>： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li>
<li><code>Joint point（连接点）</code>：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li>
<li><code>Pointcut（切点）</code>：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li>
<li><code>Advice（增强）</code>：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li>
<li><code>Target（目标对象）</code>：织入 Advice 的目标对象.。</li>
<li><code>Weaving（织入）</code>：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td><font color='red'><strong>切面声明</strong></font>，标注在类、接口（包括注解类型）或枚举上。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td><font color='red'><strong>切入点声明</strong></font>，即切入到哪些目标类的目标方法。</br>       value 属性指定切入点表达式，默认为 “”，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知, 在目标方法(切入点)执行之前执行。</br>     value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式。<font color='red'><strong>注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -&gt; 异常通知。</strong></font></td>
</tr>
<tr>
<td>@After</td>
<td><font color='red'><strong>后置通知</strong></font>, 在目标方法(切入点)执行之后执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td><font color='red'><strong>返回通知</strong></font>, 在目标方法(切入点)返回结果之后执行，在 @After 的后面执行。</br>     pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td><font color='red'><strong>异常通知</strong></font>, 在方法抛出异常之后执行, 意味着跳过返回通知。</br>     pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”。</br>     <font color='red'><strong>注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数</strong></font></td>
</tr>
<tr>
<td>@Around</td>
<td><font color='red'><strong>环绕通知</strong></font>：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。</br>     通常用于统计方法耗时，参数校验等等操作。</br>     <font color='red'><strong>环绕通知早于前置通知，晚于返回通知。</strong></font></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wmx.hb.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面注解 Aspect 使用入门</span></span><br><span class="line"><span class="comment"> * 1、<span class="doctag">@Aspect</span>：声明本类为切面类</span></span><br><span class="line"><span class="comment"> * 2、<span class="doctag">@Component</span>：将本类交由 Spring 容器管理</span></span><br><span class="line"><span class="comment"> * 3、<span class="doctag">@Order</span>：指定切入执行顺序，数值越小，切面执行顺序越靠前，默认为 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(value = 999)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(AspectHelloWorld.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Pointcut</span> ：切入点声明，即切入到哪些目标方法。value 属性指定切入点表达式，默认为 &quot;&quot;。</span></span><br><span class="line"><span class="comment">     * 用于被下面的通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 切入点表达式常用格式举例如下：</span></span><br><span class="line"><span class="comment">     * - * com.wmx.aspect.EmpService.*(..))：表示 com.wmx.aspect.EmpService 类中的任意方法</span></span><br><span class="line"><span class="comment">     * - * com.wmx.aspect.*.*(..))：表示 com.wmx.aspect 包(不含子包)下任意类中的任意方法</span></span><br><span class="line"><span class="comment">     * - * com.wmx.aspect..*.*(..))：表示 com.wmx.aspect 包及其子包下任意类中的任意方法</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * value 的 execution 可以有多个，使用 || 隔开.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(value =</span></span><br><span class="line"><span class="meta">            &quot;execution(* com.wmx.hb.controller.DeptController.*(..)) &quot; +</span></span><br><span class="line"><span class="meta">                    &quot;|| execution(* com.wmx.hb.controller.EmpController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">aspectPointcut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知：目标方法执行之前执行以下方法体的内容。</span></span><br><span class="line"><span class="comment">     * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@param</span> joinPoint：提供对连接点处可用状态和有关它的静态信息的反射访问&lt;br/&gt; &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * * * Object[] getArgs()：返回此连接点处（目标方法）的参数，目标方法无参数时，返回空数组</span></span><br><span class="line"><span class="comment">     * * * Signature getSignature()：返回连接点处的签名。</span></span><br><span class="line"><span class="comment">     * * * Object getTarget()：返回目标对象</span></span><br><span class="line"><span class="comment">     * * * Object getThis()：返回当前正在执行的对象</span></span><br><span class="line"><span class="comment">     * * * StaticPart getStaticPart()：返回一个封装此连接点的静态部分的对象。</span></span><br><span class="line"><span class="comment">     * * * SourceLocation getSourceLocation()：返回与连接点对应的源位置</span></span><br><span class="line"><span class="comment">     * * * String toLongString()：返回连接点的扩展字符串表示形式。</span></span><br><span class="line"><span class="comment">     * * * String toShortString()：返回连接点的缩写字符串表示形式。</span></span><br><span class="line"><span class="comment">     * * * String getKind()：返回表示连接点类型的字符串</span></span><br><span class="line"><span class="comment">     * * * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;aspectPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aspectBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getTarget();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">aThis</span> <span class="operator">=</span> joinPoint.getThis();</span><br><span class="line">        JoinPoint.<span class="type">StaticPart</span> <span class="variable">staticPart</span> <span class="operator">=</span> joinPoint.getStaticPart();</span><br><span class="line">        <span class="type">SourceLocation</span> <span class="variable">sourceLocation</span> <span class="operator">=</span> joinPoint.getSourceLocation();</span><br><span class="line">        <span class="type">String</span> <span class="variable">longString</span> <span class="operator">=</span> joinPoint.toLongString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">shortString</span> <span class="operator">=</span> joinPoint.toShortString();</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;【前置通知】&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;args=&#123;&#125;,signature=&#123;&#125;,target=&#123;&#125;,aThis=&#123;&#125;,staticPart=&#123;&#125;,&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;sourceLocation=&#123;&#125;,longString=&#123;&#125;,shortString=&#123;&#125;&quot;</span></span><br><span class="line">                , Arrays.asList(args), signature, target, aThis, staticPart, sourceLocation, longString, shortString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：目标方法执行之后执行以下方法体的内容，不管目标方法是否发生异常。</span></span><br><span class="line"><span class="comment">     * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;aspectPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aspectAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;【后置通知】kind=&#123;&#125;&quot;</span>, joinPoint.getKind());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：目标方法返回后执行以下代码</span></span><br><span class="line"><span class="comment">     * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span></span><br><span class="line"><span class="comment">     * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     * returning 属性：通知签名中要将返回值绑定到的参数的名称，默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint ：提供对连接点处可用状态和有关它的静态信息的反射访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result    ：目标方法返回的值，参数名称与 returning 属性值一致。无返回值时，这里 result 会为 null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;aspectPointcut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aspectAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;【返回通知】,shortString=&#123;&#125;,result=&quot;</span>, joinPoint.toShortString(), result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：目标方法发生异常的时候执行以下代码，此时返回通知不会再触发</span></span><br><span class="line"><span class="comment">     * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span></span><br><span class="line"><span class="comment">     * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     * throwing 属性：与方法中的异常参数名称一致，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex：捕获的异常对象，名称与 throwing 属性值一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;aspectPointcut()&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aspectAfterThrowing</span><span class="params">(JoinPoint jp, Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> jp.getSignature().getName();</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ArithmeticException) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;【异常通知】&quot;</span> + methodName + <span class="string">&quot;方法算术异常（ArithmeticException）：&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;【异常通知】&quot;</span> + methodName + <span class="string">&quot;方法异常：&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 1、<span class="doctag">@Around</span> 的 value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span></span><br><span class="line"><span class="comment">     * 2、Object ProceedingJoinPoint.proceed(Object[] args) 方法：继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span></span><br><span class="line"><span class="comment">     * 3、假如目标方法是控制层接口，则本方法的异常捕获与否都不会影响目标方法的事务回滚</span></span><br><span class="line"><span class="comment">     * 4、假如目标方法是控制层接口，本方法 try-catch 了异常后没有继续往外抛，则全局异常处理 <span class="doctag">@RestControllerAdvice</span> 中不会再触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;aspectPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">handleControllerMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkRequestParam(joinPoint);</span><br><span class="line"></span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> StopWatch.createStarted();</span><br><span class="line">        LOG.debug(<span class="string">&quot;【环绕通知】执行接口开始，方法=&#123;&#125;，参数=&#123;&#125; &quot;</span>, joinPoint.getSignature(), Arrays.asList(joinPoint.getArgs()).toString());</span><br><span class="line">        <span class="comment">//继续下一个切面通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span></span><br><span class="line">        <span class="comment">//如果在调用目标方法或者下一个切面通知前抛出异常，则不会再继续往后走</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="type">long</span> <span class="variable">watchTime</span> <span class="operator">=</span> stopWatch.getTime();</span><br><span class="line">        LOG.debug(<span class="string">&quot;【环绕通知】执行接口结束，方法=&#123;&#125;, 返回值=&#123;&#125;,耗时=&#123;&#125; (毫秒)&quot;</span>, joinPoint.getSignature(), proceed, watchTime);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数校验，防止 SQL 注入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkRequestParam</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span> || args.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs()).toUpperCase();</span><br><span class="line">        String[] keywords = &#123;<span class="string">&quot;DELETE &quot;</span>, <span class="string">&quot;UPDATE &quot;</span>, <span class="string">&quot;SELECT &quot;</span>, <span class="string">&quot;INSERT &quot;</span>, <span class="string">&quot;SET &quot;</span>, <span class="string">&quot;SUBSTR(&quot;</span>, <span class="string">&quot;COUNT(&quot;</span>, <span class="string">&quot;DROP &quot;</span>,</span><br><span class="line">                <span class="string">&quot;TRUNCATE &quot;</span>, <span class="string">&quot;INTO &quot;</span>, <span class="string">&quot;DECLARE &quot;</span>, <span class="string">&quot;EXEC &quot;</span>, <span class="string">&quot;EXECUTE &quot;</span>, <span class="string">&quot; AND &quot;</span>, <span class="string">&quot; OR &quot;</span>, <span class="string">&quot;--&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String keyword : keywords) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.contains(keyword)) &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;参数存在SQL注入风险，其中包含非法字符 &#123;&#125;.&quot;</span>, keyword);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数存在SQL注入风险：params=&quot;</span> + params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h2><blockquote>
<ol>
<li>权限管理<ol>
<li>情景1：控制用户的功能权限<ol>
<li>方案详述：在<code>@ControllerAdvice</code>里边，处理全局请求，控制权限。</li>
<li>权限管理的其他方案：（除了<code>AOP</code>之外的方案）<ol>
<li>在过滤器或者拦截器中处理</li>
<li>使用<code>Shiro</code>中间件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>异常处理<ol>
<li>情景1：在<code>@ControllerAdvice</code>里边，处理全局异常</li>
<li>情景2：将<code>Dubbo</code>接口作为切面，统一处理<code>Dubbo</code>接口里边的异常</li>
</ol>
</li>
<li>操作日志<ol>
<li>情景1：按产品的需求，有的接口需要记录操作日志<ol>
<li>自定义注解，需要记录操作日志的，则在<code>Controller</code>的方法上加此注解</li>
<li><code>AOP</code>中判断，如果有这个自定义注解，则将参数异步写到日志数据库</li>
</ol>
</li>
</ol>
</li>
<li>将数据同步到<code>ES</code><ol>
<li>情景1：增删改数据时，同时要处理<code>MySQL</code>和<code>ES</code><ol>
<li>将相关类作为切面，若数据库提交，则写到<code>ES</code>；若回滚，则不写到<code>ES</code></li>
</ol>
</li>
</ol>
</li>
<li>事务控制<ol>
<li>情景1：使用<code>Spring</code>的<code>@Transactional</code></li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>​		由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br>​		<code>Java</code>中的代理按照代理类生成时机不同又分为静态代理和动态代理。<strong>静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成</strong>。动态代理又有<code>JDK</code>代理和<code>CGLib</code>代理两种。</p>
<p>​		代理模式是常用的<code>java</code>设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p>
</blockquote>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote>
<p>代理（<code>Proxy</code>）模式分为三种角色：</p>
<ul>
<li>抽象主题（<code>Subject</code>）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（<code>Real Subject</code>）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（<code>Proxy</code>）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
</blockquote>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。</p>
<p>类图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/%E8%8C%83%E5%BE%B7%E8%90%A8%E5%8F%91%E5%A4%A7%E6%B0%B4%E6%B3%95%E5%9B%BD%E7%88%B1%E5%9B%BD%E7%83%AD%E7%83%AD%E7%89%B9%E6%84%9F%E5%8A%A8sv.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站 火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		从上面代码中可以看出测试类直接访问的是<code>ProxyPoint</code>类对象，也就是说<code>ProxyPoint</code>作为访问对象和目标对象的中介。同时也对<code>sell</code>方法进行了增强（代理点收取一些服务费用）。</p>
</blockquote>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><blockquote>
<p>​		接下来我们使用动态代理实现上面案例，先说说<code>JDK</code>提供的动态代理。<code>Java</code>中提供了一个动态代理类<code>Proxy</code>，<code>Proxy</code>并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（<code>newProxyInstance</code>方法）来获取代理对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p><code>ProxyFactory</code>是代理类吗？</p>
<p><code>ProxyFactory</code>不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 <code>Java </code>诊断工具（<code>Arthas</code>【阿尔萨斯】）查看代理类的结构：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（<code>$Proxy0</code>）实现了<code>SellTickets</code>。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（<code>$Proxy0</code>）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
<p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里是调用了这个方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">              new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;);</span></span><br><span class="line"><span class="comment">                        Object result = method.invoke(station, args);</span></span><br><span class="line"><span class="comment">                        return result;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">	<span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<blockquote>
<ol>
<li>在测试类中通过代理对象调用<code>sell()</code>方法</li>
<li>根据多态的特性，执行的是代理类（<code>$Proxy0</code>）中的<code>sell()</code>方法</li>
<li>代理类（<code>$Proxy0</code>）中的<code>sell()</code>方法中又调用了<code>InvocationHandler</code>接口的子实现类对象的<code>invoke</code>方法</li>
<li><code>invoke</code>方法通过反射执行了真实对象所属类(<code>TrainStation</code>)中的<code>sell()</code>方法</li>
</ol>
</blockquote>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><blockquote>
<p><code>CGLIB（Code Generator Library）</code>是一个强大的、高性能的代码生成库。 </p>
<p>其被广泛应用于<code>AOP</code>框架（<code>Spring</code>）中，用以提供方法拦截操作。 </p>
<p><code>CGLIB</code>代理主要通过对字节码的操作，以控制对象的访问。 </p>
<p><code>CGLIB</code>底层使用了<code>ASM</code>（一个短小精悍的字节码操作框架）来操作字节码生成新的类。 </p>
<p><code>CGLIB</code>相比于<code>JDK</code>动态代理更加强大：    </p>
<p>​	<code>JDK</code>动态代理虽然简单易用，但只能对接口进行代理。    </p>
<p>​	如果要代理的类为一个普通类，没有接口，那么<code>Java</code>动态代理就没法使用了。 </p>
<p><code>Java</code>动态代理使用<code>Java</code>原生的反射<code>API</code>进行操作（运行期），在生成类上比较高效。 <code>CGLIB</code>使用<code>ASM</code>框架直接对字节码进行操作（编译期），在类的执行过程中比较高效</p>
</blockquote>
<h4 id="Enhancer介绍"><a href="#Enhancer介绍" class="headerlink" title="Enhancer介绍"></a>Enhancer介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Enhancer：</span><br><span class="line">    Enhancer既能够代理普通的class，也能够代理接口。</span><br><span class="line">    Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。</span><br><span class="line">    Enhancer不能够拦截<span class="keyword">final</span>类与方法。</span><br><span class="line"></span><br><span class="line">用来设置父类型</span><br><span class="line">Enhancer.setSuperclass(Class superclass);</span><br><span class="line">    </span><br><span class="line">增强</span><br><span class="line">Enhancer.setCallback(Callback callback);</span><br><span class="line">Enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;&#125;);</span><br><span class="line">Enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">方法是用来创建代理对象，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。</span><br><span class="line">Enhancer.create(Class type, Callback callback);</span><br><span class="line">Enhancer.create(Class superclass, Class[] interfaces, Callback callback);</span><br><span class="line">Enhancer.create(Class[] argumentTypes, Object[] arguments);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="Callback介绍"><a href="#Callback介绍" class="headerlink" title="Callback介绍"></a>Callback介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Callback是一个空的接口，在Cglib中它的实现类有以下几种：</span><br><span class="line">    MethodInterceptor</span><br><span class="line">    InvocationHandler</span><br><span class="line"></span><br><span class="line">MethodInterceptor：</span><br><span class="line">    它可以实现类似于AOP编程中的环绕增强（around-advice）。</span><br><span class="line"></span><br><span class="line">    它只有一个方法：</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy)</span></span><br><span class="line"></span><br><span class="line">    代理类的所有方法调用都会转而执行这个接口中的intercept方法而不是原方法。</span><br><span class="line">    如果需要在intercept方法中执行原方法可以使用参数method进行反射调用，</span><br><span class="line">    或者使用参数proxy 一 proxy.invokeSuper(obj, args);</span><br><span class="line">    后者会快一些（反射调用比正常的方法调用的速度慢很多）。</span><br><span class="line">    MethodInterceptor允许我们完全控制被拦截的方法，并且提供了手段对原方法进行调用，</span><br><span class="line"></span><br><span class="line">    因为 MethodInterceptor的效率不高，它需要产生不同类型的字节码，</span><br><span class="line">    并且需要生成一些运行时对象（InvocationHandler就不需要），所以Cglib提供了其它的接口供我们选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InvocationHandler：</span><br><span class="line">    它的使用方式和MethodInterceptor差不多。</span><br><span class="line">    需要注意的一点是，所有对invoke()方法的参数proxy对象的方法调用都会被委托给同一个InvocationHandler，</span><br><span class="line">    所以可能会导致无限循环。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		同样是上面的案例，我们再次使用<code>CGLIB</code>代理实现。</p>
<p>​		如果没有定义<code>SellTickets</code>接口，只定义了<code>TrainStation</code>(火车站类)。很显然<code>JDK</code>代理是无法使用了，因为<code>JDK</code>动态代理要求必须定义接口，对接口进行代理。</p>
<p>​		<code>CGLIB</code>是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为<code>JDK</code>的动态代理提供了很好的补充。</p>
</blockquote>
<p><code>CGLIB</code>是第三方提供的包，所以需要引入<code>jar</code>包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><blockquote>
<p><strong>1）、<code>JDK</code>和<code>CGLib</code>的区别</strong></p>
<ul>
<li><code>JDK</code>动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li><code>CGLib</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）</li>
</ul>
<p><strong>2）、<code>Spring</code>在选择用<code>JDK</code>还是<code>CGLib</code>的依据</strong></p>
<ul>
<li>当<code>Bean</code>实现接口时，<code>Spring</code>就会用<code>JDK</code>的动态代理</li>
<li>当<code>Bean</code>没有实现接口时，<code>Spring</code>使用<code>CGLib</code>来实现</li>
<li>可以强制使用<code>CGLib</code>（在<code>Spring</code>配置中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;</code>）</li>
</ul>
<p><strong>3）、<code>JDK</code>和<code>CGLib</code>的性能对比</strong></p>
<ul>
<li>使用<code>CGLib</code>实现动态代理，<code>CGLib</code>底层采用<code>ASM</code>字节码生成框架，使用字节码技术生成代理类，在<code>JDK1.6</code>之前比使用<code>Java</code>反射效率要高。唯一需要注意的是，<code>CGLib</code>不能对声明为<code>final</code>的方法进行代理，因为<code>CGLib</code>原理是动态生成被代理类的子类。</li>
<li>在<code>JDK1.6</code>、<code>JDK1.7</code>、<code>JDK1.8</code>逐步对<code>JDK</code>动态代理优化之后，在调用次数较少的情况下，<code>JDK</code>代理效率高于<code>CGLib</code>代理效率，只有当进行大量调用的时候，<code>JDK1.6</code>和<code>JDK1.7</code>比<code>CGLib</code>代理效率低一点，但是到<code>JDK1.8</code>的时候，<code>JDK</code>代理效率高于<code>CGLib</code>代理。</li>
</ul>
<p>总结：<code>CGLib</code>创建的动态代理对象性能<code>jdk1.6</code>、<code>1.7</code>比<code>JDK</code>创建的动态代理对象的性能高不少，（<code>1.8</code>之后则不如<code>jdk</code>动态代理)，但是<code>CGLib</code>在创建代理对象时所花费的时间却比<code>JDK</code>多得多，所以对于单例的对象，因为无需频繁创建对象，用<code>CGLib</code>合适，反之，使用<code>JDK</code>方式要更为合适一些。同时，由于<code>CGLib</code>由于是采用动态创建子类的方法，对于<code>final</code>方法，无法进行代理。</p>
</blockquote>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><blockquote>
<p>​		数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么一起成功，要么一起失败，是一个不可分割的工作单元。</p>
</blockquote>
<blockquote>
<p>​		在我们日常工作中，涉及到事务的场景非常多，一个 service 中往往需要调用不同的 dao 层方法，这些方法要么同时成功要么同时失败，我们需要在 service 层确保这一点。</p>
</blockquote>
<blockquote>
<p>说到事务最典型的案例就是转账了：</p>
<p>​		张三要给李四转账 500 块钱，这里涉及到两个操作，从张三的账户上减去 500 块钱，给李四的账户添加 500 块钱，这两个操作要么同时成功要么同时失败，如何确保他们同时成功或者同时失败呢？答案就是事务。</p>
</blockquote>
<h2 id="事务有四大特性（ACID）"><a href="#事务有四大特性（ACID）" class="headerlink" title="事务有四大特性（ACID）"></a>事务有四大特性（ACID）</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/jhghftdrsxdtgujnjnibugvyfcvgujn.png"></p>
<blockquote>
<ul>
<li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</blockquote>
<h2 id="Spring-中的事务"><a href="#Spring-中的事务" class="headerlink" title="Spring 中的事务"></a>Spring 中的事务</h2><h3 id="三大基础设施"><a href="#三大基础设施" class="headerlink" title="三大基础设施"></a>三大基础设施</h3><blockquote>
<ul>
<li>PlatformTransactionManager   <strong>事务管理器接口，事务的<code>提交、回滚等操作</code>全部交给它来实现</strong></li>
<li>TransactionDefinition   <strong>事务的一些基础信息，如超时时间、隔离级别、传播属性等</strong></li>
<li>TransactionStatus   <strong>事务的一些状态信息，如是否是一个新的事务、是否已被标记为回滚</strong></li>
</ul>
</blockquote>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>PlatformTransactionManager 是事务处理的核心，它有诸多的实现类，如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/jbhugvycftxfygbhijnibugcrtyubio.png"></p>
<p>PlatformTransactionManager 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		可以看到 <code>PlatformTransactionManager</code> 中定义了基本的事务操作方法，这些事务操作方法都是平台无关的，具体的实现都是由不同的子类来实现的。</p>
</blockquote>
<blockquote>
<p>​		这就像 <code>JDBC</code> 一样，<code>SUN</code> 公司制定标准，其他数据库厂商提供具体的实现。这么做的好处就是我们 Java 程序员只需要掌握好这套标准即可，不用去管接口的具体实现。以 <code>PlatformTransactionManager</code> 为例，它有众多实现，如果你使用的是 JDBC 那么可以将 <code>DataSourceTransactionManager</code> 作为事务管理器；如果你使用的是 Hibernate，那么可以将 <code>HibernateTransactionManager</code> 作为事务管理器；如果你使用的是 JPA，那么可以将 <code>JpaTransactionManager</code> 作为事务管理器。<code>DataSourceTransactionManager</code>、<code>HibernateTransactionManager</code> 以及 <code>JpaTransactionManager</code> 都是 <code>PlatformTransactionManager</code> 的具体实现，但是我们并不需要掌握这些具体实现类的用法，我们只需要掌握好 <code>PlatformTransactionManager</code> 的用法即可。</p>
</blockquote>
<h5 id="getTransaction-Nullable-TransactionDefinition-definition"><a href="#getTransaction-Nullable-TransactionDefinition-definition" class="headerlink" title="getTransaction(@Nullable TransactionDefinition definition)"></a>getTransaction(@Nullable TransactionDefinition definition)</h5><blockquote>
<p>​		getTransaction() 是根据传入的 TransactionDefinition 获取一个事务对象，TransactionDefinition 中定义了一些事务的基本规则，例如传播性、隔离级别等。</p>
</blockquote>
<h5 id="commit-TransactionStatus-status"><a href="#commit-TransactionStatus-status" class="headerlink" title="commit(TransactionStatus status)"></a>commit(TransactionStatus status)</h5><blockquote>
<p>​		commit() 方法用来提交事务。</p>
</blockquote>
<h5 id="rollback-TransactionStatus-status"><a href="#rollback-TransactionStatus-status" class="headerlink" title="rollback(TransactionStatus status)"></a>rollback(TransactionStatus status)</h5><blockquote>
<p>​		rollback() 方法用来回滚事务</p>
</blockquote>
<h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><blockquote>
<p><code>	TransactionDefinition</code> 用来描述事务的具体规则，也称作事务的属性。</p>
<p>​	主要是五种属性：隔离性、传播性、回滚规则、超时时间、是否只读</p>
</blockquote>
<p><code>TransactionDefinition</code> 类中的方法如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/onbiyutfyiuiyutfuvybiutyuyiu.png"></p>
<p>可以看到一共有五个方法：</p>
<blockquote>
<ul>
<li><p>getIsolationLevel()    <strong>获取事务的隔离级别</strong></p>
</li>
<li><p>getName()      <strong>获取事务的名称</strong></p>
</li>
<li><p>getPropagationBehavior()      <strong>获取事务的传播性</strong></p>
</li>
<li><p>getTimeout()      <strong>获取事务的超时时间</strong></p>
</li>
<li><p>isReadOnly()      <strong>获取事务是否是只读事务</strong></p>
</li>
</ul>
</blockquote>
<p>TransactionDefinition 也有诸多的实现类，如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/nsfhgbvdsfdbdfdfbdv.png"></p>
<blockquote>
<p>​		如果开发者使用了编程式事务的话，直接使用 <code>DefaultTransactionDefinition</code> 即可。</p>
</blockquote>
<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>TransactionStatus 可以直接理解为事务本身，该接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span> <span class="keyword">extends</span> <span class="title class_">SavepointManager</span>, Flushable &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCompleted</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>isNewTransaction()    <strong>获取当前事务是否是一个新事务</strong></p>
</li>
<li><p>hasSavepoint()     <strong>判断是否存在 savePoint()</strong></p>
</li>
<li><p>setRollbackOnly()    <strong>设置事务必须回滚</strong></p>
</li>
<li><p>isRollbackOnly()     <strong>获取事务只能回滚</strong></p>
</li>
<li><p>flush()    <strong>将底层会话中的修改刷新到数据库，一般用于 Hibernate&#x2F;JPA 的会话，对如 JDBC 类型的事务无任何影响</strong></p>
</li>
<li><p>isCompleted()    <strong>用来获取是一个事务是否结束</strong></p>
</li>
</ul>
</blockquote>
<h3 id="Spring事务的配置方式"><a href="#Spring事务的配置方式" class="headerlink" title="Spring事务的配置方式"></a>Spring事务的配置方式</h3><p>Spring支持编程式事务管理以及声明式事务管理两种方式。</p>
<h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><blockquote>
<p>​		编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。</p>
</blockquote>
<blockquote>
<p>​		通过 PlatformTransactionManager 或者 TransactionTemplate 可以实现编程式事务。如果是在 Spring Boot 项目中，这两个对象 Spring Boot 会自动提供，我们直接使用即可。但是如果是在传统的 SSM 项目中，则需要我们通过配置来提供这两个对象，一个简单的配置参考，如下（简单起见，数据库操作我们使用 JdbcTemplate）：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span> id=<span class="string">&quot;dataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> id=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.transaction.support.TransactionTemplate&quot;</span> id=<span class="string">&quot;transactionTemplate&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;transactionManager&quot;</span> ref=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span> id=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>有了这两个对象，接下来的代码就简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultTransactionDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txManager.getTransaction(definition);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jdbcTemplate.update(<span class="string">&quot;update user set account=account+100 where username=&#x27;zhangsan&#x27;&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            jdbcTemplate.update(<span class="string">&quot;update user set account=account-100 where username=&#x27;lisi&#x27;&quot;</span>);</span><br><span class="line">            txManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            txManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		这段代码很简单，没啥好解释的，在 <code>try...catch...</code> 中进行业务操作，没问题就 commit，有问题就 rollback。如果我们需要配置事务的隔离性、传播性等，可以在 DefaultTransactionDefinition 对象中进行配置。</p>
</blockquote>
<blockquote>
<p>​		上面的代码是通过 PlatformTransactionManager 实现的编程式事务，我们也可以通过 TransactionTemplate 来实现编程式事务，如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate tranTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        tranTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jdbcTemplate.update(<span class="string">&quot;update user set account=account+100 where username=&#x27;zhangsan&#x27;&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                    jdbcTemplate.update(<span class="string">&quot;update user set account=account-100 where username=&#x27;lisi&#x27;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		直接注入 TransactionTemplate，然后在 execute 方法中添加回调写核心的业务即可，当抛出异常时，将当前事务标注为只能回滚即可。注意，execute 方法中，如果不需要获取事务执行的结果，则直接使用 TransactionCallbackWithoutResult 类即可，如果要获取事务执行结果，则使用 TransactionCallback 即可。</p>
</blockquote>
<h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><blockquote>
<p>​		声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。</p>
<p>​		编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。</p>
<p>​		显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。</p>
</blockquote>
<blockquote>
<p>​		声明式事务如果使用 <code>XML</code> 配置，可以做到无侵入；如果使用 <code>Java</code> 配置，也只有一个 <code>@Transactional</code> 注解侵入而已，相对来说非常容易。</p>
</blockquote>
<h5 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h5><p>XML 配置声明式事务大致上可以分为三个步骤，如下：</p>
<h6 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span> id=<span class="string">&quot;dataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> id=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h6 id="配置事务通知"><a href="#配置事务通知" class="headerlink" title="配置事务通知"></a>配置事务通知</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice transaction-manager=<span class="string">&quot;transactionManager&quot;</span> id=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name=<span class="string">&quot;m3&quot;</span>/&gt;</span><br><span class="line">        &lt;tx:method name=<span class="string">&quot;m4&quot;</span>/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>

<h6 id="配置-AOP"><a href="#配置-AOP" class="headerlink" title="配置 AOP"></a>配置 AOP</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">&quot;pc1&quot;</span> expression=<span class="string">&quot;execution(* org.javaboy.demo.*.*(..))&quot;</span>/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=<span class="string">&quot;txAdvice&quot;</span> pointcut-ref=<span class="string">&quot;pc1&quot;</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>第二步和第三步中定义出来的方法交集，就是我们要添加事务的方法。</p>
<p>配置完成后，如下一些方法就自动具备事务了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update user set money=997 where username=?&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h5><p>我们也可以使用 Java 配置来实现声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">//开启事务注解支持</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql:///test01?serverTimezone=Asia/Shanghai&quot;</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要配置的东西其实和 XML 中配置的都差不多，最最关键的就两个：</p>
<ul>
<li>事务管理器 PlatformTransactionManager。</li>
<li>@EnableTransactionManagement 注解开启事务支持。</li>
</ul>
</blockquote>
<p>配置完成后，接下来，哪个方法需要事务就在哪个方法上添加 <code>@Transactional</code> 注解即可，向下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = ArithmeticException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update4</span><span class="params">()</span> &#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;update account set money = ? where username=?;&quot;</span>, <span class="number">998</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		当<code>@Transactional</code> 注解加在类上面的时候，表示该类的所有方法都有事务，该注解加在方法上面的时候，表示该方法有事务。</p>
</blockquote>
<h5 id="混合配置"><a href="#混合配置" class="headerlink" title="混合配置"></a>混合配置</h5><blockquote>
<p>​		也可以 Java 代码和 XML 混合配置来实现声明式事务，就是一部分配置用 XML 来实现，一部分配置用 Java 代码来实现：</p>
</blockquote>
<p>假设 XML 配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    开启事务的注解配置，添加了这个配置，就可以直接在代码中通过 <span class="meta">@Transactional</span> 注解来开启事务了</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;tx:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>那么 Java 代码中的配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@ImportResource(locations = &quot;classpath:applicationContext3.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql:///test01?serverTimezone=Asia/Shanghai&quot;</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		Java 配置中通过 @ImportResource 注解导入了 XML 配置，XML 配置中的内容就是开启 <code>@Transactional</code> 注解的支持，所以 Java 配置中省略了 @EnableTransactionManagement 注解。</p>
</blockquote>
<h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><blockquote>
<p>​		MySQL 中有四种不同的隔离级别，这四种不同的隔离级别在 Spring 中都得到了很好的支持。Spring 中默认的事务隔离级别是 default，即数据库本身的隔离级别是啥就是啥，default 就能满足我们日常开发中的大部分场景。</p>
</blockquote>
<p>事务隔离级别定义<code>TransactionDefinition</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>隔离级别</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td align="left">这是个 PlatfromTransactionManager 默认的隔离级别， 使用数据库默认的事务隔离级别。另外四个与 JDBC 的 隔离级别相对应。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td align="left">这是事务最低的隔离级别，它允许另外一个事务可以看 到这个事务未提交的数据。这种隔离级别会产生脏读， 不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td align="left">保证一个事务修改的数据提交后才能被另外一个事务读 取。另外一个事务不能读取该事务未提交的数据。 ISOLATION_REPEATABLE_READ</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td align="left">这是花费最高代价但是最可靠的事务隔离级别。事务被 处理为顺序执行。</td>
</tr>
</tbody></table>
<h4 id="传播性"><a href="#传播性" class="headerlink" title="传播性"></a>传播性</h4><p>先来说说何谓事务的传播性：</p>
<blockquote>
<p>​		事务传播行为是为了解决业务层方法之间互相调用的事务问题，当一个事务方法被另一个事务方法调用时，事务该以何种状态存在？例如新方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，等等，这些规则就涉及到事务的传播性。</p>
</blockquote>
<p>关于事务的传播性，Spring 主要定义了如下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体含义如下：</p>
<table>
<thead>
<tr>
<th align="center">传播性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROPAGATION_REQUIRED</td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td>
</tr>
<tr>
<td align="center">PROPAGATION_SUPPORTS</td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td>
</tr>
<tr>
<td align="center">PROPAGATION_MANDATORY</td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td>
</tr>
<tr>
<td align="center">PROPAGATION_REQUIRES_NEW</td>
<td align="left">创建一个新的事务，如果当前存在事务，则把当前事务挂起</td>
</tr>
<tr>
<td align="center">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">以非事务方式运行，如果当前存在事务，则把当前事务挂起</td>
</tr>
<tr>
<td align="center">PROPAGATION_NEVER</td>
<td align="left">以非事务方式运行，如果当前存在事务，则抛出异常</td>
</tr>
<tr>
<td align="center">PROPAGATION_NESTED</td>
<td align="left">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</td>
</tr>
</tbody></table>
<h5 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h5><blockquote>
<p>​		如果存在一个事务，则支持当前事务，如果没有事务则开启事务。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/f26ca7d1652dscscsdcsdcsdcsdcsd73e9837822.png"></p>
</blockquote>
<blockquote>
<p>​		如下例子，单独调用methodB时，当前上下文没有事务，所以会开启一个新的事务。</p>
</blockquote>
<blockquote>
<p>​		调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务A中来。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h5><blockquote>
<p>​		如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行.</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/115884c286501588cddscsdcsdcdsc1ae7d23a024b5366.png"></p>
</blockquote>
<blockquote>
<p>​		单独的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务属性为SUPPORTS</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h5><blockquote>
<p>​		如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/21c4e6e8d4c56dbsdcdscdscs63cee652f3.png"></p>
</blockquote>
<blockquote>
<p>​		当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”)</p>
</blockquote>
<blockquote>
<p>​		当调用methodA时，methodB则加入到methodA的事务中，以事务方式执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h5><blockquote>
<p>​		使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。</p>
<p>​		它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/cbaf67a29f8a3dscsadcsdcsdcsdcsdc9144dd6.png"></p>
</blockquote>
<blockquote>
<p>​		从下面代码可以看出，事务B与事务A是两个独立的事务，互不相干。事务B是否成功并不依赖于 事务A。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		当调用methodA()，相当于</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获得一个JTA事务管理器</span></span><br><span class="line">        tm = getTransactionManager();</span><br><span class="line">        tm.begin();<span class="comment">//开启一个新的事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">ts1</span> <span class="operator">=</span> tm.getTransaction();</span><br><span class="line">        doSomeThing();</span><br><span class="line">        tm.suspend();<span class="comment">//挂起当前事务</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            tm.begin();<span class="comment">//重新开启第二个事务</span></span><br><span class="line">            <span class="type">Transaction</span> <span class="variable">ts2</span> <span class="operator">=</span> tm.getTransaction();</span><br><span class="line">            methodB();</span><br><span class="line">            ts2.commit();<span class="comment">//提交第二个事务</span></span><br><span class="line">        &#125; Catch(RunTimeException ex) &#123;</span><br><span class="line">            ts2.rollback();<span class="comment">//回滚第二个事务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//methodB执行完后，恢复第一个事务</span></span><br><span class="line">        tm.resume(ts1);</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        ts1.commit();<span class="comment">//提交第一个事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(RunTimeException ex) &#123;</span><br><span class="line">        ts1.rollback();<span class="comment">//回滚第一个事务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h5><blockquote>
<p>​		总是非事务地执行，并挂起任何存在的事务。</p>
</blockquote>
<blockquote>
<p>​		使用<code>PROPAGATION_NOT_SUPPORTED</code>，也需要使用·JtaTransactionManager·作为事务管理器。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdd9761528280csccsdcsdcsd0dbff7b33f3f4.png"></p>
</blockquote>
<h5 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h5><blockquote>
<p>​		总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
</blockquote>
<h5 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h5><blockquote>
<p>​		如果一个活动的事务存在，则运行在一个嵌套的事务中。</p>
</blockquote>
<blockquote>
<p>​		如果没有活动事务,则按<code>TransactionDefinition.PROPAGATION_REQUIRED</code> 属性执行。</p>
</blockquote>
<blockquote>
<p>​		这是一个嵌套事务,使用<code>JDBC3.0</code>驱动时,仅仅支持<code>DataSourceTransactionManager</code>作为事务管理器。 需要JDBC 驱动的java.sql.Savepoint类。使用<code>PROPAGATION_NESTED</code>，还需要把<code>PlatformTransactionManager的nestedTransactionAllowed</code>属性设为<code>true</code>(属性值默认为<code>false</code>)。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/87a0435aae0sasdcdcdcdscsdc4b3b291155aaf.png"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEWSTED)</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		单独调用<code>methodB</code>方法，则按<code>REQUIRED</code>属性执行。如果调用<code>methodA</code>方法，则相当于：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Savepoint</span> <span class="variable">savepoint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        con = getConnection();</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        doSomeThingA();</span><br><span class="line">        savepoint = con2.setSavepoint();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RuntimeException ex) &#123;</span><br><span class="line">            con.rollback(savepoint);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RuntimeException ex) &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		当<code>methodB</code>方法调用之前，调用<code>setSavepoint</code>方法，保存当前的状态到<code>savepoint</code>。如果<code>methodB</code>方法调用失败，则恢复到之前保存的状态。</p>
</blockquote>
<blockquote>
<p>​		需要注意的是，这时的事务并没有进行提交，如果后续的代码(<code>doSomeThingB()</code>方法)调用失败，则回滚包括<code>methodB</code>方法的所有操作。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
</blockquote>
<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><blockquote>
<ul>
<li><code>@Configuration</code>注解：该类等价 与<code>XML</code>中配置<code>beans</code>，相当于<code>Ioc</code>容器，它的某个方法头上如果注册了<code>@Bean</code>，就会作为这个<code>Spring</code>容器中的<code>Bean</code>，与<code>xml</code>中配置的<code>bean</code>意思一样。</li>
<li><code>@Bean</code>：注解在方法上，声明当前方法的返回值为一个<code>bean</code>，替代<code>xml</code>中的方式；</li>
<li><code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>都可以称为<code>@Component</code>。</li>
<li><code>@Controller</code>：控制层</li>
<li><code>@Service</code>：业务层</li>
<li><code>@Repository</code>：数据访问层</li>
</ul>
</blockquote>
<h2 id="Autowired-与-Resource的区别"><a href="#Autowired-与-Resource的区别" class="headerlink" title="@Autowired 与@Resource的区别"></a>@Autowired 与@Resource的区别</h2><blockquote>
<ul>
<li><code>@Autowired</code>与<code>@Resource</code>都可以用来装配<code>bean</code>，都可以写在字段上，或写在<code>setter</code>方法上。</li>
<li><code>@Autowired</code>默认按类型装配（这个注解是属业<code>spring</code>的），默认情况下必须要求依赖对象必须存在，如果要允许<code>null</code>值，可以设置它的<code>required</code>属性为<code>false</code>，如：<code>@Autowired(required=false)</code> ，如果我们想使用名称装配可以结合<code>@Qualifier</code>注解进行使用，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> () <span class="meta">@Qualifier</span> ( <span class="string">&quot;baseDao&quot;</span> )</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Resource</code>（这个注解属于<code>J2EE</code>的），默认按照名称进行装配，名称可以通过<code>name</code>属性进行指定，如果没有指定<code>name</code>属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在<code>setter</code>方法上默认取属性名进行装配。当找不到与名称匹配的<code>bean</code>时才按照类型进行装配。但是需要注意的是，如果<code>name</code>属性一旦指定，就只会按照名称进行装配。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span> (name= <span class="string">&quot;baseDao&quot;</span> )</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Resource</code>的作用相当于<code>@Autowired</code>，只不过<code>@Autowired</code>按<code>byType</code>自动注入，而<code>@Resource</code>默认按 <code>byName</code>自动注入罢了。</li>
</ul>
</blockquote>
<blockquote>
<p><code>@Resource</code>装配顺序：</p>
<p>  　　1. 如果同时指定了<code>name</code>和<code>type</code>，则从<code>Spring</code>上下文中找到唯一匹配的<code>bean</code>进行装配，找不到则抛出异常<br>        　　2. 如果指定了<code>name</code>，则从上下文中查找名称<code>（id）</code>匹配的<code>bean</code>进行装配，找不到则抛出异常<br>              　　3. 如果指定了<code>type</code>，则从上下文中找到类型匹配的唯一<code>bean</code>进行装配，找不到或者找到多个，都会抛出异常<br>                    　　4. 如果既没有指定<code>name</code>，又没有指定<code>type</code>，则自动按照<code>byName</code>方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/22/Spring-Framework/" data-id="clpsh979a000rxgvs538ldguq" data-title="Spring Framework" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Framework/" rel="tag">Spring Framework</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/13/SpringBoot/" class="article-date">
  <time class="dt-published" datetime="2022-01-13T12:18:07.000Z" itemprop="datePublished">2022-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/13/SpringBoot/">SpringBoot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote>
<p><code>SpringBoot</code>框架：两个非常重要的策略：开箱即用和约定优于配置。</p>
<ul>
<li>开箱即用：是指在开发过程中，通过在<code>MAVEN</code>项目的<code>pom</code>文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。</li>
<li>约定优于配置：是一种由<code>SpringBoot</code>本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了<code>BUG</code>定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的<code>XML</code>配置，并且可以将代码编译、测试和打包等工作自动化。</li>
</ul>
</blockquote>
<h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><blockquote>
<p>​		<code>SpringBoot</code>的<strong>自动装配</strong>实际上就是为了从spring.factories文件中获取到对应的需要进行自动装配的类，并生成相应的<code>Bean</code>对象，然后将它们交给<code>spring</code>容器来帮我们进行管理</p>
</blockquote>
<h3 id="启动类上注解的作用"><a href="#启动类上注解的作用" class="headerlink" title="启动类上注解的作用"></a>启动类上注解的作用</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><blockquote>
<p>​		这个注解是<code>springboot</code>启动类上的一个注解，是一个组合注解，也就是由其他注解组合起来，它的主要作用就是标记说明这个类是<code>springboot</code>的主配置类，<code>springboot</code>应该运行这个类里面的<code>main()</code>方法来启动程序。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bfe74f5f2dff4e278df349bf41asdcsdce840d.png"></p>
</blockquote>
<blockquote>
<p>这个注解主要由三个子注解组成：</p>
<ul>
<li><code>@SpringBootConfiguration</code></li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/9e064d08a9484af0978scsdcdsf34aa0f519815.png"></p>
</blockquote>
<h5 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h5><blockquote>
<p>​		这个注解包含了<code>@Configuration</code>，<code>@Configuration</code>里面又包含了一个<code>@Component</code>注解，也就是说，<strong>这个注解标注在哪个类上，就表示当前这个类是一个配置类，而配置类也是<code>spring</code>容器中的组件</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/9ffcf2fa6a4f41008c8bexsxxsxs1f76755bdb8.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/beaf9410c6ff4f368cad7cdcddcdcd56ec38a0602.png"></p>
</blockquote>
<h5 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h5><blockquote>
<p>这个注解是开启自动配置的功能，里面包含了两个注解</p>
<ul>
<li><code>@AutoConfigurationPackage</code></li>
<li><code>@Import（AutoConfigurationImportSelector.class）</code></li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/8ed81baf3156416497964cdscdsca2b4688c305.png"></p>
</blockquote>
<h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><blockquote>
<p>​		这个注解的作用说白了就是将主配置类（<code>@SpringBootApplication</code>标注的类）所在包以及子包里面的所有组件扫描并加载到<code>spring</code>的容器中，这也就是为什么我们在利用<code>springboot</code>进行开发的时候，无论是<code>Controller</code>还是<code>Service</code>的路径都是与主配置类同级或者次级的原因。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/da21d1b9345f47a8b97cdcdsaad223663e831.png"></p>
</blockquote>
<h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><blockquote>
<p>​		上一个注解我们把所有组件都加载到了容器里面，<strong>这个注解就是将需要自动装配的类以全类名的方式返回</strong>，那是怎么找到哪些是需要自动装配的类呢？</p>
<p>1、<code>AutoConfigurationImportSelector</code><strong>这个类里面有一个方法</strong><code>selectImports()</code>，如下</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/1ea8b6a5b9654036945c8cdcdcdscdc29448b9d0.png"></p>
<p>2、在<strong>selectImport</strong>()方法里调用了一个<strong>getAutoConfigurationEntry</strong>()方法，这个方法里面又调用了一个<strong>getCandidateConfigurations</strong>()方法</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/4919beb3764f4750afcddscsdca58cab4e8bbd4a.png"></p>
<p>3、在<strong>getCandidateConfigurations</strong>()方法里面调用了<strong>loadFactoryNames</strong>()方法</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/f212ef804fa8476dbcddscsdcf244ba5427f5429.png"></p>
<p>4、<strong>loadFactoryNames</strong>()方法里面又调用了一个<strong>loadSpringFactories</strong>()方法</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/6201de573e2e47csddcsd30a707f0bceaf818a3.png"></p>
<p>5、关键就在这个<strong>loadSpringFactories</strong>()方法里面，在这个方法里，它会查找所有在<strong>META-INF</strong>路径下的<strong>spring.factories</strong>文件</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/da917e16f65b409e91c378csscscc4e3694a2e.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/3af9641e1c8d422686a51ecdscs71fa30565f.png"></p>
<p>6、在<strong>META-INF&#x2F;spring.factories</strong>这个文件里面的数据是以<strong>键&#x3D;值</strong>的方式存储，然后解析这些文件，找出以<strong>EnableAutoConfiguration</strong>为键的所有值，以列表的方式返回</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/fbb6d7ab84144173bd2b92cddscf1b927b1d3.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/acd9aa8f646c45cf8cdcsd50ecedec08347da.png"></p>
</blockquote>
<h5 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h5><blockquote>
<p>​		这个注解的作用就是扫描当前包及子包的注解</p>
</blockquote>
<h4 id="springboot自动装配的流程"><a href="#springboot自动装配的流程" class="headerlink" title="springboot自动装配的流程"></a>springboot自动装配的流程</h4><blockquote>
<ol>
<li>在<code>springboot</code>启动的时候会创建一个<code>SpringApplication</code>对象，在对象的构造方法里面会进行一些参数的初始化工作，最主要的是判断当前应用程序的类型以及设置初始化器以及监听器，并在这个过程中会加载整个应用程序的<code>spring.factories</code>文件，将文件中的内容放到缓存当中，方便后续获取；</li>
<li><code>SpringApplication</code>对象创建完成之后会执行run()方法来完成整个应用程序的启动，启动的过程中有两个最主要的方法<code>prepareContext()</code>和<code>refreshContext()</code>，在这两个方法中完成了自动装配的核心功能，在<code>run()</code>方法里还执行了一些包括上下文对象的创建，打印<code>banner</code>图，异常报告期的准备等各个准备工作，方便后续进行调用；</li>
<li>在<code>prepareContext()</code>中主要完成的是对上下文对象的初始化操作，包括属性的设置，比如设置环境变量。在整个过程中有一个<code>load()</code>方法，它主要是完成一件事，那就是将启动类作为一个<code>beanDefinition</code>注册到<code>registry</code>，方便后续在进行<code>BeanFactoryPostProcessor</code>调用执行的时候，可以找到对应执行的主类，来完成对<code>@SpringBootApplication</code>、<code>@EnableAutoConfiguration</code>等注解的解析工作；</li>
<li>在<code>refreshContext()</code>方法中会进行整个容器的刷新过程，会调用<code>spring</code>中的<code>refresh()</code>方法，<code>refresh()</code>方法中有<code>13</code>个非常关键的方法，来完成整个应用程序的启动。而在自动装配过程中，会调用的关键的一个方法就是<code>invokeBeanFactoryPostProcessors()</code>方法，在这个方法中主要是对<code>ConfigurationClassPostProcessor</code>类的处理，这个类是<code>BFPP（BeanFactoryPostProcessor）</code>的子类，因为实现了<code>BDRPP（BeanDefinitionRegistryPostProcessor）</code>接口，在调用的时候会先调用<code>BDRPP</code>中的<code>postProcessBeanDefinitionRegistry()</code>方法，然后再调用<code>BFPP</code>中的<code>postProcessBeanFactory()</code>方法，在执行<code>postProcessBeanDefinitionRegistry()</code>方法的时候会解析处理各种的注解，包含<code>@PropertySource</code>、<code>@ComponentScan</code>、<code>@Bean</code>、<code>@Import</code>等注解，最主要的是对<code>@Import</code>注解的解析；</li>
<li>在解析<code>@Import</code>注解的时候，会有一个<code>getImport()</code>方法，从主类开始递归解析注解，把所有包含<code>@Import</code>的注解都解析到，然后在<code>processImport()</code>方法中对<code>import</code>的类进行分类，例如<code>AutoConfigurationImportSelect</code>归属于<code>ImportSelect</code>的子类，在后续的过程中会调用<code>DeferredImportSelectorHandler</code>类里面的<code>process</code>方法，来完成整个<code>EnableAutoConfiguration</code>的加载。</li>
</ol>
</blockquote>
<h2 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h2><blockquote>
<p>​		<code>JavaConfig</code>: 使用<code>java</code>类作为<code>xml</code>配置文件的替代， 是配置<code>spring</code>容器的纯<code>java</code>的方式。 在这个<code>java</code>类这可以创建<code>java</code>对象，把对象放入<code>spring</code>容器中（注入到容器）， </p>
<p>使用两个注解：</p>
<p>​	1）<code>@Configuration</code> ： 放在一个类的上面，表示这个类是作为配置文件使用的。</p>
<p>​	2）<code>@Bean</code>：声明对象，把对象注入到容器中。</p>
<p>例如：我们可以创建一个类叫<code>SpringConfig</code>，用这个类来代替以往在<code>xml</code>写<code>bean</code>的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.vo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的</span></span><br><span class="line"><span class="comment"> *       位置：在类的上面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  SpringConfig这个类就相当于beans.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建方法，方法的返回值是对象。 在方法的上面加入<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     * 方法的返回值对象就注入到容器中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     位置：方法的上面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     说明：<span class="doctag">@Bean</span>,不指定对象的名称，默认是方法名是 id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">createStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">26</span>);</span><br><span class="line">        s1.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>的name属性，指定对象的名称（id）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lisiStudent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">makeStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        s2.setAge(<span class="number">22</span>);</span><br><span class="line">        s2.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/13/SpringBoot/" data-id="clpsh9799000pxgvs0c7led60" data-title="SpringBoot" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MyBatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/13/MyBatis/" class="article-date">
  <time class="dt-published" datetime="2022-01-13T12:15:31.000Z" itemprop="datePublished">2022-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MyBatis/">MyBatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/13/MyBatis/">MyBatis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><blockquote>
<p><code>Mybatis</code>：一款半自动的ORM持久层框架，具有较高的SQL灵活性，支持高级映射(一对一，一对多)，动态SQL，延迟加载和缓存等特性，但它的数据库无关性较低。作为一个半ORM框架，MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p><code>ORM</code>：Object Relation Mapping，对象关系映射。对象指的是Java对象，关系指的是数据库中的关系模型，对象关系映射，指的就是在Java对象和数据库的关系模型之间建立一种对应关系，比如用一个Java的Student类，去对应数据库中的一张student表，类中的属性和表中的列一一对应。Student类就对应student表，一个Student对象就对应student表中的一行数据</p>
<p><strong>为什么mybatis是半自动的ORM框架？</strong></p>
<blockquote>
<p>​		称Mybatis是半自动ORM映射工具，是因为在查询关联对象或关联集合对象时，需要手动编写sql来完成。不像Hibernate这种全自动ORM映射工具，Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</p>
</blockquote>
</blockquote>
<h2 id="Mybaits的优缺点"><a href="#Mybaits的优缺点" class="headerlink" title="Mybaits的优缺点"></a>Mybaits的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ul>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</li>
<li>能够与Spring很好的集成；</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ul>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ul>
</blockquote>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><blockquote>
<ul>
<li><p><code>$&#123;&#125;</code>是字符串替换，<code>#&#123;&#125;</code>是预处理；</p>
</li>
<li><p>使用<code>#&#123;&#125;</code>可以有效的防止<code>SQL</code>注入，提高系统安全性。</p>
</li>
<li><p><code>Mybatis</code>在处理<code>$&#123;&#125;</code>时，就是把<code>$&#123;&#125;</code>直接替换成变量的值。而<code>Mybatis</code>在处理<code>#&#123;&#125;</code>时，会对<code>sql</code>语句进行预处理，将<code>sql</code>中的<code>#&#123;&#125;</code>替换为<code>?</code>号，调用<code>PreparedStatement</code>的<code>set</code>方法来赋值；</p>
</li>
</ul>
</blockquote>
<h2 id="一个mapper-xml文件对应一个Dao接口工作原理"><a href="#一个mapper-xml文件对应一个Dao接口工作原理" class="headerlink" title="一个mapper.xml文件对应一个Dao接口工作原理"></a>一个mapper.xml文件对应一个Dao接口工作原理</h2><blockquote>
<p>​		Mapper 接口的工作原理是<code>JDK</code>动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象 MappedProxy，代理对象会拦截接口方法，根据类的全限定名+方法名，唯一定位到一个MapperStatement并调用执行器执行所代表的sql，然后将sql执行结果返回。</p>
</blockquote>
<h2 id="Dao接口里参数不同的方法是否能重载"><a href="#Dao接口里参数不同的方法是否能重载" class="headerlink" title="Dao接口里参数不同的方法是否能重载"></a>Dao接口里参数不同的方法是否能重载</h2><blockquote>
<p>​		<code>Mapper</code>接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。</p>
<p>（1）<code>Dao</code>接口，就是<code>Mapper</code>接口。</p>
<p>（2）接口的全限名，就是映射文件中的<code>namespace</code>的值；</p>
<p>（3）接口的方法名，就是映射文件中<code>Mapper</code>的<code>Statement</code>的<code>id</code>值；</p>
<p>（4）接口方法内的参数，就是传递给<code>sql</code>的参数。</p>
<p>​        当调用接口方法时，通过 “接口全限名+方法名”拼接字符串作为key值，可唯一定位一个<code>MapperStatement</code>，因为在<code>Mybatis</code>中，每一个<code>SQL</code>标签，都会被解析为一个<code>MapperStatement</code>对象。</p>
</blockquote>
<h2 id="Mybatis进行分页"><a href="#Mybatis进行分页" class="headerlink" title="Mybatis进行分页"></a>Mybatis进行分页</h2><blockquote>
<p>​		<code>Mybatis</code>使用<code>RowBounds</code>对象进行分页，它是针对<code>ResultSet</code>结果集执行的内存分页，而非物理分页。可以在<code>sql</code>内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
</blockquote>
<h2 id="分页插件的原理"><a href="#分页插件的原理" class="headerlink" title="分页插件的原理"></a>分页插件的原理</h2><blockquote>
<p>​		分页插件的基本原理是使用<code>Mybatis</code>提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
</blockquote>
<h2 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h2><blockquote>
<p>（1）一级缓存: 基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存，其存储作用域为 <code>Session</code>，当 <code>Session flush</code> 或 <code>close </code>之后，该 <code>Session</code> 中的所有 <code>Cache</code> 就将清空，默认打开一级缓存。</p>
<p>（2）二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，<code>HashMap</code> 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；</p>
<p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 <code>Session</code>二级缓存<code>Namespaces</code>)的进行了<code>C/U/D</code> 操作后，默认该作用域下所有 <code>select</code> 中的缓存将被 <code>clear</code> 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
</blockquote>
<h2 id="Xml映射文件常见的标签"><a href="#Xml映射文件常见的标签" class="headerlink" title="Xml映射文件常见的标签"></a>Xml映射文件常见的标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parameterMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实体类中的属性名和表中的字段名不一样"><a href="#实体类中的属性名和表中的字段名不一样" class="headerlink" title="实体类中的属性名和表中的字段名不一样"></a>实体类中的属性名和表中的字段名不一样</h2><blockquote>
<p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”me.gacl.domain.order”</span>&gt;</span></span><br><span class="line">   select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第2种： 通过来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">       select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">       &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h2><blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">（1）第一种：</span><br><span class="line">//DAO层的函数</span><br><span class="line">Public UserselectUser(String name,String area);  </span><br><span class="line">//对应的xml,#&#123;0&#125;代表接收的是dao层中的第一个参数，#&#123;1&#125;代表dao层中第二参数，更多参数一致往后加即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span><span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line">（2）第二种： 使用 @param 注解:</span><br><span class="line">public interface usermapper &#123;</span><br><span class="line">   user selectuser(@param(“username”) string username,@param(“hashedpassword”) string hashedpassword);</span><br><span class="line">&#125;</span><br><span class="line">然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectuser”</span> <span class="attr">resulttype</span>=<span class="string">”user”</span>&gt;</span></span><br><span class="line">         select id, username, hashedpassword</span><br><span class="line">         from some_table</span><br><span class="line">         where username = #&#123;username&#125;</span><br><span class="line">         and hashedpassword = #&#123;hashedpassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">（3）第三种：多个参数封装成map</span><br><span class="line">try&#123;</span><br><span class="line">    //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span><br><span class="line">    //由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap();</span><br><span class="line">         map.put(&quot;start&quot;, start);</span><br><span class="line">         map.put(&quot;end&quot;, end);</span><br><span class="line">         return sqlSession.selectList(&quot;StudentID.pagination&quot;, map);</span><br><span class="line"> &#125;catch(Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         sqlSession.rollback();</span><br><span class="line">        throw e; &#125;</span><br><span class="line">finally&#123;</span><br><span class="line"> 		MybatisUtil.closeSqlSession();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/13/MyBatis/" data-id="clpsh97960009xgvs2va95wir" data-title="MyBatis" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java反射" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" class="article-date">
  <time class="dt-published" datetime="2022-01-04T09:01:41.000Z" itemprop="datePublished">2022-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/">Java反射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<blockquote>
<p>​	<code>Java</code>反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是<code>JVM</code>得到<code>class</code>对象之后，再通过<code>class</code>对象进行反编译，从而获取对象的各种信息。</p>
</blockquote>
<blockquote>
<p>​	<code>Java</code>属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到<code>JVM</code>。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>
</blockquote>
<h2 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h2><p>下图是类的正常加载过程、反射原理与<code>class</code>对象：</p>
<p><code>Class</code>对象的由来是将<code>.class</code>文件读入内存，并为之创建一个<code>Class</code>对象。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20201031013312441.png"></p>
<h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ol>
<li>在运行时获得类的各种内容，进行反编译，对于<code>Java</code>这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象;</li>
<li>体现了多态的应用，降低类之间的藕合性;</li>
</ol>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ol>
<li>反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li>
<li>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题;</li>
</ol>
</blockquote>
<h2 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h2><blockquote>
<ol>
<li><p>反编译：<code>.class</code>–&gt;<code>.java</code>；</p>
</li>
<li><p>通过反射机制访问java对象的属性，方法，构造方法等；</p>
</li>
<li><p>反射最重要的用途就是开发各种通用框架。比如很多框架<code>（Spring）</code>都是配置化的（比如通过<code>XML</code>文件配置<code>Bean</code>），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象；</p>
</li>
</ol>
</blockquote>
<h2 id="反射机制常用的类"><a href="#反射机制常用的类" class="headerlink" title="反射机制常用的类"></a>反射机制常用的类</h2><blockquote>
<p><code>java.lang.Class</code>：代表一个类，<code>Class</code>对象表示某个类加载后在堆内存中的对象</p>
<p><code>java.lang.reflect.Method</code>：代表类的方法，<code>Method</code>对象表示某个类的方法</p>
<p><code>java.lang.reflect.Field</code>：代表类的成员变量，<code>Field</code>对象表示某个类的成员变量</p>
<p><code>java.lang.reflect.Constructor</code>：代表类的构造方法，<code>Constructor</code>对象表示构造器</p>
<p><code>Java.lang.reflect.Modifier</code>：修饰符，例如<code>public</code>,<code>privite</code></p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><blockquote>
<p>​	先配置一个<code>application.properties</code>文件（这个文件可以是不同的类型，只要可以读取到就行），输入以下内容：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classfullpath=reflect.Cat</span><br><span class="line">method=hi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>reflect</code>包下创建<code>Cat</code>类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;招财猫&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喵喵叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//根据配置文件中的信息，创建Cat对象并调用hi方法</span></span><br><span class="line">        <span class="comment">//1.使用Properties类读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/resources/application.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString(); <span class="comment">//com.hspedu.Cat</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString(); <span class="comment">//hi</span></span><br><span class="line">        System.out.println(<span class="string">&quot;classfullpath=&quot;</span> + classfullpath);</span><br><span class="line">        System.out.println(<span class="string">&quot;methodName=&quot;</span> + methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用传统方式创建对象行不通，需要使用 反射机制</span></span><br><span class="line">        <span class="comment">//2.1加载类，返回Class类型的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//2.2通过 cls对象 得到加载的类 com.hspedu.Cat 的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//2.3通过 cls对象 得到加载的类 com.hspedu.Cat 的 methodName 方法对象</span></span><br><span class="line">        <span class="comment">//在反射机制中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//2.4通过 method1 调用方法：即通过方法对象实现调用方法</span></span><br><span class="line">        method1.invoke(o); <span class="comment">//传统方法：对象.方法(); 反射机制：方法.invoke(对象)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classfullpath=reflect.Cat</span><br><span class="line">methodName=hi</span><br><span class="line">hi 招财猫</span><br></pre></td></tr></table></figure>

<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><blockquote>
<p>在<code>reflect</code>包下创建<code>Cat</code>类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;招财猫&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喵喵叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量</span></span><br><span class="line">        <span class="comment">//getField()不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(nameField.get(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器</span></span><br><span class="line">        <span class="comment">//()中可以指定构造器的参数类型，如果不传参就是无参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="comment">//参数传递String.class就是String类的Class对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> cls.getConstructor(String.class);</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">public reflect.Cat()</span><br><span class="line">public reflect.Cat(java.lang.String)</span><br></pre></td></tr></table></figure>

<h2 id="反射调用优化——关闭访问检查"><a href="#反射调用优化——关闭访问检查" class="headerlink" title="反射调用优化——关闭访问检查"></a>反射调用优化——关闭访问检查</h2><blockquote>
<ol>
<li><p><code>Method</code>、<code>Field</code>、<code>Constructor</code>对象都有<code>setAccessible()</code>方法</p>
</li>
<li><p><code>setAccessible()</code>作用是启动和禁用访问安全检查开关</p>
<p>参数为<code>true</code>表示：反射的对象在使用时取消访问检查，提高反射的效率。</p>
<p>参数为<code>false</code>表示：反射的对象执行访问检查</p>
</li>
</ol>
</blockquote>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p>在<code>reflect</code>包下创建<code>Cat</code>类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        m1(); <span class="comment">//m1()耗时：4</span></span><br><span class="line">        m2(); <span class="comment">//m2()耗时：161</span></span><br><span class="line">        m3(); <span class="comment">//m3()耗时：109</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方式调用hi()，将hi()中的输出语句注释</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射机制调用hi()，将hi()中的输出语句注释</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2()耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用优化：关闭访问检测</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="comment">//在反射调用方法时，取消访问检查</span></span><br><span class="line">        hi.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m3()耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：（某一次的结果）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1()耗时：3ms</span><br><span class="line">m2()耗时：107ms</span><br><span class="line">m3()耗时：73ms</span><br></pre></td></tr></table></figure>

<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/,iyumtytrebrvfdsvbyhrj.png"></p>
<blockquote>
<ol>
<li><code>Class</code>也是类，因此也继承<code>Object</code>类</li>
<li><code>Class</code>类对象不是<code>new</code>出来的，而是系统创建的</li>
<li>对于某个类的<code>Class</code>类对象，在内存中只有一份，因为类只加载一次</li>
<li>每个类的实例都会记得自己是由哪个<code>Class</code>实例生成</li>
<li>通过<code>Class</code>对象可以完整地得到一个类的完整结构，通过一系列<code>API</code></li>
<li><code>Class</code>对象存放在堆内存中</li>
<li>类的字节码二进制数据存放在方法区中，有的地方称为类的元数据（包括：方法，变量名，方法名，访问权限等）</li>
</ol>
</blockquote>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.Class.forName【编译阶段】，应用场景：通过读取配置文件获取</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.类名.class【Class类阶段】，应用场景：用于参数传递</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.对象.getClass()【运行阶段】，应用场景：有对象实例</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过类加载器（4种）【类加载阶段】来获取类的Class对象</span></span><br><span class="line">        <span class="comment">//4.1获取Car类的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//4.2通过类加载器得到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cls1,cls2,cls3,cls4都是同一个Class对象（一个类只有一个Class对象）</span></span><br><span class="line">        System.out.println(cls1.hashCode());</span><br><span class="line">        System.out.println(cls2.hashCode());</span><br><span class="line">        System.out.println(cls3.hashCode());</span><br><span class="line">        System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.基本数据类型按照如下方式得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">        Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">        Class&lt;Boolean&gt; booleanClass = <span class="type">boolean</span>.class;</span><br><span class="line">        System.out.println(integerClass); <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.基本数据类型对应的包装类，可以通过.TYPE得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">        Class&lt;Character&gt; type2 = Character.TYPE;</span><br><span class="line">        System.out.println(type1); <span class="comment">//int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class reflect.Cat</span><br><span class="line">class reflect.Cat</span><br><span class="line">class reflect.Cat</span><br><span class="line">class reflect.Cat</span><br><span class="line">460141958</span><br><span class="line">460141958</span><br><span class="line">460141958</span><br><span class="line">460141958</span><br><span class="line">int</span><br><span class="line">int</span><br></pre></td></tr></table></figure>

<h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>static Class forName(String name)</code></td>
<td align="center">返回指定类名<code>name</code>的<code>Class</code>对象</td>
</tr>
<tr>
<td align="center"><code>Object newInstance()</code></td>
<td align="center">调用缺省构造函数，返回该<code>Class</code>对象的一个实例</td>
</tr>
<tr>
<td align="center"><code>getName()</code></td>
<td align="center">返回此<code>Class</code>对象所表示的实体(类、接口、数组类、基本类型等)名称</td>
</tr>
<tr>
<td align="center"><code>ClassLoader getClassLoader(）</code></td>
<td align="center">返回该类的类加载器</td>
</tr>
<tr>
<td align="center"><code>Class getSuperclass()</code></td>
<td align="center">返回表示此<code>Class</code>所表示的实体的超类的<code>Class</code></td>
</tr>
<tr>
<td align="center"><code>Constructor[l] getConstructors()</code></td>
<td align="center">返回一个包含某些<code>Constructor</code>对象的数组</td>
</tr>
<tr>
<td align="center"><code>Fieldl getDeclaredFields(）</code></td>
<td align="center">返回<code>Field</code>对象的一个数组</td>
</tr>
<tr>
<td align="center"><code>Method getMethod</code></td>
<td align="center">返回一个<code>Method</code>对象，此对象的形参类型<code>paramType</code></td>
</tr>
</tbody></table>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p>在<code>reflect</code>包下创建<code>Cat</code>类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="string">&quot;宝马&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;白色&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取Car类对应的Class对象</span></span><br><span class="line">        <span class="comment">//&lt;?&gt;表示不确定的Java类型</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;reflect.Cat&quot;</span>);</span><br><span class="line">        <span class="comment">//2.输出cls，显示cls对象是哪个类的Class对象</span></span><br><span class="line">        System.out.println(cls); <span class="comment">//com.hspedu.Car</span></span><br><span class="line">        <span class="comment">//输出cls运行类型 java.lang.Class</span></span><br><span class="line">        System.out.println(cls.getClass());</span><br><span class="line">        <span class="comment">//3.获取包名，com.hspedu</span></span><br><span class="line">        System.out.println(cls.getPackage().getName());</span><br><span class="line">        <span class="comment">//4.得到全类名，java.hspedu.Car</span></span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">        <span class="comment">//5.通过cls创建对象实例</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">car</span> <span class="operator">=</span> (Cat) cls.newInstance();</span><br><span class="line">        System.out.println(car);</span><br><span class="line">        <span class="comment">//6.通过反射获取属性 brand</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">        System.out.println(brand.get(car));</span><br><span class="line">        <span class="comment">//7.通过反射给属性赋值</span></span><br><span class="line">        brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">        System.out.println(brand.get(car));</span><br><span class="line">        <span class="comment">//8.获取所有的属性</span></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.print(field.getName()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class reflect.Cat</span><br><span class="line">class java.lang.Class</span><br><span class="line">reflect</span><br><span class="line">reflect.Cat</span><br><span class="line">Car&#123;brand=&#x27;宝马&#x27;, price=500000, color=&#x27;白色&#x27;&#125;</span><br><span class="line">宝马</span><br><span class="line">奔驰</span><br><span class="line">brand  price  color  </span><br></pre></td></tr></table></figure>

<h3 id="哪些类型有Class对象？"><a href="#哪些类型有Class对象？" class="headerlink" title="哪些类型有Class对象？"></a>哪些类型有Class对象？</h3><blockquote>
<ol>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li>接口</li>
<li>数组</li>
<li>枚举</li>
<li>注解</li>
<li>基本数据类型</li>
<li><code>void</code></li>
</ol>
</blockquote>
<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;String&gt; cls1 = String.class; <span class="comment">//外部类</span></span><br><span class="line">        Class&lt;Serializable&gt; cls2 = Serializable.class; <span class="comment">//接口</span></span><br><span class="line">        Class&lt;Integer[]&gt; cls3 = Integer[].class; <span class="comment">//数组</span></span><br><span class="line">        Class&lt;<span class="type">float</span>[][]&gt; cls4 = <span class="type">float</span>[][].class; <span class="comment">//二维数组</span></span><br><span class="line">        Class&lt;Deprecated&gt; cls5 = Deprecated.class; <span class="comment">//注解</span></span><br><span class="line">        Class&lt;Thread.State&gt; cls6 = Thread.State.class; <span class="comment">//枚举</span></span><br><span class="line">        Class&lt;Long&gt; cls7 = <span class="type">long</span>.class; <span class="comment">//基本数据类型</span></span><br><span class="line">        Class&lt;Void&gt; cls8 = <span class="keyword">void</span>.class; <span class="comment">//void 数据类型</span></span><br><span class="line">        Class&lt;Class&gt; cls9 = Class.class;</span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line">        System.out.println(cls5);</span><br><span class="line">        System.out.println(cls6);</span><br><span class="line">        System.out.println(cls7);</span><br><span class="line">        System.out.println(cls8);</span><br><span class="line">        System.out.println(cls9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.String</span><br><span class="line">interface java.io.Serializable</span><br><span class="line">class [Ljava.lang.Integer;</span><br><span class="line">class [[F</span><br><span class="line">interface java.lang.Deprecated</span><br><span class="line">class java.lang.Thread$State</span><br><span class="line">long</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>

<h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h3><blockquote>
<ol>
<li><code>getName</code>：获取全类名</li>
<li><code>getSimpleName</code>：获取简单类名</li>
<li><code>getFields</code>：获取所有<code>public</code>修饰的属性，包含本类以及父类的</li>
<li><code>getDeclaredFields</code>：获取本类中所有属性</li>
<li><code>getMethods</code>：获取所有<code>public</code>修饰的方法，包含本类以及父类的</li>
<li><code>getDeclaredMethods</code>：获取本类中所有方法</li>
<li><code>getConstructors</code>：获取本类所有<code>public</code>修饰的构造器</li>
<li><code>getDeclaredConstructors</code>：获取本类中所有构造器</li>
<li><code>getPackage</code>：以<code>Package</code>形式返回包信息</li>
<li><code>getSuperClass</code>：以<code>Class</code>形式返回父类信息</li>
<li><code>getlnterfaces</code>：以<code>Class[]</code>形式返回接口信息</li>
<li><code>getAnnotations</code>：以<code>Annotation[]</code>形式返回注解信息</li>
</ol>
</blockquote>
<h3 id="java-lang-reflect-Field类"><a href="#java-lang-reflect-Field类" class="headerlink" title="java.lang.reflect.Field类"></a>java.lang.reflect.Field类</h3><blockquote>
<ol>
<li><code>getModifiers</code>：以<code>int</code>形式返回修饰符<br>[说明：默认修饰符是 <code>0</code>，<code>public</code> 是 <code>1</code>，<code>private</code>是 <code>2</code>，<code>protected</code>是<code> 4</code>，<code>static</code>是 <code>8</code>， <code>final</code>是<code> 16</code>，<br>例如：<code>public(1) + static (8)= 9</code></li>
<li><code>getType</code>：以<code>Class</code>形式返回类型</li>
<li><code>getName</code>：返回属性名</li>
</ol>
</blockquote>
<h3 id="java-lang-reflect-Method类"><a href="#java-lang-reflect-Method类" class="headerlink" title="java.lang.reflect.Method类"></a>java.lang.reflect.Method类</h3><blockquote>
<ol>
<li><code>getModifiers</code>：以<code>int</code>形式返回修饰符<br>[说明:默认修饰符是 <code>0</code>，<code>public</code>是 <code>1</code>，<code>private</code>是 <code>2</code>，<code>protected</code>是 <code>4</code>，<code>static</code>是 <code>8</code>，<code>final</code>是<code>16</code></li>
<li><code>getReturnType</code>：以<code>Class</code>形式获取返回类型</li>
<li><code>getName</code>：返回方法名</li>
<li><code>getParameterTypes</code>：以<code>Class[]</code>返回参数类型数组</li>
</ol>
</blockquote>
<h3 id="java-lang-reflect-Constructor类"><a href="#java-lang-reflect-Constructor类" class="headerlink" title="java.lang.reflect.Constructor类"></a>java.lang.reflect.Constructor类</h3><blockquote>
<ol>
<li><code>getModifiers</code>: 以<code>int</code>形式返回修饰符</li>
<li><code>getName</code>：返回构造器名(全类名)</li>
<li><code>getParameterTypes</code>：以<code>Class[]</code>返回参数类型数组</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>, IB &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">// 4 + 8 = 12</span></span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试1：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//得到Class对象</span></span><br><span class="line">    Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//getName:获取全类名</span></span><br><span class="line">    System.out.println(personCls.getName());</span><br><span class="line">    <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">    System.out.println(personCls.getSimpleName());</span><br><span class="line">    <span class="comment">//getFields:获取所有public修饰的属性，包含本类以及父类的</span></span><br><span class="line">    Field[] fields = personCls.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">    Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span></span><br><span class="line">    Method[] methods = personCls.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">    Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getConstructors: 获取所有public修饰的构造器，包含本类</span></span><br><span class="line">    Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">    Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getPackage:以Package形式返回 包信息</span></span><br><span class="line">    System.out.println(personCls.getPackage());</span><br><span class="line">    <span class="comment">//getSuperClass:以Class形式返回父类信息</span></span><br><span class="line">    Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;父类的class对象=&quot;</span> + superclass);</span><br><span class="line">    <span class="comment">//getInterfaces:以Class[]形式返回接口信息</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getAnnotations:以Annotation[] 形式返回注解信息</span></span><br><span class="line">    Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果1：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">reflect.Person</span><br><span class="line">Person</span><br><span class="line">本类以及父类的属性=name</span><br><span class="line">本类以及父类的属性=hobby</span><br><span class="line">本类中所有属性=name</span><br><span class="line">本类中所有属性=age</span><br><span class="line">本类中所有属性=job</span><br><span class="line">本类中所有属性=sal</span><br><span class="line">本类以及父类的方法=m1</span><br><span class="line">本类以及父类的方法=hi</span><br><span class="line">本类以及父类的方法=wait</span><br><span class="line">本类以及父类的方法=wait</span><br><span class="line">本类以及父类的方法=wait</span><br><span class="line">本类以及父类的方法=equals</span><br><span class="line">本类以及父类的方法=toString</span><br><span class="line">本类以及父类的方法=hashCode</span><br><span class="line">本类以及父类的方法=getClass</span><br><span class="line">本类以及父类的方法=notify</span><br><span class="line">本类以及父类的方法=notifyAll</span><br><span class="line">本类中所有方法=m1</span><br><span class="line">本类中所有方法=m2</span><br><span class="line">本类中所有方法=m4</span><br><span class="line">本类中所有方法=m3</span><br><span class="line">本类的构造器=reflect.Person</span><br><span class="line">本类的构造器=reflect.Person</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line">package reflect</span><br><span class="line">父类的class对象=class reflect.A</span><br><span class="line">接口信息=interface reflect.IA</span><br><span class="line">接口信息=interface reflect.IB</span><br><span class="line">注解信息=@java.lang.Deprecated()</span><br><span class="line"></span><br><span class="line">===============================================</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">===============================================</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试2：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//得到Class对象</span></span><br><span class="line">    Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">    <span class="comment">//规定 说明: 默认修饰符 是0 ， public  是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">    Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">    Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">    Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">本类中所有属性=name 该属性的修饰符值=1 该属性的类型=class java.lang.String</span><br><span class="line">本类中所有属性=age 该属性的修饰符值=12 该属性的类型=int</span><br><span class="line">本类中所有属性=job 该属性的修饰符值=0 该属性的类型=class java.lang.String</span><br><span class="line">本类中所有属性=sal 该属性的修饰符值=2 该属性的类型=double</span><br><span class="line">本类中所有方法=m1 该方法的访问修饰符值=1 该方法返回类型void</span><br><span class="line">该方法的形参类型=class java.lang.String</span><br><span class="line">该方法的形参类型=int</span><br><span class="line">该方法的形参类型=double</span><br><span class="line">本类中所有方法=m2 该方法的访问修饰符值=4 该方法返回类型class java.lang.String</span><br><span class="line">本类中所有方法=m4 该方法的访问修饰符值=2 该方法返回类型void</span><br><span class="line">本类中所有方法=m3 该方法的访问修饰符值=0 该方法返回类型void</span><br><span class="line">====================</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line">该构造器的形参类型=class java.lang.String</span><br><span class="line">该构造器的形参类型=int</span><br><span class="line">====================</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line">该构造器的形参类型=class java.lang.String</span><br><span class="line">====================</span><br><span class="line">本类中所有构造器=reflect.Person</span><br><span class="line"></span><br><span class="line">===============================================</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">===============================================</span><br></pre></td></tr></table></figure>

<h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><blockquote>
<ol>
<li>方式一：调用类中的<code>public</code>修饰的无参构造器.</li>
<li>方式二：调用类中的指定构造器</li>
<li><code>Class</code>类相关方法：</li>
</ol>
<ul>
<li><code>newlnstance</code>：调用类中的无参构造器，获取对应类的对象</li>
<li><code>getConstructor(Class...class)</code>：根据参数列表，获取对应的<code>public</code>构造器对象</li>
<li><code>getDecalaredConstructor(Class...class)</code>：根据参数列表，获取对应的所有构造器对象</li>
</ul>
<p>4.<code>Constructor</code>类相关方法</p>
<ul>
<li><code>setAccessible</code>：暴破</li>
<li><code>newInstance(Obiect..obi</code>：调用构造器</li>
</ul>
</blockquote>
<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;okk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 先获取到User类的Class对象</span></span><br><span class="line">    Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;reflect.User&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 通过public的无参构造器创建实例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance();</span><br><span class="line">    System.out.println(o);</span><br><span class="line">    <span class="comment">//3. 通过public的有参构造器创建实例</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        constructor 对象就是</span></span><br><span class="line"><span class="comment">        public User(String name) &#123;//public的有参构造器</span></span><br><span class="line"><span class="comment">            this.name = name;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">    <span class="comment">//3.2 创建实例，并传入实参</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">hsp</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;hsp=&quot;</span> + hsp);</span><br><span class="line">    <span class="comment">//4. 通过非public的有参构造器创建实例</span></span><br><span class="line">    <span class="comment">//4.1 得到private的构造器对象</span></span><br><span class="line">    Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">    <span class="comment">//4.2 创建实例</span></span><br><span class="line">    <span class="comment">//暴破【暴力破解】，使用反射可以访问private构造器/方法/属性, 反射面前，都是纸老虎</span></span><br><span class="line">    constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user2=&quot;</span> + user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User [age=10, name=okk]</span><br><span class="line">hsp=User [age=10, name=hsp]</span><br><span class="line">user2=User [age=100, name=张三丰]</span><br></pre></td></tr></table></figure>

<h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><blockquote>
<ol>
<li>根据属性名获取<code>Field</code>对象<br><code>Field f = class 对象.getDeclaredField</code>(属性名);</li>
</ol>
<p>2．暴破: <code>f.setAccessible(true)</code>; &#x2F;&#x2F;<code>f </code>是<code>Field</code></p>
<p>3.访问</p>
<ul>
<li><code>f.set(o,值)</code>：&#x2F;&#x2F;<code>o</code>表示对象</li>
<li><code>f.get(o)</code>：&#x2F;&#x2F;<code>o</code>表示对象</li>
</ul>
<p>4、注意：如果是静态属性，则<code>set和</code>g<code>et</code>中的参数<code>o</code>，可以写成<code>null</code></p>
</blockquote>
<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 得到Student类对应的 Class对象</span></span><br><span class="line">    Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 创建对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是Student</span></span><br><span class="line">    System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line">    <span class="comment">//3. 使用反射得到age 属性对象</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">    System.out.println(o);<span class="comment">//</span></span><br><span class="line">    System.out.println(age.get(o));<span class="comment">//返回age属性的值</span></span><br><span class="line">    <span class="comment">//4. 使用反射操作name 属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">//对name 进行暴破, 可以操作private 属性</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//name.set(o, &quot;okk&quot;);</span></span><br><span class="line">    name.set(<span class="literal">null</span>, <span class="string">&quot;okk&quot;</span>);<span class="comment">//因为name是static属性，因此 o 也可以写出null</span></span><br><span class="line">    System.out.println(o);</span><br><span class="line">    System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">    System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//获取属性值, 要求name是static</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class reflect.Student</span><br><span class="line">Student [age=88, name=null]</span><br><span class="line">88</span><br><span class="line">Student [age=88, name=okk]</span><br><span class="line">okk</span><br><span class="line">okk</span><br></pre></td></tr></table></figure>

<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><blockquote>
<ol>
<li>根据方法名和参数列表获取<code>Method</code>方法对象：<br><code>Method m = class.getDeclaredMethod(方法名，XX.class)</code>；&#x2F;&#x2F;得到本类的所有方法</li>
<li>获取对象：<code>Object o=clazz.newlnstance()</code>；</li>
<li>暴破：<code>m.setAccessible(true)</code>；</li>
<li>访问：<code>Object returnValue = m.invoke(o,实参列表)</code>；&#x2F;&#x2F;<code>o</code>就是对象</li>
<li>注意：如果是静态方法，则<code>invoke</code>的参数<code>o</code>，可以写成<code>null!</code></li>
</ol>
</blockquote>
<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 得到Boss类对应的Class对象</span></span><br><span class="line">    Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;reflect.Boss&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 创建对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance();</span><br><span class="line">    <span class="comment">//3. 调用public的hi方法</span></span><br><span class="line">    <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">    <span class="comment">//3.1 得到hi方法对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">    <span class="comment">//3.2 调用</span></span><br><span class="line">    hi.invoke(o, <span class="string">&quot;okk~&quot;</span>);</span><br><span class="line">    <span class="comment">//4. 调用private static 方法</span></span><br><span class="line">    <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class);</span><br><span class="line">    <span class="comment">//4.2 因为say方法是private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">    say.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">    <span class="comment">//4.3 因为say方法是static的，还可以这样调用 ，可以传入null</span></span><br><span class="line">    System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 在反射中，如果方法有返回值，统一返回Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在演示一个返回的案例</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">reVal2</span> <span class="operator">=</span> m1.invoke(o);</span><br><span class="line">    System.out.println(<span class="string">&quot;reVal2的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hi okk~</span><br><span class="line">100 张三 男</span><br><span class="line">200 李四 女</span><br><span class="line">reVal 的运行类型=class java.lang.String</span><br><span class="line">reVal2的运行类型=class reflect.Monster</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/04/Java%E5%8F%8D%E5%B0%84/" data-id="clpsh97950007xgvsggda2g8h" data-title="Java反射" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2022-01-02T11:57:45.000Z" itemprop="datePublished">2022-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<blockquote>
<p>二叉树：二叉树是由<code>n（n&gt;=0）</code>个结点组成的有序集合，集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
</blockquote>
<blockquote>
<p>二叉树的五种形态：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/99fba80666a17ccaa0e6a7fecab52efb.png"></p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><blockquote>
<p>1.树的每层都有最多的结点；<br>2.树中含有的结点个数为 <code>(2^n) - 1</code>；<br>3.叶子节点都在最底下一层，除叶子节点外的所有结点度数都为<code>2</code>。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/526f13015bd3b2cf81467505baa335d9.png"></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><blockquote>
<p>​	如果一棵具有<code>n</code>个结点的高度为k的二叉树，树的每个结点都与高度为<code>k</code>的满二叉树中编号为<code>1——n</code>的结点一一对应，则二叉树为完全二叉树。<br>完全二叉树的特性：<br>A、同样结点数的二叉树，完全二叉树的高度最小<br>B、完全二叉树的叶子结点仅出现在最下边两层，并且最底层的叶子结点一定出现在左边，倒数第二层的叶子结点一定出现在右边。<br>C、完全二叉树中度为<code>1</code>的结点只有左孩子。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/e804b9faee65694a14ca2ebaf80856b2.png"></p>
<h2 id="二叉排序树（BST树）"><a href="#二叉排序树（BST树）" class="headerlink" title="二叉排序树（BST树）"></a>二叉排序树（BST树）</h2><blockquote>
<p>二叉排序树或是一棵空树，或具有以下特性：</p>
<ol>
<li>若左子树非空，其左子树上所有结点的值均小于根节点的值；</li>
<li>若右子树非空，其右子树上所有结点的值均大于根节点的值；</li>
<li>左右子树也满足二叉排序树的特性；</li>
<li>左子树结点值 &lt; 根节点值 &lt; 右子树结点值，所以如果对二叉排序树进行中序遍历可以得到一个递增的有序序列。</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/2020111810534458.png"></p>
<h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><blockquote>
<p>​	为避免树高增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树成为平衡二叉树。</p>
<p>平衡二叉树或是一棵空树，或具有以下特性：</p>
<ol>
<li>平衡树必须是排序树；</li>
<li>平衡二叉树的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差绝对值不超过<code>1</code>（平衡因子的绝对值不超过<code>1</code>）。</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20201118111507265.png"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><blockquote>
<ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点<code>（NIL）</code>是黑色。 [注意：这里叶子节点，是指为空(<code>NIL</code>或<code>NULL</code>)的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。不可以同时存在两个红色节点相连</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。如果一个节点存在黑色子节点，那么该节点肯定有两个子节点</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E4%B8%8BDFSAFASDFASDFADSFASD%E8%BD%BD.PNG"></p>
<p>左旋</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/7e230d584aac4714bcd30a09ea5d6b4a.webp"></p>
<p>右旋</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/1d0d6ee8db3f434b8d64dc350bcd23db.webp"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="clpsh979c0014xgvs1urahqo6" data-title="二叉树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JWT/">JWT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Framework/">Spring Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/">智力题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Framework/" rel="tag">Spring Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" rel="tag">智力题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" rel="tag">项目部署</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Spring-Framework/" style="font-size: 10px;">Spring Framework</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 10px;">智力题</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">项目部署</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/22/Spring-Framework/">Spring Framework</a>
          </li>
        
          <li>
            <a href="/2022/01/13/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/2022/01/13/MyBatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/">Java反射</a>
          </li>
        
          <li>
            <a href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>