<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | Blog</title><meta name="author" content="初学者"><meta name="copyright" content="初学者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录操作系统的基础知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://www.wyy-blog.cn/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="记录操作系统的基础知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/gdfgsfgsfhsdgdsbfsbfgbsf.png">
<meta property="article:published_time" content="2021-12-13T12:13:16.000Z">
<meta property="article:modified_time" content="2022-07-05T01:44:01.178Z">
<meta property="article:author" content="初学者">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/gdfgsfgsfhsdgdsbfsbfgbsf.png"><link rel="shortcut icon" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg"><link rel="canonical" href="https://www.wyy-blog.cn/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-05 09:44:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/gdfgsfgsfhsdgdsbfsbfgbsf.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-13T12:13:16.000Z" title="发表于 2021-12-13 20:13:16">2021-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-05T01:44:01.178Z" title="更新于 2022-07-05 09:44:01">2022-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴王道操作系统内容。</p>
<h1 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h1><blockquote>
<ul>
<li>是系统最基本最核心的软件，属于系统软件</li>
<li>控制和管理整个计算机的硬件和软件资源</li>
<li>合理的组织、调度计算机的工作与资源的分配</li>
<li>为用户和其它软件提供方便的接口和环境</li>
</ul>
</blockquote>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p><strong>进程</strong>：是一个具有一定独立功能的程序，在一个数据集上的一次动态执行的过程，是表示资源分配的基本单位，又是调度运行的基本单位，是应用程序运行的载体。进程一般由<strong>程序，数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志。</p>
</blockquote>
<h4 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h4><blockquote>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进行一起并发执行；</li>
<li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序，数据和进程控制块三部分组成</li>
</ul>
</blockquote>
<h4 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h4><blockquote>
<p><strong>进程</strong>：由程序段、数据段、PCB三部分组成。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/cdvdsfvdsfvfdsvdsvds1143755.png"></p>
</blockquote>
<h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><blockquote>
<ul>
<li>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</li>
<li>PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</li>
<li>进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；</li>
<li>当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在PCB中。</li>
<li>可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</li>
<li>PCB是进程存在的唯一标志。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2020030cdscdscsdcdscscs191134423.png"></p>
</blockquote>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><h5 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h5><p>按进程在执行过程中的不同情况至少要定义三种状态：</p>
<ul>
<li><p><strong>运行（<code>running</code>）态：</strong>进程占有处理器正在运行的状态。</p>
<blockquote>
<p>​	进程已获得<code>CPU</code>，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</p>
</blockquote>
</li>
<li><p><strong>就绪（<code>ready</code>）态：</strong>进程具备运行条件，等待系统分配处理器以便运行的状态。</p>
<blockquote>
<p>​	当进程已分配到除<code>CPU</code>以外的所有必要资源后，只要再获得<code>CPU</code>，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
</blockquote>
</li>
<li><p><strong>阻塞（<code>Blocked</code>）态：</strong>指进程不具备运行条件，正在等待某个时间完成的状态。</p>
<blockquote>
<p>​	也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/AryWDI.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>就绪态—→运行态：<code>CPU</code> 空闲时选择一个就绪进程。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h5><p>五态模型在三态模型的基础上增加了新建态（<code>new</code>）和终止态（<code>exit</code>）。</p>
<ul>
<li><p><strong>新建态：</strong>对应于进程被创建时的状态，尚未进入就绪队列。</p>
<blockquote>
<p>创建一个进程需要通过两个步骤：</p>
<p>​	1.为新进程分配所需要资源和建立必要的管理信息。</p>
<p>​	2.设置该进程为就绪态，并等待被调度执行。</p>
</blockquote>
</li>
<li><p><strong>终止态：</strong>指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。</p>
<blockquote>
<p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。</p>
<p>终止一个进程需要两个步骤：</p>
<p>​	1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。</p>
<p>​	2.然后回收占用的资源并被系统删除。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Aryfbt.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>NULL→新建态：执行一个程序，创建一个子进程。</p>
<p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
<p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>终止态→NULL：完成善后操作。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的七态模型"><a href="#进程的七态模型" class="headerlink" title="进程的七态模型"></a>进程的七态模型</h5><blockquote>
<p>​	三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（<code>suspend</code>），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。</p>
</blockquote>
<blockquote>
<p>引起进程挂起的原因是多样的，主要有：</p>
<ul>
<li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。 </li>
<li>父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 </li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 </li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 </li>
<li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</li>
</ul>
</blockquote>
<blockquote>
<p>七态模型在五态模型的基础上增加了挂起就绪态（<code>ready suspend</code>）和挂起等待态（<code>blocked suspend</code>）。</p>
<ul>
<li>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。</li>
<li>挂起等待态：表明进程正在等待某一个事件发生且在外存中。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Ary4VP.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下:</p>
<blockquote>
<p>等待态→挂起等待态：操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</p>
<p>挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态</p>
<p>挂起就绪态→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</p>
<p>就绪态→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</p>
<p>挂起等待态→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>运行态→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 <code>CPU</code>，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</p>
<p>新建态→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>​	挂起进程等同于不在内存中的进程，因此挂起进程将不参与低级调度直到它们被调换进内存。</p>
<p>挂起进程具有如下特征：</p>
<ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。 （等待事件结束后进程变为挂起就绪态）</li>
<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>
</ul>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p><strong>线程</strong>：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p>
</blockquote>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><blockquote>
<p>从操作系统角度：线程的状态一共可以描述为五种：初始态，可运行，运行态，阻塞态，终止态。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583507073055.png"></p>
<ol>
<li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联；</li>
<li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待<code>CPU</code>给它分配时间片就可运行；</li>
<li>运行状态，指线程获取了<code>CPU</code>时间片，正在运行<ol>
<li>当<code>CPU</code>时间片用完，线程会转换至【可运行状态】，等待<code>CPU</code>再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ol>
</li>
<li>阻塞状态<ol>
<li>如果调用了阻塞<code>API</code>，如<code>BIO</code>读写文件，那么线程实际上不会用到<code>CPU</code>，不会分配<code>CPU</code>时间片，会导致上下文切换，进入【阻塞状态】</li>
<li>等待<code>BIO</code>操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，<code>CPU</code>就一直不会分配时间片</li>
</ol>
</li>
<li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ol>
</blockquote>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote>
<p><strong>协程</strong>：是一种用户态的轻量级线程，协程的调度完全由用户（程序执行）控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210324200sdafvdsvdcsdvdsfvsdf6167.png"></p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><blockquote>
<ul>
<li><strong>调度</strong>：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li><strong>并发性</strong>：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
<li><strong>拥有资源</strong>：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.</li>
<li><strong>系统开销</strong>：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li>
<li>多进程是指操作系统能同时运行多个任务（程序）。</li>
<li>多线程是指在同一程序中有多个顺序流在执行。</li>
</ul>
</blockquote>
<h3 id="协程与线程的区别"><a href="#协程与线程的区别" class="headerlink" title="协程与线程的区别"></a>协程与线程的区别</h3><blockquote>
<ul>
<li>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</li>
<li>线程进程都是同步机制，而协程则是异步。</li>
<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li>
<li>线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li>
<li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</li>
<li>线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</li>
<li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
</blockquote>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><blockquote>
<p><strong>内核态</strong>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</p>
</blockquote>
<blockquote>
<p><strong>用户态</strong>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。 </p>
</blockquote>
<h3 id="为什么划分内核态、用户态？"><a href="#为什么划分内核态、用户态？" class="headerlink" title="为什么划分内核态、用户态？"></a>为什么划分内核态、用户态？</h3><blockquote>
<ul>
<li>为了保证系统的稳定性、安全性，需要在系统中划分内核态、用户态。</li>
<li>所有涉及IO操作、内存操作等，均在内核态中完成，因为当这些操作出现差错时，可能会导致整个计算机系统的崩溃。用户写的程序可能是含有导致这些操作出现差错的bug的，所以，用户编写的不涉及IO、内存等操作的程序在用户态中完成，而涉及这些操作时，则需要进行用户态到内核态的切换。将实际操作交付给内核态，内核态完成操作后，将结果传递至用户态。</li>
<li>注意，用户态、内核态之间的切换是十分耗费性能资源的。</li>
</ul>
</blockquote>
<h3 id="用户态切换到内核态"><a href="#用户态切换到内核态" class="headerlink" title="用户态切换到内核态"></a>用户态切换到内核态</h3><h4 id="外围设备的中断"><a href="#外围设备的中断" class="headerlink" title="外围设备的中断"></a>外围设备的中断</h4><blockquote>
<p>​		当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote>
<p>​		当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
<blockquote>
<p>按照中断信号来源于CPU 的外部还是内部，将中断类型分为外中断和内中断：</p>
<ul>
<li><p><strong>外中断</strong> （也称中断，狭义上的中断）</p>
<p>外中断与当前执行的指令无关， 中断信号来源于 CPU 外部。如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，CPU 能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
</li>
<li><p><strong>内中断</strong>（也称 异常、例外）</p>
<p>内中断与当前执行的指令有关， 中断信号来源于 CPU 内部。如非法操作码、地址越界、算术溢出，除数为 0 等。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/cdcdscdscdscdscsdfcfsdcfdscsdcs.png"></p>
</blockquote>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><blockquote>
<p>系统调用是通过陷入指令完成的，该指令会引发内中断。</p>
</blockquote>
<blockquote>
<p><strong>系统调用的过程</strong>简略版大致如下：</p>
<p>​	1）在用户态，应用程序传递系统调用参数</p>
<p>​	2）执行陷入指令，引发一个内中断，使 CPU 进入内核态</p>
<p>​	3）在内核态，执行相应的请求，内核程序处理系统调用</p>
<p>​	4）返回应用程序</p>
<p>思考一下<strong>为什么系统调用是必须的</strong>？</p>
<p>​		举个例子：我们去学校打印店打印论文，你按下了 WPS 的 “打印” 选项，于是打印机开始工作。 你的论文打印到一半时，另一位同学按下了 Word 的 “打印” 按钮，开始打印他自己的论文。想象一下如果两个进程可以随意的、并发的共享打印机资源，会发生什么情况？</p>
<p>​		显然，两个进程并发运行，导致打印机设备交替的收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了</p>
<p>​		如何解决这个问题？这就需要操作系统内核对共享资源进行统一的管理，并向上层提供 “系统调用” ，运行在用户态的应用程序或者进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，然后内核会对各个请求进行协调处理（进程调度）。</p>
<p>​		通过上面这个例子，我们就可以总结出什么功能会用到系统调用：<strong>凡是与共享资源有关的操作（比如内存分配、I&#x2F;O 操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出请求，由操作系统内核代为完成</strong>。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
</blockquote>
<h2 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h2><h3 id="0-什么是进程通信"><a href="#0-什么是进程通信" class="headerlink" title="0. 什么是进程通信"></a>0. 什么是进程通信</h3><blockquote>
<p><strong>进程通信</strong>：（ InterProcess Communication，IPC）就是指<strong>进程之间的信息交换</strong>。实际上，<strong>进程的同步与互斥本质上也是一种进程通信</strong>（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它<strong>缺乏传递数据的能力</strong>。</p>
<p>​		虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，<strong>进程之间需要交换大批数据</strong>，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。</p>
<p>​		再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以<strong>进程之间想要进行信息交换就必须通过内核</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102231vfdsvsdvdsvsdvsd12114.png"></p>
</blockquote>
<blockquote>
<p>下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：</p>
<ul>
<li>管道（也称作共享文件）</li>
<li>消息队列（也称作消息传递）</li>
<li>共享内存（也称作共享存储）</li>
<li>信号量和 PV 操作</li>
<li>信号</li>
<li>套接字（Socket）</li>
</ul>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><blockquote>
<p>​		各位如果学过 Linux 命令，那对管道肯定不陌生，Linux 管道使用竖线 <code>|</code> 连接多个命令，这被称为管道符。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">command1 | command2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		以上这行代码就组成了一个管道，它的功能是将前一个命令（<code>command1</code>）的输出，作为后一个命令（<code>command2</code>）的输入，从这个功能描述中，我们可以看出<strong>管道中的数据只能单向流动</strong>，也就是半双工通信，如果想实现相互通信（全双工通信），我们需要创建两个管道才行。</p>
</blockquote>
<blockquote>
<p>​		通过管道符 <code>|</code> 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，<strong>匿名管道只能用于父子进程之间的通信</strong>。</p>
</blockquote>
<blockquote>
<p>​		在 Linux 的实际编码中，是通过 <code>pipe</code> 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe (int fd[2]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数拥有一个存储空间为 2 的文件描述符数组：</p>
<ul>
<li><code>fd[0]</code> 指向管道的读端，<code>fd[1]</code> 指向管道的写端</li>
<li><code>fd[1]</code> 的输出是 <code>fd[0]</code> 的输入</li>
</ul>
</blockquote>
<blockquote>
<p>粗略的解释一下通过匿名管道实现进程间通信的步骤：</p>
<p>​		1）父进程创建两个匿名管道，管道 1（<code>fd1[0]</code>和 <code>fd1[1]</code>）和管道 2（<code>fd2[0]</code> 和 <code>fd2[1]</code>）；</p>
<blockquote>
<p>因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个。</p>
</blockquote>
<p>​		2）父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</p>
<p>​		3）父进程关闭管道 1 的读端 <code>fd1[0]</code> 和 管道 2 的写端 <code>fd2[1]</code>，子进程关闭管道 1 的写端 <code>fd1[1]</code> 和 管道 2 的读端 <code>fd2[0]</code>，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用<strong>环形队列</strong>实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314vdsfvdfsvdsfvds2402.png"></p>
<p>​		看完上面这些讲述，我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了），但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>​		简单来说，<strong>管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作</strong>。</p>
</blockquote>
<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><blockquote>
<p> ​	   匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
</blockquote>
<blockquote>
<p>​		所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。</p>
</blockquote>
<blockquote>
<p>​		使用 Linux 命令 <code>mkfifo</code> 来创建有名管道：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> myPipe</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		<code>myPipe</code> 就是这个管道的名称，接下来，我们往 myPipe 这个有名管道中写入数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		执行这行命令后，你会发现它就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个有名管道里的数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; myPipe</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><blockquote>
<p>​		可以看出，<strong>管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流</strong>。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314dvsdfvsdfvdsvdsf2747.png"></p>
<p>​		<strong>消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong>。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：</p>
<ul>
<li><p>消息队列允许一个或多个进程向它写入或读取消息。</p>
</li>
<li><p>消息队列可以实现消息的<strong>随机查询</strong>，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。</p>
</li>
<li><p>对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。</p>
</li>
<li><p>消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</p>
<p>​	需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
</li>
</ul>
</blockquote>
<h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><blockquote>
<p>​		为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。</p>
<p>​		顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将<strong>立即</strong>影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​		集合内存管理的内容，我们来深入理解下共享内存的原理。首先，每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。<strong>两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314vfdvsdvsfdvsdfvsd4949.png"></p>
<p>​		不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210223dfsvsfvsdfvsdfvsdfv142910.png"></p>
</blockquote>
<h3 id="4-信号量和-PV-操作"><a href="#4-信号量和-PV-操作" class="headerlink" title="4. 信号量和 PV 操作"></a>4. 信号量和 PV 操作</h3><blockquote>
<p>​		实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为<strong>消息队列无需避免冲突，而共享内存机制可能会发生冲突</strong>。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。</p>
<p>​		并且，在多道批处理系统中，多个进程是可以并发执行的，但由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进（异步性）。但有时候我们又希望多个进程能密切合作，按照某个特定的顺序依次执行，以实现一个共同的任务。</p>
</blockquote>
<blockquote>
<p>​		举个例子，如果有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102221vfsvfsvdsvdfvsdvfds82849.png"></p>
<p>​		因此，为了解决上述这两个问题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。</p>
</blockquote>
<blockquote>
<p>​		<strong>进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信</strong>。</p>
</blockquote>
<blockquote>
<p>​		信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
</blockquote>
<blockquote>
<p>​		用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：</p>
<p>​		1）<strong>P 操作</strong>：将信号量值减 1，表示<strong>申请占用一个资源</strong>。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。</p>
<p>​		可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。</p>
<p>​		2）<strong>V 操作</strong>：将信号量值加 1，表示<strong>释放一个资源</strong>，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。</p>
<p>​		我觉得已经讲的足够通俗了，不过对于 V 操作大家可能仍然有困惑，下面再来看两个关于 V 操作的问答：</p>
<p>​		问：<strong>信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程</strong>？</p>
<p>​		答：所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。</p>
<p>​		问：<strong>信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程</strong>？</p>
<p>​		答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。</p>
</blockquote>
<blockquote>
<p>信号量和 PV 操作具体的定义如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022cfdsvsbsvsdvfdsvsd2182011.png"></p>
</blockquote>
<h4 id="互斥访问共享内存"><a href="#互斥访问共享内存" class="headerlink" title="互斥访问共享内存"></a>互斥访问共享内存</h4><blockquote>
<p>两步走即可实现不同进程对共享内存的互斥访问：</p>
<ul>
<li>定义一个互斥信号量，并初始化为 1</li>
<li>把对共享内存的访问置于 P 操作和 V 操作之间</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022315vfdvsvdsfvsdfvds3221.png"></p>
<p>​		<strong>P 操作和 V 操作必须成对出现</strong>。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021cdfvdsvsfvsvsdfv0223153236.png"></p>
</blockquote>
<h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><blockquote>
<p>回顾一下进程同步，就是要各并发进程按要求有序地运行。</p>
<p>​		举个例子，以下两个进程 P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。假设 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022218cfdsvdsvsvsfvsfd1857.png"></p>
<p>​		如果 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
</blockquote>
<blockquote>
<p>使用信号量和 PV 操作实现进程的同步也非常方便，三步走：</p>
<ul>
<li>定义一个同步信号量，并初始化为当前可用资源的数量</li>
<li>在优先级较<strong>高</strong>的操作的<strong>后</strong>面执行 V 操作，释放资源</li>
<li>在优先级较<strong>低</strong>的操作的<strong>前</strong>面执行 P 操作，申请占用资源</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdsvsvsdfvdsvds2181925.png"></p>
<p>配合下面这张图直观理解下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdvsfdvcdsfvfdsv2171312.png"></p>
</blockquote>
<h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote>
<p>​		注意！<strong>信号和信号量是完全不同的两个概念</strong>！</p>
<p>​		信号是进程通信机制中唯一的<strong>异步</strong>通信机制，它可以在任何时候发送信号给某个进程。<strong>通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行</strong>。用户、内核和进程都能生成和发送信号。</p>
<p>​		信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；而软件来源就是通过 <code>kill</code> 系列的命令给进程发送信号，比如 <code>kill -9 1111</code> ，表示给 PID 为 1111 的进程发送 <code>SIGKILL</code> 信号，让其立即结束。我们来查看一下 Linux 中有哪些信号：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210223fdvdsvsvsvsvsvs154622.png"></p>
</blockquote>
<h3 id="6-Socket"><a href="#6-Socket" class="headerlink" title="6. Socket"></a>6. Socket</h3><blockquote>
<p>​		至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要<strong>跨网络与不同主机上的进程进行通信</strong>，那该怎么做呢？这就是 Socket 通信做的事情了（<strong>当然，Socket 也能完成同主机上的进程通信</strong>）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20201205vfdvdvdsvsdfvsdvs112439.png"></p>
<p>​		Socket 起源于 Unix，原意是<strong>插座</strong>，在计算机通信领域，Socket 被翻译为<strong>套接字</strong>，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>​		从计算机网络层面来说，<strong>Socket 套接字是网络通信的基石</strong>，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。</p>
<p>​		Socket 的本质其实是一个编程接口（API），是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它对 TCP&#x2F;IP 进行了封装。它<strong>把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面</strong>。对用户来说，只要通过一组简单的 API 就可以实现网络的连接。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022316ddvdfdvsdfvdfvfdvsdvs3258.png"></p>
</blockquote>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><blockquote>
<p>简单总结一下上面六种 Linux 内核提供的进程通信机制：</p>
<p>​		1）首先，最简单的方式就是<strong>管道</strong>，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。</p>
<p>​		2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此<strong>消息队列</strong>应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。</p>
<p>​		3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，<strong>共享内存</strong>可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​		对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p>​		4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。</p>
<p>​		5）<strong>信号</strong>和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。</p>
<p>​		6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 <strong>Socket</strong> 通信。另外，Socket 也能完成同主机上的进程通信。</p>
</blockquote>
<h2 id="作业-进程调度策略"><a href="#作业-进程调度策略" class="headerlink" title="作业&#x2F;进程调度策略"></a>作业&#x2F;进程调度策略</h2><h3 id="0-调度的概念"><a href="#0-调度的概念" class="headerlink" title="0. 调度的概念"></a>0. 调度的概念</h3><blockquote>
<p>​		当 CPU 有一堆任务要处理时，由于其资源有限，这些事情就没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是 “调度” 研究的问题。除了接下来将要说的进程调度，还有作业调度、内存调度等。</p>
<p>回顾一下进程的三态模型：</p>
<ul>
<li><strong>运行态</strong>（running）：进程占有 CPU 正在运行。</li>
<li><strong>就绪态</strong>（ready）：进程具备运行条件，等待系统分配 CPU 以便运行。</li>
<li><strong>阻塞态</strong> &#x2F; 等待态（wait）：进程不具备运行条件，正在等待某个事件的完成。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210219bgfbgdbdgbfdgbdfb154606.png"></p>
<p>​		所谓进程调度，就是<strong>从进程的就绪队列（阻塞）中按照一定的算法选择一个进程并将 CPU 分配给它运行</strong>，以实现进程的并发执行。这是操作系统中最基本（最低级）的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。</p>
</blockquote>
<h3 id="1-非抢占式进程调度算法"><a href="#1-非抢占式进程调度算法" class="headerlink" title="1. 非抢占式进程调度算法"></a>1. 非抢占式进程调度算法</h3><blockquote>
<p>所谓非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件发生而被阻塞时，才会把 CPU 让给其他进程。</p>
<p>对应的，抢占式的意思就是，当进程正在运行的时，可以被打断，把 CPU 让给其他进程。</p>
</blockquote>
<h4 id="①-先到先服务-FCFS"><a href="#①-先到先服务-FCFS" class="headerlink" title="① 先到先服务 FCFS"></a>① 先到先服务 FCFS</h4><blockquote>
<p><strong>先来先服务调度算法（First Come First Serve，FCFS）</strong>：按照进程到达的先后顺序进行调度，<strong>先到的进程就先被调度</strong>，也就是说，等待时间越久的越优先得到服务。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2020040vfvfvsdfvdsvfdsvds5165950995.png"></p>
<p>优点：公平、算法实现简单</p>
<p>缺点：对短进程不利。排在长进程后面的短进程需要等待很长时间，短进程的响应时间太长了，用户交互体验会变差。</p>
</blockquote>
<h4 id="②-最短作业优先-SJF"><a href="#②-最短作业优先-SJF" class="headerlink" title="② 最短作业优先 SJF"></a>② 最短作业优先 SJF</h4><blockquote>
<p><strong>最短作业&#x2F;进程优先调度算法（Shortest Job First，SJF）</strong>：<strong>每次调度时选择当前已到达的、且运行时间最短 的进程</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202004051710cdcsdadcsdcsd3262.png"></p>
<p>​		最短作业优先算法和先到先服务恰好相反，先到先服务对短进程不利，而最短作业优先算法对长程不利。因为如果一直有短进程到来，那么长进程永远得不到调度，长进程有可能会饿死，处于一直等待短作业执行完毕的状态。</p>
</blockquote>
<h4 id="③-高响应比优先-HRRN"><a href="#③-高响应比优先-HRRN" class="headerlink" title="③ 高响应比优先 HRRN"></a>③ 高响应比优先 HRRN</h4><blockquote>
<p><strong>高响应比优先算法（Highest Response Ratio Next，HRRN）</strong>：只有当前运行的进程主动放弃 CPU 时（正常&#x2F;异常完成，或主动阻塞），才需要进行调度，<strong>调度时计算所有就绪进程的响应比，为响应比最高的进程分配 CPU</strong>。响应比 &#x3D; (进程的等待时间 + 进程需要的运行时间) &#x2F; 进程需要的运行时间</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20200405cdcdcsdcsdcs210349993.png"></p>
</blockquote>
<h3 id="2-抢占式进程调度算法"><a href="#2-抢占式进程调度算法" class="headerlink" title="2. 抢占式进程调度算法"></a>2. 抢占式进程调度算法</h3><blockquote>
<p>​		抢占就是指当进程正在运行的时，可以被打断，把 CPU 让给其他进程。抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p>
</blockquote>
<h4 id="①-最短剩余时间优先-SRTN"><a href="#①-最短剩余时间优先-SRTN" class="headerlink" title="① 最短剩余时间优先 SRTN"></a>① 最短剩余时间优先 SRTN</h4><blockquote>
<p>最短剩余时间优先（Shortest Remaining Time Next，SRTN）算法是<strong>最短作业优先的抢占式版本</strong>。</p>
<p>​		<strong>当一个新的进程到达时，把它所需要的整个运行时间与当前进程的剩余运行时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20200405cdcdcsdcsdcs171532909.png"></p>
</blockquote>
<h4 id="②-轮转调度算法-RR"><a href="#②-轮转调度算法-RR" class="headerlink" title="② 轮转调度算法 RR"></a>② 轮转调度算法 RR</h4><blockquote>
<p><strong>轮转调度算法（Round Robin，RR）也称时间片调度算法</strong>：调度程序每次把 CPU 分配给就绪队列首进程使用规定的时间间隔，称为时间片，通常为 10ms ~ 200ms，<strong>就绪队列中的每个进程轮流地运行一个时间片，当时间片耗尽时就强迫当前运行进程让出 CPU 资源，转而排到就绪队列尾部，等待下一轮调度</strong>。所以，一个进程一般都需要多次轮转才能完成。</p>
<p>​		轮转调度算法对每个进程都一视同仁，就好比大家都排好队，一个一个来，每个人都运行一会儿再接着重新排队等待运行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdsvdfvdscscsdcs1145415.png"></p>
<p>需要注意的是：时间片的长度是一个很关键的因素：</p>
<ul>
<li>如果时间片设置得太短，就会导致频繁的进程上下文切换，降低了 CPU 效率；</li>
<li>如果时间片设置得太长，那么随着就绪队列中进程数目的增加，轮转一次消耗的总时间加长，即每隔进程的相应速度放慢。甚至时间片大到让进程足以完成其所有任务，RR 调度算法便退化成 FCFS 算法。</li>
</ul>
</blockquote>
<h3 id="3-最高优先级调度算法-HPF"><a href="#3-最高优先级调度算法-HPF" class="headerlink" title="3. 最高优先级调度算法 HPF"></a>3. 最高优先级调度算法 HPF</h3><blockquote>
<p>​		RR 调度算法对所有的进程都是相同的策略，如果用户进程太多，可能会导致内核的服务进程响应跟不上。而在操作系统中，内核进程是比用户进程重要的多的，毕竟它关乎整个系统的稳定性。</p>
</blockquote>
<blockquote>
<p>最高优先级调度算法（Highest Priority First，HPF）就是<strong>从就绪队列中选择最高优先级的进程进行运行</strong>。进程的优先级是怎么规定的呢？分为静态优先级或动态优先级：</p>
<ul>
<li><strong>静态优先级</strong>：创建进程时候，就预先规定优先级，并且整个运行过程中该进程的优先级都不会发生变化。一般来说，内核进程的优先级都是高于用户进程的。</li>
<li><strong>动态优先级</strong>：根据进程的动态变化调整优先级。比如随着进程的运行时间增加，适当的降低其优先级；随着就绪队列中进程的等待时间增加，适当的升高其优先级。</li>
</ul>
</blockquote>
<blockquote>
<p>另外，需要注意的是，最高优先级算法并非是固定的抢占式策略或非抢占式，<strong>系统可预先规定使用哪种策略</strong>：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，则运行完当前进程后，再选择该优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，则立即强制剥夺当前运行进程的 CPU 资源，分配给优先级更高的进程运行。</li>
</ul>
</blockquote>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p><strong>死锁</strong>：指的是多个进程在运行过程中因为争夺资源而造成的种僵局，当进程处于这种僵局状态时，若无外力作用，他们都将无法再向前推进的状态。</p>
</blockquote>
<h3 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h3><blockquote>
<ul>
<li><strong>互斥使用</strong>：即当资源被一个线程使用(占有)时，别的线程不能使用</li>
<li><strong>不可抢占</strong>：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li>
<li><strong>请求和保持</strong>：即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li>
<li><strong>循环等待</strong>：即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</li>
</ul>
</blockquote>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><blockquote>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请求和保持）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><blockquote>
<p><strong>银行家算法</strong>：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
</blockquote>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h5 id="银行家算法数据结构"><a href="#银行家算法数据结构" class="headerlink" title="银行家算法数据结构"></a>银行家算法数据结构</h5><blockquote>
<ul>
<li>Avaliable—可利用资源向量。这是一个含有m个元素的数组，每个元素代表一类可利用资源数目，其初值是系统中所配置的该类全部可用资源数目，其数值随该类资源的分配和回收而动态地改变。</li>
<li>Max—最大需求矩阵。这是一个m*n的矩阵，它定义了系统中n个进程中的每一个进程对n类资源的最大需求。</li>
<li>Allocation—分配矩阵。这是一个m*n的矩阵，它定义了当前系统的n个进程得到每一类资源的数目。</li>
<li>Request—请求向量。这是一个含有m个元素的向量，它表示进程i对各类资源的需求情况。</li>
<li>Need—需求矩阵。这是一个n*m的矩阵，它定义了当前系统的n个进程要想完成工作，还需要各类资源的数目。因此有以下关系：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Need[i,j] = Max[i,j]-Allocation[i,j]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="安全性算法数据结构"><a href="#安全性算法数据结构" class="headerlink" title="安全性算法数据结构"></a>安全性算法数据结构</h5><blockquote>
<ul>
<li>Work—工作向量。这是-一个含有m个元素的向量，表示系统可以提供给进程继续运行所需的各类资源数目，其初值Work&#x3D;Avaliable。</li>
<li>Finish—结束向量。表示系统是否有足够的资源分配给进程，使之运行完成。开始时Finish[i]&#x3D;false，当有足够资源分配给进Finish[j]&#x3D;ture。</li>
</ul>
</blockquote>
<h5 id="银行家算法-1"><a href="#银行家算法-1" class="headerlink" title="银行家算法"></a>银行家算法</h5><blockquote>
<p>假设进程Pi提出资源请求Request[i] &#x3D; k</p>
<ul>
<li>(1)若Request[i]&lt;&#x3D; Need[i,j]便转向执行步骤 (2)；否则认为出错。</li>
<li>(2)若Request[i]&lt;&#x3D; Available[i,j]便转 向执行步骤(3)；否则表示系统尚无足够的资源分配，让Pi等待。</li>
<li>(3)系统假设将Pi所要求的资源分配给Pi，并对数据结构做如下修改：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Avaliable[j] =Available[j] - Request[j]  </span><br><span class="line">Allocation[i,j] = Allocation[i,j] - Request[j]  </span><br><span class="line">Need[i,j] = Need[i,j]- Request[j]</span><br></pre></td></tr></table></figure>

<ul>
<li>(4)系统执行安全性算法，检测此次资源分配后，系统是否处于安全状态。若安全才正式将资源分配给进程Pi,以完成本次分配：否则，本次试探分配废，恢复原来的资源分配状态，让Pi等待。</li>
</ul>
</blockquote>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><blockquote>
<ul>
<li>(1)从进程集合中找到一个能满足一下条件的进程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Finish[i] = <span class="literal">false</span>;</span><br><span class="line">Need[i,j] &lt;= Work[j]; </span><br></pre></td></tr></table></figure>

<p>若找到执行步骤(2)否则执行步骤(3)。</p>
<ul>
<li>(2)进程Pi获得资源后，可以顺利执行，直至完成，并释放分配给它们的资源，故应执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work[i] = Work[i] +Allocation[i,j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>; </span><br></pre></td></tr></table></figure>

<p>转向执行步骤(2);</p>
<ul>
<li>(3)若所有的进程的<code>Finish[i]=true</code>都满足，则表示系统处于安全状态：否 则系统处于不安全状态。</li>
</ul>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><blockquote>
<p><strong>内存管理</strong>：操作系统对内存的划分和动态分配。</p>
</blockquote>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><blockquote>
<ul>
<li>内存空间的分配和回收：由操作系统完成对主存的分配和回收，对编程人员透明</li>
<li>地址转换：使逻辑地址转换为真实的物理地址</li>
<li>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li>
<li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li>
</ul>
</blockquote>
<h3 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h3><blockquote>
<p>源程序 -&gt; 可执行程序：</p>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421dadscdcdscdscdscdscd180308143.png"></p>
</blockquote>
<h4 id="程序链接的方式"><a href="#程序链接的方式" class="headerlink" title="程序链接的方式"></a>程序链接的方式</h4><blockquote>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及他们所需的库函数链接成一个可执行程序，此后不再拆开</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421203dsfsdfsdcsdac135471.png"></p>
<ul>
<li>装入时动态链接：编译后所得的一组目标模块在装入时，边装入边链接</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120cdscsdcdcsccs3248608.png"></p>
<ul>
<li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。便于修改和更新以及实现对目标模块的共享</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212034dscascsadcsadc35485.png"></p>
</blockquote>
<h4 id="装入内存的方式"><a href="#装入内存的方式" class="headerlink" title="装入内存的方式"></a>装入内存的方式</h4><blockquote>
<ul>
<li>绝对装入：在编译时即知道程序将装入的内存具体地址，则编译程序将产生绝对地址的目标代码。而后将程序和数据装入内存，只适用于单道程序环境</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120202sfevdsvdsvsd5892.png"></p>
<ul>
<li>可重定位装入：在多道程序环境中，多个目标模块的起始地址均为0开始。装入内存时，通过所分配的内存起始地址加上程序内的相对地址进行地址的动态变换，一次完成，又称为静态重定位。【必须一次性全部装入，运行期间不能动态扩充和移动】</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212dfvdvdfvdfvdvdfvd02117615.png"></p>
<ul>
<li>动态运行时装入：装入模块装入内存后并不立即进行地址转换，而是等到程序执行时才进行。需要重定位寄存器的支持【可以将程序分哦到不连续的存储区中，程序运行前只需要装入部分代码，运行期间根据需要动态分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间】</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120dcdscsdcsdcsdcs2516120.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212csdcscscsdcsdcs02728962.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421202csdcdscsdcsdcsdcsdcs859982.png"></p>
</blockquote>
<h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><blockquote>
<ul>
<li>逻辑地址空间：程序编译后的每个模块都是以0开始编址，称为目标模块的逻辑地址。当链接为一个完整的可执行目标程序时，链接程序将按顺序以0开始编址，构造统一的逻辑地址空间。</li>
<li>物理地址空间：内存中物理单元的集合，是地址转换的最终地址，当装入程序将可执行代码装入内存中时，必须将逻辑地址转化为物理地址。</li>
</ul>
</blockquote>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><blockquote>
<p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p>
</blockquote>
<h4 id="内存保护的两种方式"><a href="#内存保护的两种方式" class="headerlink" title="内存保护的两种方式"></a>内存保护的两种方式</h4><blockquote>
<ul>
<li>在CPU中设立一对上、下限寄存器，存放用户作业在主存中的上下限地址，每当CPU要访问一个地址时，先根据这对上下限判断是否越界访问。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212053vfdvdsfvfdsvfvdsf54626.png"></p>
<ul>
<li>采用重定位寄存器和限长寄存器来实现这种保护。重定位寄存器保存最小的物理地址，限长寄存器保存逻辑地址的最大值。进行内存访问时，先判断逻辑地址是否大于限长寄存器值，若未越界，则加上重定位寄存器的值映射成物理地址，再进行内存访问。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421cdscdscdscsdcsd205641907.png"></p>
</blockquote>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><blockquote>
<p>覆盖与交换技术是在多道程序环境下扩充内存的两种方法。</p>
</blockquote>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004dscascscsacsacscsd025985.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231csdcdscsacscsdc80820382.png"></p>
</blockquote>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020cdcsacsacsdcsdcsd0423181112552.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042318cdscsdcscsdcsd1400473.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423182csdcsdcsdcs501764.png"></p>
</blockquote>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><blockquote>
<p>连续分配:指为用户进程分配的必须是一个连续的内存空间。</p>
</blockquote>
<blockquote>
<p>包括单一连续分配、固定分区分配和动态分区分配。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231bfbfgbfgbfgbfg83108555.png"></p>
</blockquote>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231838ddfvfddfgfdgdfg33877.png"></p>
</blockquote>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423dffdgfhvsfdbfsbsdf184230246.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231846vfdvfdsvdfvdfvfd27961.png"></p>
</blockquote>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231bfgbgfbvdfvfsdvsdf8520337.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231853vfdbvfsdvsdfvvfdvdf21400.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042fbsfbfsdfvsdfvds3185404256.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423185vfdvfsvdsfvds425770.png"></p>
<p>（1）系统要用怎样的数据结构记录内存的使用情况呢？</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321042cdvfdsvdsfvfvsfvfs395.png"></p>
<p>（2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232fvfsbgfbdfvdsfvdsfvsd10641126.png"></p>
<p>（3）如何进行分区的分配和回收操作？</p>
<p><strong>如何分配？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232vdsfvfdvfvdfvdvfdsv10951871.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423211fvfdsvfsvdfvdfvdfvd031656.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423cfdvfdsbvfgbfsbfgbdf211234282.png"></p>
<p><strong>如何回收？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423211vfdvbfbgfbgdbfgbfg626193.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423vfdbfsbdgbgdbdg211751743.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2vdfvfdsvfdsbdgbfgbfgbf1954749.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042vfdvsvdfvfdvfdsvdsfv3212108969.png"></p>
</blockquote>
<h3 id="内部碎片与外部碎片"><a href="#内部碎片与外部碎片" class="headerlink" title="内部碎片与外部碎片"></a>内部碎片与外部碎片</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232vfdvfdsvfdsvfdsv12544902.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321cdfvfdvfdvfsvdfvdfvd2650781.png"></p>
</blockquote>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><blockquote>
<ul>
<li>首次适应算法：按地址升序查找</li>
<li>最佳适应算法：按容量升序查找</li>
<li>最坏适应算法：按容量降序查找</li>
<li>邻近适应算法：在按地址升序查找的前提下，查找的起点是上一次查找结束的位置</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321391cdcdacasdcdscdscs8738.png"></p>
</blockquote>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcadscdscscsadcas1452336.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321dvsdfvfdvfsdvsdf4600818.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321cdfvddscsdcsd465411.png"></p>
</blockquote>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232156cdscssasdcsdcdscd41164.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423cdcdscdscdcdscdscsd215758679.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcdcdscsdcdscdscsd1590110.png"></p>
</blockquote>
<h4 id="最坏（大）适应算法"><a href="#最坏（大）适应算法" class="headerlink" title="最坏（大）适应算法"></a>最坏（大）适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423frefrefvsfvsfdvfdsvsdf220300386.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232204vfvfdsvsdvdsfvsfvs32246.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232205cdcdscscsdcsdcds49394.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232206vfdvdsvfdsvdsfvs33433.png"></p>
</blockquote>
<h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423220cdscdscdscdascads900503.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232209cadscdsacdsacsad37204.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcdscdscdscdscds21300749.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042322cdcdscdscdscdsc1401765.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcscsadcsdcsdcs21603115.png"></p>
</blockquote>
<h4 id="四种算法归纳比较"><a href="#四种算法归纳比较" class="headerlink" title="四种算法归纳比较"></a>四种算法归纳比较</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232219cdcdascdscdsacadsc37764.png"></p>
</blockquote>
<h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><h4 id="为什么学习分页存储"><a href="#为什么学习分页存储" class="headerlink" title="为什么学习分页存储"></a>为什么学习分页存储</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050319cdcsdccsdcsdcsdcdsc1058819.png"></p>
</blockquote>
<h4 id="基本分页存储管理的思想"><a href="#基本分页存储管理的思想" class="headerlink" title="基本分页存储管理的思想"></a>基本分页存储管理的思想</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020efefwefwefwefwefwef03191933864.png"></p>
</blockquote>
<h4 id="分页存储管理的重要概念"><a href="#分页存储管理的重要概念" class="headerlink" title="分页存储管理的重要概念"></a>分页存储管理的重要概念</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503sdfsfsdfsdfsfsfdsf192356252.png"></p>
</blockquote>
<h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503192fvfdvfdvfdvfdvds553130.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050319474vdfvdfvdfvfdvfdv3868.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005fvfdvfdvfdvdfvdsf03215055931.png"></p>
</blockquote>
<h4 id="如何计算页号和页偏移量"><a href="#如何计算页号和页偏移量" class="headerlink" title="如何计算页号和页偏移量"></a>如何计算页号和页偏移量</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032cadascsadcsadcdsacadsc15344637.png"></p>
<p><strong>为什么页面大小一般设为2的整数次幂？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005vgfvfvdfvdfdfvfdvdfvdfv03215910111.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20csdcdscdscdscsdcsdcsdc200503220214800.png"></p>
</blockquote>
<h4 id="分页存储的逻辑结构"><a href="#分页存储的逻辑结构" class="headerlink" title="分页存储的逻辑结构"></a>分页存储的逻辑结构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503220cdscdscdscdscsdcsdcsd607170.png"></p>
</blockquote>
<h4 id="如何知道页面在内存中的起始地址"><a href="#如何知道页面在内存中的起始地址" class="headerlink" title="如何知道页面在内存中的起始地址"></a>如何知道页面在内存中的起始地址</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322cdscsccdscdscdscsdc0952295.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503cdcdscdscdscdscdscsd221250554.png"></p>
</blockquote>
<h4 id="分页存储管理的基本地址变换结构"><a href="#分页存储管理的基本地址变换结构" class="headerlink" title="分页存储管理的基本地址变换结构"></a>分页存储管理的基本地址变换结构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032cscscscscscscsscsc21903305.png"></p>
</blockquote>
<h5 id="页表寄存器"><a href="#页表寄存器" class="headerlink" title="页表寄存器"></a>页表寄存器</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322csdcdscdscdscdscdsc2207602.png"></p>
</blockquote>
<h5 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503223sdcdcdscdscdscdscds729773.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200csdcsdscdcsdcsdcsc503223548369.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322cdscdscsdcsdcdscds4323607.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032csacascsacascssscscs25214679.png"></p>
</blockquote>
<h5 id="对页表项大小的进一步讨论"><a href="#对页表项大小的进一步讨论" class="headerlink" title="对页表项大小的进一步讨论"></a>对页表项大小的进一步讨论</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050csdcsdcsdcdscsdcdscs3230227132.png"></p>
</blockquote>
<h4 id="快表的地址变换结构"><a href="#快表的地址变换结构" class="headerlink" title="快表的地址变换结构"></a>快表的地址变换结构</h4><h5 id="局部性原理引入快表机制"><a href="#局部性原理引入快表机制" class="headerlink" title="局部性原理引入快表机制"></a>局部性原理引入快表机制</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050cdcdscdscdcascsdcsdc5111434415.png"></p>
</blockquote>
<h5 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005051114cdsdscsdcdscsdcsdcd55765.png"></p>
</blockquote>
<h5 id="一个例图了解基于快表的地址变换结构"><a href="#一个例图了解基于快表的地址变换结构" class="headerlink" title="一个例图了解基于快表的地址变换结构"></a>一个例图了解基于快表的地址变换结构</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005051vdfvfdvfdvfdvfdv12605873.png"></p>
<p><strong>引入快表后，地址变换的过程的文字描述：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005csdcsccsdcdscsdc05114142450.png"></p>
</blockquote>
<h4 id="基本地址变换与快表地址变换的比较"><a href="#基本地址变换与快表地址变换的比较" class="headerlink" title="基本地址变换与快表地址变换的比较"></a>基本地址变换与快表地址变换的比较</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200505scsdcdscdscsdcdsc11441885.png"></p>
</blockquote>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><h5 id="为什么引入二级页表"><a href="#为什么引入二级页表" class="headerlink" title="为什么引入二级页表"></a>为什么引入二级页表</h5><blockquote>
<p><strong>因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051252cdscdscdscdscsdcdsc43303.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202csdcdscdscdscdscds00505125432184.png"></p>
<p><strong>上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202csdccsdcdscdscdscdscsd00505125857508.png"></p>
</blockquote>
<h5 id="二级页表的原理和地址结构"><a href="#二级页表的原理和地址结构" class="headerlink" title="二级页表的原理和地址结构"></a>二级页表的原理和地址结构</h5><blockquote>
<ul>
<li>对页表再次分组</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051csdcdscdscscsdcds31124485.png"></p>
<ul>
<li>二级页表的地址结构及对应关系</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020scdcsdcsdcdscdscdscdsc0505131519939.png"></p>
</blockquote>
<h5 id="如何实现二级页表的地址变换"><a href="#如何实现二级页表的地址变换" class="headerlink" title="如何实现二级页表的地址变换"></a>如何实现二级页表的地址变换</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdscsdcdscdscdscsdcs05133306791.png"></p>
<p><strong>上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051csdcsdcsdcsdcdscdscdsc34203409.png"></p>
</blockquote>
<h5 id="几个小细节"><a href="#几个小细节" class="headerlink" title="几个小细节"></a>几个小细节</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200505csdcdscdscdscsdcds144046207.png"></p>
</blockquote>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071333531csdcsdcsdcsdcdscsdcds33.png"></p>
</blockquote>
<h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071425cssdcdscdscdscdscdsc04777.png"></p>
<p><strong>分段的逻辑地址结构</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcdscdscdscds43112191.png"></p>
</blockquote>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050714cdscdscdscsdcdscsdcds3835462.png"></p>
</blockquote>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507144csdcsdcdscsdcsdcds037443.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscsdcdscd07144834316.png"></p>
</blockquote>
<h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050sacscascsacasc7145814456.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcdscdscdsc51524501.png"></p>
</blockquote>
<h4 id="分段实现信息共享共享"><a href="#分段实现信息共享共享" class="headerlink" title="分段实现信息共享共享"></a>分段实现信息共享共享</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507150csdcsdcdscdscdscdsc216415.png"></p>
</blockquote>
<h4 id="为什么分页不方便实现信息共享和保护"><a href="#为什么分页不方便实现信息共享和保护" class="headerlink" title="为什么分页不方便实现信息共享和保护"></a>为什么分页不方便实现信息共享和保护</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050715125fbfbfbfgbgfbfgbgf4763.png"></p>
</blockquote>
<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507scdcdscdscdscdscdsc154258573.png"></p>
</blockquote>
<h4 id="分页、分段的优缺点分析"><a href="#分页、分段的优缺点分析" class="headerlink" title="分页、分段的优缺点分析"></a>分页、分段的优缺点分析</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050715cdcsdcsdcsdcsdcdscds3829103.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005scdfvfdvfdvfdvfdvdv07153921773.png"></p>
</blockquote>
<h4 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段+分页&#x3D;段页式管理"></a>分段+分页&#x3D;段页式管理</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200cddscdscdscsdcdscsdc507154133960.png"></p>
<p><strong>段页式管理的逻辑地址结构</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071547cdcsdcdscdscsdcdscsdcsd55703.png"></p>
<p><strong>段页式存储的段表、页表</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071fdvfdvfdvfdvdfvfdv60703773.png"></p>
</blockquote>
<h4 id="段页式管理的地址转换过程"><a href="#段页式管理的地址转换过程" class="headerlink" title="段页式管理的地址转换过程"></a>段页式管理的地址转换过程</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071612cdscddscsdcdscdscdsc08162.png"></p>
</blockquote>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><h4 id="传统存储管理的特征、缺点"><a href="#传统存储管理的特征、缺点" class="headerlink" title="传统存储管理的特征、缺点"></a>传统存储管理的特征、缺点</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071cdcscdscdscsdcdsc75726392.png"></p>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507cdscscscsdcsdcsdcds180621142.png"></p>
</blockquote>
<h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcsdcsdcdscdscsdcdsc07180934242.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200csdcdscdscsdcsdc507181109721.png"></p>
</blockquote>
<h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507cdscdcdscsdcds181418228.png"></p>
</blockquote>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><h4 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507182cdscsdcsdcdscdscds75041.png"></p>
</blockquote>
<h4 id="页表机制—请求页表与基本页表的区别"><a href="#页表机制—请求页表与基本页表的区别" class="headerlink" title="页表机制—请求页表与基本页表的区别"></a>页表机制—请求页表与基本页表的区别</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscdscsdcdscsdcdsc07183231700.png"></p>
</blockquote>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050718csdcscscsdcdscsdc5201230.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscdscdscdscdscds7184941487.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcsdcdscsdcsdc85905607.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcdscdscsdcdscdscd9010754.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005cdscdscdscdscdscds07220913997.png"></p>
</blockquote>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507csdcssdcdscsdcsdcs221140511.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005vdvdfvfdvfdvfdvfdvd0722145316.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005072cdscdscdscsdcdscsdcsdcds22657919.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcscsdcdscsdcsdc7222739960.png"></p>
</blockquote>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508154300ascsdcdscdscsdcdsc75.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020dscscdscdscsdcsdcdscds0508164532762.png"></p>
</blockquote>
<h4 id="最佳置换算法—OPT"><a href="#最佳置换算法—OPT" class="headerlink" title="最佳置换算法—OPT"></a>最佳置换算法—OPT</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200cdscdscsdcdscsdcdsc508154738464.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005sdcdscdscdscdscdscsdc08155059159.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508155cdscdscdscdscdscsdcds134553.png"></p>
</blockquote>
<h4 id="先进先出置换算法—FIFO"><a href="#先进先出置换算法—FIFO" class="headerlink" title="先进先出置换算法—FIFO"></a>先进先出置换算法—FIFO</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081csdcdscdscdscds55429175.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscsdcsdcdscds08155751826.png"></p>
</blockquote>
<h4 id="最近最久未使用置换算法—LRU"><a href="#最近最久未使用置换算法—LRU" class="headerlink" title="最近最久未使用置换算法—LRU"></a>最近最久未使用置换算法—LRU</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508160sdcdscdscsdcsdcdscds546901.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcdscdscdscsdcds8160702605.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcdscsdcdscsdcsdc160751452.png"></p>
</blockquote>
<h4 id="时钟置换算法—CLOCK"><a href="#时钟置换算法—CLOCK" class="headerlink" title="时钟置换算法—CLOCK"></a>时钟置换算法—CLOCK</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcsdcsdcsdacdssdc161527270.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081csdcscsdcsdcdscdsc61856209.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcdscdscdscsdc8162122576.png"></p>
</blockquote>
<h4 id="改造型时钟置换算法"><a href="#改造型时钟置换算法" class="headerlink" title="改造型时钟置换算法"></a>改造型时钟置换算法</h4><blockquote>
<p><strong>只需一轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200csdcsdcdscsdcsd508163111666.png"></p>
<p><strong>需要两轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508sdcsdcsdcdscsdcds163620613.png"></p>
<p><strong>需要三轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005cascsdcdasvcdfsvvfdsvsdcds08163834664.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcsdcsdcsdcds164014937.png"></p>
<p><strong>需要四轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcsdcsdsdcsdcdsc8164118342.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdscdscscsdcdscsdcsd8164207831.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050816cdscssdcdscdscdsc4330498.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508164sdcdscsdcdscsdcsdc453588.png"></p>
</blockquote>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cdscsdcdscdscsdcds0109170.png"></p>
</blockquote>
<h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508xdscsdcsdcdscsdcdscsdcs171207873.png"></p>
</blockquote>
<h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817csdcdscdscdscsdcsd1838609.png"></p>
<p><strong>固定分配局部置换、可变分配局部置换、可变分配全局置换</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817285dcdscdcdscsdcdscds5194.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscdscdscsdcdscsdcs8172936378.png"></p>
</blockquote>
<h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817csdcscsdcdscdscdsc3243782.png"></p>
</blockquote>
<h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cdscdscdscdscds3648546.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscscscdscdscdscsdcd8173856601.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081739424bfgbfgbgfvdfvfdvsdf34.png"></p>
</blockquote>
<h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cascscavdfsvfdsbgbfbfd4328925.png"></p>
</blockquote>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081746csdbnhfbgdvfbnbfvdfbgnbfvfbg21232.png"></p>
</blockquote>
<h2 id="进程切换为什么比线程切换慢"><a href="#进程切换为什么比线程切换慢" class="headerlink" title="进程切换为什么比线程切换慢"></a>进程切换为什么比线程切换慢</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><blockquote>
<p>​		在进入文题之前，我想有必要解释下虚拟地址（逻辑地址）和物理地址的区别</p>
<p>​		下面这段 C 代码摘录自《操作系统导论 -  [美] 雷姆兹·H.阿帕希杜塞尔》，依次打印出 main 函数的地址，由 malloc（类似于 Java 中的 new 操作）返回的堆空间分配的值，以及栈上一个整数的地址：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051cascsdcscsdcdscdscvfdvfdv3130338.png"></p>
<p>得到以下输出：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051313cdscscsdcdscdscdsc0523.png"></p>
<p>​		我们需要知道的是，<strong>所有这些打印出来的地址都是虚拟的</strong>，在物理内存中这些地址并不真实存在，它们最终都将由操作系统和 CPU 硬件翻译成真正的物理地址，然后才能从真实的物理位置获取该地址的值。</p>
</blockquote>
<h3 id="物理寻址-Physical-Addressing"><a href="#物理寻址-Physical-Addressing" class="headerlink" title="物理寻址 Physical Addressing"></a>物理寻址 Physical Addressing</h3><blockquote>
<p>​		计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。比如说，第一个字节的物理地址是 0，接下来的字节地址是 1，再下一个是 2，以此类推，给定这种简单的结构，CPU 访问内存的最自然的方式就是使用这样的物理地址。我们把这种方式称为<strong>物理寻址</strong>（physical  addressing）。</p>
<p>​		举个例子，比如说当程序执行了一条加载指令，指令内容是从物理地址 4 中读取 4 字节字传送到某个寄存器中。</p>
<p>​		物理寻址过程如下：当 CPU 执行到这条指令时，会生成物理地址 4，然后通过内存主线，把它传递给内存，内存取出从物理地址 4 处开始的 4 字节字，并将它返回给 CPU，CPU 会将它存放到指定的寄存器中。看下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051dcdscdscdscdscds2224824.png"></p>
<p>​		其实不难发现，物理寻址这种方式，<strong>每一个程序都直接访问物理内存</strong>，其实是存在重大缺陷的：</p>
<p>1）首先，用户程序可以寻址内存的任意一个字节，它们就可以<strong>很容易地破坏操作系统</strong>，从而使系统慢慢地停止运行。</p>
<p>2）再次，<strong>这种寻址方式使得操作系统中同时运行两个或以上的程序几乎是不可能的</strong>。</p>
<p>​		举个例子，我们打开了三个相同的程序（计算器），都执行到某一步。比方说，用户在这三个计算器程序的界面上分别输入了 10、100、1000，其对应的指令就是把用户输入的数字保存在内存中的某个地址中。如果这个位置只能保存一个数，那应该保存哪个呢？这不就冲突了吗？</p>
<p>​		简单来说，第一个计算器程序给物理内存地址赋值 10，第二个计算器程序也同样给这个地址赋值为 100，那么第二个程序的赋值会覆盖掉第一个程序所赋的值，这会造成两个程序同时崩溃。</p>
<p>​		最简单的方法就是：首先，<strong>将空闲的进程存储在磁盘上，这样当它们不运行时就不会占用内存</strong>，然后，让一个程序（或者说进程）单独占用全部内存运行一小段时间，当发生上下文切换的时候，就停止这个进程，并将它所有的状态信息保存在磁盘上，再加载其他进程的状态信息，然后运行一段时间…… 只要在某一个时间内存中只有一个程序，那么就不会发生上述所说的地址冲突。这就实现了一种<strong>比较粗糙的并发</strong>。</p>
<p>​		为什么说他是粗糙的呢，因为这种方法有一个问题：<strong>将全部的内存信息保存到磁盘太慢了</strong>！特别是当内存增长的时候。</p>
<p>​		因此，我们考虑<strong>把进程对应的内存一直留在物理内存中，给每个进程分别划分各自的区域，在发生上下文切换的时候就切换到特定的区域</strong>。</p>
<p>​		如下图所示，有 3 个进程（A、B、C），每个进程拥有从 512KB 物理内存中切出来给它们的一小部分内存，可以理解为这 3 个进程共享物理内存：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051cdsvdbnhgfbdfvbgnhjmghfgbdfv3110350.png"></p>
<p>​		那么如何对每个进程使用的地址进行<strong>保护</strong>（protection）呢？继续使用物理内存模型肯定是不行了，因此操作系统创造了一个新的内存抽象，引入了一个新的内存模型，那就是<strong>虚拟地址空间</strong>，很多书中都会直接称呼为 “地址空间（Address Space）”。</p>
</blockquote>
<h3 id="虚拟寻址-Virtual-Addressing"><a href="#虚拟寻址-Virtual-Addressing" class="headerlink" title="虚拟寻址 Virtual Addressing"></a>虚拟寻址 Virtual Addressing</h3><blockquote>
<p>​		操作系统会给每个进程分配一个<strong>虚拟地址空间</strong>（vitural address），每个进程包含的栈、堆、代码段这些都会从这个地址空间中被分配一个地址，这个地址就被称为<strong>虚拟地址</strong>。底层指令写入的地址也是虚拟地址。</p>
<p>​		<strong>每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间</strong>。（注意这句话非常重要！！！兄弟姐妹们背起来）也就是说一个进程中的虚拟地址 28 所对应的物理地址与另一个进程中的虚拟地址 28 所对应的物理地址是不同的，这样就不会发生冲突了。</p>
<p>​		有了虚拟地址空间后，CPU 就可以通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前会先被转换成合适的物理地址，这个虚拟地址到物理地址的转换过程称为 <strong>地址翻译&#x2F;地址转换</strong>（address translation）。</p>
<p>​		地址翻译需要 CPU 硬件和操作系统的密切合作：CPU 上的<strong>内存管理单元</strong>（Memory Management Unit，<strong>MMU</strong>）就是专门用来进行虚拟地址到物理地址的转换的，不过 MMU 需要借助存放在内存中的<strong>页表</strong>，而这张表的内容正是由操作系统进行管理的。</p>
<p>​		页表是一个十分重要的数据结构！</p>
<p>​		操作系统为每个进程建立了一张页表。一个进程对应一张页表，进程的每个页面对应一个页表项，每个页表项由页号和块号（页框号）组成，记录着进程页面和实际存放的内存块之间的映射关系。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20210521csdcdscdcscdscdsc213621.png"></p>
<p>​		从数学角度来说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p>
<p>​		至此，上述这一套 CPU 生成虚拟地址并进行地址翻译的流程就是<strong>虚拟寻址</strong>（virtual addressing）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20210cascascdsdcsdccsdcsdcsd513124736.png"></p>
</blockquote>
<h3 id="进程切换为什么比线程切换慢-1"><a href="#进程切换为什么比线程切换慢-1" class="headerlink" title="进程切换为什么比线程切换慢"></a>进程切换为什么比线程切换慢</h3><blockquote>
<p>​		每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间，<strong>进程切换会涉及到虚拟地址空间的切换，而这正是导致进程切换比线程切换慢的原因所在</strong>！</p>
<p>​		每次访问内存，都需要进行虚拟地址到物理地址的转换，对吧，因此，每条指令进行一两次或更多地去访问页表是必要的，而页表又是存在于内存中的。</p>
<p>​		显然，访问页表（内存）次数太多导致其成为了操作系统地一个性能瓶颈，我们得想个法子解决它，于是，转换检测缓冲区（Translation Lookaside Buffer，<strong>TLB</strong>）应运而生，也称为<strong>快表</strong></p>
<p>​		为啥说他快呢？因为 TLB 通常内置在 CPU 的 MMU 中，这访问速度跟内存不是一个档次的。内存中的页表一般被称为<strong>慢表</strong>。</p>
<p>​		事实上，TLB 的出现是基于这样一种现象的：大多数程序总是对少量的页面进行多次的访问。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。TLB 中存放的就是那些会被反复读取的页表项。换句话说，TLB 中存放的就是页表中的一部分副本。<strong>若 TLB 命中，就不需要再访问内存了</strong>；若 TLB 中没有目标页表项，则还需要去查询内存中的页表（慢表），从页表中得到物理页框地址，同时将页表中的该表项添加到 TLB 中。</p>
<blockquote>
<p>简单理解，TLB 就相当于一个缓存</p>
</blockquote>
<p>​		由于进程切换会涉及到虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。</p>
<p>​		而线程切换呢，由于不涉及虚拟地址空间的切换，也就不存在这个问题了。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn">初学者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://www.wyy-blog.cn/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wyy-blog.cn" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/gdfgsfgsfhsdgdsbfsbfgbsf.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img12/ChMkJ1bKzZOIarWZAA1JqwXnLT0AALJCQBfVkcADUnD166.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/11/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="Linux操作系统"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/ChMkJ1bKzZSIIs6lABaR-QrYQkAAALJCQCh1KQAFpIR208.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux操作系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初学者</div><div class="author-info__description">虽千万人，吾往矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">操作系统的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程、线程、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">进程特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">进程组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">PCB</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">进程的三态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">进程的五态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">进程的七态模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">线程状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">进程与线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">协程与线程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">用户态和内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%92%E5%88%86%E5%86%85%E6%A0%B8%E6%80%81%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么划分内核态、用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">用户态切换到内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">外围设备的中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-number">1.3.</span> <span class="toc-text">进程通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">0. 什么是进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%A1%E9%81%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">1. 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">匿名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">有名管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">2. 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">3. 共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C-PV-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.</span> <span class="toc-text">4. 信号量和 PV 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">互斥访问共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">实现进程同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.6.</span> <span class="toc-text">5. 信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Socket"><span class="toc-number">1.3.7.</span> <span class="toc-text">6. Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.8.</span> <span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.</span> <span class="toc-text">作业&#x2F;进程调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">0. 调度的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">1. 非抢占式进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">① 先到先服务 FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">② 最短作业优先 SJF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">③ 高响应比优先 HRRN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">2. 抢占式进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-SRTN"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">① 最短剩余时间优先 SRTN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-RR"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">② 轮转调度算法 RR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-HPF"><span class="toc-number">1.4.4.</span> <span class="toc-text">3. 最高优先级调度算法 HPF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">死锁的4个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">银行家算法数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">安全性算法数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-1"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">安全性算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">内存管理的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E5%85%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">程序的链接和装入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">程序链接的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">装入内存的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.3.</span> <span class="toc-text">逻辑地址空间与物理地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.6.4.</span> <span class="toc-text">内存保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">内存保护的两种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.6.5.</span> <span class="toc-text">覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8E%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">1.6.7.</span> <span class="toc-text">内部碎片与外部碎片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.</span> <span class="toc-text">动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%EF%BC%88%E5%A4%A7%EF%BC%89%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">最坏（大）适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.4.</span> <span class="toc-text">临近适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.8.5.</span> <span class="toc-text">四种算法归纳比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.9.</span> <span class="toc-text">分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">为什么学习分页存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">基本分页存储管理的思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">分页存储管理的重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.9.4.</span> <span class="toc-text">如何实现地址的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E9%A1%B5%E5%8F%B7%E5%92%8C%E9%A1%B5%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.6.9.5.</span> <span class="toc-text">如何计算页号和页偏移量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.9.6.</span> <span class="toc-text">分页存储的逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.9.7.</span> <span class="toc-text">如何知道页面在内存中的起始地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.9.8.</span> <span class="toc-text">分页存储管理的基本地址变换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.9.8.1.</span> <span class="toc-text">页表寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.9.8.2.</span> <span class="toc-text">地址变换过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.6.9.8.3.</span> <span class="toc-text">对页表项大小的进一步讨论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.9.9.</span> <span class="toc-text">快表的地址变换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.9.9.1.</span> <span class="toc-text">局部性原理引入快表机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89"><span class="toc-number">1.6.9.9.2.</span> <span class="toc-text">快表（TLB）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%9B%BE%E4%BA%86%E8%A7%A3%E5%9F%BA%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.9.9.3.</span> <span class="toc-text">一个例图了解基于快表的地址变换结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%BF%AB%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.9.10.</span> <span class="toc-text">基本地址变换与快表地址变换的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.6.9.11.</span> <span class="toc-text">二级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.6.9.11.1.</span> <span class="toc-text">为什么引入二级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.9.11.2.</span> <span class="toc-text">二级页表的原理和地址结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.6.9.11.3.</span> <span class="toc-text">如何实现二级页表的地址变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="toc-number">1.6.9.11.4.</span> <span class="toc-text">几个小细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.10.</span> <span class="toc-text">分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%AE%B5"><span class="toc-number">1.6.10.1.</span> <span class="toc-text">什么是分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">1.6.10.2.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.6.10.3.</span> <span class="toc-text">地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.10.4.</span> <span class="toc-text">分段、分页管理的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB%E5%85%B1%E4%BA%AB"><span class="toc-number">1.6.10.5.</span> <span class="toc-text">分段实现信息共享共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E9%A1%B5%E4%B8%8D%E6%96%B9%E4%BE%BF%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.6.10.6.</span> <span class="toc-text">为什么分页不方便实现信息共享和保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.11.</span> <span class="toc-text">页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E3%80%81%E5%88%86%E6%AE%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.6.11.1.</span> <span class="toc-text">分页、分段的优缺点分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.11.2.</span> <span class="toc-text">分段+分页&#x3D;段页式管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.11.3.</span> <span class="toc-text">段页式管理的地址转换过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.7.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">传统存储管理的特征、缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">虚拟内存的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">如何实现虚拟内存技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">知识总览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6%E2%80%94%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">页表机制—请求页表与基本页表的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">缺页中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">思维导图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E2%80%94OPT"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">最佳置换算法—OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E2%80%94FIFO"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">先进先出置换算法—FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E2%80%94LRU"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">最近最久未使用置换算法—LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E2%80%94CLOCK"><span class="toc-number">1.7.3.5.</span> <span class="toc-text">时钟置换算法—CLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E9%80%A0%E5%9E%8B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.6.</span> <span class="toc-text">改造型时钟置换算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.4.</span> <span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">驻留集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">页面分配、置换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">何时调入页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E9%A1%B5"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">从何处调页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">抖动（颠簸）现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">1.7.4.6.</span> <span class="toc-text">工作集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%85%A2"><span class="toc-number">1.8.</span> <span class="toc-text">进程切换为什么比线程切换慢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AF%BB%E5%9D%80-Physical-Addressing"><span class="toc-number">1.8.2.</span> <span class="toc-text">物理寻址 Physical Addressing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80-Virtual-Addressing"><span class="toc-number">1.8.3.</span> <span class="toc-text">虚拟寻址 Virtual Addressing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%85%A2-1"><span class="toc-number">1.8.4.</span> <span class="toc-text">进程切换为什么比线程切换慢</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/Lua%E5%9F%BA%E7%A1%80/" title="Lua基础"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua基础"/></a><div class="content"><a class="title" href="/2023/12/18/Lua%E5%9F%BA%E7%A1%80/" title="Lua基础">Lua基础</a><time datetime="2023-12-18T14:10:20.000Z" title="发表于 2023-12-18 22:10:20">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/C++%E5%9F%BA%E7%A1%80/" title="C++基础"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++基础"/></a><div class="content"><a class="title" href="/2023/12/18/C++%E5%9F%BA%E7%A1%80/" title="C++基础">C++基础</a><time datetime="2023-12-18T13:50:33.000Z" title="发表于 2023-12-18 21:50:33">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="发表于 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="发表于 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="发表于 2022-01-13 20:15:31">2022-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 初学者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>