<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>并发编程 | Blog</title><meta name="author" content="初学者"><meta name="copyright" content="初学者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录多线程相关知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程">
<meta property="og:url" content="http://example.com/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="记录多线程相关知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/tyjukitlikyudtys9865.jpg">
<meta property="article:published_time" content="2021-12-06T13:23:10.000Z">
<meta property="article:modified_time" content="2022-08-01T03:46:50.125Z">
<meta property="article:author" content="初学者">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/tyjukitlikyudtys9865.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-01 11:46:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/tyjukitlikyudtys9865.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-06T13:23:10.000Z" title="发表于 2021-12-06 21:23:10">2021-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-01T03:46:50.125Z" title="更新于 2022-08-01 11:46:50">2022-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴传智播客并发编程资料与<a target="_blank" rel="noopener" href="https://pdai.tech/%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9">https://pdai.tech/网站内容</a></p>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p>　　我们都知道计算机的核心是<code>CPU</code>，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。</p>
<p>　　<strong>进程是一个具有一定独立功能的程序，在一个数据集上的一次动态执行的过程</strong>，是表示资源分配的基本单位，又是调度运行的基本单位，是应用程序运行的载体。进程一般由<strong>程序，数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志</p>
</blockquote>
<blockquote>
<p><strong>进程具有的特征：</strong></p>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进行一起并发执行；</li>
<li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序，数据和进程控制块三部分组成</li>
</ul>
</blockquote>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><h5 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h5><p>按进程在执行过程中的不同情况至少要定义三种状态：</p>
<ul>
<li><p><strong>运行（<code>running</code>）态：</strong>进程占有处理器正在运行的状态。</p>
<blockquote>
<p>​	进程已获得<code>CPU</code>，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</p>
</blockquote>
</li>
<li><p><strong>就绪（<code>ready</code>）态：</strong>进程具备运行条件，等待系统分配处理器以便运行的状态。</p>
<blockquote>
<p>​	当进程已分配到除<code>CPU</code>以外的所有必要资源后，只要再获得<code>CPU</code>，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
</blockquote>
</li>
<li><p><strong>阻塞（<code>Blocked</code>）态：</strong>指进程不具备运行条件，正在等待某个时间完成的状态。</p>
<blockquote>
<p>​	也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/AryWDI.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>就绪态—→运行态：<code>CPU</code> 空闲时选择一个就绪进程。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h5><p>五态模型在三态模型的基础上增加了新建态（<code>new</code>）和终止态（<code>exit</code>）。</p>
<ul>
<li><p><strong>新建态：</strong>对应于进程被创建时的状态，尚未进入就绪队列。</p>
<blockquote>
<p>创建一个进程需要通过两个步骤：</p>
<p>​	1.为新进程分配所需要资源和建立必要的管理信息。</p>
<p>​	2.设置该进程为就绪态，并等待被调度执行。</p>
</blockquote>
</li>
<li><p><strong>终止态：</strong>指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。</p>
<blockquote>
<p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。</p>
<p>终止一个进程需要两个步骤：</p>
<p>​	1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。</p>
<p>​	2.然后回收占用的资源并被系统删除。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Aryfbt.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>NULL→新建态：执行一个程序，创建一个子进程。</p>
<p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
<p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>终止态→NULL：完成善后操作。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的七态模型"><a href="#进程的七态模型" class="headerlink" title="进程的七态模型"></a>进程的七态模型</h5><blockquote>
<p>​	三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（<code>suspend</code>），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。</p>
</blockquote>
<blockquote>
<p>引起进程挂起的原因是多样的，主要有：</p>
<ul>
<li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。 </li>
<li>父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 </li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 </li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 </li>
<li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</li>
</ul>
</blockquote>
<blockquote>
<p>七态模型在五态模型的基础上增加了挂起就绪态（<code>ready suspend</code>）和挂起等待态（<code>blocked suspend</code>）。</p>
<ul>
<li>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。</li>
<li>挂起等待态：表明进程正在等待某一个事件发生且在外存中。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Ary4VP.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下:</p>
<blockquote>
<p>等待态→挂起等待态：操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</p>
<p>挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态</p>
<p>挂起就绪态→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</p>
<p>就绪态→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</p>
<p>挂起等待态→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>运行态→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 <code>CPU</code>，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</p>
<p>新建态→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>​	挂起进程等同于不在内存中的进程，因此挂起进程将不参与低级调度直到它们被调换进内存。</p>
<p>挂起进程具有如下特征：</p>
<ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。 （等待事件结束后进程变为挂起就绪态）</li>
<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>
</ul>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p>​	它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</blockquote>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><h5 id="线程状态之五种状态"><a href="#线程状态之五种状态" class="headerlink" title="线程状态之五种状态"></a>线程状态之五种状态</h5><blockquote>
<p>从操作系统角度：线程的状态一共可以描述为五种：初始态，可运行，运行态，阻塞态，终止态。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583507073055.png"></p>
<ol>
<li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联；</li>
<li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待<code>CPU</code>给它分配时间片就可运行；</li>
<li>运行状态，指线程获取了<code>CPU</code>时间片，正在运行<ol>
<li>当<code>CPU</code>时间片用完，线程会转换至【可运行状态】，等待<code>CPU</code>再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ol>
</li>
<li>阻塞状态<ol>
<li>如果调用了阻塞<code>API</code>，如<code>BIO</code>读写文件，那么线程实际上不会用到<code>CPU</code>，不会分配<code>CPU</code>时间片，会导致上下文切换，进入【阻塞状态】</li>
<li>等待<code>BIO</code>操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，<code>CPU</code>就一直不会分配时间片</li>
</ol>
</li>
<li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ol>
</blockquote>
<h5 id="线程状态之六种状态"><a href="#线程状态之六种状态" class="headerlink" title="线程状态之六种状态"></a>线程状态之六种状态</h5><blockquote>
<p>从<code>Java</code>线程角度：线程的状态一共可以描述为六种：初始态，运行态，阻塞态，等待态、超时等待态、终止态。</p>
<ol>
<li>**初始(<code>NEW</code>)**：新创建了一个线程对象，但还没有调用<code>start()</code>方法。</li>
<li>**运行(<code>RUNNABLE</code>)**：Java线程中将就绪（<code>ready</code>）和运行中（<code>running</code>）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如<code>main</code>线程）调用了该对象的<code>start()</code>方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取<code>CPU</code>的使用权，此时处于就绪状态（<code>ready</code>）。就绪状态的线程在获得<code>CPU</code>时间片后变为运行中状态（<code>running</code>）。</li>
<li>**阻塞(<code>BLOCKED</code>)**：表示线程阻塞于锁。</li>
<li>**等待(<code>WAITING</code>)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>**超时等待(<code>TIMED_WAITING</code>)**：该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li>
<li>**终止(<code>TERMINATE</code>D)**：表示该线程已经执行完毕。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2018070117435683.png"></p>
</blockquote>
<p><strong>假设有线程 Thread t</strong></p>
<h6 id="NEW-RUNNABLE"><a href="#NEW-RUNNABLE" class="headerlink" title="NEW &lt;–&gt; RUNNABLE"></a>NEW &lt;–&gt; RUNNABLE</h6><blockquote>
<p><code>t.start()</code>方法时, <code>NEW --&gt; RUNNABLE</code></p>
</blockquote>
<h6 id="RUNNABLE-WAITING"><a href="#RUNNABLE-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<p>线程用<code>synchronized(obj)</code>获取了对象锁后</p>
<ol>
<li>调用<code>obj.wait()</code>方法时，<code>t</code> 线程从<code>RUNNABLE --&gt; WAITING</code></li>
<li>调用<code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ol>
<li>竞争锁成功，<code>t</code> 线程从<code>WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code> 线程从<code>WAITING --&gt; BLOCKED</code></li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="RUNNABLE-WAITING-1"><a href="#RUNNABLE-WAITING-1" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-WAITING-2"><a href="#RUNNABLE-WAITING-2" class="headerlink" title="RUNNABLE &lt;–&gt; WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 &#96;&#96;RUNNABLE –&gt; WAITING<code>注意是当前线程在</code>t&#96; 线程对象的监视器上等待</li>
<li><code>t</code> 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING"><a href="#RUNNABLE-TIMED-WAITING" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<p><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p>
<ol>
<li>调用 <code>obj.wait(long n)</code> 方法时，<code>t </code>线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li><code>t</code> 线程等待时间超过了 <code>n</code> 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时,唤醒的线程都到**<code>entrySet</code>**阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列，和其他线程再进行 <strong>竞争锁</strong><ol>
<li>竞争锁成功，<code>t</code> 线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code> 线程从 <code>TIMED_WAITING --&gt; BLOCKED</code></li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-1"><a href="#RUNNABLE-TIMED-WAITING-1" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code><br>注意是当前线程在t 线程对象的监视器上等待</li>
<li>当前线程等待时间超过了 <code>n</code> 毫秒，或 <code>t</code> 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从<br><code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-2"><a href="#RUNNABLE-TIMED-WAITING-2" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a><code>RUNNABLE</code> &lt;–&gt; <code>TIMED_WAITING</code></h6><blockquote>
<ol>
<li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>当前线程等待时间超过了 <code>n</code> 毫秒或调用了线程 的 <code>interrupt()</code> ，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-TIMED-WAITING-3"><a href="#RUNNABLE-TIMED-WAITING-3" class="headerlink" title="RUNNABLE &lt;–&gt; TIMED_WAITING"></a>RUNNABLE &lt;–&gt; TIMED_WAITING</h6><blockquote>
<ol>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线<br>程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从<br><code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ol>
</blockquote>
<h6 id="RUNNABLE-BLOCKED"><a href="#RUNNABLE-BLOCKED" class="headerlink" title="RUNNABLE &lt;–&gt; BLOCKED"></a><code>RUNNABLE &lt;–&gt; BLOCKED</code></h6><blockquote>
<p><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE –&gt; BLOCKED</code>, 持 <code>obj</code> 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 <code>t</code> 线程竞争 成功，从 <code>BLOCKED –&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></p>
</blockquote>
<h6 id="RUNNABLE-TERMINATED"><a href="#RUNNABLE-TERMINATED" class="headerlink" title="RUNNABLE &lt;–&gt; TERMINATED"></a><code>RUNNABLE</code> &lt;–&gt; <code>TERMINATED</code></h6><blockquote>
<p>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></p>
</blockquote>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><blockquote>
<ul>
<li>线程是进程的一部分</li>
<li>一个线程只能属于一个进程，而一个进程至少有一个线程</li>
</ul>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote>
<p>​	理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）</p>
<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p><strong>开销方面：</strong>每个进程都有独立的代码和数据空间（程序上下文），进程之间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小</p>
<p><strong>所处环境：</strong>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行</p>
<p><strong>内存分配：</strong>系统为每个进程分配不同的内存空间；而对线程而言，除了<code>CPU</code>外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>
<p><strong>包含关系：</strong>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>
</blockquote>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote>
<p>​	<strong>并发（<code>Concurrent</code>），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</strong></p>
<p>​	并发不是真正意义上的“同时进行”，只是<code>CPU</code>把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于<code>CPU</code>处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。如：打游戏和听音乐两件事情在<strong>同一个时间段内</strong>都是在同一台电脑上完成了<strong>从开始到结束的动作</strong>。那么，就可以说听音乐和打游戏是并发的。</p>
</blockquote>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><blockquote>
<p>​	<strong>并行（<code>Parallel</code>），当系统有一个以上<code>CPU</code>时，当一个<code>CPU</code>执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占<code>CPU</code>资源，可以同时进行，这种方式我们称之为并行(<code>Parallel</code>)。</strong></p>
<p>​	<strong>其实决定并行的因素不是<code>CPU</code>的数量，而是<code>CPU</code>的核心数量，比如一个<code>CPU</code>多个核也可以并行。</strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1628624-20190505161932608-1136050215.jpg"></p>
<h3 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h3><blockquote>
<ul>
<li><p><strong>并发：</strong>指的是多个事情，在同一时间段内同时发生了。 </p>
</li>
<li><p><strong>并行：</strong>指的是多个事情，在同一时间点上同时发生了。</p>
</li>
<li><p>并发的多个任务之间是互相抢占资源的。 </p>
</li>
<li><p>并行的多个任务之间是不互相抢占资源的</p>
</li>
</ul>
<p>只有在多<code>CPU</code>或者一个<code>CPU</code>多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
</blockquote>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><blockquote>
<p>​	<code>Java</code>使用<code>Thread</code>类代表线程，所有的线程对象都必须是<code>Thread</code>类或其子类的实例。<code>Java</code>可以用四种方式来创建线程，如下所示：</p>
<p>​	1）继承<code>Thread</code>类创建线程</p>
<p>​	2）实现<code>Runnable</code>接口创建线程</p>
<p>​	3）使用<code>Callable</code>和<code>Future</code>创建线程</p>
<p>​	4）使用线程池例如用<code>Executor</code>框架</p>
</blockquote>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><code>Thread</code></h3><blockquote>
<ul>
<li>定义<code>Thread</code>类的子类，并重写该类的<code>run()</code>方法，该方法的方法体就是线程需要完成的任务，<code>run()</code>方法也称为线程执行体；</li>
<li>创建<code>Thread</code>子类的实例，也就是创建了线程对象；</li>
<li>启动线程，即调用线程的<code>start()</code>方法；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a><code>Runnable</code></h3><blockquote>
<ul>
<li><p>定义<code>Runnable</code>接口的实现类，一样要重写<code>run()</code>方法，这个<code>run（）</code>方法和<code>Thread</code>中的<code>run()</code>方法一样是线程的执行体；</p>
</li>
<li><p>创建<code>Runnable</code>实现类的实例，并用这个实例作为<code>Thread</code>的<code>target</code>来创建<code>Thread</code>对象，这个<code>Thread</code>对象才是真正的线程对象；</p>
</li>
<li><p>第三部依然是通过调用线程对象的<code>start()</code>方法来启动线程；</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t1&quot;</span>).start();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">          log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">      thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="Callable-Future"><a href="#Callable-Future" class="headerlink" title="Callable + Future"></a><code>Callable + Future</code></h3><h4 id="Callable和Runnable不同点："><a href="#Callable和Runnable不同点：" class="headerlink" title="Callable和Runnable不同点："></a><code>Callable</code>和<code>Runnable</code>不同点：</h4><blockquote>
<ul>
<li><p><code>Callable</code>规定的方法是<code>call()</code>，而<code>Runnable</code>规定的方法是<code>run()</code>.</p>
</li>
<li><p><code>Callable</code>的任务执行后可返回值，而<code>Runnable</code>的任务是不能返回值的。</p>
</li>
<li><p><code>call()</code>方法可抛出异常，而<code>run()</code>方法是不能抛出异常的。</p>
</li>
<li><p>运行<code>Callable</code>任务可拿到一个<code>Future</code>对象，<code>Future</code>表示异步计算的结果。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>创建<code>Callable</code>接口的实现类，并实现<code>call()方</code>法，然后创建该实现类的实例；</p>
</li>
<li><p>使用<code>FutureTask</code>类来包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了<code>Callable</code>对象的<code>call()</code>方法的返回值；</p>
</li>
<li><p>使用<code>FutureTask</code>对象作为<code>Thread</code>对象的<code>target</code>创建并启动线程（因为<code>FutureTask</code>实现了<code>Runnable</code>接口）；</p>
</li>
<li><p>调用<code>FutureTask</code>对象的<code>get()</code>方法来获得子线程执行结束后的返回值；</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, futureTask.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;创建线程了！！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, futureTask.get());</span><br></pre></td></tr></table></figure>

<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（<code>Thread Context Switch</code>）</h3><blockquote>
<p>因为以下一些原因导致 <code>cpu</code> 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 <code>cpu</code> 时间片用完(每个线程轮流执行，看前面并行的概念)</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>​	当 <code>Context Switch</code> 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，<code>Java</code> 中对应的概念就是程序计数器（<code>Program Counter Register</code>），它的作用是记住下一条 <code>jvm</code> 指令的执行地址，是线程私有的</p>
</blockquote>
<h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center"><code>static</code></th>
<th align="center">功能说明</th>
<th align="center">注意</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>start()</code></td>
<td align="center"></td>
<td align="center">启动一个新线程，在新的线程运行run方法中的代码</td>
<td align="center"><code>start</code>方法只是让线程进入就绪，里面代码不一定立刻运行(<code>CPU</code>的时间片还没分给它)。每个线程对象的<code>start</code>方法只能调用一次 ,如果调用了多次会出现<code>IllegalThreadStateException</code></td>
</tr>
<tr>
<td align="center"><code>run()</code></td>
<td align="center"></td>
<td align="center">新线程启动后会调用的方法</td>
<td align="center">如果在构造<code>Thread</code>对象时传递了<code>Runnable</code>参数，则线程启动后会调用<code>Runnable</code>中的<code>run</code>方法，否则默认不执行任何操作。但可以创建<code>Thread</code>的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td align="center"><code>join()</code></td>
<td align="center"></td>
<td align="center">等待线程运行结束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>join(long n)</code></td>
<td align="center"></td>
<td align="center">等待线程运行结束，最多等待 <code>n</code> 毫秒</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>getId()</code></td>
<td align="center"></td>
<td align="center">获取线程长整型的<code>id</code></td>
<td align="center"><code>id</code> 唯一</td>
</tr>
<tr>
<td align="center"><code>getName()</code></td>
<td align="center"></td>
<td align="center">获取线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>setNmae(String)</code></td>
<td align="center"></td>
<td align="center">修改线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>getPriority()</code></td>
<td align="center"></td>
<td align="center">获取线程优先级</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>setPriority()</code></td>
<td align="center"></td>
<td align="center">修改线程优先级</td>
<td align="center"><code>java</code>中规定线程优先级是<code>1-10</code>的整数,较大的优先级能提高该线程被<code>CPU</code>调度的几率</td>
</tr>
<tr>
<td align="center"><code>getState()</code></td>
<td align="center"></td>
<td align="center">获取线程状态</td>
<td align="center"><code>Java</code>中线程状态是用<code>6</code>个<code>enum</code>表示，分别为:<code>NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</code></td>
</tr>
<tr>
<td align="center"><code>isInterrupted()</code></td>
<td align="center"></td>
<td align="center">判断是否被打断</td>
<td align="center">不会清除<code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>isAlive()</code></td>
<td align="center"></td>
<td align="center">线程是否存活(还没有运行完毕)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>interrupt()</code></td>
<td align="center"></td>
<td align="center">打断线程</td>
<td align="center">如果被打断线程正在<code>sleep，wait，join</code>会导致被打断的线程抛出<code>InterruptedException</code>，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记; <code>park</code>的线程被打断，也会设置 <code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>interrupted()</code></td>
<td align="center"><code>static</code></td>
<td align="center">判断当前线程是否被打断</td>
<td align="center">会清除<code>打断标记</code></td>
</tr>
<tr>
<td align="center"><code>currentThread()</code></td>
<td align="center"><code>static</code></td>
<td align="center">获取当前正在执行的线程</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a><code>start</code> 与 <code>run</code></h4><h5 id="调用start"><a href="#调用start" class="headerlink" title="调用start"></a>调用<code>start</code></h5><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          log.debug(<span class="string">&quot;我是一个新建的线程正在运行中&quot;</span>);</span><br><span class="line">          FileReader.read(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">&quot;新建线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出：程序在 <code>t1</code> 线程运行， <code>run()</code>方法里面内容的调用是异步的 <code>Test4.java</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">11</span>:<span class="string">59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...</span></span><br><span class="line"><span class="attr">11</span>:<span class="string">59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms</span></span><br></pre></td></tr></table></figure>

<h5 id="调用run"><a href="#调用run" class="headerlink" title="调用run"></a>调用<code>run</code></h5><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>输出结果如下：程序仍在 <code>main </code>线程运行，<code>run()</code>方法里面内容的调用还是同步的</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">12</span>:<span class="string">03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.727 [main] DEBUG com.concurrent.test.FileReader - read [test] start ...</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.729 [main] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 2 ms</span></span><br><span class="line"><span class="attr">12</span>:<span class="string">03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程</span></span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程<br>使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p>
</blockquote>
<h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a><code>sleep</code> 与 <code>yield</code></h4><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a><code>sleep</code></h5><blockquote>
<ol>
<li>调用 <code>sleep</code> 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>
<li>其它线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li>
<li>睡眠结束后的线程未必会立刻得到执行(需要分配到<code>cpu</code>时间片)</li>
<li>建议用 <code>TimeUnit</code> 的 <code>sleep()</code> 代替 <code>Thread</code> 的 <code>sleep()</code>来获得更好的可读性</li>
</ol>
</blockquote>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a><code>yield</code></h5><blockquote>
<ol>
<li>调用 <code>yield</code> 会让当前线程从 <code>Running</code> 进入 <code>Runnable</code> 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了<code>yield</code>方法，但是也没有用)</li>
</ol>
</blockquote>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><blockquote>
<p>​	<code>yield</code>使<code>cpu</code>调用其它线程，但是<code>cpu</code>可能会再分配时间片给该线程；而<code>sleep</code>需要等过了休眠时间之后才有可能被分配<code>cpu</code>时间片</p>
</blockquote>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程的优先级属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程所能拥有的最大优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程默认的优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程所能拥有的最大优先级.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h4><p>在主线程中调用<code>t1.join</code>，则主线程会等待<code>t1</code>线程执行完之后再继续执行 <code>Test10.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583483843354.png"></p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><code>interrupt</code></h4><p> <code>sleep，wait，join</code> 的线程，这几个方法都会让线程进入阻塞状态，以 <code>sleep</code> 为例<code>Test7.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;线程任务执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                log.debug(<span class="string">&quot;被打断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;111是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;222是否被打断？&#123;&#125;&quot;</span>,t1.isInterrupted());</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	输出结果：（我下面将中断和打断两个词混用）可以看到，打断 <code>sleep</code> 的线程, 会清空中断状态，刚被中断完之后<code>t1.isInterrupted()</code>的值为<code>true</code>，后来变为<code>false</code>，即中断状态会被清除。那么线程是否被中断过可以通过异常来判断。【同时要注意如果打断被<code>join()</code>，<code>wait()</code> <code>blocked</code>的线程也是一样会被清除，被清除(<code>interrupt status will be cleared</code>)的意思即中断状态设置为<code>false</code>，被设置(<code>interrupt status will be set</code>)的意思就是中断状态设置为<code>true</code>】</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">17</span>:<span class="string">06:11.890 [Thread-0] DEBUG com.concurrent.test.Test7 - 线程任务执行</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.387 [main] DEBUG com.concurrent.test.Test7 - 111是否被打断？false</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.390 [Thread-0] DEBUG com.concurrent.test.Test7 - 被打断</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.390 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？true</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？false</span></span><br><span class="line"><span class="attr">17</span>:<span class="string">06:12.890 [main] DEBUG com.concurrent.test.Test7 - 主线程</span></span><br></pre></td></tr></table></figure>

<h4 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h4><p>​	打断正常运行的线程, 线程并不会暂停，只是调用方法<code>Thread.currentThread().isInterrupted();</code>的返回值为<code>true</code>，可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO bat.Main - interrupt</span><br><span class="line">[t1] INFO bat.Main - 被打断了, 退出循环</span><br></pre></td></tr></table></figure>

<h4 id="终止模式之两阶段终止模式"><a href="#终止模式之两阶段终止模式" class="headerlink" title="终止模式之两阶段终止模式"></a>终止模式之两阶段终止模式</h4><blockquote>
<p>​	<code>Two Phase Termination</code>，就是考虑在一个线程<code>T1</code>中如何优雅地终止另一个线程<code>T2</code>？这里的优雅指的是给<code>T2</code>一个料理后事的机会（如释放锁）。</p>
<p>​	如下所示：那么线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为<code>false</code>，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。处理好这两种情况那我们就可以放心地来料理后事啦！</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583496991915.png"></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoParseTermination</span> <span class="variable">twoParseTermination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoParseTermination</span>();</span><br><span class="line">        twoParseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);  <span class="comment">// 让监控线程执行一会儿</span></span><br><span class="line">        twoParseTermination.stop(); <span class="comment">// 停止监控线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoParseTermination</span>&#123;</span><br><span class="line">    Thread thread ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程结束。。正在料理后事中&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行监控的功能&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a><code>sleep，yiled，wait，join</code> 对比</h4><blockquote>
<ol>
<li><p><code>sleep，join，yield，interrupted</code>是<code>Thread</code>类中的方法</p>
</li>
<li><p><code>wait/notify</code>是<code>object</code>中的方法</p>
<p><code>sleep</code> 不释放锁、释放<code>cpu</code></p>
<p><code>join</code> 释放锁、抢占<code>cpu</code></p>
<p><code>yiled</code> 不释放锁、释放<code>cpu</code></p>
<p><code>wait</code> 释放锁、释放<code>cpu</code></p>
</li>
</ol>
</blockquote>
<h4 id="park与unpark"><a href="#park与unpark" class="headerlink" title="park与unpark"></a><code>park</code>与<code>unpark</code></h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><blockquote>
<p>它们是 <code>LockSupport</code> 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="park与unpark-原理"><a href="#park与unpark-原理" class="headerlink" title="park与unpark 原理"></a><code>park</code>与<code>unpark</code> 原理</h5><blockquote>
<p>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成 <code>_counter</code>， <code>_cond</code>和 <code>_mutex</code></p>
<ol>
<li>打个比喻线程就像一个旅人，<code>Parker</code> 就像他随身携带的背包，条件变量 <code>_cond</code>就好比背包中的帐篷。<code>_counter</code> 就好比背包中的备用干粮（<code>0</code> 为耗尽，<code>1</code> 为充足）</li>
<li>调用 <code>park</code> 就是要看需不需要停下来歇息<ol>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ol>
</li>
<li>调用 <code>unpark</code>，就好比令干粮充足<ol>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 <code>park</code> 时，仅是消耗掉备用干粮，不需停留继续前进<ol>
<li>因为背包空间有限，多次调用 <code>unpark</code> 仅会补充一份备用干粮</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h6 id="先调用park再调用unpark的过程"><a href="#先调用park再调用unpark的过程" class="headerlink" title="先调用park再调用unpark的过程"></a>先调用<code>park</code>再调用<code>unpark</code>的过程</h6><blockquote>
<p><strong>一、先调用<code>park</code></strong></p>
<ol>
<li><p>当前线程调用 <code>Unsafe.park()</code> 方法</p>
</li>
<li><p>检查 <code>_counter</code> ，本情况为 <code>0</code>，这时，获得 <code>_mutex</code> 互斥锁(<code>mutex</code>对象有个等待队列 <code>_cond</code>)</p>
</li>
<li><p>线程进入 <code>_cond</code> 条件变量阻塞</p>
</li>
<li><p>设置 <code>_counter = 0</code></p>
</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594531894163.png"></p>
<blockquote>
<p><strong>二、调用<code>unpark</code></strong></p>
<p>​    1. 调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 <code>1</code></p>
<p>​    2. 唤醒 <code>_cond</code> 条件变量中的 <code>Thread_0</code></p>
<p>​    3. <code>Thread_0</code> 恢复运行</p>
<p>​    4. 设置 <code>_counter</code> 为 <code>0</code></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594532057205.png"></p>
<h6 id="先调用unpark再调用park的过程"><a href="#先调用unpark再调用park的过程" class="headerlink" title="先调用unpark再调用park的过程"></a>先调用<code>unpark</code>再调用<code>park</code>的过程</h6><blockquote>
<ol>
<li>调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 <code>1</code></li>
<li>当前线程调用 <code>Unsafe.park()</code> 方法</li>
<li>检查 <code>_counter</code> ，本情况为 <code>1</code>，这时线程无需阻塞，继续运行</li>
<li>设置 <code>_counter</code> 为 <code>0</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1594532135616.png"></p>
<h4 id="wait与notify-属于重量级锁的方法"><a href="#wait与notify-属于重量级锁的方法" class="headerlink" title="wait与notify(属于重量级锁的方法)"></a><code>wait</code>与<code>notify</code>(属于重量级锁的方法)</h4><blockquote>
<p> <img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220084652893.png"></p>
<p>​	当线程<code>0</code>获得到了锁, 成为<code>Monitor</code>的<code>Owner</code>, 但是此时它发现自己想要执行<code>synchroized</code>代码块的条件不满足; 此时它就调用<code>obj.wait</code>方法, 进入到<code>Monitor</code>中的<code>WaitSet</code>集合, 此时线程<code>0</code>的状态就变为<code>WAITING</code><br>​	处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为阻塞状态，<code>CPU</code>都不会分给他们时间片。但是有所区别：<br>​		<code>BLOCKED</code>状态的线程是在竞争锁对象时，发现<code>Monitor</code>的<code>Owner</code>已经是别的线程了，此时就会进入<code>EntryList</code>中，并处于<code>BLOCKED</code>状态<br>​		<code>WAITING</code>状态的线程是获得了对象的锁，但是自身的原因无法执行<code>synchroized</code>的临界区资源需要进入阻塞状态时，锁对象调用了<code>wait</code>方法而进入了<code>WaitSet</code>中，处于<code>WAITING</code>状态<br>​	<strong>处于<code>BLOCKED</code>状态的线程会在锁被释放的时候被唤醒</strong><br>​	<strong>处于<code>WAITING</code>状态的线程只有被锁对象调用了<code>notify</code>方法<code>(obj.notify/obj.notifyAll)</code>，才会被唤醒。然后它会进入到<code>EntryList</code>, 重新竞争锁 (此时就将锁升级为重量级锁)</strong></p>
</blockquote>
<h5 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a><code>API</code>介绍</h5><blockquote>
<p>下面的三个方法都是<code>Object</code>中的方法; 通过锁对象来调用</p>
<p>​	<code>wait()</code>: 让获得对象锁的线程到<code>waitSet</code>中一直等待</p>
<p>​	<code>wait(long n)</code> : 当该等待线程没有被<code>notify</code>, 等待时间到了之后, 也会自动唤醒</p>
<p>​	<code>notify()</code>: 让获得对象锁的线程, 使用锁对象调用<code>notify</code>去<code>waitSet</code>的等待线程中挑一个唤醒</p>
<p>​	<code>notifyAll()</code> : 让获得对象锁的线程, 使用锁对象调用<code>notifyAll</code>去唤醒<code>waitSet</code>中所有的等待线程</p>
<p>​	它们都是线程之间进行协作的手段, 都属于<code>Object</code>对象的方法, 必须获得此对象的锁, 才能调用这些方法</p>
</blockquote>
<p><strong>注：只有当对象被锁以后(成为<code>Owner</code>)，才能调用<code>wait</code>和<code>notify</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//只有在对象被锁住后才能调用wait方法</span></span><br><span class="line">		<span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">			LOCK.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>演示<code>wait和notify</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 只有获得锁对象之后, 才能调用wait/notify</span></span><br><span class="line">                    obj.wait(); <span class="comment">// 此时t1线程进入WaitSet等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// 此时t2线程进入WaitSet等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;其它代码...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程等两秒在执行,为了`唤醒`,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;唤醒waitSet中的线程!&quot;</span>);</span><br><span class="line">        <span class="comment">// 只有获得锁对象之后, 才能调用wait/notify</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// obj.notify(); // 唤醒waitset中的一个线程</span></span><br><span class="line">             obj.notifyAll(); <span class="comment">// 唤醒waitset中的全部等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">36.176</span> guizy.WaitNotifyTest [t1] - 执行...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">36.178</span> guizy.WaitNotifyTest [t2] - 执行...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [main] - 唤醒waitSet中的线程!</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [t2] - 其它代码...</span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">37.175</span> guizy.WaitNotifyTest [t1] - 其它代码...</span><br></pre></td></tr></table></figure>

<h5 id="sleep-long-n-和-wait-long-n-的区别-重点"><a href="#sleep-long-n-和-wait-long-n-的区别-重点" class="headerlink" title="sleep(long n) 和 wait(long n)的区别 (重点)"></a><code>sleep(long n)</code> 和 <code>wait(long n)</code>的区别 <code>(重点)</code></h5><blockquote>
<p><strong>不同点:</strong></p>
<p>​	<code>sleep</code>是<code>Thread</code>类的静态方法，<code>wait</code>是<code>Object</code>的方法，<code>Object</code>又是所有类的父类，所以所有类都有<code>Wait</code>方法。<br>​	<code>sleep</code>在阻塞的时候不会释放锁，而<code>wait</code>在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)<br>​	<code>sleep</code>方法不需要与<code>synchronized</code>一起使用，而<code>wait</code>方法需要与<code>synchronized</code>一起使用（<code>wait/notify</code>等方法, 必须要使用对象锁来调用）<br><strong>相同点:</strong></p>
<p>​	阻塞状态都为<code>TIMED_WAITING</code> (限时等待)</p>
</blockquote>
<p><strong><code>sleep</code>方法 &#x2F; <code>wait</code>方法 测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 测试sleep不释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SleepTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得锁了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的</span></span><br><span class="line">                    lock.wait(<span class="number">5000</span>); <span class="comment">// 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程睡一秒</span></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获得锁了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep打印结果 : 表明在sleep期间, 锁是不会被释放的</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220094013513.png"></p>
<p>wait打印结果 : 当调用wait方法后, 锁就会被立刻释放</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220094129242.png"></p>
<h5 id="wait-notify的正确使用"><a href="#wait-notify的正确使用" class="headerlink" title="wait/notify的正确使用"></a><code>wait/notify</code>的正确使用</h5><h6 id="Step-1-逐渐向下优化"><a href="#Step-1-逐渐向下优化" class="headerlink" title="Step 1 : 逐渐向下优化"></a><strong>Step 1 : 逐渐向下优化</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//思考下面的解决方案好不好，为什么？</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    Sleeper.sleep(<span class="number">2</span>);   <span class="comment">// 会阻塞2s, 不会释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 此时没有加锁, 所以会优先于其他人先执行</span></span><br><span class="line">            <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="comment">//synchronized (room) &#123; // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..</span></span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不给<code>送烟线程加synchronized</code>输出情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">32.311</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">32.318</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">33.318</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [小南] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.320</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.321</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">34.321</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<ul>
<li>给<code>送烟线程加synchronized</code>输出情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">57.565</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">57.570</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.574</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.574</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.575</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">59.576</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220101906421.png"></p>
<h6 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a><strong>Step2:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 小南进入等待状态了, 其他线程就可以获得锁了</span></span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                room.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.840</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">51.847</span> guizy.WaitNotifyTest [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.847</span> guizy.WaitNotifyTest [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.847</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">52.848</span> guizy.WaitNotifyTest [小南] - 可以开始干活了</span><br></pre></td></tr></table></figure>

<p>如果此时除了小南在等待唤醒, 还有一个线程也在等待唤醒呢? 此时的<code>notify</code>方法会唤醒谁呢?</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220110553609.png"></p>
<h6 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a><strong>Step3:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.516</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">39.521</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">40.521</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">10</span>:<span class="number">40.521</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br></pre></td></tr></table></figure>

<p>问题: 当外卖送到了, 却唤醒了<code>小南</code>, 此时就出现了问题</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220111243224.png"></p>
<h6 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a><strong>Step4:</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">	 hasTakeout = <span class="literal">true</span>;</span><br><span class="line">	 log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">	 room.notifyAll();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.670</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">53.676</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.674</span> guizy.WaitNotifyTest [小女] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">14</span>:<span class="number">54.675</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br></pre></td></tr></table></figure>

<p>还是唤醒了小南, 小南还是回去看看送来的是外卖还是烟. 很麻烦, 怎么解决?</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201220111655619.png"></p>
<h6 id="Step5"><a href="#Step5" class="headerlink" title="Step5:"></a><strong>Step5:</strong></h6><ul>
<li>使用<code>while循环</code>来解决<code>虚假唤醒</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotifyTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait(); <span class="comment">// 此时进入到waitset等待集合, 同时会释放锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.275</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.282</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.282</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">25.283</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.287</span> guizy.WaitNotifyTest [小女] - 可以开始干活了</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">26.288</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为改为<code>while</code>如果唤醒之后, 就在<code>while</code>循环中执行了, 不会跑到<code>while</code>外面去执行”有烟没…”, 此时小南就不需要每次<code>notify</code>, 就去看是不是送来的烟, 如果是烟, <code>while</code>就为<code>false</code>了.</p>
</blockquote>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><h3 id="线程出现问题的根本原因分析"><a href="#线程出现问题的根本原因分析" class="headerlink" title="线程出现问题的根本原因分析"></a>线程出现问题的根本原因分析</h3><blockquote>
<p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面举一个例子 <code>Test13.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">               count--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.join();</span><br><span class="line">       t2.join();</span><br><span class="line">       log.debug(<span class="string">&quot;count的值是&#123;&#125;&quot;</span>,count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从字节码的层面进行分析：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br><span class="line">    </span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到<code>count++</code> 和 <code>count--</code> 操作实际都是需要这个<code>4</code>个指令完成的，那么这里问题就来了！<code>Java</code> 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569253392.png"></p>
<blockquote>
<p>如果代码是正常按顺序运行的，那么<code>count</code>的值不会计算错</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569326977.png"></p>
<blockquote>
<p>出现负数的情况：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569380639.png"></p>
<blockquote>
<p>出现正数的情况：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583569416016.png"></p>
<h3 id="问题的进一步描述"><a href="#问题的进一步描述" class="headerlink" title="问题的进一步描述"></a>问题的进一步描述</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><blockquote>
<ol>
<li><p>一个程序运行多线程本身是没有问题的</p>
</li>
<li><p>问题出现在多个线程共享资源的时候</p>
<ol>
<li>多个线程同时对共享资源进行读操作本身也没有问题</li>
<li>问题出现在对对共享资源同时进行读写操作时就有问题了</li>
</ol>
</li>
<li><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区，如：</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h4><blockquote>
<p>​	多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件</p>
</blockquote>
<h3 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a><code>synchronized</code> 解决方案</h3><blockquote>
<p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p>
<ul>
<li>阻塞式解决方案：<code>synchronized</code> ，<code>Lock</code></li>
<li>非阻塞式解决方案：原子变量</li>
</ul>
</blockquote>
<h4 id="synchronized加锁方式"><a href="#synchronized加锁方式" class="headerlink" title="synchronized加锁方式"></a><code>synchronized</code>加锁方式</h4><h5 id="修饰普通方法（锁住的是当前实例对象）"><a href="#修饰普通方法（锁住的是当前实例对象）" class="headerlink" title="修饰普通方法（锁住的是当前实例对象）"></a>修饰普通方法（锁住的是当前实例对象）</h5><blockquote>
<ul>
<li>同一个实例调用会阻塞</li>
<li>不同实例调用不会阻塞</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">   <span class="comment">//锁住了本类的实例对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test1 进入了同步方法&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test1 休眠结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test1();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test1();</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步代码块传参this（锁住的是当前实例对象）"><a href="#同步代码块传参this（锁住的是当前实例对象）" class="headerlink" title="同步代码块传参this（锁住的是当前实例对象）"></a>同步代码块传参<code>this</code>（锁住的是当前实例对象）</h5><blockquote>
<ul>
<li>同一个实例调用会阻塞</li>
<li>不同实例调用不会阻塞</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">   <span class="comment">//锁住了本类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test2 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test2 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test2();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test2();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步代码块传参变量对象-（锁住的是变量对象）"><a href="#同步代码块传参变量对象-（锁住的是变量对象）" class="headerlink" title="同步代码块传参变量对象 （锁住的是变量对象）"></a>同步代码块传参变量对象 （锁住的是变量对象）</h5><blockquote>
<ul>
<li>同一个属性对象才会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> Integer lockObject;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(Integer lockObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockObject = lockObject;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//锁住了实例中的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test3 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test3 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test3();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test3();</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	同一个实例对象的成员属性肯定是同一个，此处列举的是不同实例的情况，但是 依旧实现了同步，原因如下：</p>
<p>​	<code>Integer</code>存在静态缓存，范围是<code>-128 ~ 127</code>，当使用<code>Integer A = 127</code> 或者 <code>Integer A = Integer.valueOf(127)</code> 这样的形式，都是从此缓存拿。如果使用 <code>Integer A = new Integer(127)</code>，每次都是一个新的对象。此例中，两个对象实例的成员变量 <code>lockObject</code> 其实是同一个对象，因此实现了同步。还有字符串常量池也要注意。所以此处关注是，同步代码块传参的对象是否是同一个。这跟第二个方式其实是同一种。</p>
</blockquote>
<h5 id="同步代码块传参class对象（全局锁）"><a href="#同步代码块传参class对象（全局锁）" class="headerlink" title="同步代码块传参class对象（全局锁）"></a>同步代码块传参class对象（全局锁）</h5><blockquote>
<ul>
<li>所有调用该方法的线程都会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//全局锁，类是全局唯一的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test4 进入了同步块&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                logger.info(Thread.currentThread().getName() + <span class="string">&quot; test4 休眠结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test4();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test4();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰静态方法（全局锁）"><a href="#修饰静态方法（全局锁）" class="headerlink" title="修饰静态方法（全局锁）"></a>修饰静态方法（全局锁）</h5><blockquote>
<ul>
<li>所有调用该方法的线程都会实现同步</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//全局锁，静态方法全局唯一的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test5 进入同步方法&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test5 休眠结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            st2.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">&quot; test 准备进入&quot;</span>);</span><br><span class="line">            SynchronizedTest.test5();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a><code>Java</code>对象内存布局</h2><blockquote>
<p><code>HotSpot</code>虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（<code>Header</code>）、实例数据（<code>Instance Data</code>）和对齐填充（<code>Padding</code>）。</p>
</blockquote>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote>
<p><code>java</code>的对象头由以下三部分组成：</p>
<ul>
<li><code>Mark Word</code> </li>
<li>指向类的指针</li>
<li>数组长度（只有数组对象才有）</li>
</ul>
</blockquote>
<h4 id="32位的虚拟机"><a href="#32位的虚拟机" class="headerlink" title="32位的虚拟机"></a><code>32</code>位的虚拟机</h4><h5 id="普通对象的对象头"><a href="#普通对象的对象头" class="headerlink" title="普通对象的对象头"></a>普通对象的对象头</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                     Object <span class="title function_">Header</span> <span class="params">(<span class="number">64</span> bits)</span>                  |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|        Mark <span class="title function_">Word</span> <span class="params">(<span class="number">32</span> bits)</span>         |    Klass <span class="title function_">Word</span> <span class="params">(<span class="number">32</span> bits)</span> |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure>

<h5 id="数组对象的对象头"><a href="#数组对象的对象头" class="headerlink" title="数组对象的对象头"></a>数组对象的对象头</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-----------------------------------------------------------------|</span><br><span class="line">|                       Object <span class="title function_">Header</span> <span class="params">(<span class="number">96</span> bits)</span>                   |</span><br><span class="line">|-----------------------|--------------------|--------------------|</span><br><span class="line">|    Mark <span class="title function_">Word</span><span class="params">(32bits)</span>  | Klass <span class="title function_">Word</span><span class="params">(32bits)</span> |array <span class="title function_">length</span><span class="params">(32bits)</span>|</span><br><span class="line">|----------------- -----|--------------------|--------------------|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="32位虚拟机详情"><a href="#32位虚拟机详情" class="headerlink" title="32位虚拟机详情"></a><code>32</code>位虚拟机详情<img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/KLLTKNY3CW9T7YPF9NX3%7BCK.png"></h5><h4 id="64位虚拟机详情"><a href="#64位虚拟机详情" class="headerlink" title="64位虚拟机详情"></a><code>64</code>位虚拟机详情</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/79O0H$36]$4HIW%60%60Q~Y2HE0.png"></p>
<h4 id="下面以32位虚拟机为例"><a href="#下面以32位虚拟机为例" class="headerlink" title="下面以32位虚拟机为例"></a>下面以<code>32</code>位虚拟机为例</h4><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a><code>Mark Word</code></h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/91Y8W[0~8FMG3E_$G$_3P%J.png"></p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><code>Monitor</code></h2><blockquote>
<p><code>Monitor</code> 被翻译为监视器或管程</p>
</blockquote>
<h4 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a><code>Monitor</code>原理</h4><blockquote>
<p>​	每个 <code>Java</code> 对象都可以关联一个 <code>Monitor</code> 对象， 如果使用 <code>synchronized</code> 给对象上锁（重量级）之后，该对象头的 <code>Mark Word</code> 中就被设置指向 <code>Monitor</code> 对象的指针</p>
</blockquote>
<blockquote>
<p>下图原理解释:</p>
<ul>
<li>当<code>Thread1</code>访问到<code>synchronized(obj)</code>中的共享资源的时候</li>
<li>首先会将<code>synchronized</code>中的锁对象中对象头的<code>MarkWord</code>去尝试指向操作系统的<code>Monitor</code>对象, 让锁对象中的<code>MarkWord</code>和<code>Monitor</code>对象相关联, 如果关联成功, 将<code>obj</code>对象头中的<code>MarkWord</code>的对象状态从<code>01</code>改为<code>10</code>。</li>
<li>因为<code>Monitor</code>没有和其他的<code>obj</code>的<code>MarkWord</code>相关联, 所以<code>Thread1</code>就成为了该<code>Monitor</code>的<code>Owner</code>(所有者)。</li>
<li>又来了个<code>Thread1</code>执行<code>synchronized(obj)</code>代码, 它首先会看看能不能执行该临界区的代码; 它会检查<code>obj</code>是否关联了<code>Montior</code>, 此时已经有关联了, 它就会去看看该<code>Montior</code>有没有所有者(<code>Owner</code>), 发现有所有者了(<code>Thread2</code>); <code>Thread1</code>也会和该<code>Monitor</code>关联, 该线程就会进入到它的<code>EntryList</code>(阻塞队列);</li>
<li>当<code>Thread2</code>执行完临界区代码后, <code>Monitor</code>的<code>Owner</code>(所有者)就空出来了. 此时就会通知<code>Monitor</code>中的<code>EntryList</code>阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201219192811839.png"></li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/98c3189e41fd654fe34ead273ec76eba.png"></p>
</blockquote>
<blockquote>
<ul>
<li>刚开始时<code>Monitor</code>中的<code>Owner</code>为<code>null</code></li>
<li>当<code>Thread-2</code> 执行<code>synchronized(obj)&#123;&#125;</code>代码时就会将<code>Monitor</code>的所有者<code>Owner</code> 设置为 <code>Thread-2</code>，上锁成功，<code>Monitor</code>中同一时刻只能有一个<code>Owner</code></li>
<li>当<code>Thread-2</code> 占据锁时，如果线程<code>Thread-3</code>，<code>Thread-4</code>也来执行<code>synchronized(obj)&#123;&#125;</code>代码，就会进入<code>EntryList</code>中变成<code>BLOCKED</code>状态</li>
<li><code>Thread-2</code> 执行完同步代码块的内容，然后唤醒 EntryList&#96; 中等待的线程来竞争锁，竞争时是非公平的 (仍然是抢占式)</li>
<li>图中 <code>WaitSet</code> 中的<code>Thread-0，Thread-1</code> 是之前获得过锁，但条件不满足进入 <code>WAITING</code> 状态的线程，后面讲<code>wait-notify</code> 时会分析</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>synchronized</code> 必须是进入同一个锁对象的<code>monitor</code> 才有上述的效果; —&gt; 也就要使用同一把锁</li>
<li>不加 <code>synchronized</code>的锁对象不会关联监视器，不遵从以上规则</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201219200615817.png"></p>
<p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p>
<ul>
<li>在<code>JDK6</code>的时候, 对<code>synchronized</code>进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在<code>JVM</code>的层面上进行加锁逻辑, 就没有了切换的消耗~</li>
</ul>
</blockquote>
<h2 id="Synchronized原理分析"><a href="#Synchronized原理分析" class="headerlink" title="Synchronized原理分析"></a><code>Synchronized</code>原理分析</h2><h3 id="加锁和释放锁的原理加锁和释放锁的原理"><a href="#加锁和释放锁的原理加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理加锁和释放锁的原理"></a>加锁和释放锁的原理加锁和释放锁的原理</h3><blockquote>
<p>深入<code>JVM</code>看字节码，创建如下的代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>javac</code>命令进行编译生成<code>.class</code>文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; javac SynchronizedDemo2.java</span><br></pre></td></tr></table></figure>

<p>使用<code>javap</code>命令反编译查看<code>.class</code>文件的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; javap -verbose SynchronizedDemo2.class</span><br></pre></td></tr></table></figure>

<p>得到如下的信息：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-schronized-x1.png"></p>
<blockquote>
<p>关注红色方框里的<code>monitorenter</code>和<code>monitorexit</code>即可。</p>
<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加<code>1</code>或者减<code>1</code>。每一个对象在同一时间只与一个<code>monitor</code>(锁)相关联，而一个<code>monitor</code>在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的<code>Monitor</code>锁的所有权的时候，<code>monitorenter</code>指令会发生如下<code>3</code>中情况之一：</p>
<ul>
<li><code>monitor</code>计数器为<code>0</code>，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器<code>+1</code>，一旦<code>+1</code>，别的线程再想获取，就需要等待</li>
<li><strong>如果这个<code>monitor</code>已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成<code>2</code>，并且随着重入的次数，会一直累加</strong></li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code>：释放对于<code>monitor</code>的所有权，释放过程很简单，就是讲<code>monitor</code>的计数器减<code>1</code>，如果减完以后，计数器不是<code>0</code>，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成<code>0</code>，则代表当前线程不再拥有该<code>monitor</code>的所有权，即释放锁。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-schronized-2.png"></p>
<blockquote>
<p>​	该图可以看出，任意线程对<code>Object</code>的访问，首先要获得<code>Object</code>的监视器，如果获取失败，该线程就进入同步状态，线程状态变为<code>BLOCKED</code>，当<code>Object</code>的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
</blockquote>
<h3 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h3><blockquote>
<p>​	上面的<code>demo</code>中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条<code>monitorexit</code>指令，并没有<code>monitorenter</code>获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。</p>
<p>​	<code>Synchronized</code>先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p>
</blockquote>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote>
<p>​	轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁<br>eg: 线程A来操作临界区的资源, 给资源加锁,到执行完临界区代码,释放锁的过程, 没有线程来竞争, 此时就可以使用轻量级锁; 如果这期间有线程来竞争的话, 就会升级为重量级锁(<code>synchronized</code>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、每次指向到<code>synchronized</code>代码块时，都会创建锁记录（<code>Lock Record</code>）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的<code>Mark Word</code>和对象引用<code>reference</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755737580.png"></p>
<p>2、让锁记录中的<code>Object reference</code>指向对象，并且尝试用<code>cas(compare and sweep)</code>替换<code>Object</code>对象的<code>Mark Word</code> ，将<code>Mark Word</code> 的值存入锁记录中</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755888236.png"></p>
<p>3、如果<code>cas</code>替换成功，那么对象的对象头储存的就是锁记录的地址和状态<code>01</code>，如下所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583755964276.png"></p>
<p>4、如果<code>cas</code>失败，有两种情况</p>
<p>​	1、如果是其它线程已经持有了该<code>Object</code>的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</p>
<p>​	2、如果是自己的线程已经执行了<code>synchronized</code>进行加锁，那么那么再添加一条 <code>Lock Record</code> 作为重入的计数</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583756190177.png"></p>
<p>5、当线程退出<code>synchronized</code>代码块的时候，**如果获取的是取值为 <code>null</code> 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583756357835.png"></p>
<p>6、当线程退出<code>synchronized</code>代码块的时候，如果获取的锁记录取值不为 <code>null</code>，那么使用<code>cas</code>将<code>Mark Word</code>的值恢复给对象</p>
<p>​	1、成功则解锁成功</p>
<p>​	2、失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
</blockquote>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><blockquote>
<p>​	如果在尝试加轻量级锁的过程中，<code>cas</code>操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p>
</blockquote>
<blockquote>
<ol>
<li>当 <code>Thread-1</code> 进行轻量级加锁时，<code>Thread-0</code> 已经对该对象加了轻量级锁</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583757433691.png"></p>
<p>2、这时 <code>Thread-1</code> 加轻量级锁失败，进入锁膨胀流程</p>
<p>​	即为对象申请<code>Monitor</code>锁，让<code>Object</code>指向重量级锁地址，然后自己进入<code>Monitor</code> 的<code>EntryList</code> 变成<code>BLOCKED</code>状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583757586447.png"></p>
<p>3、当<code>Thread-0</code> 线程执行完<code>synchronized</code>同步块时，使用<code>cas</code>将<code>Mark Word</code>的值恢复给对象头, 肯定恢复失败,因为对象的对象头中存储的是重量级锁的地址,状态变为<code>10</code>了之前的是<code>00</code>, 肯定恢复失败。那么会进入重量级锁的解锁过程，即按照<code>Monitor</code>的地址找到<code>Monitor</code>对象，将<code>Owner</code>设置为<code>null</code>，唤醒<code>EntryList</code>中的<code>Thread-1</code>线程</p>
</blockquote>
<h3 id="自旋锁优化-优化重量级锁竞争"><a href="#自旋锁优化-优化重量级锁竞争" class="headerlink" title="自旋锁优化 (优化重量级锁竞争)"></a>自旋锁优化 (优化重量级锁竞争)</h3><blockquote>
<p>​	引入背景：大家都知道，在没有加入锁优化时，<code>Synchronized</code>是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时<code>HotSpot</code>团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃<code>CPU</code>的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。	</p>
<p>​	自旋锁早在<code>JDK1.4</code> 中就引入了，只是当时默认时关闭的。在<code>JDK 1.6</code>后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用<code>CPU</code>的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉<code>CPU</code>资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在<code>JDK</code>定义中，自旋锁默认的自旋次数为<code>10</code>次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
<p>​	可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p>
<p><strong>自适应自旋锁</strong></p>
<p>​	在<code>JDK 1.6</code>中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，<strong>而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</strong>。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么<code>JVM</code>会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到<code>100</code>次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，<code>JVM</code>对程序的锁的状态预测会越来越准确，<code>JVM</code>也会越来越聪明。</p>
<p>​	当发生重量级锁竞争的时候，还可以使用自旋来进行优化 (不加入<code>Monitor</code>的阻塞队列<code>EntryList</code>中)，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换(持锁线程执行完<code>synchronized</code>同步块后,释放锁,<code>Owner</code>为空,唤醒阻塞队列来竞争,胜出的线程得到<code>cpu</code>执行权的过程) 就获得了锁<br>优化的点: 不用将线程加入到阻塞队列, 减少<code>cpu</code>切换.<br>1、自旋重试成功的情况<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583758113724.png"></p>
<p>2、自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583758136650.png"></p>
</blockquote>
<blockquote>
<p>​	自旋会占用 <code>CPU</code> 时间，单核 <code>CPU</code> 自旋就是浪费，多核 <code>CPU</code> 自旋才能发挥优势。<br>​	在 <code>Java 6</code> 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。<code>Java 7</code> 之后不能控制是否开启自旋功能</p>
</blockquote>
<h3 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (<code>biased lock</code>) (用于优化轻量级锁重入)</h3><blockquote>
<p>场景:</p>
<ul>
<li><p>没有竞争的时候, 一个线程中多次使用<code>synchronized</code>需要重入加锁的情况; (只有一个线程进入临界区)</p>
</li>
<li><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过<code>JVM</code>的配置, 将偏向锁给关闭</p>
</li>
<li><p>将进入临界区的线程的<code>ID</code>, 直接设置给锁对象的<code>Mark word</code>, 下次该线程又获取锁, 发现线程<code>ID</code>是自己, 就不需要<code>CAS</code>了</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块A</span></span><br><span class="line">            m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块B</span></span><br><span class="line">            m3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 同步块C</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583760728806.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202174407252.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202174448323.png"></p>
<blockquote>
<p>一个对象的创建过程</p>
<ol>
<li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，<code>Mark Word</code> 最后三位的值<code>101</code>，并且这是它的<code>Thread</code>，<code>epoch</code>，<code>age</code>都是<code>0</code>，在加锁的时候进行设置这些的值.</p>
</li>
<li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p>
</li>
<li><p>注意：处于偏向锁的对象解锁后，线程 <code>id</code> 仍存储于对象头中</p>
</li>
<li><p>实验<code>Test18.java</code>，加上虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t))；</span><br><span class="line">        <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">            test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">        &#125;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，三次输出的状态码都为<code>101</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure>

<p>测试禁用：如果没有开启偏向锁，那么对象创建后最后三位的值为<code>001</code>，这时候它的<code>hashcode</code>，<code>age</code>都为<code>0</code>，<code>hashcode</code>是第一次用到<code>hashcode</code>时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出<code>synchronized</code>状态变回<code>001</code></p>
<ol>
<li><p>测试代码<code>Test18.java</code> 虚拟机参数<code>-XX:-UseBiasedLocking</code></p>
</li>
<li><p>输出结果如下，最开始状态为001，然后加轻量级锁变成<code>00</code>，最后恢复成<code>001</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">	LockFlag (2bit): <span class="number">01</span></span><br><span class="line">LockFlag (2bit): <span class="number">00</span></span><br><span class="line">biasedLockFlag (1bit): <span class="number">0</span></span><br><span class="line">	LockFlag (2bit): <span class="number">01</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>撤销偏向锁-hashcode方法</strong></p>
<p>测试 <code>hashCode</code>：当调用对象的<code>hashcode</code>方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p>
<ol>
<li><p>测试代码如下，使用虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>  ，确保我们的程序最开始使用了偏向锁！但是结果显示程序还是使用了轻量级锁。  <code>Test20.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    t.hashCode();</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<p><strong>撤销 - 调用 <code>wait/notify</code></strong></p>
<p>会使对象的锁变成重量级锁，因为<code>wait/notify</code>方法之后重量级锁才支持</p>
</blockquote>
<blockquote>
<p><strong>批量重偏向</strong><br>    如果对象被多个线程访问，但是没有竞争 (上面撤销偏向锁就是这种情况: 一个线程执行完, 另一个线程再来执行, 没有竞争), 这时偏向<code>T1</code>的对象仍有机会重新偏向<code>T2</code>，重偏向会重置<code>Thread ID</code><br>    当撤销偏向锁<code>101</code> 升级为 轻量级锁<code>00</code>超过<code>20</code>次后（超过阈值），<code>JVM</code>会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程 <code>(T2)</code>。<br><strong>批量撤销偏向锁</strong><br>    当撤销偏向锁的阈值超过<code>40</code>以后 ，就会将整个类的对象都改为不可偏向的</p>
</blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2><h3 id="Lock和synchronized区别"><a href="#Lock和synchronized区别" class="headerlink" title="Lock和synchronized区别"></a><code>Lock</code>和<code>synchronized</code>区别</h3><table>
<thead>
<tr>
<th></th>
<th><code>Lock</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>层次方面</td>
<td>1、<code>Lock</code>是一个接口，是在类级别上的实现<br/>2、<code>JDK</code>层次的实现</td>
<td>1、是Java关键字<br/>2、在JVM层次定义的</td>
</tr>
<tr>
<td>灵活性方面</td>
<td><code>Lock</code>接口提供的<code>lock()</code>和<code>unlock()</code>方法，可以随时获得锁、释放锁，非常灵活</td>
<td>1、释放锁、获得锁是被动的<br/>2、释放锁只有两种情况:① 同步代码块执行完毕；② 抛出异常，同步器执行<code>monitorexit</code>释放锁</td>
</tr>
<tr>
<td>锁的状态方面</td>
<td>① <code>Lock</code>可以判断锁的状态<br/>它会提供<code>tryLock()</code>方法来告诉我们是否获得锁成功<br/>② <code>tryLock()</code>方法有返回值，用来尝试获取锁，如果获取成功，则返回<code>true</code>;获取失败，返回<code>false</code>, 这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</td>
<td>1、在锁的状态方面，<code>synchronized</code> 完全是被动的，没法判断锁的状态。<br/>2、<code>synchronized</code>在拿不到锁时，则会阻塞在那里，一直等待</td>
</tr>
<tr>
<td>锁的类型方面</td>
<td>1、基于<code>Lock</code>接口，有多种锁的实现。如:<br/>① 可重入锁: <code>ReentrantLock</code><br/>② 可重入读写锁: <code>ReentrantReadWriteLock</code> 等<br/>2、针对可重入锁，还有公平锁和非公平锁之分</td>
<td>1、对于<code>synchronized</code>来说，它只是一个<code>JVM</code>层次的关键字，并不是一个接口，没有具体实现。<br/>2、<code>synchronized</code>相当于非公平锁。</td>
</tr>
</tbody></table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p><strong>概念：</strong> 多个并发进程因争夺系统资源而产生相互等待的现象。</p>
<p><strong>原理：</strong> 当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p>
</blockquote>
<p>​	如：线程<code>1</code>获取<code>A</code>对象锁, 线程<code>2</code>获取<code>B</code>对象锁; 此时线程<code>1</code>又想获取<code>B</code>对象锁, 线程<code>2</code>又想获取<code>A</code>对象锁; 它们都等着对象释放锁, 此时就称为死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发生死锁的必要条件-重点"><a href="#发生死锁的必要条件-重点" class="headerlink" title="发生死锁的必要条件 (重点)"></a>发生死锁的必要条件 (重点)</h4><blockquote>
<p><strong>互斥：</strong> 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。<br><strong>占有且等待：</strong> 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。<br><strong>不可抢占：</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。<br><strong>循环等待：</strong> 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。<br>       当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。</p>
</blockquote>
<h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><h5 id="方式一、JPS-JStack-进程ID"><a href="#方式一、JPS-JStack-进程ID" class="headerlink" title="方式一、JPS + JStack 进程ID"></a>方式一、<code>JPS</code> + <code>JStack 进程ID</code></h5><blockquote>
<ul>
<li><code>jps</code>先找到<code>JVM</code>进程</li>
<li><code>jstack 进程ID</code><ul>
<li>在<code>Java</code>控制台中的<code>Terminal</code>中输入 <strong><code>jps</code></strong> 指令可以查看<code>正在运行中的进程ID</code>，使用 <strong><code>jstack 进程ID</code></strong> 可以查看进程状态。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123336643.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123406253.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201223123554788.png"></p>
<h5 id="方式二、-jconsole检测死锁"><a href="#方式二、-jconsole检测死锁" class="headerlink" title="方式二、 jconsole检测死锁"></a>方式二、 <code>jconsole</code>检测死锁</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/359638cf867dbe8d03da37c3e19fefe3.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e9f23bd07142b38d856fef84e6ded641.png"></p>
<h3 id="ReentrantLock-的特点"><a href="#ReentrantLock-的特点" class="headerlink" title="ReentrantLock 的特点"></a><code>ReentrantLock</code> 的特点</h3><blockquote>
<p><strong>支持锁重入</strong><br>    可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此 有权利再次获取这把锁<br><strong>可中断</strong><br>    <code>lock.lockInterruptibly()</code> : 可以被其他线程打断的中断锁<br><strong>可以设置超时时间</strong><br>    <code>lock.tryLock(时间)</code> : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁<br><strong>可以设置为公平锁</strong><br>    (先到先得) 默认是非公平, <code>true</code>为公平 <code>new ReentrantLock(true)</code><br><strong>支持多个条件变量( 有多个<code>waitset</code>)</strong><br>    (可避免虚假唤醒) - <code>lock.newCondition()</code>创建条件变量对象; 通过条件变量对象调用 <code>await/signal</code>方法, 等待&#x2F;唤醒</p>
</blockquote>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要执行的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持锁重入"><a href="#支持锁重入" class="headerlink" title="支持锁重入"></a>支持锁重入</h4><blockquote>
<ul>
<li>可重入锁是指<code>同一个线程如果首次获得了这把锁</code>，那么因为它是这把<code>锁的拥有者</code>，因此 <strong>有权利再次获取这把锁</strong></li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;entry main...&quot;</span>);</span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;entry m1...&quot;</span>);</span><br><span class="line">            m2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;entry m2....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.324</span> guizy.ReentrantTest [main] - entry main...</span><br><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.326</span> guizy.ReentrantTest [main] - entry m1...</span><br><span class="line"><span class="number">13</span>:<span class="number">54</span>:<span class="number">29.326</span> guizy.ReentrantTest [main] - entry m2....</span><br></pre></td></tr></table></figure>

<h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><blockquote>
<p> (针对于<code>lockInterruptibly()</code>方法获得的中断锁) 直接退出阻塞队列, 获取锁失败</p>
<p><code>synchronized</code> 和 <code>reentrantlock.lock()</code> 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断</p>
<p>​	可被中断的锁, 通过<code>lock.lockInterruptibly()</code>获取的锁对象, 可以通过调用阻塞线程的<code>interrupt()</code>方法</p>
<ul>
<li>如果某个线程处于阻塞状态，可以调用其<code>interrupt</code>方法让其停止阻塞，获得锁失败<ul>
<li>处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</li>
</ul>
</li>
<li>可中断的锁, 在一定程度上可以<code>被动</code>的减少<code>死锁</code>的概率, 之所以被动, 是因为我们需要手动调用<code>阻塞线程的interrupt</code>方法;</li>
</ul>
</blockquote>
<p>测试使用<code>lock.lockInterruptibly()</code>可以从阻塞队列中,打断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的可打断锁方法 lock.lockInterruptibly();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;t1线程启动...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); <span class="comment">//没有获得锁就被打断跑出的异常</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;t1线程获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程获得锁(此锁不可打断)</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;main线程获得了锁&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动t1线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            t1.interrupt();            <span class="comment">//打断t1线程</span></span><br><span class="line">            log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><blockquote>
<h4 id="锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败"><a href="#锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败" class="headerlink" title="锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败"></a>锁超时 (<code>lock.tryLock()</code>) 直接退出阻塞队列, 获取锁失败</h4><p><strong>防止<code>无限制</code>等待, 减少死锁</strong></p>
<p>​	使用 <code>lock.tryLock()</code> 方法会返回获取锁是否成功。如果成功则返回<code>true</code>，反之则返回<code>false</code>。<br>​	并且<code>tryLock</code>方法可以设置指定等待时间，参数为：<code>tryLock(long timeout, TimeUnit unit)</code> , 其中<code>timeout</code>为最长等待时间，<code>TimeUnit</code>为时间单位<br>​	获取锁的过程中, 如果<code>超过等待时间</code>, <code>或者被打断</code>, 就直接从<code>阻塞队列</code>移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)</p>
</blockquote>
<ul>
<li><strong>不设置等待时间, 立即失败</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(), 获取锁立即失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="comment">// 此时肯定获取失败, 因为主线程已经获得了锁对象</span></span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 主线程2s之后才释放锁</span></span><br><span class="line">        Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.726</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.728</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">19.728</span> guizy.WaitNotifyTest [t1] - 获取立刻失败，返回</span><br><span class="line"><span class="number">14</span>:<span class="number">52</span>:<span class="number">21.728</span> guizy.WaitNotifyTest [main] - 释放了锁</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(long mills), 超过锁设置的等待时间,就从阻塞队列移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置等待时间, 超过等待时间 / 被打断, 都会获取锁失败; 退出阻塞队列</span></span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;获取锁超时，返回&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;被打断了, 获取锁失败, 返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//        t1.interrupt();</span></span><br><span class="line">        <span class="comment">// 主线程2s之后才释放锁</span></span><br><span class="line">        Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;main线程释放了锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时的打印</span></span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">56.647</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">56.651</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">57.652</span> guizy.WaitNotifyTest [t1] - 获取锁超时，返回</span><br><span class="line"><span class="number">14</span>:<span class="number">55</span>:<span class="number">58.652</span> guizy.WaitNotifyTest [main] - main线程释放了锁</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断的打印</span></span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.258</span> guizy.WaitNotifyTest [main] - 获得到锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.260</span> guizy.WaitNotifyTest [main] - main线程释放了锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.261</span> guizy.WaitNotifyTest [t1] - 尝试获得锁</span><br><span class="line"><span class="number">14</span>:<span class="number">56</span>:<span class="number">41.261</span> guizy.WaitNotifyTest [t1] - 被打断了, 获取锁失败, 返回</span><br><span class="line">java.lang.InterruptedException</span><br></pre></td></tr></table></figure>

<h4 id="通过lock-tryLock-来解决-哲学家就餐问题-重点"><a href="#通过lock-tryLock-来解决-哲学家就餐问题-重点" class="headerlink" title="通过lock.tryLock()来解决, 哲学家就餐问题 (重点)"></a>通过<code>lock.tryLock()</code>来解决, <code>哲学家就餐</code>问题 (<code>重点</code>)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用了ReentrantLock锁, 该类中有一个tryLock()方法, 在指定时间内获取不到锁对象, 就从阻塞队列移除,不用一直等待。</span></span><br><span class="line"><span class="comment"> *              当获取了左手边的筷子之后, 尝试获取右手边的筷子, 如果该筷子被其他哲学家占用, 获取失败, 此时就先把自己左手边的筷子,</span></span><br><span class="line"><span class="comment"> *              给释放掉. 这样就避免了死锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhilosopherEat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得了左手边筷子 (针对五个哲学家, 它们刚开始肯定都可获得左筷子)</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">// 此时发现它的right筷子被占用了, 使用tryLock(), </span></span><br><span class="line">                	<span class="comment">// 尝试获取失败, 此时它就会将自己左筷子也释放掉</span></span><br><span class="line">                    <span class="comment">// 临界区代码</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123; <span class="comment">//尝试获取右手边筷子, 如果获取失败, 则会释放左边的筷子</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类称为锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">01.793</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">01.795</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.293</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.295</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.794</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">02.796</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.294</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.296</span> guizy.Philosopher [柏拉图] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.795</span> guizy.Philosopher [赫拉克利特] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">03.797</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.295</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.297</span> guizy.Philosopher [苏格拉底] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.796</span> guizy.Philosopher [亚里士多德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">04.798</span> guizy.Philosopher [阿基米德] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">05.296</span> guizy.Philosopher [柏拉图] - eating...</span><br><span class="line"><span class="number">15</span>:<span class="number">16</span>:<span class="number">05.299</span> guizy.Philosopher [赫拉克利特] - eating...</span><br></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><blockquote>
<h4 id="公平锁-new-ReentrantLock-true"><a href="#公平锁-new-ReentrantLock-true" class="headerlink" title="公平锁 new ReentrantLock(true)"></a>公平锁 <code>new ReentrantLock(true)</code></h4><p>​	<code>ReentrantLock</code>默认是非公平锁, 可以指定为公平锁。</p>
<p>​	在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置<code>ReentrantLock</code>为公平的, 会降低并发度</p>
<p><code>Synchronized</code>底层的<code>Monitor</code>锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="什么是公平锁-什么是非公平锁"><a href="#什么是公平锁-什么是非公平锁" class="headerlink" title="什么是公平锁? 什么是非公平锁?"></a>什么是公平锁? 什么是非公平锁?</h5><blockquote>
<p>公平锁 (<code>new ReentrantLock(true)</code>)<br>    公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上<br>    只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁<br>非公平锁 (<code>synchronized</code>, <code>new ReentrantLock()</code>)<br>    非公平锁, 当阻塞队列中已经有等待的线程<code>A</code>了, 此时后到的线程<code>B</code>, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程<code>B</code>就先活的到锁了<br>**所以公平和非公平的区别:**线程执行同步代码块时, 是否回去尝试获取锁, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的</p>
<p>如果不进如队列呢? 线程一直尝试获取锁不就行了?<br>    一直尝试获取锁, 在<code>synchronized</code>轻量级锁升级为重量级锁时, 做的一个优化, 叫做自旋锁, 一般很消耗资源, <code>cpu</code>一直空转, 最后获取锁也失败, 所以不推荐使用。在<code>jdk6</code>对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等</p>
</blockquote>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><blockquote>
<h4 id="条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒"><a href="#条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒" class="headerlink" title="条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用await/signal方法, 等待&#x2F;唤醒"></a>条件变量 (可避免虚假唤醒) - <code>lock.newCondition()</code>创建条件变量对象; 通过条件变量对象调用<code>await/signal</code>方法, 等待&#x2F;唤醒</h4><p>​	<code>Synchronized</code> 中也有条件变量，就是<code>Monitor</code>监视器中的 <code>waitSet</code>等待集合，当条件不满足时进入<code>waitSet</code> 等待<br>​	<code>ReentrantLock</code> 的条件变量比 <code>synchronized</code> 强大之处在于,它是 支持多个条件变量。这就好比<code>synchronized</code> 是那些不满足条件的线程都在一间休息室等通知; (此时会造成虚假唤醒), 而 <code>ReentrantLock </code>支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; (可以避免虚假唤醒)<br>使用要点：</p>
<p>​	<code>await</code> 前需要 获得锁</p>
<p>​	<code>await</code> 执行后，会释放锁，进入 <code>conditionObject (条件变量)</code>中等待</p>
<p>​	<code>await</code> 的线程被唤醒（或打断、或超时）取重新竞争 <code>lock</code> 锁</p>
<p>​	竞争 <code>lock </code>锁成功后，从 <code>await</code> 后继续执行</p>
<p>​	<code>signal</code> 方法用来唤醒条件变量(等待室)汇总的某一个等待的线程</p>
<p>​	<code>signalAll</code>方法, 唤醒条件变量(休息室)中的所有线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ReentrantLock可以设置多个条件变量(多个休息室), 相对于synchronized底层monitor锁中waitSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.ConditionVariable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionVariable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeoutSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到 等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到 等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:08:<span class="number">58.231</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.234</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.235</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">15</span>:08:<span class="number">58.235</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！</span><br><span class="line"><span class="number">15</span>:08:<span class="number">59.232</span> guizy.WaitNotifyTest [送外卖的] - 送外卖的来咯~</span><br><span class="line"><span class="number">15</span>:08:<span class="number">59.233</span> guizy.WaitNotifyTest [小女] - 外卖来咯, 可以开始干活了</span><br><span class="line"><span class="number">15</span>:09:<span class="number">00.233</span> guizy.WaitNotifyTest [送烟的] - 送烟的来咯~</span><br><span class="line"><span class="number">15</span>:09:<span class="number">00.234</span> guizy.WaitNotifyTest [小南] - 烟来咯, 可以开始干活了</span><br></pre></td></tr></table></figure>

<h3 id="同步模式之顺序控制-案例"><a href="#同步模式之顺序控制-案例" class="headerlink" title="同步模式之顺序控制 (案例)"></a>同步模式之顺序控制 (案例)</h3><ul>
<li>假如有两个线程, 线程<code>A</code>打印<code>1</code>, 线程<code>B</code>打印<code>2</code>.</li>
<li>要求: <strong>程序先打印<code>2</code>, 再打印<code>1</code></strong></li>
</ul>
<h4 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a><code>wait/notify</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用wait/notify来实现顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// t2线程释放执行过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!t2Runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 进入等待(waitset), 会释放锁</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                t2Runned = <span class="literal">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="await-signal版本"><a href="#await-signal版本" class="headerlink" title="await/signal版本"></a><code>await/signal</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用ReentrantLock的await/sinal 来实现顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// t2线程释放执行过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">                <span class="keyword">while</span> (!t2Runned) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                t2Runned = <span class="literal">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="park-unpartk版本"><a href="#park-unpartk版本" class="headerlink" title="park/unpartk版本"></a><code>park/unpartk</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用LockSupport中的park,unpark来实现, 顺序打印 2, 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncPrintWaitTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>需求</p>
<ul>
<li><strong>线程<code>1</code> 输出 <code>a</code> <code>5</code>次, 线程<code>2</code> 输出 <code>b</code> <code>5</code>次, 线程<code>3</code> 输出 <code>c</code> <code>5</code>次。现在要求输出 <code>abcabcabcabcabcabc</code></strong></li>
</ul>
<h4 id="wait-notify版本-1"><a href="#wait-notify版本-1" class="headerlink" title="wait/notify版本"></a><code>wait/notify</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用wait/notify来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWaitNotify</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotify</span> <span class="variable">waitNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotify</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.WaitNotify&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="built_in">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="built_in">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="await-signal版本-1"><a href="#await-signal版本-1" class="headerlink" title="await/signal版本"></a><code>await/signal</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用await/signal来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAwaitSignal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c_condition</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    <span class="comment">//System.out.print(&quot;i:===&quot;+i);</span></span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="park-unpark版本"><a href="#park-unpark版本" class="headerlink" title="park/unpark版本"></a><code>park/unpark</code>版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用park/unpark来实现三个线程交替打印abcabcabcabcabc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParkUnpark</span> <span class="variable">parkUnpark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Thread nextThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个线程轮流打印1-100"><a href="#三个线程轮流打印1-100" class="headerlink" title="三个线程轮流打印1-100"></a>三个线程轮流打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> loop;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> _flag, <span class="type">int</span> _loop, <span class="type">int</span> _a)</span> &#123;</span><br><span class="line">        flag = _flag;</span><br><span class="line">        loop = _loop;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> _flag, <span class="type">int</span> _nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != _flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                flag = _nextFlag;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><code>Java</code> 内存模型</h2><blockquote>
<p>​	<code>JMM</code>定义了程序中各个共享变量的访问规则，即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节。</p>
<p>​	在 <code>java</code> 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（<code>Local variables</code>），方法定义参数（<code>java</code> 语言规范称之为 <code>formal method parameters</code>）和异常处理器参数（<code>exception handler parameters</code>）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>​	<code>Java</code> 线程之间的通信由 <code>Java</code> 内存模型（本文简称为 <code>JMM</code>）控制，<code>JMM</code> 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，<code>JMM</code> 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（<code>main memory</code>）中，每个线程都有一个私有的本地内存（<code>local memory</code>），本地内存中存储了该线程以读 &#x2F; 写共享变量的副本。本地内存是 <code>JMM</code> 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
</blockquote>
<blockquote>
<p><code>Java</code> 内存模型是一种规范，定义了很多东西：</p>
<ul>
<li>所有的变量都存储在主内存（<code>Main Memory</code>）中。</li>
<li>每个线程都有一个私有的本地内存（<code>Local Memory</code>），本地内存中存储了该线程以读&#x2F;写共享变量的拷贝副本。</li>
<li>线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。</li>
<li>不同的线程之间无法直接访问对方本地内存中的</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/3be664e6b9167e361954a15cd1d8edf3.png"></p>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>​	原子性指的是一个操作不可中断，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>​	在<code>Java</code>中，对于基本数据类型的变量的读取和赋值操作是原子性操作需要注意的是：对于<code>32</code>位系统来说，<code>long</code> 类型数据和 <code>double</code> 类型数据（对于基本类型数据：<code>byte、short、int、float、boolean、char</code> 读写是原子操作），它们的读写并非原子性的，也就是说如果存在两条线程同时对 <code>long</code> 类型或者 <code>double</code> 类型的数据进行读写是存在相互干扰的，因为对于<code>32</code>位虚拟机来说，每次原子读写是<code>32</code>位，而 <code>long</code> 和 <code>double</code> 则是<code>64</code>位的存储单元，这样回导致一个线程在写时，操作完成前<code>32</code>位的原子操作后，轮到<code>B</code>线程读取时，恰好只读取来后<code>32</code>位的数据，这样可能回读取到一个即非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即<code>64</code>位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少，至少在目前的商用虚拟机中，几乎都把<code>64</code>位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道怎么回事即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">10</span>; <span class="comment">//原子性(简单的读取、将数字赋值给变量) </span></span><br><span class="line">Y = x; <span class="comment">//变量之间的相互赋值，不是原子操作 </span></span><br><span class="line">X++; <span class="comment">//对变量进行计算操作 X=x+1; </span></span><br></pre></td></tr></table></figure>

<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote>
<p>​	可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取到这个变量，并且是修改过的新值。</p>
<p>​	但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量 <code>x</code> 的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量 <code>x</code> 进行操作，但此时A线程工作内存中共享变量 <code>x</code> 对线程B来说并不可见，这种工作内存与主内存同步延迟现象就会造成可见性问题，另外指令重排以及编译器优化也可能回导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实回导致程序乱序执行的问题，从而也就导致可见性问题。</p>
</blockquote>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote>
<p>​	有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，比较对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译称机器码指令后可能回会现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在<code>Java</code>程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指令重排现象和工作内存与主内存同步延迟现象</p>
</blockquote>
<h3 id="JMM如何解决原子性、可见性和有序性问题"><a href="#JMM如何解决原子性、可见性和有序性问题" class="headerlink" title="JMM如何解决原子性、可见性和有序性问题"></a>JMM如何解决原子性、可见性和有序性问题</h3><h4 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h4><blockquote>
<p>​	除了 <code>JVM</code> 自身提供的对基本数据类型读写操作的原子性外，可以通过 <code>synchronized</code> 和<code>Lock</code> 实现原子性。因为 <code>synchronized</code> 和 <code>Lock</code> 能够保证任一时刻只有一个线程访问该代码块。</p>
</blockquote>
<h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4><blockquote>
<p>​	<code>volatile</code> 关键字可以保证可见性。当一个共享变量被 <code>volatile</code> 关键字修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。<code>synchronized</code> 和 <code>Lock</code> 也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。</p>
</blockquote>
<h4 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h4><blockquote>
<p>​	在<code>Java</code>里面，可以通过 <code>volatile</code> 关键字来保证一定的“有序性”。另外可以通过 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性，很显然，<code>synchronized</code> 和 <code>Lock</code> 保证每个时刻是只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证来有序性。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><blockquote>
<p>　　<code>java</code>语言规范<code>JVM</code>线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑不一致，这个过程就叫做执行重排序；</p>
</blockquote>
<blockquote>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，重排序分为三种类型：</p>
<p>​	1.编译器优化的重排序：编译器在不改变单线程程序的语义下，可以重新安排语句的执行顺序；</p>
<p>​	2.指令级并行重排序：线程处理器采用了指令级并行技术来将多条指令重叠执行；如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；</p>
<p>​	3.内存系统重排序：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱执行；</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1508365-20200327133446831-1974934373.png"></p>
<blockquote>
<p>​	这些重排序可能会导致多线程程序出现内存可见性问题；对于编译器，<code>JMM</code>的编译器重排序规则会禁止特定类型的编译器重排序；对于处理器重排序，<code>JMM</code>的处理器重排序规则会要求<code>java</code>编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型处理器重排序；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PossibleReordering</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	很容易想到这段代码的运行结果可能为<code>(1,0)</code>、<code>(0,1)</code>或<code>(1,1)</code>，因为线程<code>one</code>可以在线程<code>two</code>开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p>
<p>​	然而，这段代码的执行结果也可能是<code>(0,0)</code>, 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到<code>(0,0)</code>结果的语句执行过程，如下图所示。值得注意的是，<code>a=1</code>和<code>x=b</code>这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”<code>(reordering)</code>。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/decdc45db40d1775e8b16db006e21a4232890.png"></p>
<p>对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/319709161b06ee0c058a08a77bb8a32126550.png"></p>
<blockquote>
<p>​	实验代码是构造一个循环，反复执行上面的实例代码，直到出现<code>a=0</code>且<code>b=0</code>的输出为止。实验结果说明，循环执行到第<code>13830</code>次时输出了<code>(0,0)</code>.</p>
<p>​	大多数现代微处理器都会采用将指令乱序执行（<code>out-of-order execution</code>，简称<code>OoOE</code>或&#96;OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。	通过乱序执行的技术，处理器可以大大提高执行效率。</p>
<p>​	除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p>
</blockquote>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><code>as-if-serial</code>语义</h4><blockquote>
<p>​	<code>As-if-serial</code>语义的意思是，所有的动作(<code>Action</code>)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。<code>Java</code>编译器、运行时和处理器都会保证单线程下的<code>as-if-serial</code>语义。 比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p>
<ul>
<li><code>int a = 1</code>;</li>
<li><code>int b = 2</code>;</li>
<li><code>int c = a + b</code>;</li>
</ul>
<p>将上面的代码编译成<code>Java</code>字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</p>
<ol>
<li>对<code>a</code>赋值<code>1</code></li>
<li>对<code>b</code>赋值<code>2</code></li>
<li>取<code>a</code>的值</li>
<li>取<code>b</code>的值</li>
<li>将取到两个值相加后存入<code>c</code></li>
</ol>
<p>​    在上面<code>5</code>个动作中，动作<code>1</code>可能会和动作<code>2、4</code>重排序，动作<code>2</code>可能会和动作<code>1、3</code>重排序，动作<code>3</code>可能会和动作<code>2、4</code>重排序，动作<code>4</code>可能会和<code>1、3</code>重排序。但动作<code>1</code>和动作<code>3、5</code>不能重排序。动作<code>2</code>和动作<code>4、5</code>不能重排序。因为它们之间存在数据依赖关系，一旦重排，<code>as-if-serial</code>语义便无法保证。</p>
<p>​	为保证<code>as-if-serial</code>语义，<code>Java</code>异常处理机制也会为重排序做一些特殊处理。例如在下面的代码中，<code>y = 0 / 0</code>可能会被重排序在<code>x = 2</code>之前执行，为了保证最终不致于输出<code>x = 1</code>的错误结果，<code>JIT</code>在重排序时会在<code>catch</code>语句中插入错误代偿代码，将<code>x</code>赋值为<code>2</code>，将程序恢复到发生异常时应有的状态。这种做法的确将异常捕捉的逻辑变得复杂了，但是<code>JIT</code>的优化的原则是，尽力优化正常运行下的代码逻辑，哪怕以<code>catch</code>块逻辑变得复杂为代价，毕竟，进入<code>catch</code>块内是一种“异常”情况的表现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reordering</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = <span class="number">2</span>;</span><br><span class="line">            y = <span class="number">0</span> / <span class="number">0</span>;    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><code>happens-before</code> 原则</h4><blockquote>
<p>​	只靠 <code>synchronized</code> 和 <code>volatile</code> 关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从<code>JDK 5</code> 开始，<code>Java</code> 使用新的 <code>JSR-133</code> 内存模型，提供了 <code>happens-before</code> 原则 来辅助保证程序执行的原子性、可见性和有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。<code>happens-before</code> 原则内容如下：</p>
<ol>
<li><strong>程序顺序原则</strong>，即在一个线程内必须保证语义串行，也就是说按照代码顺序执行。</li>
<li><strong>锁规则</strong>，解锁（<code>unlock</code>）操作必然发生在后续的同一个锁的加锁（<code>lock</code>）之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后（同一个锁）。</li>
<li><strong><code>volatile</code>规则</strong>， <code>volatile</code>变量的写，先发生于读，这保证了<code>volatile</code>变量的可见性，简单理解就是，<code>volatile</code>变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>
<li><strong>线程启动规则</strong>，线程的 <code>start()</code> 方法先于它的每一个动作，即如果线程<code>A</code>在执行线程<code>B</code>的 <code>start</code> 方法之前修改了共享变量的值，那么当线程<code>B</code>执行<code>start</code>方法时，线程<code>A</code>对共享变量的修改对线程<code>B</code>可见。</li>
<li><strong>传递性</strong>，<code>A</code>先于<code>B</code>，<code>B</code>先于<code>C</code>，那么<code>A</code>必然先于<code>C</code>。</li>
<li><strong>线程终止原则</strong>，线程的所有操作先于线程的终结，<code>Thread.join()</code> 方法的作用是等待当前执行的线程终止。假设在线程<code>B</code>终止之前，修改了共享变量，线程<code>A</code>从线程<code>B</code>的<code>join</code>方法成功返回，线程<code>B</code>对共享变量的修改将对线程<code>A</code>可见。</li>
<li><strong>线程中断规则</strong>，对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检查到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测线程十分中断。</li>
<li><strong>对象终结规则</strong>，对象的构造函数执行，结束先于 <code>finalize()</code> 方法。</li>
</ol>
</blockquote>
<blockquote>
<p>​	除此之外，<code>Java</code>内存模型对<code>volatile</code>和<code>final</code>的语义做了扩展。对<code>volatile</code>语义的扩展保证了<code>volatile</code>变量在一些情况下不会重排序，<code>volatile</code>的<code>64</code>位变量<code>double</code>和<code>long</code>的读取和赋值操作都是原子的。对<code>final</code>语义的扩展保证一个对象的构建方法结束前，所有<code>final</code>成员变量都必须完成初始化（的前提是没有<code>this</code>引用溢出）。</p>
</blockquote>
<p><code>Java</code>内存模型关于重排序的规定，总结后如下表所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/94e93b3a7b49dc4c46b528fde1a03cd967665.png"></p>
<blockquote>
<p>​	表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有<code>volatile</code>写重排序。另外，<code>JMM</code>也规定了上述<code>volatile</code>和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括<code>JIT</code>，下同）证明了一个<code>volatile</code>变量只能被单线程访问，那么就可能会把它做为普通变量来处理。</p>
<p>​	留白的单元格代表允许在不违反<code>Java</code>基本语义的情况下重排序。例如，编译器不会对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。</p>
</blockquote>
<blockquote>
<p>​	为了保证内存可见性，<code>java</code> 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。<code>JMM</code> 把内存屏障指令分为下列四类：</p>
</blockquote>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LoadLoad Barriers</code></td>
<td><code>Load1; LoadLoad; Load2</code></td>
<td>确保 <code>Load1</code> 数据的装载，之前于 <code>Load2</code> 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td><code>StoreStore Barriers</code></td>
<td><code>Store1; StoreStore; Store2</code></td>
<td>确保 <code>Store1</code> 数据对其他处理器可见（刷新到内存），之前于 <code>Store2</code> 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td><code>LoadStore Barriers</code></td>
<td><code>Load1; LoadStore; Store2</code></td>
<td>确保 <code>Load1</code> 数据装载，之前于 <code>Store2</code> 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td><code>StoreLoad Barriers</code></td>
<td><code>Store1; StoreLoad; Load2</code></td>
<td>确保 <code>Store1</code> 数据对其他处理器变得可见（指刷新到内存），之前于 <code>Load2</code> 及所有后续装载指令的装载。</td>
</tr>
</tbody></table>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-volatile-3.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-key-volatile-4.png"></p>
<blockquote>
<p>​	<code>StoreLoad Barriers</code> 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p>
<p>​	<code>StoreLoad Barriers</code> 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（<code>buffer fully flush</code>）。</p>
</blockquote>
<h3 id="并发编程的两个关键问题"><a href="#并发编程的两个关键问题" class="headerlink" title="并发编程的两个关键问题"></a>并发编程的两个关键问题</h3><h4 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a>线程之间如何通信</h4><blockquote>
<p>两种通信机制，<strong>共享内存</strong>和<strong>消息传递</strong>，<code>Java</code>内存模型中使用共享内存</p>
</blockquote>
<h4 id="线程之间如何同步"><a href="#线程之间如何同步" class="headerlink" title="线程之间如何同步"></a>线程之间如何同步</h4><blockquote>
<ul>
<li>共享内存通信机制中，线程同步是显式的，程序员要显式指定</li>
<li>消息传递通信机制中，线程同步是隐式的，消息的发送必须在消息的接受之前</li>
</ul>
</blockquote>
<h3 id="JMM原子操作"><a href="#JMM原子操作" class="headerlink" title="JMM原子操作"></a><code>JMM</code>原子操作</h3><h4 id="八种原子操作"><a href="#八种原子操作" class="headerlink" title="八种原子操作"></a>八种原子操作</h4><table>
<thead>
<tr>
<th align="center">名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lock</code>(锁定)</td>
<td>作用于主内存的变量，一个变量在同一时间只能一个线程锁定。该操作表示该线程独占锁定的变量。</td>
</tr>
<tr>
<td align="center"><code>unlock</code>(解锁)</td>
<td>作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定。</td>
</tr>
<tr>
<td align="center"><code>read</code>(读取)</td>
<td>作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用。</td>
</tr>
<tr>
<td align="center"><code>load</code>(载入)</td>
<td>作用于线程的工作内存的变量，表示把<code>read</code>操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</td>
</tr>
<tr>
<td align="center"><code>use</code>(使用)</td>
<td>作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</td>
</tr>
<tr>
<td align="center"><code>assign</code>(赋值)</td>
<td>作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</td>
</tr>
<tr>
<td align="center"><code>store</code>(存储)</td>
<td>作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的<code>write</code>操作使用。</td>
</tr>
<tr>
<td align="center"><code>write</code>(写入)</td>
<td>作用于主内存的变量，把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中。</td>
</tr>
</tbody></table>
<h4 id="JMM规定了以上8中操作需要按照如下规则进行"><a href="#JMM规定了以上8中操作需要按照如下规则进行" class="headerlink" title="JMM规定了以上8中操作需要按照如下规则进行"></a><code>JMM</code>规定了以上<code>8</code>中操作需要按照如下规则进行</h4><blockquote>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li>
<li><strong>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值。</strong></li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被其他线程锁定住的变量。<br>以上<code>8</code>中规则看着也是比较生涩的，其实如果你没看明白也没关系，其实这些规则就是保障数据同步的一些规则。不是很重要，重要的在后面的<code>happens-before</code>原则。</li>
</ul>
</blockquote>
<h4 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200203151627869.png"></p>
<blockquote>
<p>线程<code>1</code>：先把<code>initFlag</code>变量<code>read</code>读取出来，再<code>load</code>载入工作内存，<code>use</code>使用线程<code>1</code>执行代码<code>!initFlag</code></p>
<p>线程<code>2</code>：先把<code>initFlag</code>变量<code>read</code>读取出来，再<code>load</code>载入工作内存，<code>use</code>使用线程<code>2</code>执行代码<code>initFlag=true</code>，再<code>assign</code>重新赋值，<code>store</code>存储并写入主内存，<code>write</code>写入到主内存中的变量。（线程<code>2</code>对缓存行<code>lock</code>加锁，<code>write</code>写入主内存后会解锁<code>unlock</code>，防止<code>initFlag</code>还未<code>write</code>写入主内存就被线程<code>1</code>读取为<code>false</code>）。</p>
<p>线程<code>1</code>：因为<code>initFlag</code>被<code>volatile</code>修饰，使用<code>MESI</code>缓存一致性协议，线程<code>1</code>cpu总线嗅探机制监听到了<code>initFlag</code>值的修改，线程<code>1</code>中<code>initFlag=false</code>失效变为true&#96;退出循环继续执行，体现了多线程同步运行共享变量副本的可见性。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200702162128208.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibilityTest</span> &#123;</span><br><span class="line">    <span class="comment">//volatile变量，用来确保将变量的更新操作通知到其他线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;waiting data...&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!initFlag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;==============success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                prepareData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareData</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;preparing data...&quot;</span>);</span><br><span class="line">            initFlag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;prepare data end...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lock和unlock"><a href="#lock和unlock" class="headerlink" title="lock和unlock"></a><code>lock</code>和<code>unlock</code></h4><blockquote>
<p>​	上面的<code>8</code>个原子操作中没有具体说<code>lock</code>和<code>unlock</code>，这里单拿出来聊一聊，因为这两个操作相比于其他操作涉及的东西多一些。在早些时候<code>lock</code>和<code>unlock</code>操作是通过总线加锁方式实现的，这种实现方式是在<code>read</code>之前就进行了<code>lock</code>操作，如下图所示，这种方式的弊端之一就是性能低下，因为这样的话一个<code>cpu</code>在从主内存读取数据到工作内存回对整个过程加锁，这样的话其他<code>cpu</code>就没有办法从主内存读取这个数据，直到这个<code>cpu</code>使用完数据后释放掉锁之后其他<code>cpu</code>才能继续读取数据。这样多核<code>cpu</code>“并行”执行任务的优点就体现不出来，因为这样的话，虽然有多个<code>cpu</code>,但其实在执行任务的时候还是“串行”执行。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20200519001952558.png"></p>
<blockquote>
<p>​	而<code>volatile</code>方式的<code>lock</code>操作是在<code>store</code>之前进行的，这个锁的粒度相比于上面的粒度要小很多，因为上面的锁它的作用范围横跨了主内存和工作内存交换数据的整个过程<code>（read、load、use、assign、store、write）</code>,而这个锁只涉及<code>store</code>和<code>write</code>两个过程，这样效率得到了很大的提升。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2020051717501490.png"></p>
<blockquote>
<p>​	清楚了上面的概念后我们再思考一个问题：<code>lock</code>和<code>unlock</code>操作可不可以省略？其实我们在上面讲的时候就没有在流程图中画这两个操作，感觉也很好的实现了共享变量的可见性，但仔细分析你就会发现没有这两个操作是不行的，主要原因还是“高并发”会引起的问题，思考下面两个场景：</p>
<p>​	假如线程<code>1</code>和线程<code>2</code>同时往主内存中回写数据，如果没有锁机制是不是会导致数据出错。<br>​	假如线程<code>2</code>执行完了<code>store</code>操作（已经写入主内存中，但是还没有赋值给<code>initFlag</code>变量，此时的<code>initFlag</code>依旧是<code>false</code>)，而正在此时，线程<code>1</code>进行了read操作，那么它拿到的值依旧时<code>initFlag=false</code>的值。<br>​	所以综上，<code>lock</code>和<code>unlock</code>是必须要有的操作。</p>
</blockquote>
<h3 id="JMM-缓存不一致问题"><a href="#JMM-缓存不一致问题" class="headerlink" title="JMM 缓存不一致问题"></a><code>JMM</code> 缓存不一致问题</h3><blockquote>
<p>​	如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题，这个时候该怎么解决呢？</p>
<p>解决 <code>JMM</code> 中的本地内存变量的缓存不一致问题有两种解决方案，分别是<strong>总线加锁</strong>和**<code>MESI</code>缓存一致性协议**。</p>
</blockquote>
<h4 id="总线加锁"><a href="#总线加锁" class="headerlink" title="总线加锁"></a>总线加锁</h4><blockquote>
<p>​	总线加锁是 <code>CPU</code> 从主内存读取数据到本地内存时，会先在总线对这个数据加锁，这样其它 <code>CPU</code> 就没法去读或者去写这个数据，直到这个 <code>CPU</code> 使用完数据释放锁后，其它的 <code>CPU</code> 才能读取该数据。</p>
<p>​	总线加锁虽然能保证数据一致，但是它却严重降低了系统性能，因为当一个线程多总线加锁后，其它线程都只能等待，将原有的并行操作转成了串行操作。<br>​	通常情况下，我们不采用这种方法，而是使用性能较高的缓存一致性协议。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/340ebc442de393e5d6eada74e0f5cea6.png"></p>
<h4 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI 缓存一致性协议"></a><code>MESI</code> 缓存一致性协议</h4><blockquote>
<p>​	<code>MESI</code> 缓存一致性协议是多个 <code>CPU</code> 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 <code>CPU</code> 修改了缓存里的数据，该数据会马上同步回主内存，其它 <code>CPU</code> 通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据<strong>失效</strong>。<br>​	在并发编程中，如果多个线程对同一个共享变量进行操作时，我们通常会在变量名称前加上关键在<code>volatile</code>,因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发<code>read</code>操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上，<code>volatile</code>的工作原理就是依赖于 <code>MESI</code> 缓存一致性协议实现的。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><h3 id="防重排序"><a href="#防重排序" class="headerlink" title="防重排序"></a>防重排序</h3><blockquote>
<p>​	我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁<code>(DCL)</code>的方式来实现。其源码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在我们分析一下为什么要在变量<code>singleton</code>之间加上<code>volatile</code>关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为<code>volatile</code>类型的变量。</p>
</blockquote>
<h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><blockquote>
<p>​	可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。<code>volatile</code>关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span>+b+<span class="string">&quot;;a=&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">VolatileTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest</span>();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	直观上说，这段代码的结果只可能有两种：<code>b=3;a=3</code> 或 <code>b=2;a=1</code>。不过运行上面的代码(可能时间上要长一点)，你会发现除了上两种结果之外，还出现了第三种结果：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...... </span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">1</span> <span class="comment">// 这里</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	为什么会出现<code>b=3;a=1</code>这种结果呢? 正常情况下，如果先执行<code>change</code>方法，再执行<code>print</code>方法，输出结果应该为<code>b=3;a=3</code>。相反，如果先执行的<code>print</code>方法，再执行<code>change</code>方法，结果应该是 <code>b=2;a=1</code>。那<code>b=3;a=1</code>的结果是怎么出来的? 原因就是第一个线程将值<code>a=3</code>修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将<code>a</code>和<code>b</code>都改成<code>volatile</code>类型的变量再执行，则再也不会出现<code>b=3;a=1</code>的结果了。</p>
</blockquote>
<h3 id="保证原子性-单次读-写"><a href="#保证原子性-单次读-写" class="headerlink" title="保证原子性:单次读&#x2F;写"></a>保证原子性:单次读&#x2F;写</h3><blockquote>
<p>​	<code>volatile</code>不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）：</p>
</blockquote>
<h4 id="问题1：-i-为什么不能保证原子性"><a href="#问题1：-i-为什么不能保证原子性" class="headerlink" title="问题1： i++为什么不能保证原子性?"></a>问题1： <code>i++</code>为什么不能保证原子性?</h4><blockquote>
<p>​	对于原子性，需要强调一点，也是大家容易误解的一点：对<code>volatile</code>变量的单次读&#x2F;写操作可以保证原子性的，如<code>long</code>和<code>double</code>类型变量，但是并不能保证<code>i++</code>这种操作的原子性，因为本质上<code>i++</code>是读、写两次操作。</p>
<p>​	现在我们就通过下列程序来演示一下这个问题：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest01</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addI</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span>  <span class="type">VolatileTest01</span> <span class="variable">test01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest01</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">1000</span>; n++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test01.addI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);<span class="comment">//等待10秒，保证上面程序执行完成</span></span><br><span class="line">        System.out.println(test01.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	大家可能会误认为对变量<code>i</code>加上关键字<code>volatile</code>后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：<code>981</code> 可能每个人运行的结果不相同。不过应该能看出，<code>volatile</code>是无法保证原子性的(否则结果应该是<code>1000</code>)。原因也很简单，<code>i++</code>其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取<code>i</code>的值。</li>
<li>对<code>i</code>加<code>1</code>。</li>
<li>将i的值写回内存。 <code>volatile</code>是无法保证这三个操作是具有原子性的，我们可以通过<code>AtomicInteger</code>或者<code>Synchronized</code>来保证<code>+1</code>操作的原子性。 注：上面几段代码中多处执行了<code>Thread.sleep()</code>方法，目的是为了增加并发问题的产生几率，无其他作用。</li>
</ul>
</blockquote>
<h4 id="问题2：-共享的long和double变量的为什么要用volatile"><a href="#问题2：-共享的long和double变量的为什么要用volatile" class="headerlink" title="问题2： 共享的long和double变量的为什么要用volatile?"></a>问题2： 共享的<code>long</code>和<code>double</code>变量的为什么要用<code>volatile</code>?</h4><blockquote>
<p>​	因为<code>long``和double</code>两种数据类型的操作可分为高<code>32</code>位和低<code>32</code>位两部分，因此普通的<code>long</code>或<code>double</code>类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的<code>long</code>和<code>double</code>变量设置为<code>volatile</code>类型，这样能保证任何情况下对<code>long</code>和<code>double</code>的单次读&#x2F;写操作都具有原子性。</p>
</blockquote>
<h3 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a><code>volatile</code> 的实现原理</h3><h4 id="volatile可见性实现"><a href="#volatile可见性实现" class="headerlink" title="volatile可见性实现"></a><code>volatile</code>可见性实现</h4><blockquote>
<p><code>volatile</code> 变量的内存可见性是基于内存屏障<code>(Memory Barrier)</code>实现:</p>
<ul>
<li>内存屏障，又称内存栅栏，是一个 <code>CPU</code> 指令。</li>
<li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，<code>JMM</code> 为了保证在不同的编译器和 <code>CPU</code> 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 <code>CPU</code>：不管什么指令都不能和这条 <code>Memory Barrier</code> 指令重排序。</li>
</ul>
</blockquote>
<p>写一段简单的 <code>Java</code> 代码，声明一个 <code>volatile</code> 变量，并赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  <span class="number">0x0000000002951563</span>: and    $<span class="number">0xffffffffffffff87</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951567</span>: je     <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295156d</span>: test   $<span class="number">0x7</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951574</span>: jne    <span class="number">0x00000000029515bd</span></span><br><span class="line">  <span class="number">0x0000000002951576</span>: test   $<span class="number">0x300</span>,%rdi</span><br><span class="line">  <span class="number">0x000000000295157d</span>: jne    <span class="number">0x000000000295159c</span></span><br><span class="line">  <span class="number">0x000000000295157f</span>: and    $<span class="number">0x37f</span>,%rax</span><br><span class="line">  <span class="number">0x0000000002951586</span>: mov    %rax,%rdi</span><br><span class="line">  <span class="number">0x0000000002951589</span>: or     %r15,%rdi</span><br><span class="line">  <span class="number">0x000000000295158c</span>: lock cmpxchg %rdi,(%rdx)  <span class="comment">//在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span></span><br><span class="line">  <span class="number">0x0000000002951591</span>: jne    <span class="number">0x0000000002951a15</span></span><br><span class="line">  <span class="number">0x0000000002951597</span>: jmpq   <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295159c</span>: mov    <span class="number">0x8</span>(%rdx),%edi</span><br><span class="line">  <span class="number">0x000000000295159f</span>: shl    $<span class="number">0x3</span>,%rdi</span><br><span class="line">  <span class="number">0x00000000029515a3</span>: mov    <span class="number">0xa8</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">0x00000000029515aa</span>: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lock</code> 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 <code>CPU</code> 里缓存了该内存地址的额数据无效。</li>
</ul>
<p>​    为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(<code>L1，L2</code> 或其他)后再进行操作，但操作完不知道何时会写到内存。</p>
<p>​	如果对声明了 <code>volatile</code> 的变量进行写操作，<code>JVM</code> 就会向处理器发送一条 <code>lock</code> 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>​	为了保证各个处理器的缓存是一致的，实现了缓存一致性协议<code>(MESI)</code>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>​	所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>​	<code>volatile</code> 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
</blockquote>
<h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a><code>volatile</code> 禁止重排序</h4><blockquote>
<p>​	为了性能优化，<code>JMM</code> 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。<code>JMM</code> 提供了内存屏障阻止这种重排序。</p>
</blockquote>
<h3 id="volatile-的应用场景"><a href="#volatile-的应用场景" class="headerlink" title="volatile 的应用场景"></a><code>volatile</code> 的应用场景</h3><blockquote>
<p>使用 <code>volatile</code> 必须具备的条件</p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
<li>只有在状态真正独立于程序内其他内容时才能使用 <code>volatile</code>。</li>
</ul>
</blockquote>
<h4 id="模式1：状态标志"><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式<code>1</code>：状态标志</h4><blockquote>
<p>​	也许实现 <code>volatile</code> 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequested;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式2：一次性安全发布-one-time-safe-publication"><a href="#模式2：一次性安全发布-one-time-safe-publication" class="headerlink" title="模式2：一次性安全发布(one-time safe publication)"></a>模式<code>2</code>：一次性安全发布(<code>one-time safe publication</code>)</h4><blockquote>
<p>​	缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(<code>double-checked-locking</code>)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackgroundFloobleLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initInBackground</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> <span class="title class_">Flooble</span>();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeOtherClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="literal">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式3：独立观察-independent-observation"><a href="#模式3：独立观察-independent-observation" class="headerlink" title="模式3：独立观察(independent observation)"></a>模式<code>3</code>：独立观察(<code>independent observation</code>)</h4><blockquote>
<p>​	安全使用 <code>volatile</code> 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 <code>volatile</code> 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">authenticate</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式4：volatile-bean-模式"><a href="#模式4：volatile-bean-模式" class="headerlink" title="模式4：volatile bean 模式"></a>模式<code>4</code>：<code>volatile bean</code> 模式</h4><blockquote>
<p>​	在 <code>volatile bean</code> 模式中，<code>JavaBean</code> 的所有数据成员都是 <code>volatile</code> 类型的，并且 <code>getter </code>和 <code>setter</code> 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 <code>volatile </code>时，只有引用而不是数组本身具有 <code>volatile</code> 语义)。对于任何 <code>volatile</code> 变量，不变式或约束都不能包含 JavaBean 属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式5：开销较低的读－写锁策略"><a href="#模式5：开销较低的读－写锁策略" class="headerlink" title="模式5：开销较低的读－写锁策略"></a>模式<code>5</code>：开销较低的读－写锁策略</h4><blockquote>
<p>​	<code>volatile</code> 的功能还不足以实现计数器。因为 <code>++x</code> 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 <code>volatile</code> 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 <code>volatile</code> 变量来减少公共代码路径的开销。 安全的计数器使用 <code>synchronized</code> 确保增量操作是原子的，并使用 <code>volatile</code> 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 <code>volatile</code> 读操作，这通常要优于一个无竞争的锁获取的开销。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesyCounter</span> &#123;</span><br><span class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></span><br><span class="line">    <span class="comment">// All mutative operations MUST be done with the &#x27;this&#x27; lock held</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检查-double-checked"><a href="#双重检查-double-checked" class="headerlink" title="双重检查(double-checked)"></a>双重检查(<code>double-checked</code>)</h4><blockquote>
<p>​	单例模式的一种实现方式，但很多人会忽略 <code>volatile</code> 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 <code>100%</code>，说不定在未来的某个时刻，隐藏的 <code>bug </code>就出来了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><blockquote>
<p>​	当某个类的整体定义为<code>final</code>时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
</blockquote>
<blockquote>
<p>​	注意：<code>final</code>类中的所有方法都隐式为<code>final</code>，因为无法覆盖他们，所以在<code>final</code>类中给任何方法添加<code>final</code>关键字是没有任何意义的。</p>
</blockquote>
<blockquote>
<p>​	这里顺道说说<code>final</code>类型的类如何拓展? 比如<code>String</code>是<code>final</code>类型，我们想写个<code>MyString</code>复用所有<code>String</code>中方法，同时增加一个新的<code>toMyString()</code>的方法，应该如何做? </p>
</blockquote>
<blockquote>
<p>​	设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的(<code>final</code>修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toMyString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><blockquote>
<p>常规的使用就不说了，这里说下:</p>
<ul>
<li><code>private</code> 方法是隐式的<code>final</code></li>
<li><code>final</code>方法是可以被重载的</li>
</ul>
</blockquote>
<blockquote>
<p><strong>重载(<code>Overload</code>)</strong></p>
<ul>
<li>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数&#x2F;类型。</li>
<li>是一个类中多态性的一种表现。</li>
<li>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是<code>fun(int, float)</code>， 但是不能为<code>fun(int, int)）</code>；</li>
<li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
<li>方法的异常类型和数目不会对重载造成影响；</li>
<li>对于继承来说，如果某一方法在父类中是访问权限是<code>priavte</code>，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li>
</ul>
<p><strong>重写(<code>Override</code>)</strong></p>
<ul>
<li>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</li>
<li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li>
<li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li>
<li>被覆盖的方法不能为<code>private</code>，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
</ul>
</blockquote>
<h4 id="private-final"><a href="#private-final" class="headerlink" title="private final"></a><code>private final</code></h4><blockquote>
<p>​	类中所有<code>private</code>方法都隐式地指定为<code>final</code>的，由于无法取用<code>private</code>方法，所以也就不能覆盖它。可以对<code>private</code>方法增添<code>final</code>关键字，但这样做并没有什么好处。看下下面的例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Base</span> <span class="variable">father</span> <span class="operator">=</span> son;</span><br><span class="line">        <span class="comment">//father.test();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>Base</code>和<code>Son</code>都有方法<code>test()</code>，但是这并不是一种覆盖，因为<code>private</code>所修饰的方法是隐式的<code>final</code>，也就是无法被继承，所以更不用说是覆盖了，在<code>Son</code>中的<code>test()</code>方法不过是属于<code>Son</code>的新成员罢了，<code>So</code>n进行向上转型得到<code>father</code>，但是<code>father.test()</code>是不可执行的，因为<code>Base</code>中的<code>test</code>方法是<code>private</code>的，无法被访问到。</p>
</blockquote>
<h4 id="final方法是可以被重载的"><a href="#final方法是可以被重载的" class="headerlink" title="final方法是可以被重载的"></a><code>final</code>方法是可以被重载的</h4><blockquote>
<p>​	我们知道父类的<code>final</code>方法是不能够被子类重写的，那么<code>final</code>方法可以被重载吗?  答案是可以的，下面代码是正确的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExampleParent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h3><blockquote>
<p>​	<code>Java</code>允许在参数列表中以声明的方式将参数指明为<code>final</code>，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
</blockquote>
<h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><blockquote>
<p>常规的用法比较简单，这里通过下面三个问题进一步说明。</p>
</blockquote>
<h4 id="所有的final修饰的字段都是编译期常量吗"><a href="#所有的final修饰的字段都是编译期常量吗" class="headerlink" title="所有的final修饰的字段都是编译期常量吗?"></a>所有的<code>final</code>修饰的字段都是编译期常量吗?</h4><blockquote>
<p>​	现在来看编译期常量和非编译期常量, 如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是<code>k</code>的值在被初始化后无法被更改。</p>
</blockquote>
<h4 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a><code>static final</code></h4><blockquote>
<p>​	一个既是<code>static</code>又是<code>final</code> 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码某次输出结果：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=2 k2=7</span><br><span class="line">k=8 k2=7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	我们可以发现对于不同的对象k的值是不同的，但是<code>k2</code>的值却是相同的，这是为什么呢? 因为<code>static</code>关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为<code>static final</code>所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p>
</blockquote>
<h4 id="blank-final"><a href="#blank-final" class="headerlink" title="blank final"></a><code>blank final</code></h4><blockquote>
<p>​	<code>Java</code>允许生成空白<code>final</code>，也就是说被声明为<code>final</code>但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白<code>final</code>)</li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。</li>
</ul>
<p>这增强了<code>final</code>的灵活性。</p>
</blockquote>
<blockquote>
<p>看下面代码:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> i2;<span class="comment">//空白final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        i2 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到<code>i2</code>的赋值更为灵活。但是请注意，如果字段由<code>static</code>和<code>final</code>修饰，仅能在定义处赋值，因为该字段不属于对象，属于这个类。</p>
</blockquote>
<h3 id="使用-final-的限制条件和局限性"><a href="#使用-final-的限制条件和局限性" class="headerlink" title="使用 final 的限制条件和局限性"></a>使用 <code>final</code> 的限制条件和局限性</h3><blockquote>
<p>当声明一个 <code>final</code> 成员时，必须在构造函数退出前设置它的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">myField</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> myField;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    myField = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将指向对象的成员声明为 <code>final</code> 只能将该引用设为不可变的，而非所指的对象。</p>
</blockquote>
<blockquote>
<p>下面的方法仍然可以修改该 <code>list</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明为 <code>final</code> 可以保证如下操作不合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">myList = someOtherList;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 <code>final</code>，则必须提供其他方式保证线程安全。</p>
<p>​	“ 其他方式 “ 可以包括声明成员为 <code>volatile</code>，使用 <code>synchronized</code> 或者显式 <code>Lock</code> 控制所有该成员的访问。</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><code>CAS</code></h2><blockquote>
<ul>
<li><code>Java</code>中 <strong><code>synchronized</code></strong> 和 <strong><code>ReentrantLock</code></strong> 等 独占锁 就是 <strong><code>悲观锁</code></strong> 思想的实现</li>
<li>在<code>Java</code>中**<code>java.util.concurrent.atomic</code>包下面的原子变量类**就是使用了<code>乐观锁</code>的一种实现方式 <strong><code>CAS</code></strong> 实现的</li>
<li>管程即<code>monitor</code>是<code>阻塞式的悲观锁</code>实现<code>并发控制</code>，这章我们将通过<code>非阻塞式的乐观锁</code>的来实现<code>并发控制</code></li>
<li><strong>CAS有三个操作值：内存值V，预期值A，要修改的值B，当且仅当预期值A等于当前内存值V的时候，才将内存值更新为B。</strong></li>
</ul>
</blockquote>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><blockquote>
<p>有如下需求，保证<code>account.withdraw</code>取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用重量级锁synchronized来保证多线程访问共享资源发生的安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountCas</span>(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决思路-无锁</strong></p>
<blockquote>
<p>​	上面的代码中使用<code>synchronized加锁</code>操作来<code>保证线程安全</code>，但是 **<code>synchronized</code>加锁操作太耗费资源 (因为底层使用了操作系统<code>mutex</code>指令, 造成内核态和用户态的切换)**，这里我们使用 <strong><code>无锁</code></strong> 来解决此问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountCas</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">	<span class="comment">//使用原子整数: 底层使用CAS+重试的机制</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AccountCas</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//得到原子整数的值</span></span><br><span class="line">		<span class="keyword">return</span> balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">//获得修改前的值</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">			<span class="comment">//获得修改后的值</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">			<span class="comment">//比较并设置值</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,</span></span><br><span class="line"><span class="comment">				就继续where(true),如果匹配上了, 将next值设置给共享变量.</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS-与-volatile-重点"><a href="#CAS-与-volatile-重点" class="headerlink" title="CAS 与 volatile (重点)"></a><code>CAS</code> 与 <code>volatile</code> (重点)</h3><blockquote>
<p>​	使用原子操作来保证线程访问共享资源的安全性, <code>cas+重试</code>的机制来确保(乐观锁思想), 相对于悲观锁思想的<code>synchronized</code>,<code>reentrantLock</code>来说, <code>cas</code>的方式效率会更好!</p>
</blockquote>
<h4 id="cas-重试-的原理"><a href="#cas-重试-的原理" class="headerlink" title="cas + 重试 的原理"></a><code>cas</code> + 重试 的原理</h4><blockquote>
<p>前面看到的<code>AtomicInteger</code>的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         compareAndSet 保证操作共享变量安全性的操作:</span></span><br><span class="line"><span class="comment">         ① 线程A首先获取balance.get(),拿到当前的balance值prev</span></span><br><span class="line"><span class="comment">         ② 根据这个prev值 - amount值 = 修改后的值next</span></span><br><span class="line"><span class="comment">         ③ 调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的</span></span><br><span class="line"><span class="comment">         	balance值相同;</span></span><br><span class="line"><span class="comment">         	3.1、如果相同,表示其他线程没有修改balance的值, 此时就可以将next值</span></span><br><span class="line"><span class="comment">         		设置给balance属性</span></span><br><span class="line"><span class="comment">         	3.2、如果不相同,表示其他线程也修改了balance值, 此时就设置next值失败, </span></span><br><span class="line"><span class="comment">				然后一直重试, 重新获取balance.get()的值,计算出next值,</span></span><br><span class="line"><span class="comment">				并判断本次的prev和balnce的值是否相同...重复上面操作</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (atomicInteger.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	其中的关键是 <code>compareAndSet（比较并设置值）</code>，它的简称就是 <code>CAS</code> （也有 <code>Compare And Swap </code>的说法），它必须是<code>原子操作</code>。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/436a166f7e783537464879edf14ccc0c.png"></p>
<p><strong>流程 :</strong></p>
<blockquote>
<p>​	当一个线程要去修改<code>Account</code>对象中的值时，先获取值<code>prev</code>（调用<code>get</code>方法），然后再将其设置为新的值<code>next</code>（调用<code>cas</code>方法）。在调用<code>cas</code>方法时，会将<code>prev</code>与<code>Account</code>中的余额进行比较。<br>​	如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。<br>​	如果两者不相等，就不设置值，重新获取值<code>prev</code>（调用<code>get</code>方法），然后再将其设置为新的值<code>next</code>（调用cas方法），直到修改成功为止。</p>
</blockquote>
<p><strong>注意 :</strong></p>
<blockquote>
<p>​	其实 <code>CAS</code> 的底层是 <code>lock cmpxchg</code> 指令（<code>X86</code> 架构），在单核 <code>CPU</code> 和多核 <code>CPU</code> 下都能够保证【比较-交换】的 原子性。<br>​	在多核状态下，某个核执行到带 <code>lock</code> 的指令时，<code>CPU</code> 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p>
</blockquote>
<h4 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a><code>volatile</code>的作用</h4><blockquote>
<p>​	在上面代码中的<code>AtomicInteger</code>类，保存值的<code>value</code>属性使用了<code>volatile</code> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 <code>volatile</code> 修饰。<br>​	<code>volatile</code>可以用来修饰 成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <code>volatile</code> 变量都是直接操作主存。即一个线程对 <code>volatile</code> 变量的修改，对另一个线程可见。<br>​	注意: <code>volatile</code> 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
<p>​	<strong><code>CAS</code> 必须借助 <code>volatile</code> 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
</blockquote>
<h4 id="为什么CAS-重试-无锁-效率高"><a href="#为什么CAS-重试-无锁-效率高" class="headerlink" title="为什么CAS+重试(无锁)效率高"></a>为什么<code>CAS</code>+重试(无锁)效率高</h4><blockquote>
<p>​	使用<code>CAS+重试</code>—无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 <code>synchronized</code>会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。<br>​	打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大<br>​	但无锁情况下，因为线程要保持运行，需要额外 <code>CPU</code> 的支持，<code>CPU</code> 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p>
</blockquote>
<h3 id="CAS-的特点-乐观锁和悲观锁的特点"><a href="#CAS-的特点-乐观锁和悲观锁的特点" class="headerlink" title="CAS 的特点 (乐观锁和悲观锁的特点)"></a><code>CAS</code> 的特点 (乐观锁和悲观锁的特点)</h3><blockquote>
<p>​	结合 <code>CAS</code> 和 <code>volatile</code> 可以实现无锁并发，适用于线程数少、多核 <code>CPU</code> 的场景下。</p>
<p>​	<code>CAS</code> 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br>​	<code>synchronized</code> 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。<br>​	<strong><code>CAS</code> 体现的是无锁并发、无阻塞并发</strong>，请仔细体会这两句话的意思<br>​	因为没有使用 <code>synchronized</code>，所以线程不会陷入阻塞，这是效率提升的因素之一<br>​	但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</p>
</blockquote>
<h3 id="原子整数-内部通过CAS来实现-Atom"><a href="#原子整数-内部通过CAS来实现-Atom" class="headerlink" title="原子整数 (内部通过CAS来实现-Atom)"></a>原子整数 (内部通过<code>CAS</code>来实现-<code>Atom</code>)</h3><blockquote>
<p>​	<code>java.util.concurrent.atomic</code>并发包提供了一些并发工具类，这里把它分成五类：<br>​	使用原子的方式 (共享数据为基本数据类型原子类)<br>​	<code>AtomicInteger</code>：整型原子类<br>​	<code>AtomicLong</code>：长整型原子类<br>​	<code>AtomicBoolean</code> ：布尔型原子类<br>​	上面三个类提供的方法几乎相同，所以我们将以 <code>AtomicInteger</code>为例子来介绍。<br>​	先讨论原子整数类，以 <code>AtomicInteger</code> 为例讨论它的<code>api</code>接口：通过观察源码可以发现<br>​	<code>AtomicInteger</code> 内部都是通过<code>cas</code>的原理来实现的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子: updateAndGet的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> <span class="title class_">IntUnaryOperator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">applyAsInt</span><span class="params">(<span class="type">int</span> operand)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (<code>AtomicReference</code>)</h3><blockquote>
<p>原子引用的作用: <strong>保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)</strong></p>
</blockquote>
<blockquote>
<p>为什么需要原子引用类型 ? (引用数据类型原子类)</p>
<ul>
<li><code>AtomicReference</code></li>
<li><code>AtomicMarkableReference</code></li>
<li><code>AtomicStampedReference</code> (可以解决<code>ABA</code>问题)</li>
</ul>
<p>为什么需要原子引用类型？保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。</p>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 <code>CAS</code> 进行原子更新时可能出现的 <code>ABA</code> 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记的引用类型。该类将 <code>boolean</code> 标记与引用关联起来，也可以解决使用 <code>CAS</code> 进行原子更新时可能出现的 <code>ABA</code> 问题。</li>
</ul>
</blockquote>
<p>例子 : 使用原子引用实现<code>BigDecimal</code>存取款的线程安全：</p>
<p>下面这个是不安全的实现过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决代码如下：在<code>AtomicReference类</code>中，存在一个<code>value</code>类型的变量，保存对<code>BigDecimal</code>对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用，泛型类型为小数类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ABA-问题及解决-重点"><a href="#ABA-问题及解决-重点" class="headerlink" title="ABA 问题及解决 (重点)"></a><code>ABA</code> 问题及解决 (<code>重点</code>)</h3><blockquote>
<p>​	如下程序所示，虽然 <strong>在 <code>other</code> 方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值</strong>，**<code>main</code>线程对<code>修改过共享变量的过程</code>是不可见的，这种操作这对业务代码并无影响。**</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="comment">// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS</span></span><br><span class="line">        	<span class="comment">// 可以修改成功, B</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="comment">// 同上, 修改为A</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201227200916774.png"></p>
<blockquote>
<p>​	因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是<code>A</code>，变成了<code>B</code>，又变成了<code>A</code>，那么使用<code>CAS</code>进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>​	<code>ABA</code>问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加<code>1</code>，那么<code>A-&gt;B-&gt;A</code>就会变成<code>1A-&gt;2B-&gt;3A</code>。</p>
<p>​	从<code>Java 1.5</code>开始，<code>JDK</code>的<code>Atomic</code>包里提供了一个类<code>AtomicStampedReference</code>来解决<code>ABA</code>问题。这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</blockquote>
<h3 id="AtomicStampedReference-加版本号解决ABA问题"><a href="#AtomicStampedReference-加版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (加版本号解决ABA问题)"></a><code>AtomicStampedReference</code> (加版本号解决<code>ABA</code>问题)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicMarkableReference-标记cas的共享变量是否被修改过"><a href="#AtomicMarkableReference-标记cas的共享变量是否被修改过" class="headerlink" title="AtomicMarkableReference (标记cas的共享变量是否被修改过)"></a><code>AtomicMarkableReference</code> (标记<code>cas</code>的共享变量是否被修改过)</h3><blockquote>
<ul>
<li><code>AtomicStampedReference</code> 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：<code>A -&gt; B -&gt; A -&gt;C</code>，通过<code>AtomicStampedReference</code>，我们可以知道，引用变量中途被更改了几次。</li>
<li>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了<code>AtomicMarkableReference</code></li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/23026a8d2e27e7a4f474d15f0e3684bc.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestABAAtomicMarkableReference&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;打扫卫生的线程 start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.062</span> guizy.TestABAAtomicMarkableReference [main] - 主线程 start...</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.069</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 装满了垃圾</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.312</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="number">0</span>] - 打扫卫生的线程 start...</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">24.313</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="number">0</span>] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.313</span> guizy.TestABAAtomicMarkableReference [main] - 主线程想换一只新垃圾袋？</span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - 换了么？<span class="literal">false</span></span><br><span class="line"><span class="number">23</span>:<span class="number">00</span>:<span class="number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋</span><br></pre></td></tr></table></figure>

<p>举例2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C mark &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;A mark &quot;</span> + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20201227201642314.png"></p>
<h3 id="AtomicStampedReference和AtomicMarkableReference两者的区别"><a href="#AtomicStampedReference和AtomicMarkableReference两者的区别" class="headerlink" title="AtomicStampedReference和AtomicMarkableReference两者的区别"></a><code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>两者的区别</h3><blockquote>
<ul>
<li><code>AtomicStampedReference</code> 需要我们传入 整型变量 作为版本号，来判定是否被更改过</li>
<li><code>AtomicMarkableReference</code>需要我们传入布尔变量 作为标记，来判断是否被更改过</li>
</ul>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。(创建的线程,实际最后要和操作系统的线程做映射,很消耗资源)</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</blockquote>
<h3 id="线程池的继承关系"><a href="#线程池的继承关系" class="headerlink" title="线程池的继承关系"></a>线程池的继承关系</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210102231106611.png"></p>
<h3 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a><code>Executor</code> 框架结构</h3><h4 id="任务类-Runnable-Callable"><a href="#任务类-Runnable-Callable" class="headerlink" title="任务类 (Runnable &#x2F;Callable)"></a>任务类 (<code>Runnable</code> &#x2F;<code>Callable</code>)</h4><blockquote>
<p>​	执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code>接口。<code>Runnable</code> 接口或 <code>Callable</code> 接口 实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p>
</blockquote>
<h4 id="任务的执行-Executor"><a href="#任务的执行-Executor" class="headerlink" title="任务的执行 (Executor)"></a>任务的执行 (<code>Executor</code>)</h4><blockquote>
<p>​	如上图所示，包括任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。<br>​	这里有很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，它在我们实际使用线程池的过程中，使用频率非常高。</p>
</blockquote>
<h4 id="异步计算的结果-Future"><a href="#异步计算的结果-Future" class="headerlink" title="异步计算的结果 (Future)"></a>异步计算的结果 (<code>Future</code>)</h4><blockquote>
<ul>
<li><code>Future</code> 接口 以及 <code>Future</code>接口的 实现类 <code>FutureTask</code> 类 都可以代表异步计算的结果。</li>
<li>当把 <code>Runnable</code>接口 或 <code>Callable</code> 接口 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个<code> FutureTask</code>对象）<ul>
<li><code>Futrue</code>和<code>join</code>方法类似, <code>futrue</code>的<code>get</code>方法需要等待线程执行完毕,才可以获取的线程的执行结果。也称之为保护性暂停</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210102232801152.png"></p>
<h3 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a><code>Executor</code> 框架的使用示意图</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw.png"></p>
<blockquote>
<ol>
<li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p>
</li>
<li><p>把创建完成的实现 <code>Runnable</code>&#x2F;<code>Callable</code>接口的对象 直接交给 <code>ExecutorService</code> 执行:</p>
<ul>
<li><code>ExecutorService.execute（Runnable command））</code></li>
<li><code>ExecutorService.submit（Runnable task）</code></li>
<li><code>ExecutorService.submit（Callable &lt;T&gt; task）</code>。</li>
</ul>
</li>
<li><p>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现Future接口的对象<br>（刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，submit()会返回一个 <code>FutureTask</code> 对象）。</p>
</li>
<li><p>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning</code>）来取消此任务的执行</p>
</li>
</ol>
</blockquote>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><blockquote>
<p><code>ThreadPoolExecutor</code> 使用 <code>int</code> 的高 <code>3</code> 位来表示线程池状态，低 <code>29</code> 位表示线程数量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// RUNNING 高3位为111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHUTDOWN 高3位为000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高3位 011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">高3位的值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center">任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center">终结状态</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>从数字上比较(第一位是符号位)，<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code></li>
</ul>
</blockquote>
<blockquote>
<p>线程池状态和线程池中线程的数量 <strong>由一个原子整型<code>ctl</code>来共同表示</strong></p>
<ul>
<li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次<code>CAS</code>同时更改两个属性的值</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不是所有平台的int都是32位。</span></span><br><span class="line"><span class="comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span></span><br><span class="line"><span class="comment">// 高3位为0，剩余位数全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span></span><br><span class="line"><span class="comment">// CAPACITY 的高3位为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	获取线程池状态、线程数量以及合并两个值的操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="comment">// 该操作会让除高3位以外的数全部变为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行线程数</span></span><br><span class="line"><span class="comment">// 该操作会让高3位为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算ctl新值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这些信息存储在一个原子变量 <code>ctl</code> 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 <code>cas </code>原子操作进行赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的属性"><a href="#线程池的属性" class="headerlink" title="线程池的属性"></a>线程池的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程，内部封装了Thread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="构造方法及参数"><a href="#构造方法及参数" class="headerlink" title="构造方法及参数"></a>构造方法及参数</h3><blockquote>
<p>​	<code>ThreadPoolExecutor</code>最全的构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong><code>corePoolSize</code></strong> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于<code>corePoolSize</code>, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为<code>corePoolSize</code>，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有核心线程。</li>
<li><strong><code>workQueue</code></strong> 用来保存等待被执行的任务的阻塞队列. 在<code>JDK</code>中提供了如下阻塞队列: <ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按<code>FIFO</code>排序任务；</li>
<li><code>LinkedBlockingQuene</code>: 基于链表结构的阻塞队列，按<code>FIF</code>O排序任务，吞吐量通常要高于<code>ArrayBlockingQuene</code>；</li>
<li><code>SynchronousQuene</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQuene</code>；</li>
<li><code>PriorityBlockingQuene</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><p><strong><code>maximumPoolSize</code></strong> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于<code>maximumPoolSize</code>；当阻塞队列是无界队列, 则<code>maximumPoolSize</code>则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入<code>workQueue</code>.</p>
</li>
<li><p>**<code>keepAliveTime</code> **线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于<code>corePoolSize</code>时才有用, 超过这个时间的空闲线程将被终止；</p>
</li>
<li><p><strong><code>unit</code></strong> <code>keepAliveTime</code>的单位</p>
</li>
<li><p>**<code>threadFactory</code> **创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为<code>DefaultThreadFactory</code></p>
</li>
<li><p>**<code>handler</code> **线程池的饱和策略，拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
<p> 当然也可以根据应用场景实现<code>RejectedExecutionHandler</code>接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
</li>
</ul>
</blockquote>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式<img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202214622633.png"></h3><blockquote>
<p>当一个任务传给线程池以后，可能有以下几种可能:</p>
<ul>
<li>将任务分配给一个核心线程来执行</li>
<li>核心线程都在执行任务，将任务放到阻塞队列<code>workQueue</code>中等待被执行</li>
<li>阻塞队列满了，使用救急线程来执行任务<ul>
<li>救急线程用完以后，超过生存时间（<code>keepAliveTime</code>）后会被释放</li>
</ul>
</li>
<li>任务总数大于了 最大线程数（<code>maximumPoolSize</code>）与阻塞队列容量的最大值（<code>workQueue.capacity</code>），使用拒接策略</li>
</ul>
</blockquote>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><h4 id="AbortPolicy-中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略"><a href="#AbortPolicy-中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略" class="headerlink" title="AbortPolicy 中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略"></a><code>AbortPolicy</code> 中止策略：丢弃任务并抛出<code>RejectedExecutionException</code>异常。这是默认策略</h4><blockquote>
<ul>
<li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li>
<li><strong>功能：</strong>当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.</li>
<li><strong>使用场景：</strong>这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。<code>ThreadPoolExecutor</code>中默认的策略就是<code>AbortPolicy</code>，<code>ExecutorService</code>接口的系列<code>ThreadPoolExecutor</code>因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，<code>ExecutorService</code>中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</li>
</ul>
</blockquote>
<h4 id="CallerRunsPolicy-调用者运行策略：由调用线程处理该任务。"><a href="#CallerRunsPolicy-调用者运行策略：由调用线程处理该任务。" class="headerlink" title="CallerRunsPolicy 调用者运行策略：由调用线程处理该任务。"></a><code>CallerRunsPolicy 调用者运行策略</code>：由调用线程处理该任务。</h4><blockquote>
<ul>
<li><strong>功能：</strong>当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。</li>
<li><strong>使用场景：</strong>一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</li>
</ul>
</blockquote>
<h4 id="DiscardPolicy-丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。"><a href="#DiscardPolicy-丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。" class="headerlink" title="DiscardPolicy 丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。"></a><code>DiscardPolicy 丢弃策略</code>：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</h4><blockquote>
<ul>
<li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li>
<li><strong>功能：</strong>直接静悄悄的丢弃这个任务，不触发任何动作。</li>
<li><strong>使用场景：</strong>如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</li>
</ul>
</blockquote>
<h4 id="DiscardOldestPolicy-弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。"><a href="#DiscardOldestPolicy-弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。" class="headerlink" title="DiscardOldestPolicy 弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。"></a><code>DiscardOldestPolicy 弃老策略</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</h4><blockquote>
<ul>
<li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li>
<li><strong>功能：</strong>如果线程池未关闭，就弹出队列头部的元素，然后尝试执行</li>
<li><strong>使用场景：</strong>这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 <code>corePoolSize</code> 并没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 <code>maximumPoolSize - corePoolSize</code> 数目的线程来救急。</li>
<li>如果线程到达 <code>maximumPoolSize</code> 仍然有新任务这时会执行拒绝策略。拒绝策略 <code>jdk</code> 提供了 下面的前<code>4</code> 种实现，其它著名框架也提供了实现<ol>
<li><code>ThreadPoolExecutor.AbortPolicy</code>让调用者抛出 <code>RejectedExecutionException</code> 异常，这是默认策略</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 让调用者运行任务</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code> 放弃本次任务</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 放弃队列中最早的任务，本任务取而代之</li>
<li><code>Dubbo</code> 的实现，在抛出 <code>RejectedExecutionException</code> 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位问题</li>
<li><code>Netty</code> 的实现，是创建一个新线程来执行任务</li>
<li><code>ActiveMQ</code> 的实现，带超时等待<code>（60s）</code>尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li><code>PinPoint</code> 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ol>
</li>
<li>当高峰过去后，超过<code>corePoolSize</code> 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由<code>keepAliveTime</code> 和 <code>unit</code> 来控制。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        <span class="comment">// 创建有界阻塞队列, 用来存放任务对象</span></span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 创建线程工厂: 主要给线程起名字</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;guizy_thread&quot;</span> + threadId.getAndIncrement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        <span class="comment">// 拒绝策略采用默认策略</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行20个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210103001214433.png"></p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h3><blockquote>
<ul>
<li>这个是<code>Executors类</code>提供的工厂方法来创建线程池！<code>Executors</code> 是<code>Executor</code> 框架的工具类！</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFixedThreadPool</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 自定义线程工厂</span></span><br><span class="line">      <span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">         <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread_&quot;</span> + atomicInteger.getAndIncrement());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建核心线程数量为2的线程池</span></span><br><span class="line">      <span class="comment">// 通过 ThreadFactory可以给线程添加名字</span></span><br><span class="line"></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, factory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 任务</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;this is fixedThreadPool&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      executorService.execute(runnable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>固定大小的线程池可以传入两个参数</p>
<ul>
<li>核心线程数：**<code>nThreads</code>**</li>
<li>线程工厂：**<code>threadFactory</code>**</li>
</ul>
</blockquote>
<blockquote>
<p>内部调用的构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li><code>阻塞队列是无界的，可以放任意数量的任务</code></li>
<li><strong>适用于任务量已知，相对耗时的任务</strong></li>
</ol>
</blockquote>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 内部构造方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ul>
<li><p>没有核心线程，最大线程数为<code>Integer.MAX_VALUE</code>，所有创建的线程都是救急线程 (可以无限创建)，空闲时生存时间为<code>60</code>秒</p>
</li>
<li><p>阻塞队列使用的是<code>SynchronousQueue</code></p>
</li>
<li><p><code>SynchronousQueue</code>是一种特殊的队列</p>
<ul>
<li>没有容量，没有线程来取是放不进去的</li>
<li>只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
<li><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 <code>1</code>分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
<li><p><code>newCachedThreadPool</code>在没有任务执行时，当线程的空闲时间超过<code>keepAliveTime</code>，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开&#96;销；</p>
</li>
</ul>
</blockquote>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><blockquote>
<ul>
<li><p>希望多个任务排队执行。线程数固定为 <code>1</code>，任务数多于 <code>1 </code>时，会放入无界队列排队。 任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p>区别：</p>
<ul>
<li>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而<code>newSingleThreadExecutor</code>线程池还会新建一个线程，保证池的正常工作</li>
<li><code>Executors.newSingleThreadExecutor()</code> 线程个数始终为<code>1</code>，不能修改<br><code>FinalizableDelegatedExecutorService</code> 应用的是装饰器模式，只对外暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中特有的方法</li>
<li>和<code>Executors.newFixedThreadPool(1)</code> 初始时为<code>1</code>时的区别：<code>Executors.newFixedThreadPool(1)</code> 初始时为<code>1</code>，以后还可以修改，对外暴露的是 <code>ThreadPoolExecutor</code> 对象，可以强转后调用 <code>setCorePoolSize</code> 等方法进行修改</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Executors-返回线程池对象的弊端如下"><a href="#Executors-返回线程池对象的弊端如下" class="headerlink" title="Executors 返回线程池对象的弊端如下"></a><code>Executors</code> 返回线程池对象的弊端如下</h3><blockquote>
<p>注意: <code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许<strong>请求</strong>的队列长度为 <code>Integer.MAX_VALUE</code> (无界阻塞队列),可能堆积大量的请求，从而导致 <code>OOM</code>。</li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许<strong>创建</strong>的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li>
</ul>
</blockquote>
<blockquote>
<p>避免上面的措施 : 使用有界队列，控制线程创建数量。</p>
<p>除了避免 <code>OOM</code> 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
</blockquote>
<h3 id="执行-提交任务-execute-submit"><a href="#执行-提交任务-execute-submit" class="headerlink" title="执行&#x2F;提交任务 execute/submit"></a>执行&#x2F;提交任务 <code>execute/submit</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a><code>execute()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute(Runnable command)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入一个<code>Runnable</code>对象，执行其中的<code>run</code>方法</p>
</blockquote>
<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a><code>submit()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入一个<code>Callable</code>对象，用<code>Future</code>来<strong>捕获返回值</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过submit执行Callable中的call方法</span></span><br><span class="line"><span class="comment">// 通过Future来捕获返回值</span></span><br><span class="line">Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello submit&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看捕获的返回值</span></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池-shutdown"><a href="#关闭线程池-shutdown" class="headerlink" title="关闭线程池 shutdown()"></a>关闭线程池 <code>shutdown()</code></h3><blockquote>
<ul>
<li><strong>将线程池的状态改为 <code>SHUTDOWN</code></strong></li>
<li><strong>不再接受新任务，但是会将阻塞队列中的任务执行完</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程池的状态改为 SHUTDOWN</span></span><br><span class="line"><span class="comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        </span><br><span class="line">  		<span class="comment">// 中断空闲线程（没有执行任务的线程）</span></span><br><span class="line">        <span class="comment">// Idle：空闲的</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结，不一定成功</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 终结失败的条件</span></span><br><span class="line">        <span class="comment">// 线程池状态为RUNNING</span></span><br><span class="line">        <span class="comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span></span><br><span class="line">        <span class="comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果活跃线程数不为0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 中断空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处于可以终结的状态</span></span><br><span class="line">            <span class="comment">// 通过CAS将线程池状态改为TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过CAS将线程池状态改为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a><code>shutdownNow()</code></h3><blockquote>
<ul>
<li><strong>将线程池的状态改为 <code>STOP</code></strong></li>
<li><strong>不再接受新任务，也不会再执行阻塞队列中的任务</strong></li>
<li>会将阻塞队列中未执行的任务返回给调用者</li>
<li>并用 <code>interrupt</code> 的方式中断正在执行的任务</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程池的状态改为 STOP</span></span><br><span class="line"><span class="comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span></span><br><span class="line"><span class="comment">* 会将阻塞队列中未执行的任务返回给调用者</span></span><br><span class="line"><span class="comment">* 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改状态为STOP，不执行任何任务</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 中断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将未执行的任务从队列中移除，然后返回给调用者</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="创建多大的线程池合适"><a href="#创建多大的线程池合适" class="headerlink" title="创建多大的线程池合适?"></a>创建多大的线程池合适?</h3><blockquote>
<p>过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存</p>
<ol>
<li><h6 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a><code>CPU</code> 密集型运算</h6><p>通常采用 <code>cpu</code> 核数 <code>+ 1</code> 能够实现最优的 <code>CPU</code> 利用率，<code>+1</code> 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 <code>CPU</code> 时钟周期不被浪费</p>
</li>
<li><h6 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a><code>I/O</code> 密集型运算</h6><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 <code>CPU</code> 资源，但当你执行 <code>I/O</code> 操作时、远程<code>RPC</code> 调用时，包括进行数据库操作时，这时候 <code>CPU</code> 就闲下来了，你可以利用多线程提高它的利用率。</p>
<ol>
<li>经验公式如下：<code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code><br>例如 <code>4</code> 核 <code>CPU</code> 计算时间是 <code>50%</code> ，其它等待时间是 <code>50%</code>，期望 <code>cpu</code> 被 <code>100% </code>利用，套用公式<br><code>4 * 100% * 100% / 50% = 8</code><br>例如 <code>4</code> 核 <code>CPU</code> 计算时间是 <code>10%</code> ，其它等待时间是 <code>90%</code>，期望<code> cpu</code> 被 <code>100% </code>利用，套用公式<br><code>4 * 100% * 100% / 10% = 40</code></li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h3><blockquote>
<p>​	<code>ScheduledThreadPoolExecutor</code>继承自<code> ThreadPoolExecutor</code>，为任务提供延迟或周期执行，属于线程池的一种。和 <code>ThreadPoolExecutor </code>相比，它还具有以下几种特性:</p>
<ul>
<li>使用专门的任务类型—<code>ScheduledFutureTask</code> 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 <code>ExecutorService</code> 来执行)。</li>
<li>使用专门的存储队列—<code>DelayedWorkQueue</code> 来存储任务，<code>DelayedWorkQueue</code> 是无界延迟队列<code>DelayQueue</code> 的一种。相比<code>ThreadPoolExecutor</code>也简化了执行机制(<code>delayedExecute</code>方法，后面单独分析)。</li>
<li>支持可选的<code>run-after-shutdown</code>参数，在池被关闭(<code>shutdown</code>)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 <code>shutdown</code> 操作重叠时，复查逻辑也不相同</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">&quot;任务1, 执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">&quot;任务2, 执行时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()), <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任务<span class="number">1</span>, 执行时间:Sun Jan <span class="number">03</span> 08:<span class="number">53</span>:<span class="number">54</span> CST <span class="number">2021</span></span><br><span class="line">任务<span class="number">2</span>, 执行时间:Sun Jan <span class="number">03</span> 08:<span class="number">53</span>:<span class="number">54</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<h4 id="ScheduledExecutorService-中-scheduleAtFixedRate方法的使用"><a href="#ScheduledExecutorService-中-scheduleAtFixedRate方法的使用" class="headerlink" title="ScheduledExecutorService 中 scheduleAtFixedRate方法的使用"></a><code>ScheduledExecutorService</code> 中 <code>scheduleAtFixedRate</code>方法的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; log.debug(<span class="string">&quot;running&quot;</span>), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">08:<span class="number">51</span>:<span class="number">59.930</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">52</span>:<span class="number">01.050</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">02.049</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">03.045</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">04.046</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">05.045</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">52</span>:<span class="number">06.047</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡眠时间 &gt; 速率, 按睡眠时间打印</span></span><br><span class="line">08:<span class="number">54</span>:<span class="number">58.567</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">54</span>:<span class="number">59.675</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">01.684</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">03.685</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">55</span>:<span class="number">05.690</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br></pre></td></tr></table></figure>

<h4 id="ScheduledExecutorService-中scheduleWithFixedDelay方法的使用"><a href="#ScheduledExecutorService-中scheduleWithFixedDelay方法的使用" class="headerlink" title="ScheduledExecutorService 中scheduleWithFixedDelay方法的使用"></a><code>ScheduledExecutorService</code> 中<code>scheduleWithFixedDelay</code>方法的使用</h4><ul>
<li>睡眠时间 + 速率时间, 为打印的间隔时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        <span class="comment">// 延迟1s后, 按1s的速率打印running</span></span><br><span class="line">        executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">08:<span class="number">56</span>:<span class="number">22.581</span> guizy.TestTimer [main] - start....</span><br><span class="line">08:<span class="number">56</span>:<span class="number">23.674</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">26.679</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">29.680</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br><span class="line">08:<span class="number">56</span>:<span class="number">32.689</span> guizy.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running</span><br></pre></td></tr></table></figure>

<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><code>AQS</code></h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210202223902808.png"></p>
<blockquote>
<p><strong><code>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</code>。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制<code>AQS</code>是用<code>CLH</code>队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>​	<code>CLH</code>锁其实就是一种基于逻辑队列非线程饥饿的一种自旋公平锁。当多个线程竞争一把锁时，获取不到锁的线程，会排队进入<code>CLH</code>队列的队尾，然后自旋等待，直到其前驱线程释放锁。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210119105644735.png"></p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li><p>用 <code>state</code> 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p>
<ul>
<li><code>getState</code> - 获取 <code>state</code> 状态</li>
<li><code>setState</code> - 设置 <code>state</code> 状态</li>
<li><code>compareAndSetState</code> - <code>cas</code> 机制设置 <code>state</code> 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li><p>提供了基于 <code>FIFO</code> 的等待队列，类似于 <code>Monitor</code> 的 <code>EntryList</code></p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 <code>Monitor</code> 的 <code>WaitSet</code></p>
</li>
</ul>
</blockquote>
<p>​	子类主要实现这样一些方法（默认抛出 <code>UnsupportedOperationException</code>）</p>
<blockquote>
<ul>
<li><strong><code>tryAcquire</code></strong></li>
<li><strong><code>tryRelease</code></strong></li>
<li><strong><code>tryAcquireShared</code></strong></li>
<li><strong><code>tryReleaseShared</code></strong></li>
<li><strong><code>isHeldExclusively</code></strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	下面实现一个不可重入的阻塞式锁：使用<code>AbstractQueuedSynchronizer</code>自定义一个同步器来实现自定义锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guizy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/4 23:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;guizy.TestAQS&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAqs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁, 同一线程在锁释放前, 只能加一次锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 这里不需要确定原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的, 具体见volatile原理(写屏障)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a><code>ReentrantLock</code> 原理</h3><blockquote>
<p><code>ReentrantLock</code>提供了两个同步器，实现<code>公平锁</code>和<code>非公平锁</code>，默认是非公平锁！</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/14f43b7a0fa8b979b9101ab5170398cc.png"></p>
<h4 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h4><h5 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h5><blockquote>
<ul>
<li><code>加锁, 解锁</code>流程，先从构造器开始看，默认为非公平锁实现</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line"> 	sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有竞争时</p>
<ul>
<li>Thread-0成为锁的持有者</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/5ed1f22fcfc9dda5a8b3b1cc737f2bb5.png"></p>
<ul>
<li>第一个竞争出现时，查看源码的<code>NonfairSync</code>的<code>lock</code>方法</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/07d53face5cb7d27d43a9b8dbee38820.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的lock</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Thread-1</code> 执行了</p>
<ol>
<li><code>lock</code>方法中<code>CAS</code> 尝试将 <code>state</code> 由 <code>0</code> 改为 <code>1</code>，结果失败 (因为此时<code>CAS</code>操作, <code>state</code>已经为<code>1</code>了)</li>
<li><code>lock</code>方法中进一步调用<code>acquire</code>方法，进入 <code>tryAcquire</code> 逻辑，这里我们认为这时 <code>state</code> 已经是1，结果仍然失败</li>
<li>接下来进入 <code>acquire</code>方法的<code>addWaiter</code> 逻辑，构造 <code>Node</code> 队列 (双向链表实现)<ol>
<li>下图中黄色三角表示该 <code>Node</code> 的<code>waitStatus</code>状态，其中 <code>0</code> 为默认正常状态</li>
<li><code>Node</code> 的创建是懒惰的</li>
<li>其中第一个 <code>Node</code> 称为 <code>Dummy</code>（哑元）或哨兵，用来占位，并不关联线程</li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/be834858592889523943183e15acfa58.png"></p>
<blockquote>
<p>当前线程进入 <code>acquire</code>方法的 <code>acquireQueued</code> 逻辑</p>
<ol>
<li><code>acquireQueued</code> 会在一个死循环中不断尝试获得锁，失败后进入 <code>park</code> 阻塞</li>
<li>如果自己是紧邻着 <code>head</code>（排第二位），那么再次 <code>tryAcquire</code> 尝试获取锁，我们这里设置这时 <code>state</code> 仍为 <code>1</code>，失败</li>
<li>进入 <code>shouldParkAfterFailedAcquire</code> 逻辑，将前驱 <code>node</code>，即 <code>head</code> 的 <code>waitStatus</code> 改为 <code>-1</code>，这次返回 <code>false</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/d66b53fa0c1ecaffa3fae6580c846292.png"></p>
<blockquote>
<ol start="4">
<li><code>shouldParkAfterFailedAcquire</code> 执行完毕回到 <code>acquireQueued</code> ，再次 <code>tryAcquire</code> 尝试获取锁，当然这时 <code>state</code> 仍为 <code>1</code>，失败</li>
<li>当再次进入 <code>shouldParkAfterFailedAcquire</code> 时，这时因为其前驱 <code>node</code> 的 <code>waitStatus</code> 已经是 <code>-1</code>，这次返回 <code>true</code></li>
<li>进入<code>parkAndCheckInterrupt</code>， <code>Thread-1 park</code>（灰色表示已经阻塞）</li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210105234001801.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/844a2077a9096fed80b31ae91e8e8c13.png"></p>
<blockquote>
<ul>
<li>再次有多个线程经历上述过程竞争失败，变成这个样子</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c673a02e84847dd8e7fbef4944863a5f.png"></p>
<blockquote>
<p>​	<code>Thread-0</code> 调用<code>unlock</code>方法里的<code>release</code>方法释放锁，进入<code>tryRelease</code>(使用<code>ctrl+alt+b</code>查看<code>tryRelease</code>方法的具体<code>ReentrantLock</code>实现)流程，如果成功，<strong>设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>，<code>state = 0</code></strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/674d24535dcb379439c6105468bcb72b.png"></p>
<blockquote>
<p>​	<code>unlock</code>方法里的<code>release</code>方法方法中，如果当前队列不为 <code>null</code>，并且 <code>head</code> 的 <code>waitStatus = -1</code>，进入 <code>unparkSuccessor</code> 流程： <code>unparkSuccessor</code>中会找到队列中离 <code>head</code> 最近的一个 <code>Node</code>（没取消的），<code>unpark</code> 唤醒<code>Thread-1</code> 恢复其运行，本例中即为 <code>Thread-1</code> 回到 <code>Thread-1</code> 阻塞的位置继续执行, 会继续执行 <code>acquireQueued</code> 流程</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210105235033126.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0c4dd83170dbced9979e3c0a5b7cc69c.png"></p>
<blockquote>
<p>如果加锁成功（没有竞争），会设置 （<code>acquireQueued</code> 方法中）</p>
<ol>
<li><code>exclusiveOwnerThread</code> 为 <code>Thread-1</code>，<code>state = 1</code></li>
<li><code>head</code> 指向刚刚 <code>Thread-1</code> 所在的<code> Node</code>，该 <code>Node</code> 清空 <code>Thread</code></li>
<li>原本的 <code>head</code> 因为从链表断开，而可被垃圾回收</li>
</ol>
</blockquote>
<blockquote>
<p><strong>如果这时候有其它线程来竞争（非公平的体现）</strong>，例如这时有 <code>Thread-4</code> 来了</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/990731fe3d516c3947623aeba1a356d3.png"></p>
<blockquote>
<p>如果不巧又被 <code>Thread-4</code> 占了先</p>
<ol>
<li><code>Thread-4</code> 被设置为 <code>exclusiveOwnerThread</code>，<code>state = 1</code></li>
<li><code>Thread-1</code> 再次进入 <code>acquireQueued</code> 流程，获取锁失败，重新进入 <code>park</code> 阻塞</li>
</ol>
</blockquote>
<p><code>加锁</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            	<span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"><span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>解锁</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><blockquote>
<p>​	同一个线程, 锁重入, 会对<code>state</code>进行自增. 释放锁的时候, <code>state</code>进行自减; 当<code>state</code>自减为<code>0</code>的时候. 此时线程才会将<code>锁</code>释放成功, 才会进一步去唤醒<code>其他线程</code>来竞争锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><blockquote>
<p>不可打断模式：在此模式下，<strong>即使它被打断，仍会驻留在 <code>AQS</code> 队列中，一直要等到获得锁后方能得知自己被打断了</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可打断模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h4><blockquote>
<p>​	看<code>AQS</code>队列中, 自己(线程) 有没有前驱节点(线程), (该节点不是占位的哨兵节点); 如果有就不去竞争锁. 如果没有, 才会去<code>CAS</code>操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                        <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">                        (s = h.next) == <span class="literal">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><h5 id="图解流程-1"><a href="#图解流程-1" class="headerlink" title="图解流程"></a>图解流程</h5><blockquote>
<p>每个条件变量其实就对应着一个等待队列，其实现类是 <code>ConditionObject</code></p>
<ul>
<li><code>await</code> 流程 开始 <code>Thread-0</code> 持有锁，<code>conditionObject</code>对象调用 <code>await</code>，进入 <code>ConditionObject</code> 的 <code>addConditionWaiter</code> 流程 创建新的 <code>Node</code> 状态为 <code>-2``（Node.CONDITION）</code>，关联 <code>Thread-0</code>，加入等待队列尾部</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/09246ff55afe135799cd51abc4986653.png"></p>
<blockquote>
<p>接下来进入 <code>AQS</code> 的 <code>fullyRelease</code> 流程，释放同步器上的所有的锁 (因为可能线程发生可重入, 锁有很多层)</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2195e5eaae4a475239669598553df5db.png"></p>
<blockquote>
<p><code>unparkSuccessor(h); —&gt; unpark</code>唤醒 <code>AQS</code> 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 <code>Thread-1</code> 竞争成功</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e792aec6dc7581bb2dc160ede42c9e46.png"></p>
<blockquote>
<p><code>LockSupport.park(this); —&gt; park</code> 阻塞 <code>Thread-0</code></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/7917fb349c6c2af1cd40575968f829da.png"></p>
<ul>
<li><code>signal 流程</code><ul>
<li>假设 <code>Thread-1</code> 要来唤醒 <code>Thread-0</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有持有锁，会抛出异常 --&gt; 这里表示Thread-1要持有锁, </span></span><br><span class="line">	<span class="comment">//才可以去条件变量中去唤醒等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) </span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aca67cba0461a01aca2ba48fbf04203c.png"></p>
<blockquote>
<p>进入 <code>ConditionObject</code> 的 <code>doSignal</code> 流程，取得等待队列中第一个 <code>Node</code>，即 <code>Thread-0</code> 所在 <code>Node</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="comment">// 去firstWaiter条件变量中将等待的线程拿出来.</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转移到AQS的队列中, 等待竞争锁</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/a0d8ac2c5ea30e856db42691f2eb1a2b.png"></p>
<blockquote>
<p>​	执行 <code>transferForSignal</code> 流程，<strong>将该 <code>Node</code> 加入 <code>AQS</code> 队列尾部，将 <code>Thread-0</code> 的 <code>waitStatus</code> 改为 <code>0</code>，<code>Thread-3 的waitStatus</code> 改为 <code>-1</code></strong> , 改为<code>-1</code>就有责任去唤醒自己的后继节点</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c9e2f0c07b88d0dcd7b4b9a49238a50a.png"></p>
<p><code>Thread-1</code> 释放锁，进入 <code>unlock</code> 流程，略</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">                !transferForSignal(first) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 队列还有节点</span></span><br><span class="line">                        (first = firstWaiter) != <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 插入节点的上一个节点被取消</span></span><br><span class="line">                ws &gt; <span class="number">0</span> ||</span><br><span class="line">                        <span class="comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有持有锁，会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 唤醒等待队列队列中的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞              </span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><blockquote>
<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！</p>
<p>提供一个数据容器类内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法  </p>
</blockquote>
<p>注意事项</p>
<blockquote>
<ol>
<li><p>读锁不支持条件变量</p>
</li>
<li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     w.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">         w.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">     r.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h4><ol>
<li>缓存更新策略</li>
</ol>
<p>更新时，是先清缓存还是先更新数据库？先清缓存</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120911022.png"></p>
<p>先更新数据库</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120924901.png"></p>
<p>补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询：这种情况的出现几率非常小</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595120940992.png"></p>
<h4 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h4><h5 id="图解流程-2"><a href="#图解流程-2" class="headerlink" title="图解流程"></a>图解流程</h5><p>读写锁用的是同一个 <code>Sycn</code> 同步器，因此等待队列、<code>state</code> 等也是同一个   下面执行：<code>t1 w.lock</code>，<code>t2 r.lock</code></p>
<p>1） <code>t1</code> 成功上锁，流程与 <code>ReentrantLock</code> 加锁相比没有特殊之处，不同是写锁状态占了 <code>state</code> 的低 <code>16</code> 位，而读锁<br>使用的是 <code>state</code> 的高 <code>16</code> 位</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149666861.png"></p>
<p>2）<code>t2</code> 执行 <code>r.lock</code>，这时进入读锁的 <code>sync.acquireShared(1)</code> 流程，首先会进入 <code>tryAcquireShared</code> 流程。如果有写锁占据，那么 <code>tryAcquireShared</code> 返回 <code>-1</code> 表示失败</p>
<blockquote>
<p><code>tryAcquireShared</code> 返回值表示</p>
<ol>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，我们这里的读写锁返回 <code>1</code></li>
</ol>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149816131.png"></p>
<p>3）这时会进入 <code>sync.doAcquireShared(1)</code> 流程，首先也是调用 <code>addWaiter</code> 添加节点，不同之处在于节点被设置为<code>Node.SHARED</code> 模式而非 <code>Node.EXCLUSIVE</code> 模式，注意此时 <code>t2</code> 仍处于活跃状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595149862569.png"></p>
<p>4）<code>t2</code> 会看看自己的节点是不是老二，如果是，还会再次调用 <code>tryAcquireShared(1)</code> 来尝试获取锁</p>
<p>5）如果没有成功，在 <code>doAcquireShared</code> 内 <code>for (;;)</code> 循环一次，把前驱节点的 <code>waitStatus</code> 改为<code> -1</code>，再 <code>for (;;)</code> 循环一次尝试 <code>tryAcquireShared(1)</code> 如果还不成功，那么在 <code>parkAndCheckInterrupt()</code> 处 <code>park</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595150020844.png"></p>
<p><strong>又继续执行：<code>t3 r.lock</code>，<code>t4 w.lock</code></strong><br>这种状态下，假设又有 <code>t3</code> 加读锁和 <code>t4</code> 加写锁，这期间 <code>t1</code> 仍然持有锁，就变成了下面的样子</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595150111679.png"></p>
<p><strong>继续执行<code>t1 w.unlock</code></strong><br>这时会走到写锁的 <code>sync.release(1)</code> 流程，调用 <code>sync.tryRelease(1)</code> 成功，变成下面的样子</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152703040.png"></p>
<p>接下来执行唤醒流程 <code>sync.unparkSuccessor</code>，即让老二恢复运行，这时 <code>t2</code> 在 <code>doAcquireShared</code> 内<code>parkAndCheckInterrupt()</code> 处恢复运行，图中的<code>t2</code>从黑色变成了蓝色（注意这里只是恢复运行而已，并没有获取到锁！）<br>这回再来一次 <code>for (;;)</code> 执行 <code>tryAcquireShared</code> 成功则让读锁计数加一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152000565.png"></p>
<p>这时 <code>t2</code> 已经恢复运行，接下来 <code>t2</code> 调用 <code>setHeadAndPropagate(node, 1)</code>，它原本所在节点被置为头节点</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152203229.png"></p>
<p>​	事情还没完，在 <code>setHeadAndPropagate</code> 方法内还会检查下一个节点是否是 <code>shared</code>，如果是则调用<code>doReleaseShared()</code> 将 <code>head</code> 的状态从 <code>-1</code> 改为 <code>0</code> 并唤醒老二，这时 <code>t3</code> 在 <code>doAcquireShared</code> 内<code>parkAndCheckInterrupt()</code> 处恢复运行</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152506026.png"></p>
<p>​	这回再来一次 <code>for (;;)</code> 执行 <code>tryAcquireShared</code> 成功则让读锁计数加一</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152518613.png"></p>
<p>这时 <code>t3</code> 已经恢复运行，接下来 <code>t3</code> 调用 <code>setHeadAndPropagate(node, 1)</code>，它原本所在节点被置为头节点</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595152534234.png"></p>
<p>下一个节点不是 <code>shared</code> 了，因此不会继续唤醒 <code>t4</code> 所在节点</p>
<p><strong>再继续执行<code>t2 r.unlock</code>，<code>t3 r.unlock</code></strong><br><code>t2</code> 进入 <code>sync.releaseShared(1)</code> 中，调用 <code>tryReleaseShared(1)</code> 让计数减一，但由于计数还不为零</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153460990.png"></p>
<p><code>t3</code> 进入 <code>sync.releaseShared(1)</code> 中，调用 <code>tryReleaseShared(1)</code> 让计数减一，这回计数为零了，进入<code>doReleaseShared()</code> 将头节点从 <code>-1</code> 改为 <code>0 </code>并唤醒老二，即</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153473005.png"></p>
<p>之后 <code>t4</code> 在 <code>acquireQueued</code> 中 <code>parkAndCheckInterrupt</code> 处恢复运行，再次 <code>for (;;)</code> 这次自己是老二，并且没有其他竞争，<code>tryAcquire(1)</code> 成功，修改头结点，流程结束</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1595153528383.png"></p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>写锁上锁流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 尝试获得写锁失败</span></span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">                        <span class="comment">// 进入 AQS 队列阻塞</span></span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span></span><br><span class="line">                    w == <span class="number">0</span> ||</span><br><span class="line">                            <span class="comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span></span><br><span class="line">                            current != getExclusiveOwnerThread()</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// 获得锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写锁计数超过低 16 位, 报异常</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 写锁重入, 获得锁成功</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 判断写锁是否该阻塞这里返回false, 或者</span></span><br><span class="line">                writerShouldBlock() ||</span><br><span class="line">                        <span class="comment">// 尝试更改计数失败</span></span><br><span class="line">                        !compareAndSetState(c, c + acquires)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获得锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写锁释放流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放写锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// unpark AQS 中等待的线程</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free) &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读锁上锁流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果是其它线程持有写锁, 获取读锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        getExclusiveOwnerThread() != current</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span></span><br><span class="line">                !readerShouldBlock() &amp;&amp;</span><br><span class="line">                        <span class="comment">// 小于读锁计数, 并且</span></span><br><span class="line">                        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                        <span class="comment">// 尝试增加计数成功</span></span><br><span class="line">                        compareAndSetState(c, c + SHARED_UNIT)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span></span><br><span class="line">    <span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ㈠</span></span><br><span class="line">						<span class="comment">// r 表示可用资源数, 在这里总是 1 允许传播</span></span><br><span class="line">                        <span class="comment">//（唤醒 AQS 中下一个 Share 节点）</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span></span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                <span class="comment">// park 当前线程</span></span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置自己为 head</span></span><br><span class="line">        setHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">        <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">                (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">                <span class="comment">// 进入 ㈡</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析，参考这里：http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#5propagate-%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 下一个节点 unpark 如果成功获取读锁</span></span><br><span class="line">                    <span class="comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读锁释放流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadLock 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略不重要的代码</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span></span><br><span class="line">                <span class="comment">// 计数为 0 才是真正释放</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><blockquote>
<p>​	<code>Semaphore</code>是<code>JDK</code>提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。 如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。 <code>Semaphore</code>所维护的许可证数量就是允许访问共享资源的最大线程数量。 所以，线程想要访问共享资源必须从<code>Semaphore</code>中获取到许可证。</p>
</blockquote>
<h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Semaphore</code>实现了<code>Serializable</code>接口，即可以进行序列化。</p>
</blockquote>
<h3 id="类的内部类"><a href="#类的内部类" class="headerlink" title="类的内部类"></a>类的内部类</h3><blockquote>
<p><code>Semaphore</code>总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-1.png"></p>
<blockquote>
<p>说明: <code>Semaphore</code>与<code>ReentrantLock</code>的内部类的结构相同，类内部总共存在<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code>三个类，<code>NonfairSync</code>与<code>FairSync</code>类继承自<code>Sync</code>类，<code>Sync</code>类继承自<code>AbstractQueuedSynchronizer</code>抽象类。下面逐个进行分析。</p>
</blockquote>
<h4 id="类的内部类-Sync类"><a href="#类的内部类-Sync类" class="headerlink" title="类的内部类 - Sync类"></a>类的内部类 - Sync类</h4><p><code>Sync</code>类的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        setState(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPermits</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reducePermits</span><span class="params">(<span class="type">int</span> reductions)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">drainPermits</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Sync</code>类的属性相对简单，只有一个版本号，<code>Sync</code>类存在如下方法和作用如下。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getPermits</code></td>
<td align="center">获取许可</td>
</tr>
<tr>
<td align="center"><code>nonfairTryAcquireShared</code></td>
<td align="center">共享模式下非公平策略获取</td>
</tr>
<tr>
<td align="center"><code>tryReleaseShared</code></td>
<td align="center">共享模式下进行释放</td>
</tr>
<tr>
<td align="center"><code>reducePermits</code></td>
<td align="center">根据指定的缩减量减小可用许可的数目</td>
</tr>
<tr>
<td align="center"><code>drainPermits</code></td>
<td align="center">获取并返回立即可用的所有许可</td>
</tr>
</tbody></table>
<h4 id="类的内部类-NonfairSync类"><a href="#类的内部类-NonfairSync类" class="headerlink" title="类的内部类 - NonfairSync类"></a>类的内部类 - NonfairSync类</h4><blockquote>
<p><code>NonfairSync</code>类继承了<code>Sync</code>类，表示采用非公平策略获取资源，其只有一个<code>tryAcquireShared</code>方法，重写了<code>AQS</code>的该方法，其源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 从<code>tryAcquireShared</code>方法的源码可知，其会调用父类<code>Sync</code>的<code>nonfairTryAcquireShared</code>方法，表示按照非公平策略进行资源的获取。</p>
</blockquote>
<h4 id="类的内部类-FairSync类"><a href="#类的内部类-FairSync类" class="headerlink" title="类的内部类 - FairSync类"></a>类的内部类 - FairSync类</h4><blockquote>
<p><code>FairSync</code>类继承了<code>Sync</code>类，表示采用公平策略获取资源，其只有一个<code>tryAcquireShared</code>方法，重写了<code>AQS</code>的该方法，其源码如下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 同步队列中存在其他节点</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 剩余的许可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余的许可小于0或者比较设置成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 从<code>tryAcquireShared</code>方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。</p>
</blockquote>
<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: <code>Semaphore</code>自身只有两个属性，最重要的是<code>sync</code>属性，基于<code>Semaphore</code>对象的操作绝大多数都转移到了对<code>sync</code>的操作。</p>
</blockquote>
<h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul>
<li><code>Semaphore(int)</code>型构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 该构造函数会创建具有给定的许可数和非公平的公平设置的<code>Semaphore</code>。</p>
</blockquote>
<ul>
<li><code>Semaphore(int, boolean)</code>型构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 该构造函数会创建具有给定的许可数和给定的公平设置的<code>Semaphore</code>。</p>
</blockquote>
<h3 id="Semaphore有哪些常用的方法？"><a href="#Semaphore有哪些常用的方法？" class="headerlink" title="Semaphore有哪些常用的方法？"></a>Semaphore有哪些常用的方法？</h3><blockquote>
<p>​	有<code>acquire</code>方法和<code>release</code>方法。 当调用<code>acquire</code>方法时线程就会被阻塞，直到<code>Semaphore</code>中可以获得到许可证为止，然后线程再获取这个许可证。 当调用<code>release</code>方法时将向<code>Semaphore</code>中添加一个许可证，如果有线程因为获取许可证被阻塞时，它将获取到许可证并被释放；如果没有获取许可证的线程， <code>Semaphore</code>只是记录许可证的可用数量。</p>
</blockquote>
<h3 id="可以举一个使用Semaphore的例子吗？"><a href="#可以举一个使用Semaphore的例子吗？" class="headerlink" title="可以举一个使用Semaphore的例子吗？"></a>可以举一个使用<code>Semaphore</code>的例子吗？</h3><blockquote>
<p>​	张三、李四和王五和赵六<code>4</code>个人一起去饭店吃饭，不过在特殊时期洗手很重要，饭前洗手也是必须的，可是饭店只有<code>2</code>个洗手池，洗手池就是不能被同时使用的公共资源，这种场景就可以用到<code>Semaphore</code>。</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>当然可以，这是张三、李四、王五和赵六的顾客类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore washbasin;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Semaphore washbasin, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.washbasin = washbasin;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">            washbasin.acquire();</span><br><span class="line">            System.out.println(</span><br><span class="line">            	sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; 开始洗手...&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (random.nextDouble() * <span class="number">5000</span>) + <span class="number">2000</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">            	sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; 洗手完毕!&quot;</span>);</span><br><span class="line">            washbasin.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，写一个测试类模拟一下他们洗手的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//饭店里只用两个洗手池，所以初始化许可证的总数为2。</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">washbasin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;张三&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;李四&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;王五&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(washbasin, <span class="string">&quot;赵六&quot;</span>)));</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以后的结果应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">54.416</span> 李四 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">54.416</span> 张三 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">57.251</span> 张三 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">57.251</span> 王五 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">59.418</span> 李四 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">51</span>:<span class="number">59.418</span> 赵六 开始洗手...</span><br><span class="line"><span class="number">06</span>:<span class="number">52</span>:<span class="number">02.496</span> 王五 洗手完毕!</span><br><span class="line"><span class="number">06</span>:<span class="number">52</span>:<span class="number">06.162</span> 赵六 洗手完毕!</span><br></pre></td></tr></table></figure>

<p>可以看到，当已经有两个人在洗手的时候，其他人就被阻塞，直到有人洗手完毕才是开始洗手。</p>
<h4 id="这4个人会按照线程启动的顺序洗手嘛？"><a href="#这4个人会按照线程启动的顺序洗手嘛？" class="headerlink" title="这4个人会按照线程启动的顺序洗手嘛？"></a>这4个人会按照线程启动的顺序洗手嘛？</h4><blockquote>
<p>​	不会按照线程启动的顺序洗手，有可能赵六比王五先洗手。</p>
</blockquote>
<p>因为在我的代码中，使用<code>Semaphore</code>的构造函数是这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在这个构造函数中，使用的是<code>NonfairSync</code>（非公平锁），这个类不保证线程获得许可证的顺序，调用<code>acquire</code>方法的线程可以在一直等待的线程之前获得一个许可证。</p>
</blockquote>
<p>15.6.3 有没有什么方法可保证他们的顺序？</p>
<blockquote>
<p>​	可以使用Semaphore的另一个构造函数：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用构造方法时，<code>fair</code>参数传入<code>true</code>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">washbasin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这样使用的是<code>FairSync</code>（公平锁），可以确保按照各个线程调用<code>acquire</code>方法的顺序获得许可证。</p>
<h3 id="对Semaphore的内部原理有没有了解？"><a href="#对Semaphore的内部原理有没有了解？" class="headerlink" title="对Semaphore的内部原理有没有了解？"></a>对Semaphore的内部原理有没有了解？</h3><blockquote>
<p>​	<code>Semaphore</code>内部主要通过<code>AQS（AbstractQueuedSynchronizer）</code>实现线程的管理。<code>Semaphore</code>在构造时，需要传入许可证的数量，它最后传递给了<code>AQS</code>的<code>state</code>值。线程在调用<code>acquire</code>方法获取许可证时，如果<code>Semaphore</code>中许可证的数量大于<code>0</code>，许可证的数量就减<code>1</code>，线程继续运行，当线程运行结束调用<code>release</code>方法时释放许可证时，许可证的数量就加<code>1</code>。如果获取许可证时，<code>Semaphore</code>中许可证的数量为<code>0</code>，则获取失败，线程进入<code>AQS</code>的等待队列中，等待被其它释放许可证的线程唤醒。</p>
</blockquote>
<h3 id="NonfairSync和FairSync有什么区别？为什么会造成这样的效果？"><a href="#NonfairSync和FairSync有什么区别？为什么会造成这样的效果？" class="headerlink" title="NonfairSync和FairSync有什么区别？为什么会造成这样的效果？"></a>NonfairSync和FairSync有什么区别？为什么会造成这样的效果？</h3><p>这就涉及到<code>NonfairSync</code>和<code>FairSync</code>的内部实现了，在<code>NonfairSync</code>中，<code>acquire</code>方法核心源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">	<span class="comment">//acquires参数默认为1，表示尝试获取1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//remaining是剩余的许可数数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//剩余的许可数数量小于0时，</span></span><br><span class="line">        <span class="comment">//当前线程进入AQS中的doAcquireSharedInterruptibly方法</span></span><br><span class="line">        <span class="comment">//等待可用许可证并挂起，直到被唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>release</code>方法核心源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">	<span class="comment">//releases参数默认为1，表示尝试释放1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//next是如果许可证释放成功，可用许可证的数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//如果许可证释放成功，</span></span><br><span class="line">        <span class="comment">//当前线程进入到AQS的doReleaseShared方法，</span></span><br><span class="line">        <span class="comment">//唤醒队列中等待许可的线程。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	当一个线程<code>A</code>调用<code>acquire</code>方法时，会直接尝试获取许可证，而不管同一时刻阻塞队列中是否有线程也在等待许可证，如果恰好有线程<code>C</code>调用<code>release</code>方法释放许可证，并唤醒阻塞队列中第一个等待的线程<code>B</code>，此时线程<code>A</code>和线程<code>B</code>是共同竞争可用许可证，不公平性就体现在：线程<code>A</code>没任何等待就和线程<code>B</code>一起竞争许可证了。</p>
</blockquote>
<blockquote>
<p>​	而在<code>FairSync</code>中，<code>acquire</code>方法核心源码是：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">	<span class="comment">//acquires参数默认为1，表示尝试获取1个许可证。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//检查阻塞队列中是否有等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//remaining是剩余的许可数数量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	和非公平策略相比，<code>FairSync</code>中多一个对阻塞队列是否有等待的线程的检查，如果没有，就可以参与许可证的竞争；如果有，线程直接被插入到阻塞队列尾节点并挂起，等待被唤醒。</p>
</blockquote>
<h2 id="Semaphore示例"><a href="#Semaphore示例" class="headerlink" title="Semaphore示例"></a>Semaphore示例</h2><p>下面给出了一个使用<code>Semaphore</code>的示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name, Semaphore semaphore)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SEM_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(SEM_SIZE);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;t1&quot;</span>, semaphore);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;t2&quot;</span>, semaphore);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">permits</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(<span class="keyword">permits</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果(某一次):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main trying to acquire</span><br><span class="line">main acquire successfully</span><br><span class="line">t1 trying to acquire</span><br><span class="line">t1 acquire successfully</span><br><span class="line">t2 trying to acquire</span><br><span class="line">t1 release successfully</span><br><span class="line">main release successfully</span><br><span class="line">t2 acquire successfully</span><br><span class="line">t2 release successfully</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明: 首先，生成一个信号量，信号量有<code>10</code>个许可，然后，<code>main</code>，<code>t1</code>，<code>t2</code>三个线程获取许可运行，根据结果，可能存在如下的一种时序。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-5.png"></p>
<blockquote>
<p>​	说明: 如上图所示，首先，<code>main</code>线程执行<code>acquire</code>操作，并且成功获得许可，之后<code>t1</code>线程执行<code>acquire</code>操作，成功获得许可，之后<code>t2</code>执行<code>acquire</code>操作，由于此时许可数量不够，<code>t2</code>线程将会阻塞，直到许可可用。之后<code>t1</code>线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时<code>t2</code>线程会成功获得许可运行，<code>t2</code>运行完成后释放许可。下面进行详细分析。</p>
</blockquote>
<ul>
<li><code>main</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-6.png"></p>
<blockquote>
<p>说明: 此时，可以看到只是<code>AQS</code>的<code>state</code>变为了<code>5</code>，<code>main</code>线程并没有被阻塞，可以继续运行。</p>
</blockquote>
<ul>
<li><code>t1</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-7.png"></p>
<blockquote>
<p>说明: 此时，可以看到只是<code>AQS</code>的<code>state</code>变为了<code>2</code>，<code>t1</code>线程并没有被阻塞，可以继续运行。</p>
</blockquote>
<ul>
<li><code>t2</code>线程执行<code>semaphore.acquire</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-8.png"></p>
<blockquote>
<p>说明: 此时，<code>t2</code>线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，<code>AQS</code>的<code>state</code>还是为<code>2</code>。</p>
</blockquote>
<ul>
<li><code>t1</code>执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-9.png"></p>
<p>说明: 此时，<code>t2</code>线程将会被<code>unpark</code>，并且<code>AQS</code>的<code>state</code>为<code>5</code>，<code>t2</code>获取<code>cpu</code>资源后可以继续运行。</p>
<ul>
<li><code>main</code>线程执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-10.png"></p>
<p>说明: 此时，<code>t2</code>线程还会被<code>unpark</code>，但是不会产生影响，此时，只要<code>t2</code>线程获得<code>CPU</code>资源就可以运行了。此时，<code>AQS</code>的<code>state</code>为<code>10</code>。</p>
<ul>
<li><code>t2</code>获取<code>CPU</code>资源，继续运行，此时<code>t2</code>需要恢复现场，回到<code>parkAndCheckInterrupt</code>函数中，也是在<code>should</code>继续运行。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-11.png"></p>
<p>说明: 此时，可以看到，<code>Sync queue</code>中只有一个结点，头节点与尾节点都指向该结点，在<code>setHeadAndPropagate</code>的函数中会设置头节点并且会<code>unpark</code>队列中的其他结点。</p>
<ul>
<li><code>t2</code>线程执行<code>semaphore.release</code>操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-thread-x-semaphore-12.png"></p>
<p>说明: <code>t2</code>线程经过<code>release</code>后，此时信号量的许可又变为<code>10</code>个了，此时<code>Sync queue</code>中的结点还是没有变化。</p>
<h3 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h3><h4 id="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</h4><blockquote>
<p>答案：拿不到令牌的线程阻塞，不会继续往下运行。</p>
</blockquote>
<h4 id="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</h4><blockquote>
<p>答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次<code>acquire</code>方法，就需要有一个令牌才能继续运行。</p>
</blockquote>
<h4 id="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗"><a href="#semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗" class="headerlink" title="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?"></a>semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</h4><blockquote>
<p>答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p>
</blockquote>
<h4 id="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a>semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h4><blockquote>
<p>答案：能，原因是<code>release</code>会添加令牌，并不会以初始化的大小为准。<code>Semaphore</code>中<code>release</code>方法的调用并没有限制要在<code>acquire</code>后调用。</p>
</blockquote>
<p>具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSemaphore2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">permitsNum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permitsNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p><code>CountDownLatch</code>是<code>JDK</code>提供的一个同步工具，它可以让一个或多个线程等待，一直等到其他线程中执行完成一组操作。</p>
</blockquote>
<h3 id="CountDownLatch有哪些常用的方法？"><a href="#CountDownLatch有哪些常用的方法？" class="headerlink" title="CountDownLatch有哪些常用的方法？"></a>CountDownLatch有哪些常用的方法？</h3><blockquote>
<p>​	有<code>countDown</code>方法和<code>await</code>方法，<code>CountDownLatch</code>在初始化时，需要指定用给定一个整数作为计数器。当调用<code>countDown</code>方法时，计数器会被减<code>1</code>；当调用<code>await</code>方法时，如果计数器大于<code>0</code>时，线程会被阻塞，一直到计数器被<code>countDown</code>方法减到<code>0</code>时，线程才会继续执行。计数器是无法重置的，当计数器被减到<code>0</code>时，调用<code>await</code>方法都会直接返回。</p>
</blockquote>
<h3 id="调用countDown方法时，线程也会阻塞嘛？"><a href="#调用countDown方法时，线程也会阻塞嘛？" class="headerlink" title="调用countDown方法时，线程也会阻塞嘛？"></a>调用<code>countDown</code>方法时，线程也会阻塞嘛？</h3><blockquote>
<p>不会的，调用<code>countDown</code>的线程可以继续执行，不需要等待计数器被减到<code>0</code>，只是调用<code>await</code>方法的线程需要等待。</p>
</blockquote>
<h3 id="可以举一个使用CountDownLatch的例子吗？"><a href="#可以举一个使用CountDownLatch的例子吗？" class="headerlink" title="可以举一个使用CountDownLatch的例子吗？"></a>可以举一个使用CountDownLatch的例子吗？</h3><blockquote>
<p>比如张三、李四和王五几个人约好去饭店一起去吃饭，这几个人都是比较绅士，要等到所有人都到齐以后才让服务员上菜。这种场景就可以用到<code>CountDownLatch</code>。</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>当然可以，这是张三、李四和王五的顾客类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(CountDownLatch latch, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;出发去饭店&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (random.nextDouble() * <span class="number">3000</span>) + <span class="number">1000</span>);</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;到了饭店&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是服务员类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitress</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitress</span><span class="params">(CountDownLatch latch, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name  + <span class="string">&quot;等待顾客&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot; &quot;</span> + name  + <span class="string">&quot;开始上菜&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，再写一个测试类，用于模拟上面所说的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onemore.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;张三&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;李四&quot;</span>)));</span><br><span class="line">        threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Customer</span>(latch, <span class="string">&quot;王五&quot;</span>)));</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Waitress</span>(latch, <span class="string">&quot;♥小芳♥&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以后的结果应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 王五出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 李四出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.015</span> 张三出发去饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">53.062</span> ♥小芳♥等待顾客</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">54.341</span> 张三到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">54.358</span> 李四到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">56.784</span> 王五到了饭店</span><br><span class="line"><span class="number">15</span>:<span class="number">25</span>:<span class="number">56.784</span> ♥小芳♥开始上菜</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，服务员小芳在调用<code>await</code>方法时一直阻塞着，一直等到三个顾客都调用了<code>countDown</code>方法才继续执行。</p>
</blockquote>
<h4 id="如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？"><a href="#如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？" class="headerlink" title="如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？"></a>如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？</h4><blockquote>
<p>可以使用<code>await</code>方法的另一个重载，传入等待的超时时间，比如服务员只等<code>3</code>秒钟，可以把服务员类中的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latch.await();</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>运行结果可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 张三出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 李四出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.915</span> 王五出发去饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">40.948</span> ♥小芳♥等待顾客</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.376</span> 李四到了饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.544</span> 王五到了饭店</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">43.951</span> ♥小芳♥开始上菜</span><br><span class="line"><span class="number">17</span>:<span class="number">24</span>:<span class="number">44.762</span> 张三到了饭店</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，服务员小芳在调用<code>await</code>方法时虽然被阻塞了，但是时间超过3秒后，没等顾客张三调用<code>countDown</code>方法就继续执行开始上菜了。</p>
</blockquote>
<h3 id="CountDownLatch的实现原理是什么？"><a href="#CountDownLatch的实现原理是什么？" class="headerlink" title="CountDownLatch的实现原理是什么？"></a>CountDownLatch的实现原理是什么？</h3><blockquote>
<p><code>CountDownLatch</code>有一个内部类叫做<code>Sync</code>，它继承了<code>AbstractQueuedSynchronizer</code>类，其中维护了一个整数<code>state</code>，并且保证了修改<code>state</code>的可见性和原子性。</p>
</blockquote>
<blockquote>
<p>创建<code>CountDownLatch</code>实例时，也会创建一个<code>Sync</code>的实例，同时把计数器的值传给<code>Sync</code>实例，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>countDown</code>方法中，只调用了<code>Sync</code>实例的<code>releaseShared</code>方法，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<code>releaseShared</code>方法，先对计数器进行减<code>1</code>操作，如果减<code>1</code>后的计数器为<code>0</code>，唤醒被<code>await</code>方法阻塞的所有线程，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">//对计数器进行减一操作</span></span><br><span class="line">        doReleaseShared();<span class="comment">//如果计数器为0，唤醒被await方法阻塞的所有线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<code>tryReleaseShared</code>方法，先获取当前计数器的值，如果计数器为0时，就直接返回；如果不为0时，使用CAS方法对计数器进行减1操作，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环，如果CAS操作失败就会不断继续尝试。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">//获取当前计数器的值。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">// 计数器为0时，就直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))<span class="comment">// 使用CAS方法对计数器进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;<span class="comment">//如果操作成功，返回计数器是否为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>await</code>方法中，只调用了Sync实例的<code>acquireSharedInterruptibly</code>方法，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>acquireSharedInterruptibly</code>方法，判断计数器是否为<code>0</code>，如果不为<code>0</code>则阻塞当前线程，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//判断计数器是否为0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);<span class="comment">//如果不为0则阻塞当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>tryAcquireShared</code>方法，是<code>AbstractQueuedSynchronizer</code>中的一个模板方法，其具体实现在<code>Sync</code>类中，其主要是判断计数器是否为零，如果为零则返回<code>1</code>，如果不为零则返回<code>-1</code>，具体是这样的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：王者荣耀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏加载中!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                        all[temp] = i + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">250</span>));</span><br><span class="line"><span class="comment">//                    后面的打印覆盖前面的打印</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏开始运行！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">游戏加载中!!!</span><br><span class="line">[<span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%, <span class="number">100</span>%]</span><br><span class="line">游戏开始运行！！！</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><blockquote>
<p>​	栅栏类似于闭锁，它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。</p>
<p>​	<code>CyclicBarrier</code>可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用<code>await</code>方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。</p>
</blockquote>
<blockquote>
<p>​	在<code>JUC</code>包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是<code>CyclicBarrier</code>类。利用<code>CyclicBarrier</code>类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。下图演示了这一过程。</p>
</blockquote>
<p>![](<a target="_blank" rel="noopener" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20181218144511688">https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20181218144511688</a> (1).gif)</p>
<blockquote>
<p> ​	<code>CyclicBarrier</code>字面意思是“可重复使用的栅栏”，<code>CyclicBarrier</code> 相比 <code>CountDownLatch</code> 来说，要简单很多，其源码没有什么高深的地方，它是 <code>ReentrantLock</code> 和 <code>Condition</code> 的组合使用。</p>
</blockquote>
<blockquote>
<p>看如下示意图，<code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 是不是很像，只是 <code>CyclicBarrier </code>可以有不止一个栅栏，因为它的栅栏<code>（Barrier）</code>可以重复使用（Cyclic）。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/fa4d24955103ee1c8c0564ab45eebe26.png"></p>
<h3 id="CyclicBarrier源码解析"><a href="#CyclicBarrier源码解析" class="headerlink" title="CyclicBarrier源码解析"></a>CyclicBarrier源码解析</h3><p><code>CyclicBarrier</code>的类图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20180603173118965.png"></p>
<p>通过类图我们可以看到，<code>CyclicBarrier</code>内部使用了<code>ReentrantLock</code>和<code>Condition</code>两个类。它有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程使用<code>await()</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p>
</blockquote>
<blockquote>
<p>​	<code>CyclicBarrier</code>的另一个构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。</p>
</blockquote>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><blockquote>
<p>​	调用<code>await</code>方法的线程告诉<code>CyclicBarrier</code>自己已经到达同步点，然后当前线程被阻塞。直到<code>parties</code>个参与线程调用了<code>await</code>方法，<code>CyclicBarrier</code>同样提供带超时时间的<code>await</code>和不带超时时间的<code>await</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不超时等待</span></span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">            BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法最终都会调用<code>dowait(boolean, long)</code>方法，它也是<code>CyclicBarrier</code>的核心方法，该方法定义如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前代</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 如果这代损坏了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将损坏状态设置为true</span></span><br><span class="line">            <span class="comment">// 并通知其他阻塞在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 如果是 0，说明最后一个线程调用了该方法</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="comment">// 执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新一代，将count重置，将generation重置</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果执行栅栏任务的时候失败了，就将损坏状态设置为true</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果没有时间限制，则直接等待，直到被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 如果有时间限制，则等待指定时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 当前代没有损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面条件不满足，说明这个线程不是这代的</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏的执行，所以，就打个中断标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 当有任何一个线程中断了，就会调用breakBarrier方法</span></span><br><span class="line">            <span class="comment">// 就会唤醒其他的线程，其他线程醒来后，也要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// g != generation表示正常换代了，返回当前线程所在栅栏的下标</span></span><br><span class="line">            <span class="comment">// 如果 g == generation，说明还没有换代，那为什么会醒了？</span></span><br><span class="line">            <span class="comment">// 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span></span><br><span class="line">            <span class="comment">// 正是因为这个原因，才需要generation来保证正确。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>dowait(boolean, long)</code>方法的主要逻辑处理比较简单，如果该线程不是最后一个调用<code>await</code>方法的线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ul>
<li><p>最后一个线程到达，即<code>index == 0</code></p>
</li>
<li><p>某个参与线程等待超时</p>
</li>
<li><p>某个参与线程被中断</p>
</li>
<li><p>调用了<code>CyclicBarrier</code>的<code>reset()</code>方法。该方法会将屏障重置为初始状态</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>​	在上面的源代码中，我们可能需要注意<code>Generation</code> 对象，在上述代码中我们总是可以看到抛出<code>BrokenBarrierException</code>异常，那么什么时候抛出异常呢？如果一个线程处于等待状态时，如果其他线程调用<code>reset()</code>，或者调用的<code>barrier</code>原本就是被损坏的，则抛出<code>BrokenBarrierException</code>异常。同时，任何线程在等待时被中断了，则其他所有线程都将抛出<code>BrokenBarrierException</code>异常，并将<code>barrier</code>置于损坏状态。</p>
</blockquote>
<blockquote>
<p>​	同时，<code>Generation</code>描述着<code>CyclicBarrier</code>的更新换代。在<code>CyclicBarrier</code>中，同一批线程属于同一代。当有<code>parties</code>个线程到达<code>barrier</code>之后，<code>generation</code>就会被更新换代。其中<code>broken</code>标识该当前<code>CyclicBarrier</code>是否已经处于中断状态。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认<code>barrier</code>是没有损坏的。当<code>barrier</code>损坏了或者有一个线程中断了，则通过<code>breakBarrier()</code>来终止所有的线程：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>breakBarrier()</code>中除了将<code>broken</code>设置为<code>true</code>，还会调用<code>signalAll</code>将在<code>CyclicBarrier</code>处于等待状态的线程全部唤醒。</p>
</blockquote>
<blockquote>
<p>当所有线程都已经到达<code>barrier</code>处（<code>index == 0</code>），则会通过<code>nextGeneration()</code>进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置<code>count</code>，<code>generation</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了上面讲到的栅栏更新换代以及损坏状态，我们在使用<code>CyclicBarrier</code>时还要要注意以下几点：</p>
<ul>
<li><code>CyclicBarrier</code>使用独占锁来执行<code>await</code>方法，并发性可能不是很高</li>
<li>如果在等待过程中，线程被中断了，就抛出异常。但如果中断的线程所对应的<code>CyclicBarrier</code>不是这代的，比如，在最后一次线程执行<code>signalAll</code>后，并且更新了这个“代”对象。在这个区间，这个线程被中断了，那么，<code>JDK</code>认为任务已经完成了，就不必在乎中断了，只需要打个标记。该部分源码已在<code>dowait(boolean, long)</code>方法中进行了注释。</li>
<li>如果线程被其他的<code>CyclicBarrier</code>唤醒了，那么<code>g</code>肯定等于<code>generation</code>，这个事件就不能<code>return</code>了，而是继续循环阻塞。反之，如果是当前<code>CyclicBarrier</code>唤醒的，就返回线程在<code>CyclicBarrier</code>的下标。完成了一次冲过栅栏的过程。该部分源码已在<code>dowait(boolean, long)</code>方法中进行了注释。</li>
</ul>
</blockquote>
<h3 id="应用程序示例"><a href="#应用程序示例" class="headerlink" title="应用程序示例"></a>应用程序示例</h3><p>我们看一个<code>CyclicBarrier</code>的应用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">	<span class="comment">// 自定义工作线程</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.run();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始等待其他线程&quot;</span>);</span><br><span class="line">				cyclicBarrier.await();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">				<span class="comment">// 工作线程开始处理，这里用Thread.sleep()来模拟业务处理</span></span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;创建工作线程&quot;</span> + i);</span><br><span class="line">			<span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(cyclicBarrier);</span><br><span class="line">			worker.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（不唯一）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建工作线程<span class="number">0</span></span><br><span class="line">创建工作线程<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>开始等待其他线程</span><br><span class="line">创建工作线程<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">2</span>开始等待其他线程</span><br><span class="line">Thread-<span class="number">2</span>开始执行</span><br><span class="line">Thread-<span class="number">0</span>开始执行</span><br><span class="line">Thread-<span class="number">1</span>开始执行</span><br><span class="line">Thread-<span class="number">1</span>执行完毕</span><br><span class="line">Thread-<span class="number">0</span>执行完毕</span><br><span class="line">Thread-<span class="number">2</span>执行完毕</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在上述代码中，我们自定义的工作线程必须要等所有参与线程开始之后才可以执行，我们可以使用<code>CyclicBarrier</code>类来帮助我们完成。从程序的执行结果中也可以看出，所有的工作线程都运行<code>await()</code>方法之后都到达了栅栏位置，然后，<code>3</code>个工作线程才开始执行业务处理。</p>
<p><strong><code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</strong></p>
<ul>
<li><p><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置，可以使用多次，所以<code>CyclicBarrier</code>能够处理更为复杂的场景；</p>
</li>
<li><p><code>CyclicBarrier</code>还提供了一些其他有用的方法，比如<code>getNumberWaiting()</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量，<code>isBroken()</code>方法用来了解阻塞的线程是否被中断；</p>
</li>
<li><p><code>CountDownLatch</code>允许一个或多个线程等待一组事件的产生，而<code>CyclicBarrier</code>用于等待其他线程运行到栅栏位置。</p>
</li>
</ul>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><blockquote>
<p>定义：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 新建了5个SimpleDateFormat对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里<code>10</code>个线程即便使用了线程池，但是每个线程都会在执行过程中创建一个<code>SimpleDateFormat</code>对象，这比较耗费内存资源。</p>
</blockquote>
<blockquote>
<p>改进一：将<code>SimpleDateFormat</code>提出来用<code>static</code>修饰，这样每个线程都可以公用一个<code>SimpleDateFormat</code>对象，减少内存消耗，但是这样会打印出相同的时间，所有线程都在争夺这个资源，我们需要一个锁去控制，避免出现线程安全问题。</p>
</blockquote>
<blockquote>
<p>改进二：在改进一的基础上添加锁控制，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadLocalTest.class) &#123;</span><br><span class="line">            s = dateFormat.format(date);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这虽然能够满足要求，但是在高并发场景下，所有线程需要一个个的去获取锁，需要排队等待，这显然性能损耗太大。</p>
</blockquote>
<blockquote>
<p>改进三：使用<code>ThreadLocal</code>（不仅线程安全，而且也没有<code>synchronized</code>带来的性能问题，每个线程内有自己独享的<code>SimpleDateFormat</code>对象）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> date(finalI);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="comment">//参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> ThreadSafeFormatter.dateFormatThreadLocal.get(); <span class="comment">// 拿到initialValue返回对象</span></span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeFormatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda表达式写法，和上面写法效果完全一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal2 = ThreadLocal</span><br><span class="line">            .withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">04</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">03</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">02</span></span><br></pre></td></tr></table></figure>

<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><blockquote>
<p>​	当一个请求进来了，一个线程负责处理该请求，该请求会依次调用<code>service-1()</code>,<code> service-2(),</code> <code>service-3()</code>, <code>service-4()</code>，同时，每个<code>service()</code>都需要获得调用方用户<code>user</code>的信息，也就是需要拿到<code>user</code>对象。</p>
<p>​	一个比较繁琐的解决方案是把<code>user</code>作为参数层层传递，从<code>service-1()</code>传到<code>service-2()</code>,再从<code>service-2()</code>传到<code>service-3()</code>，以此类推，但是这样做会导致代码冗余且不易维护。</p>
<p>​	在此基础上可以演进，使用<code>UserMap</code>，就是每个用户的信息都存在一个<code>Map</code>中，当多线程同时工作时，我们需要保证线程安全，可以用<code>synchronized</code>也可以用<code>ConcurrentHashMap</code>，但这两者无论用什么，都会对性能有所影响。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service1</span>().process(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        UserContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service3</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service3拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        UserContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); <span class="comment">// 对比上一个例子，这里没有重写initialValue方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service2拿到用户名：张三</span><br><span class="line">Service3拿到用户名：张三</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这样，不管哪个<code>Service</code>都能拿到<code>User</code>对象，能获取<code>User</code>对象内的所有信息。并且假如有多个请求，一个张三，一个李四，因为他们并没有直接共享<code>User</code>对象，所以他们之间不会有线程安全问题。</p>
<p>​	使用<code>ThreadLocal</code>后无需<code>synchronized</code>，可以在不影响性能的情况下，也无需层层传递参数，就可以达到保存当前线程对应的用户信息的目的。</p>
</blockquote>
<h3 id="ThreadLocal的作用和好处"><a href="#ThreadLocal的作用和好处" class="headerlink" title="ThreadLocal的作用和好处"></a>ThreadLocal的作用和好处</h3><h4 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h4><blockquote>
<ul>
<li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li>
<li>在任何方法中都可以轻松获取到该对象</li>
</ul>
</blockquote>
<h4 id="ThreadLocal两种用法"><a href="#ThreadLocal两种用法" class="headerlink" title="ThreadLocal两种用法"></a>ThreadLocal两种用法</h4><blockquote>
<p>根据共享对象的生成时机不同，选择<code>initialValue</code>或<code>set</code>来保存对象</p>
<ul>
<li>不受外界传参影响的时候，可以选择重写<code>initialValue()</code>方法来初始化保存对象，会在<code>ThreadLocal</code>第一次调用<code>get()</code>方法的时候初始化对象，对象的初始化时机可以由我们控制，比如上面第一个例子工具类。</li>
<li>如果需要保存到<code>ThreadLocal</code>里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息，用<code>ThreadLocal.set()</code>直接放到我们的<code>ThreadLocal</code>中去，以便后续使用，对应代码就是上面第二个例子。</li>
</ul>
</blockquote>
<h4 id="使用ThreadLocal带来的四个好处"><a href="#使用ThreadLocal带来的四个好处" class="headerlink" title="使用ThreadLocal带来的四个好处"></a>使用ThreadLocal带来的四个好处</h4><blockquote>
<ul>
<li>达到线程安全</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效地利用内存节省开销，上面例子中，相比于成千上万个任务，每个任务都新建一个<code>SimpleDateFormat</code>，显然用<code>ThreadLocal</code>可以节省内存和开销。</li>
<li>免去传参的繁琐，不需要每次都传同样的参数，<code>ThreadLocal</code>使得代码耦合度更低，更优雅</li>
</ul>
</blockquote>
<h3 id="ThreadLocal主要方法介绍"><a href="#ThreadLocal主要方法介绍" class="headerlink" title="ThreadLocal主要方法介绍"></a>ThreadLocal主要方法介绍</h3><p>主要是<code>initialValue</code>、<code>set</code>、<code>get</code>、<code>remove</code>这几个方法，关于源码分析，后面介绍</p>
<blockquote>
<ul>
<li><p><code>initialValue</code>方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，<strong>只有在调用<code>get</code>的时候，才会触发</strong>。</p>
</li>
<li><p>当线程第一次使用<code>get</code>方法访问变量时，将调用<code>initialValue</code>方法，除非线程先前调用了<code>set</code>方法，在这种情况下，不会为线程调用本<code>initialValue</code>方法。</p>
</li>
<li><p>通常，每个线程最多调用一次<code>initialValue()</code>方法，但如果已经调用了一次<code>remove()</code>后，再调用<code>get()</code>，则可以再次调用<code>initialValue()</code>，相当于第一次调用<code>get()</code>。</p>
</li>
<li><p>如果不重写<code>initialValue()</code>方法，这个方法会返回<code>null</code>。一般使用匿名内部类的方法来重写<code>initialValue()</code>方法，以便在后续使用中可以初始化副本对象。</p>
</li>
</ul>
</blockquote>
<h3 id="ThreadLocal原理源码分析"><a href="#ThreadLocal原理源码分析" class="headerlink" title="ThreadLocal原理源码分析"></a>ThreadLocal原理源码分析</h3><h4 id="Thread、ThreadLocal、ThreadLocalMap三者的关系"><a href="#Thread、ThreadLocal、ThreadLocalMap三者的关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap三者的关系"></a>Thread、ThreadLocal、ThreadLocalMap三者的关系</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njhuvtcyre5rydtufyiguohi.png"></p>
<blockquote>
<p><font color='red'>从图中可以看出，每个<code>Thread</code>对象都有一个<code>ThreadLocalMap</code>，每个<code>ThreadLocalMap</code>可以存储多个<code>ThreadLocal</code>。</font></p>
</blockquote>
<h4 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法没有默认实现，如果要用<code>initialValue</code>方法，需要自己实现，通常使用匿名内部类的方式实现（可以回顾上面代码）</p>
</blockquote>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">    	第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">    	第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong><code>get</code>方法是先取出当前线程的<code>ThreadLocalMap</code>，然后调用<code>map.getEntry()</code>方法，把本<code>ThreadLocal</code>的引用作为参数传入，取出<code>map</code>中属于本<code>ThreadLocal</code>的<code>value</code></p>
<p><strong>注意：</strong>这个<code>map</code>以及<code>map</code>中的<code>key</code>和<code>value</code>都是保存在线程中<code>ThreadLocalMap</code>的，而不是保存在<code>ThreadLocal</code>中</p>
<p><code>getMap</code>方法：获取到当前线程内的<code>ThreadLocalMap</code>对象<br>每个线程内都有<code>ThreadLocalMap</code>对象，名为<code>threadLocals</code>，初始值为<code>null</code></p>
</blockquote>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">       <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h4><p><code>ThreadLocalMap</code>类，也就是<code>Thread.threadLocals</code></p>
<blockquote>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，没有实现<code>Map</code>接口，用独立的方式实现了<code>Map</code>的功能，其内部的<code>Entry</code>也是独立实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此行声明在Thread类中，创建ThreadLocalMap就是对Thread类的这个成员变量赋值</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/monubyutvyctxerdtcyvgbhijnomkl.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment"> */</span>        <span class="number">0.75</span> * length</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	在<code>ThreadLocalMap</code>中，也是用<code>Entry</code>来保存<code>K-V</code>结构数据的。不过<code>Entry</code>中的<code>key</code>只能是<code>ThreadLocal</code>对象，这点在构造方法中已经限定死了。</p>
</blockquote>
<blockquote>
<p>​	<font color='red'>另外，<code>Entry</code>继承<code>WeakReference</code>，也就是<code>key</code>（<code>ThreadLocal</code>）是弱引用，其目的是将<code>ThreadLocal</code>对象的生命周期和线程生命周期解绑。</font>&gt;</p>
</blockquote>
<h3 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h3><blockquote>
<ul>
<li><code>ThreadLocalMap</code>中的<code>Entry</code>继承自 <code>WeakReference</code>，是弱引用</li>
<li>弱引用：通过<code>WeakReference</code>类实现的，在<code>GC</code>的时候，不管内存空间足不足都会回收这个对象，适用于内存敏感的缓存，<code>ThreadLocal</code>中的<code>key</code>就用到了弱引用，有利于内存回收。</li>
<li>强引用：我们平日里面的用到的<code>new</code>了一个对象就是强引用，例如 <code>Object obj = new Object()</code>;当<code>JVM</code>的内存空间不足时，宁愿抛出<code>OutOfMemoryError</code>使得程序异常终止也不愿意回收具有强引用的存活着的对象。</li>
</ul>
</blockquote>
<p><font color='red'><code>ThreadLocalMap</code> 的每个 <code>Entry</code> 都是一个对<code>key</code>的弱引用，同时，每个 <code>Entry</code> 都包含了一个对<code>value</code>的强引用，如下：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">         <span class="built_in">super</span>(k); <span class="comment">// key值给WeakReference处理</span></span><br><span class="line">         value = v; <span class="comment">// value直接用变量保存，是强引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	正常情况下，当线程终止，保存在<code>ThreadLocalMap</code>里的<code>value</code>会被垃圾回收，因为没有任何强引用了。但如果线程不终止（比如线程需要保持很久），那么<code>key</code>对应的<code>value</code>就不能被回收，因为有以下的调用链：</p>
<p><code>CurrentThread----&gt;ThreadLocalMap----&gt;Entry(key为null，弱引用被回收)----&gt;value</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ljnbhugvyctxercytbium.png"></p>
<p>​	因为<code>value</code>和<code>Thread</code>之间还存在这个强引用链路，所以导致<code>value</code>无法回收，就可能会出现<code>OOM</code></p>
<p>​	<code>JDK</code>已经考虑到了这个问题，所以在<code>set</code>, <code>remove</code>, <code>rehash</code>方法中会扫描<code>key</code>为<code>null</code>的<code>Entry</code>，并把对应的<code>value</code>设置为<code>null</code>，这样<code>value</code>对象就可以被回收&#96;</p>
<p>比如<code>rehash</code>里面调用<code>resize</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">          ......省略代码</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">          <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">              e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">          &#125; </span><br><span class="line">          ......</span><br></pre></td></tr></table></figure>

<p>​	如果<code>key</code>回收了，那么<code>value</code>也设置为<code>null</code>，断开强引用链路，便于垃圾回收。</p>
<p>​	<strong>但是如果一个<code>ThreadLocal</code>不被使用，那么实际上<code>set</code>, <code>remove</code>, <code>rehash</code>方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了<code>value</code>的内存泄漏</strong>。</p>
</blockquote>
<h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><blockquote>
<p>​	及时调用<code>remove</code>方法，就会删除对应的<code>Entry</code>对象，可以避免内存<code>remove</code>泄漏，所以使用完<code>ThreadLocal</code>之后，应该调用<code>remove</code>方法。</p>
<p>​	比如拦截器获取到用户信息，用户信息存在<code>ThreadLocalMap</code>中，线程请求结束之前拦住它，并用<code>remove</code>清除<code>User</code>对象，这样就能稳妥的保证不会内存泄漏。</p>
</blockquote>
<h3 id="ThreadLocalMap的hash冲突的解决"><a href="#ThreadLocalMap的hash冲突的解决" class="headerlink" title="ThreadLocalMap的hash冲突的解决"></a>ThreadLocalMap的hash冲突的解决</h3><blockquote>
<p>​	构造函数首先创建一个长度为<code>16</code>的<code>Entry</code>数组，然后计算出<code>firstKey</code>对应的索引，然后存储到<code>table</code>中，并设置<code>size</code>和<code>threshold</code>。</p>
</blockquote>
<h4 id="ThreadLocalMap中的set方法"><a href="#ThreadLocalMap中的set方法" class="headerlink" title="ThreadLocalMap中的set方法"></a>ThreadLocalMap中的set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">        <span class="comment">//计算索引(重点代码，刚才分析过了）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用线性探测法查找元素（重点代码）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//ThreadLocal 对应的 key 存在，直接覆盖之前的值</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，</span></span><br><span class="line">           <span class="comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。</span></span><br><span class="line"><span class="comment">             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行				 * rehash（执行一次全表的扫描清理工作）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码执行流程：</strong></p>
<ol>
<li>首先还是根据<code>key</code>计算出索引 <code>i</code>，然后查找<code>i</code>位置上的<code>Entry</code></li>
<li>若是<code>Entry</code>已经存在并且<code>key</code>等于传入的<code>key</code>，那么这时候直接给这个<code>Entry</code>赋新的<code>value</code>值</li>
<li>若是<code>Entry</code>存在，但是<code>key</code>为<code>null</code>，则调用<code>replaceStaleEntry</code>来更换这个<code>key</code>为空的<code>Entry</code></li>
<li>不断循环检测，直到遇到为<code>null</code>的地方，这时候要是还没在循环过程中<code>return</code>，那么就在这个<code>null</code>的位置新建一个<code>Entry</code>，并且插入，同时<code>size</code>增加<code>1</code></li>
</ol>
<p>​	最后调用<code>cleanSomeSlots</code>，清理<code>key</code>为<code>null</code>的<code>Entry</code>，最后返回是否清理了<code>Entry</code>，接下来再判断<code>sz</code> 是否<code>&gt;= thresgold</code>达到了<code>rehash</code>的条件，达到的话就会调用<code>rehash</code>函数执行一次全表的扫描清理。</p>
<p>​	如果遇到空<code>Entry</code>，则直接设置<code>Key</code>，<code>Value</code>值，并判断<code>Entry</code>数组是否需要扩容；因为此处<code>Entry</code>数组新增了一个<code>Entry</code>，所以首先执行一次启发式擦除过程，如果成功擦除了元素，表明<code>Entry</code>数组并无变大，不需要扩容，否则，新增一个元素后，如果<code>Entry</code>数组大小大于阈值，则进行扩容。</p>
</blockquote>
<blockquote>
<p>重点分析：<code>ThreadLocalMap</code>使用<strong>线性探测法</strong>来解决哈希冲突的。（<code>HashMap</code>使用<strong>拉链法</strong>）</p>
<p>​	举个例子，假设当前table长度为<code>16</code>，也就是说如果计算出来<code>key</code>的<code>hash</code>值为<code>14</code>，如果<code>table[14]</code>上已经有值，并且其<code>key</code>与当前<code>key</code>不一致，那么就发生了<code>hash</code>冲突，这个时候将<code>14</code>加<code>1</code>得到<code>15</code>，取<code>table[15]</code>进行判断，这个时候如果还是冲突会回到<code>0</code>，取<code>table[0]</code>,以此类推，直到可以插入。</p>
<p>​	按照上面的描述，可以把<code>Entry[] table</code>看成一个环形数组。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">初学者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://example.com/2021/12/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/tyjukitlikyudtys9865.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="牛客网编程遇到的问题"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/umtjnyrhbgvsfcad.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">牛客网编程遇到的问题</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="常见的设计模式"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/olkijhfgbvf9485.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见的设计模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初学者</div><div class="author-info__description">虽千万人，吾往矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">进程的三态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">进程的五态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">进程的七态模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">线程状态之五种状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">线程状态之六种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NEW-RUNNABLE"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">NEW &lt;–&gt; RUNNABLE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-WAITING"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-WAITING-1"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-WAITING-2"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-TIMED-WAITING"><span class="toc-number">1.2.1.2.5.</span> <span class="toc-text">RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-TIMED-WAITING-1"><span class="toc-number">1.2.1.2.6.</span> <span class="toc-text">RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-TIMED-WAITING-2"><span class="toc-number">1.2.1.2.7.</span> <span class="toc-text">RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-TIMED-WAITING-3"><span class="toc-number">1.2.1.2.8.</span> <span class="toc-text">RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-BLOCKED"><span class="toc-number">1.2.1.2.9.</span> <span class="toc-text">RUNNABLE &lt;–&gt; BLOCKED</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RUNNABLE-TERMINATED"><span class="toc-number">1.2.1.2.10.</span> <span class="toc-text">RUNNABLE &lt;–&gt; TERMINATED</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">进程和线程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">进程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">并行和并发的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread"><span class="toc-number">3.1.</span> <span class="toc-text">Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable"><span class="toc-number">3.2.</span> <span class="toc-text">Runnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-Future"><span class="toc-number">3.3.</span> <span class="toc-text">Callable + Future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable%E5%92%8CRunnable%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">3.3.1.</span> <span class="toc-text">Callable和Runnable不同点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Thread-Context-Switch%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">线程上下文切换（Thread Context Switch）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">Thread的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#start-%E4%B8%8E-run"><span class="toc-number">3.5.1.</span> <span class="toc-text">start 与 run</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8start"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">调用start</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8run"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">调用run</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E4%B8%8E-yield"><span class="toc-number">3.5.2.</span> <span class="toc-text">sleep 与 yield</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sleep"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">sleep</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">yield</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.5.3.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">3.5.4.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt"><span class="toc-number">3.5.5.</span> <span class="toc-text">interrupt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E6%96%AD%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.5.6.</span> <span class="toc-text">打断正常运行的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.7.</span> <span class="toc-text">终止模式之两阶段终止模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%EF%BC%8Cyiled%EF%BC%8Cwait%EF%BC%8Cjoin-%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.8.</span> <span class="toc-text">sleep，yiled，wait，join 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park%E4%B8%8Eunpark"><span class="toc-number">3.5.9.</span> <span class="toc-text">park与unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.9.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#park%E4%B8%8Eunpark-%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.9.2.</span> <span class="toc-text">park与unpark 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E8%B0%83%E7%94%A8park%E5%86%8D%E8%B0%83%E7%94%A8unpark%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.9.2.1.</span> <span class="toc-text">先调用park再调用unpark的过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E8%B0%83%E7%94%A8unpark%E5%86%8D%E8%B0%83%E7%94%A8park%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.9.2.2.</span> <span class="toc-text">先调用unpark再调用park的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E4%B8%8Enotify-%E5%B1%9E%E4%BA%8E%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.10.</span> <span class="toc-text">wait与notify(属于重量级锁的方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#API%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.10.1.</span> <span class="toc-text">API介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sleep-long-n-%E5%92%8C-wait-long-n-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%87%8D%E7%82%B9"><span class="toc-number">3.5.10.2.</span> <span class="toc-text">sleep(long n) 和 wait(long n)的区别 (重点)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait-notify%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.10.3.</span> <span class="toc-text">wait&#x2F;notify的正确使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Step-1-%E9%80%90%E6%B8%90%E5%90%91%E4%B8%8B%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.10.3.1.</span> <span class="toc-text">Step 1 : 逐渐向下优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Step2"><span class="toc-number">3.5.10.3.2.</span> <span class="toc-text">Step2:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Step3"><span class="toc-number">3.5.10.3.3.</span> <span class="toc-text">Step3:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Step4"><span class="toc-number">3.5.10.3.4.</span> <span class="toc-text">Step4:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Step5"><span class="toc-number">3.5.10.3.5.</span> <span class="toc-text">Step5:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">线程出现问题的根本原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">问题的进一步描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">竞态条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.3.</span> <span class="toc-text">synchronized 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">synchronized加锁方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%88%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">修饰普通方法（锁住的是当前实例对象）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BC%A0%E5%8F%82this%EF%BC%88%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">同步代码块传参this（锁住的是当前实例对象）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BC%A0%E5%8F%82%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1-%EF%BC%88%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">同步代码块传参变量对象 （锁住的是变量对象）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BC%A0%E5%8F%82class%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%89"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">同步代码块传参class对象（全局锁）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%89"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">修饰静态方法（全局锁）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">5.</span> <span class="toc-text">Java对象内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">5.1.</span> <span class="toc-text">对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E4%BD%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">5.1.1.</span> <span class="toc-text">32位的虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">普通对象的对象头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">数组对象的对象头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E6%83%85"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">32位虚拟机详情</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%A6%E6%83%85"><span class="toc-number">5.1.2.</span> <span class="toc-text">64位虚拟机详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%A532%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%BA%E4%BE%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">下面以32位虚拟机为例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mark-Word"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">Mark Word</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor"><span class="toc-number">6.</span> <span class="toc-text">Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.1.</span> <span class="toc-text">Monitor原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">Synchronized原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">加锁和释放锁的原理加锁和释放锁的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9A%E5%8A%A0%E9%94%81%E6%AC%A1%E6%95%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">可重入原理：加锁次数计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">7.4.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E4%BC%98%E5%8C%96-%E4%BC%98%E5%8C%96%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89"><span class="toc-number">7.5.</span> <span class="toc-text">自旋锁优化 (优化重量级锁竞争)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-biased-lock-%E7%94%A8%E4%BA%8E%E4%BC%98%E5%8C%96%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">7.6.</span> <span class="toc-text">偏向锁 (biased lock) (用于优化轻量级锁重入)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">8.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">Lock和synchronized区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6-%E9%87%8D%E7%82%B9"><span class="toc-number">8.2.1.</span> <span class="toc-text">发生死锁的必要条件 (重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">定位死锁的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E3%80%81JPS-JStack-%E8%BF%9B%E7%A8%8BID"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">方式一、JPS + JStack 进程ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E3%80%81-jconsole%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">方式二、 jconsole检测死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.3.</span> <span class="toc-text">ReentrantLock 的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">8.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">8.3.2.</span> <span class="toc-text">支持锁重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">8.3.3.</span> <span class="toc-text">可中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">8.3.4.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6-lock-tryLock-%E7%9B%B4%E6%8E%A5%E9%80%80%E5%87%BA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-%E8%8E%B7%E5%8F%96%E9%94%81%E5%A4%B1%E8%B4%A5"><span class="toc-number">8.3.5.</span> <span class="toc-text">锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87lock-tryLock-%E6%9D%A5%E8%A7%A3%E5%86%B3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98-%E9%87%8D%E7%82%B9"><span class="toc-number">8.3.6.</span> <span class="toc-text">通过lock.tryLock()来解决, 哲学家就餐问题 (重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">8.3.7.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-new-ReentrantLock-true"><span class="toc-number">8.3.8.</span> <span class="toc-text">公平锁 new ReentrantLock(true)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">8.3.8.1.</span> <span class="toc-text">什么是公平锁? 什么是非公平锁?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.9.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E5%8F%AF%E9%81%BF%E5%85%8D%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92-lock-newCondition-%E5%88%9B%E5%BB%BA%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1-%E9%80%9A%E8%BF%87%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8await-signal%E6%96%B9%E6%B3%95-%E7%AD%89%E5%BE%85-%E5%94%A4%E9%86%92"><span class="toc-number">8.3.10.</span> <span class="toc-text">条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用await&#x2F;signal方法, 等待&#x2F;唤醒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6-%E6%A1%88%E4%BE%8B"><span class="toc-number">8.4.</span> <span class="toc-text">同步模式之顺序控制 (案例)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify%E7%89%88%E6%9C%AC"><span class="toc-number">8.4.1.</span> <span class="toc-text">wait&#x2F;notify版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await-signal%E7%89%88%E6%9C%AC"><span class="toc-number">8.4.2.</span> <span class="toc-text">await&#x2F;signal版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park-unpartk%E7%89%88%E6%9C%AC"><span class="toc-number">8.4.3.</span> <span class="toc-text">park&#x2F;unpartk版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number">8.5.</span> <span class="toc-text">交替输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify%E7%89%88%E6%9C%AC-1"><span class="toc-number">8.5.1.</span> <span class="toc-text">wait&#x2F;notify版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await-signal%E7%89%88%E6%9C%AC-1"><span class="toc-number">8.5.2.</span> <span class="toc-text">await&#x2F;signal版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park-unpark%E7%89%88%E6%9C%AC"><span class="toc-number">8.5.3.</span> <span class="toc-text">park&#x2F;unpark版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E6%89%93%E5%8D%B01-100"><span class="toc-number">8.6.</span> <span class="toc-text">三个线程轮流打印1-100</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">Java 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">9.1.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">9.1.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">9.1.3.</span> <span class="toc-text">有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.</span> <span class="toc-text">JMM如何解决原子性、可见性和有序性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.1.</span> <span class="toc-text">原子性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.2.</span> <span class="toc-text">可见性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.3.</span> <span class="toc-text">有序性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.</span> <span class="toc-text">指令重排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#as-if-serial%E8%AF%AD%E4%B9%89"><span class="toc-number">9.3.1.</span> <span class="toc-text">as-if-serial语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="toc-number">9.3.2.</span> <span class="toc-text">happens-before 原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.</span> <span class="toc-text">并发编程的两个关键问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">9.4.1.</span> <span class="toc-text">线程之间如何通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5"><span class="toc-number">9.4.2.</span> <span class="toc-text">线程之间如何同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">9.5.</span> <span class="toc-text">JMM原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">9.5.1.</span> <span class="toc-text">八种原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E8%A7%84%E5%AE%9A%E4%BA%86%E4%BB%A5%E4%B8%8A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E6%8C%89%E7%85%A7%E5%A6%82%E4%B8%8B%E8%A7%84%E5%88%99%E8%BF%9B%E8%A1%8C"><span class="toc-number">9.5.2.</span> <span class="toc-text">JMM规定了以上8中操作需要按照如下规则进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.5.3.</span> <span class="toc-text">具体操作步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock%E5%92%8Cunlock"><span class="toc-number">9.5.4.</span> <span class="toc-text">lock和unlock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM-%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">JMM 缓存不一致问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%8A%A0%E9%94%81"><span class="toc-number">9.6.1.</span> <span class="toc-text">总线加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MESI-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.6.2.</span> <span class="toc-text">MESI 缓存一致性协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">10.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.</span> <span class="toc-text">防重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">10.2.</span> <span class="toc-text">实现可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8D%95%E6%AC%A1%E8%AF%BB-%E5%86%99"><span class="toc-number">10.3.</span> <span class="toc-text">保证原子性:单次读&#x2F;写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A-i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">10.3.1.</span> <span class="toc-text">问题1： i++为什么不能保证原子性?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A-%E5%85%B1%E4%BA%AB%E7%9A%84long%E5%92%8Cdouble%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8volatile"><span class="toc-number">10.3.2.</span> <span class="toc-text">问题2： 共享的long和double变量的为什么要用volatile?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.4.</span> <span class="toc-text">volatile 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.4.1.</span> <span class="toc-text">volatile可见性实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.2.</span> <span class="toc-text">volatile 禁止重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.5.</span> <span class="toc-text">volatile 的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">10.5.1.</span> <span class="toc-text">模式1：状态标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F2%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83-one-time-safe-publication"><span class="toc-number">10.5.2.</span> <span class="toc-text">模式2：一次性安全发布(one-time safe publication)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F3%EF%BC%9A%E7%8B%AC%E7%AB%8B%E8%A7%82%E5%AF%9F-independent-observation"><span class="toc-number">10.5.3.</span> <span class="toc-text">模式3：独立观察(independent observation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F4%EF%BC%9Avolatile-bean-%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.5.4.</span> <span class="toc-text">模式4：volatile bean 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E5%BC%80%E9%94%80%E8%BE%83%E4%BD%8E%E7%9A%84%E8%AF%BB%EF%BC%8D%E5%86%99%E9%94%81%E7%AD%96%E7%95%A5"><span class="toc-number">10.5.5.</span> <span class="toc-text">模式5：开销较低的读－写锁策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5-double-checked"><span class="toc-number">10.5.6.</span> <span class="toc-text">双重检查(double-checked)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">11.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">修饰方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private-final"><span class="toc-number">11.2.1.</span> <span class="toc-text">private final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E6%96%B9%E6%B3%95%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%E7%9A%84"><span class="toc-number">11.2.2.</span> <span class="toc-text">final方法是可以被重载的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%82%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">修饰参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">11.4.</span> <span class="toc-text">修饰变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%9A%84final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%90%97"><span class="toc-number">11.4.1.</span> <span class="toc-text">所有的final修饰的字段都是编译期常量吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-final"><span class="toc-number">11.4.2.</span> <span class="toc-text">static final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blank-final"><span class="toc-number">11.4.3.</span> <span class="toc-text">blank final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-final-%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">11.5.</span> <span class="toc-text">使用 final 的限制条件和局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">12.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA"><span class="toc-number">12.1.</span> <span class="toc-text">问题提出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E4%B8%8E-volatile-%E9%87%8D%E7%82%B9"><span class="toc-number">12.2.</span> <span class="toc-text">CAS 与 volatile (重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cas-%E9%87%8D%E8%AF%95-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.1.</span> <span class="toc-text">cas + 重试 的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.2.2.</span> <span class="toc-text">volatile的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88CAS-%E9%87%8D%E8%AF%95-%E6%97%A0%E9%94%81-%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">12.2.3.</span> <span class="toc-text">为什么CAS+重试(无锁)效率高</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E7%89%B9%E7%82%B9-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">12.3.</span> <span class="toc-text">CAS 的特点 (乐观锁和悲观锁的特点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0-%E5%86%85%E9%83%A8%E9%80%9A%E8%BF%87CAS%E6%9D%A5%E5%AE%9E%E7%8E%B0-Atom"><span class="toc-number">12.4.</span> <span class="toc-text">原子整数 (内部通过CAS来实现-Atom)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8-AtomicReference"><span class="toc-number">12.5.</span> <span class="toc-text">原子引用 (AtomicReference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3-%E9%87%8D%E7%82%B9"><span class="toc-number">12.6.</span> <span class="toc-text">ABA 问题及解决 (重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicStampedReference-%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98"><span class="toc-number">12.7.</span> <span class="toc-text">AtomicStampedReference (加版本号解决ABA问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicMarkableReference-%E6%A0%87%E8%AE%B0cas%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E8%A2%AB%E4%BF%AE%E6%94%B9%E8%BF%87"><span class="toc-number">12.8.</span> <span class="toc-text">AtomicMarkableReference (标记cas的共享变量是否被修改过)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicStampedReference%E5%92%8CAtomicMarkableReference%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.9.</span> <span class="toc-text">AtomicStampedReference和AtomicMarkableReference两者的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">13.1.</span> <span class="toc-text">线程池的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="toc-number">13.2.</span> <span class="toc-text">Executor 框架结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%B1%BB-Runnable-Callable"><span class="toc-number">13.2.1.</span> <span class="toc-text">任务类 (Runnable &#x2F;Callable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C-Executor"><span class="toc-number">13.2.2.</span> <span class="toc-text">任务的执行 (Executor)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9C-Future"><span class="toc-number">13.2.3.</span> <span class="toc-text">异步计算的结果 (Future)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">13.3.</span> <span class="toc-text">Executor 框架的使用示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">13.4.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">13.5.</span> <span class="toc-text">线程池的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8F%82%E6%95%B0"><span class="toc-number">13.6.</span> <span class="toc-text">构造方法及参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">13.7.</span> <span class="toc-text">工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">13.8.</span> <span class="toc-text">拒绝策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AbortPolicy-%E4%B8%AD%E6%AD%A2%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%A2%E5%BC%83%E4%BB%BB%E5%8A%A1%E5%B9%B6%E6%8A%9B%E5%87%BARejectedExecutionException%E5%BC%82%E5%B8%B8%E3%80%82%E8%BF%99%E6%98%AF%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="toc-number">13.8.1.</span> <span class="toc-text">AbortPolicy 中止策略：丢弃任务并抛出RejectedExecutionException异常。这是默认策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CallerRunsPolicy-%E8%B0%83%E7%94%A8%E8%80%85%E8%BF%90%E8%A1%8C%E7%AD%96%E7%95%A5%EF%BC%9A%E7%94%B1%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E8%AF%A5%E4%BB%BB%E5%8A%A1%E3%80%82"><span class="toc-number">13.8.2.</span> <span class="toc-text">CallerRunsPolicy 调用者运行策略：由调用线程处理该任务。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardPolicy-%E4%B8%A2%E5%BC%83%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%A2%E5%BC%83%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E5%88%99%E5%90%8E%E7%BB%AD%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%83%BD%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83%EF%BC%8C%E4%B8%94%E6%98%AF%E9%9D%99%E9%BB%98%E4%B8%A2%E5%BC%83%E3%80%82"><span class="toc-number">13.8.3.</span> <span class="toc-text">DiscardPolicy 丢弃策略：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardOldestPolicy-%E5%BC%83%E8%80%81%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%A2%E5%BC%83%E9%98%9F%E5%88%97%E6%9C%80%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E7%84%B6%E5%90%8E%E9%87%8D%E6%96%B0%E6%8F%90%E4%BA%A4%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%82"><span class="toc-number">13.8.4.</span> <span class="toc-text">DiscardOldestPolicy 弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">13.9.</span> <span class="toc-text">newFixedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">13.9.0.1.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">13.10.</span> <span class="toc-text">newCachedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">13.10.0.1.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">13.11.</span> <span class="toc-text">newSingleThreadExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.11.0.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors-%E8%BF%94%E5%9B%9E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%A6%82%E4%B8%8B"><span class="toc-number">13.12.</span> <span class="toc-text">Executors 返回线程池对象的弊端如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1-execute-submit"><span class="toc-number">13.13.</span> <span class="toc-text">执行&#x2F;提交任务 execute&#x2F;submit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-%E6%96%B9%E6%B3%95"><span class="toc-number">13.13.1.</span> <span class="toc-text">execute()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-%E6%96%B9%E6%B3%95"><span class="toc-number">13.13.2.</span> <span class="toc-text">submit()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0-shutdown"><span class="toc-number">13.14.</span> <span class="toc-text">关闭线程池 shutdown()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdownNow"><span class="toc-number">13.15.</span> <span class="toc-text">shutdownNow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="toc-number">13.16.</span> <span class="toc-text">其它方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%A4%A7%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%88%E9%80%82"><span class="toc-number">13.17.</span> <span class="toc-text">创建多大的线程池合适?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CPU-%E5%AF%86%E9%9B%86%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="toc-number">13.17.0.0.1.</span> <span class="toc-text">CPU 密集型运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="toc-number">13.17.0.0.2.</span> <span class="toc-text">I&#x2F;O 密集型运算</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPoolExecutor"><span class="toc-number">13.18.</span> <span class="toc-text">ScheduledThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ScheduledExecutorService-%E4%B8%AD-scheduleAtFixedRate%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.18.1.</span> <span class="toc-text">ScheduledExecutorService 中 scheduleAtFixedRate方法的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScheduledExecutorService-%E4%B8%ADscheduleWithFixedDelay%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.18.2.</span> <span class="toc-text">ScheduledExecutorService 中scheduleWithFixedDelay方法的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">14.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">14.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.</span> <span class="toc-text">ReentrantLock 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.1.</span> <span class="toc-text">非公平锁实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B"><span class="toc-number">14.2.1.1.</span> <span class="toc-text">图解流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.2.</span> <span class="toc-text">可重入原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.3.</span> <span class="toc-text">可打断原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.4.</span> <span class="toc-text">公平锁实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.5.</span> <span class="toc-text">条件变量实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-1"><span class="toc-number">14.2.5.1.</span> <span class="toc-text">图解流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">14.2.5.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">14.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">14.3.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98"><span class="toc-number">14.3.2.</span> <span class="toc-text">应用之缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">14.3.3.</span> <span class="toc-text">读写锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-2"><span class="toc-number">14.3.3.1.</span> <span class="toc-text">图解流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">14.3.3.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">15.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">15.1.</span> <span class="toc-text">类的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">类的内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-Sync%E7%B1%BB"><span class="toc-number">15.2.1.</span> <span class="toc-text">类的内部类 - Sync类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-NonfairSync%E7%B1%BB"><span class="toc-number">15.2.2.</span> <span class="toc-text">类的内部类 - NonfairSync类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB-FairSync%E7%B1%BB"><span class="toc-number">15.2.3.</span> <span class="toc-text">类的内部类 - FairSync类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">15.3.</span> <span class="toc-text">类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">15.4.</span> <span class="toc-text">类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">Semaphore有哪些常用的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8Semaphore%E7%9A%84%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">可以举一个使用Semaphore的例子吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.6.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%994%E4%B8%AA%E4%BA%BA%E4%BC%9A%E6%8C%89%E7%85%A7%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%B4%97%E6%89%8B%E5%98%9B%EF%BC%9F"><span class="toc-number">15.6.2.</span> <span class="toc-text">这4个人会按照线程启动的顺序洗手嘛？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Semaphore%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">15.7.</span> <span class="toc-text">对Semaphore的内部原理有没有了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonfairSync%E5%92%8CFairSync%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%80%A0%E6%88%90%E8%BF%99%E6%A0%B7%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-number">15.8.</span> <span class="toc-text">NonfairSync和FairSync有什么区别？为什么会造成这样的效果？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.</span> <span class="toc-text">Semaphore示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">16.1.</span> <span class="toc-text">场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C11%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%90%84%E8%B0%83%E7%94%A81%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">16.1.1.</span> <span class="toc-text">semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A811%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">16.1.2.</span> <span class="toc-text">semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%891%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C1%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1acquire%E6%96%B9%E6%B3%95%EF%BC%8C%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1release%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8acquire-2-%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AD%A4%E7%BA%BF%E7%A8%8B%E8%83%BD%E5%A4%9F%E8%8E%B7%E5%8F%96%E5%88%B0%E8%B6%B3%E5%A4%9F%E7%9A%84%E4%BB%A4%E7%89%8C%E5%B9%B6%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C%E5%90%97"><span class="toc-number">16.1.3.</span> <span class="toc-text">semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%892%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A81%E6%AC%A1release%E6%96%B9%E6%B3%95%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E8%8E%B7%E5%8F%963%E4%B8%AA%E4%BB%A4%E7%89%8C%EF%BC%8C%E4%BC%9A%E8%8E%B7%E5%8F%96%E5%88%B0%E5%90%97"><span class="toc-number">16.1.4.</span> <span class="toc-text">semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">17.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">CountDownLatch有哪些常用的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8countDown%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B9%9F%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%98%9B%EF%BC%9F"><span class="toc-number">17.2.</span> <span class="toc-text">调用countDown方法时，线程也会阻塞嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8CountDownLatch%E7%9A%84%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="toc-number">17.3.</span> <span class="toc-text">可以举一个使用CountDownLatch的例子吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">17.3.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E9%A1%BE%E5%AE%A2%E8%BF%9F%E8%BF%9F%E6%B2%A1%E5%88%B0%EF%BC%8C%E9%A5%AD%E5%BA%97%E9%83%BD%E6%89%93%E6%A0%B7%E4%BA%86%EF%BC%8C%E4%B9%9F%E4%B8%8D%E8%83%BD%E4%B8%80%E7%9B%B4%E7%AD%89%E5%95%8A%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%BF%99%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">17.3.2.</span> <span class="toc-text">如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.4.</span> <span class="toc-text">CountDownLatch的实现原理是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">18.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">18.1.</span> <span class="toc-text">CyclicBarrier源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.</span> <span class="toc-text">await方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">18.3.</span> <span class="toc-text">应用程序示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">19.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">19.1.</span> <span class="toc-text">举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901%EF%BC%9A"><span class="toc-number">19.1.1.</span> <span class="toc-text">例子1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902%EF%BC%9A"><span class="toc-number">19.1.2.</span> <span class="toc-text">例子2：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%A5%BD%E5%A4%84"><span class="toc-number">19.2.</span> <span class="toc-text">ThreadLocal的作用和好处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BD%9C%E7%94%A8"><span class="toc-number">19.2.1.</span> <span class="toc-text">ThreadLocal的两个作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">19.2.2.</span> <span class="toc-text">ThreadLocal两种用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadLocal%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%A5%BD%E5%A4%84"><span class="toc-number">19.2.3.</span> <span class="toc-text">使用ThreadLocal带来的四个好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.3.</span> <span class="toc-text">ThreadLocal主要方法介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">19.4.</span> <span class="toc-text">ThreadLocal原理源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E3%80%81ThreadLocal%E3%80%81ThreadLocalMap%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">19.4.1.</span> <span class="toc-text">Thread、ThreadLocal、ThreadLocalMap三者的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initialValue%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.2.</span> <span class="toc-text">initialValue方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.3.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.4.</span> <span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.5.</span> <span class="toc-text">remove方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E7%B1%BB"><span class="toc-number">19.4.6.</span> <span class="toc-text">ThreadLocalMap类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">19.5.</span> <span class="toc-text">弱引用和内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">19.5.1.</span> <span class="toc-text">避免内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84hash%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">19.6.</span> <span class="toc-text">ThreadLocalMap的hash冲突的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E4%B8%AD%E7%9A%84set%E6%96%B9%E6%B3%95"><span class="toc-number">19.6.1.</span> <span class="toc-text">ThreadLocalMap中的set方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="发表于 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="发表于 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="发表于 2022-01-13 20:15:31">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2022-01-04T09:01:41.000Z" title="发表于 2022-01-04 17:01:41">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-01-02T11:57:45.000Z" title="发表于 2022-01-02 19:57:45">2022-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 初学者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>