<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java集合 | Blog</title><meta name="author" content="初学者"><meta name="copyright" content="初学者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录Java集合的基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合">
<meta property="og:url" content="https://www.wyy-blog.cn/2021/12/30/Java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="记录Java集合的基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/vzbgnhgmjujydhstgra5.jpg">
<meta property="article:published_time" content="2021-12-30T02:57:33.000Z">
<meta property="article:modified_time" content="2022-02-28T04:53:14.000Z">
<meta property="article:author" content="初学者">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/vzbgnhgmjujydhstgra5.jpg"><link rel="shortcut icon" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg"><link rel="canonical" href="https://www.wyy-blog.cn/2021/12/30/Java%E9%9B%86%E5%90%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-28 12:53:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/vzbgnhgmjujydhstgra5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-30T02:57:33.000Z" title="发表于 2021-12-30 10:57:33">2021-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-28T04:53:14.000Z" title="更新于 2022-02-28 12:53:14">2022-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>154分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<p>说明：本篇博客主要内容来自网上的资料，我只是做个总结。</p>
<h2 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2243690-9cd9c896e0d512ed.gif"></p>
<h2 id="常用集合的分类"><a href="#常用集合的分类" class="headerlink" title="常用集合的分类"></a>常用集合的分类</h2><blockquote>
<p><code>Collection</code> 接口的接口 对象的集合（单列集合）<br>├——-├ <code>List</code> 接口：元素按进入先后有序保存，可重复<br>│—————-├ <code>LinkedList</code> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ <code>ArrayList</code> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-├ <code>Vector</code> 接口实现类 数组， 同步， 线程安全<br>│ ———————├ <code>Stack</code> 是<code>Vector</code>类的实现类<br>└——-├ <code>Set</code> 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-├ <code>HashSet</code> 使用<code>hash</code>表（数组）存储元素<br>│————————├ <code>LinkedHashSet</code> 链表维护元素的插入次序<br>└ —————-├ <code>TreeSet</code> 底层实现为二叉树，元素排好序</p>
<p><code>Map</code> 接口 键值对的集合 （双列集合）<br>├———-├ <code>Hashtable</code> 接口实现类， 同步， 线程安全<br>├———-├ <code>HashMap</code> 接口实现类 ，没有同步， 线程不安全-<br>│—————–├ <code>LinkedHashMap</code> 双向链表和哈希表实现<br>│—————-├ <code>WeakHashMap</code><br>├ ——-├ <code>TreeMap</code> 红黑树对所有的<code>key</code>进行排序<br>└———-├ <code>IdentifyHashMap</code></p>
</blockquote>
<h2 id="List、Set、Map的区别是什么？"><a href="#List、Set、Map的区别是什么？" class="headerlink" title="List、Set、Map的区别是什么？"></a>List、Set、Map的区别是什么？</h2><blockquote>
<ul>
<li><code>List</code>是一个继承于<code>Collection</code>的接口，即<code>List</code>是集合中的一种。**<code>List</code>是有序的队列<strong>，<code>List</code>中的每一个元素都有一个索引。和<code>Set</code>不同，</strong><code>List</code>中允许有重复的元素，可以插入多个<code>null</code>元素**。实现<code>List</code>接口的集合主要有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>、<code>Stack</code>。 </li>
<li><code>Set</code>是一个继承于<code>Collection</code>的接口，<code>Set</code>是一种不包括重复元素的<code>Collection</code>。 <strong>它是一个无序容器</strong>，你无法保证每个元素的存储顺序。与<code>List</code>一样，<strong>它同样允许<code>null</code>的存在但是仅有一个</strong>。由于<code>Set</code>接口的特殊性，所有传入<code>Set</code>集合中的元素都必须不同，关于<code>API</code>方面。<code>Set</code>的<code>API</code>和<code>Collection</code>完全一样。实现了<code>Set</code>接口的集合有：<code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>、<code>EnumSet</code>。 </li>
<li><code>Map</code>与<code>List</code>、<code>Set</code>接口不同，它是由一系列键值对组成的集合，提供了<code>key</code>到<code>Value</code>的映射。在<code>Map</code>中它保证了<code>key</code>与<code>value</code>之间的一一对应关系。也就是说一个<code>key</code>对应一个<code>value</code>，所以它不能存在相同的<code>key</code>值，当然<code>value</code>值可以相同。实现<code>map</code>的集合有：<code>HashMap</code>、<code>HashTable</code>、<code>TreeMap</code>、<code>WeakHashMap</code>。 </li>
<li>总结：   </li>
<li><code>List</code>、<code>Set</code>都是继承自<code>Collection</code>接口，<code>Map</code>则不是 </li>
<li><code>List</code>特点：元素有放入顺序，元素可重复 ，<code>Set</code>特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在<code>set</code>中的位置是有该元素的<code>HashCode</code>决定的，其位置其实是固定的，加入<code>Set</code> 的<code>Object</code>必须定义<code>equals()</code>方法 ，另外<code>list</code>支持<code>for</code>循环，也就是通过下标来遍历，也可以用迭代器，但是<code>set</code>只能用迭代，因为他无序，无法用下标来取得想要的值。） </li>
<li><code>Set</code>和<code>List</code>对比：<br>-  <code>Set</code>：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>-  <code>List</code>：和数组类似，<code>List</code>可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 </li>
<li><code>Map</code>适合储存键值对的数据 </li>
<li>线程安全集合类与非线程安全集合类 :<br>-  <code>LinkedList</code>、<code>ArrayList</code>、<code>HashSet</code>是非线程安全的，<code>Vector</code>是线程安全的;<br>- <code> HashMap</code>是非线程安全的，<code>HashTable</code>是线程安全的;<br>-  <code>StringBuilder</code>是非线程安全的，<code>StringBuffer</code>是线程安全的。</li>
</ul>
</blockquote>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>​	<code>ArrayList</code>实现了<code>List</code>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<code>Vector</code>大致相同。每个<code>ArrayList</code>都有一个容量<code>(capacity)</code>，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，<code>Java</code>泛型只是编译器提供的语法糖，所以这里的数组是一个<code>Object</code>数组，以便能够容纳任何类型的对象。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList_base.png"></p>
<blockquote>
<p>​	<code>size()</code>, <code>isEmpty()</code>, <code>get()</code>, <code>set()</code>方法均能在常数时间内完成，<code>add()</code>方法的时间开销跟插入位置有关，<code>addAll()</code>方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>
<p>​	为追求效率，<code>ArrayList</code>没有实现同步<code>(synchronized)</code>，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>
</blockquote>
<h3 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Serializable标记性接口"><a href="#Serializable标记性接口" class="headerlink" title="Serializable标记性接口"></a>Serializable标记性接口</h4><blockquote>
<p><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化。<br><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>​	当我们想把内存中的对象状态保存到一个文件中或者数据库中时候，就需要使用序列化。</p>
</blockquote>
<h4 id="Cloneable-标记性接口"><a href="#Cloneable-标记性接口" class="headerlink" title="Cloneable 标记性接口"></a>Cloneable 标记性接口</h4><blockquote>
<p>​	一个类实现<code>Cloneable</code> 接口来指示<code>Object.clone()</code> 方法，该方法对于该类的实例进行字段的复制是合法的。在不实现<code>Cloneable</code> 接口的实例上调用对象的克隆方法会导致异常<code>CloneNotSupportedException</code> 被抛出。简言之:克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝</p>
</blockquote>
<h4 id="RandomAccess标记性接口"><a href="#RandomAccess标记性接口" class="headerlink" title="RandomAccess标记性接口"></a>RandomAccess标记性接口</h4><blockquote>
<p>​	标记接口由<code>List</code>实现使用，以表明它们支持快速（通常为恒定时间）随机访问。此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。<br>​	用于操纵随机访问列表的最佳算法（例如<code>ArrayList</code>）可以在应用于顺序访问列表时产生二次行为（如<code>LinkedList</code>）。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，检查给定列表是否为<code>instanceof</code>，并在必要时更改其行为以保证可接受的性能。</p>
</blockquote>
<blockquote>
<p>根据经验，<code>List</code>实现应实现此接口，如果对于类的典型实例，此循环：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对返回的集合进行判断,如果返回的集合实现了 RandomAccess 就使用 普通for</span></span><br><span class="line"><span class="comment">//否则使用迭代器(增强for)    增强for本质上也是迭代器</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = list.size(); i &lt; n; i++) &#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 真正保存数据的数组   </span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 序列化id    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始容量大小为 10</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于空实例的共享空数组实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于默认大小的空实例的共享空数组实例。我们将其与空元素数据区分开，以知道何时充气添加第一个元素。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// size 是指 elementData 中实际有多少个元素，而 elementData.length 为集合容量，表示最多可以容纳多少个元素。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个变量是定义在 AbstractList 中的。记录对 List 操作的次数。主要使用是在 Iterator，是防止在迭代的过程中集合被修改。</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ArrayList()</code></td>
<td align="center">构造一个初始容量为<code>10</code>的空列表。</td>
</tr>
<tr>
<td align="center"><code>ArrayList(int initialCapacity)</code></td>
<td align="center">构造具有指定初始容量的空列表。</td>
</tr>
<tr>
<td align="center"><code>ArrayList(Collection&lt;? extends&lt;E&gt; c)</code></td>
<td align="center">构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</td>
</tr>
</tbody></table>
<h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="空参构造ArrayList"><a href="#空参构造ArrayList" class="headerlink" title="空参构造ArrayList()"></a>空参构造<code>ArrayList()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这行代码做了什么?</span></span><br><span class="line">        <span class="comment">//真的构造一个初始容量为十的空列表?</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 默认初始容量</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 空数组</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 默认容量的空数组</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 集合真正存储数组元素的数组</span></span><br><span class="line">       <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 集合的大小</span></span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>两个空数组的区别：</p>
<blockquote>
<ol>
<li><p><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 该数组为空数组，用来记录<code>ArrayList</code>在生成时没有进行传参数，随后在操作过程中将<code>elementData</code>（底层数组）的大小设置为默认值<code>10</code>。</p>
</li>
<li><p><code>EMPTY_ELEMENTDATA</code>用来记录<code>ArrayList</code>在生成时传参为<code>0</code>的情况。而为了与没传参数的情况分开所以重新用了一个空数组。</p>
</li>
</ol>
</blockquote>
<p>结论：</p>
<blockquote>
<p>​	通过空参构造方法创建集合对象并未构造一个初始容量为十的空列表，仅仅将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的地址赋值给<code>elementData</code></p>
</blockquote>
<h6 id="指定容量ArrayList-int-initialCapacity"><a href="#指定容量ArrayList-int-initialCapacity" class="headerlink" title="指定容量ArrayList(int initialCapacity)"></a>指定容量<code>ArrayList(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这行代码ArrayList底层做了什么?</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123; <span class="comment">//initialCapacity = 5</span></span><br><span class="line">        <span class="comment">//判断初始容量initialCapacity是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个数组,且指定长度为initialCapacity</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果initialCapacity容量为0，把EMPTY_ELEMENTDATA的地址赋值给elementData</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//以上两个条件都不满足报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +  initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论</p>
<blockquote>
<p>根据<code>ArrayList</code> 构造方法参数创建指定长度的数组</p>
</blockquote>
<h6 id="ArrayList-Collection-c"><a href="#ArrayList-Collection-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a><code>ArrayList(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">//这行代码做了什么?</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// 将集合构造中的集合对象转成数组,且将数组的地址赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 将elementData的长度赋值给 集合长度size,且判断是否不等于 0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断elementData 和 Object[] 是否为不一样的类型</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//如果不一样,使用Arrays的copyOf方法进行元素的拷贝</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合转数组的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="comment">//调用数组工具类方法进行拷贝</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">        <span class="comment">//再次调用方法进行拷贝</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;</span><br><span class="line">            newType) &#123;</span><br><span class="line">        <span class="comment">//用三元运算符进行判断,不管结果如何都是创建一个新数组</span></span><br><span class="line">        T[] copy = ((Object) newType == (Object) Object[].class)</span><br><span class="line">                ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">                : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        <span class="comment">//将数组的内容拷贝到 copy 该数组中</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                Math.min(original.length, newLength));</span><br><span class="line">        <span class="comment">//返回拷贝元素成功后的数组</span></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public boolean add(E e)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public void add(int index, E element)</code></td>
<td>在此列表中的指定位置插入指定的元素。</td>
</tr>
<tr>
<td><code>public boolean addAll(Collection&lt;?extends E&gt; c)</code></td>
<td>按指定集合的<code>Iterator</code>返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public boolean addAll(int index,Collection&lt;? extends E&gt; c)</code></td>
<td>将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td>
</tr>
</tbody></table>
<h5 id="public-boolean-add-E-e-添加单个元素"><a href="#public-boolean-add-E-e-添加单个元素" class="headerlink" title="public boolean add(E e) 添加单个元素"></a><code>public boolean add(E e)</code> 添加单个元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//将添加的数据传入给 e</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法对内部容量进行校验</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//判断集合存数据的数组是否等于空容量的数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//通过最小容量和默认容量 求出较大值 (用于第一次扩容)</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将if中计算出来的容量传递给下一个方法,继续校验</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//实际修改集合次数++ (在扩容的过程中没用,主要是用于迭代器中)</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//判断最小容量 - 数组长度是否大于 0</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//将第一次计算出来的容量传递给 核心扩容方法</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//记录数组的实际长度,此时由于木有存储元素,长度为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//核心扩容算法 原容量的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断新容量 - 最小容量 是否小于 0, 如果是第一次调用add方法必然小于</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//还是将最小容量赋值给新容量</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//判断新容量-最大数组大小 是否&gt;0,如果条件满足就计算出一个超大容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 调用数组工具类方法,创建一个新数组,将新数组的地址赋值给elementData</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element-在指定索引处添加元素"><a href="#public-void-add-int-index-E-element-在指定索引处添加元素" class="headerlink" title="public void add(int index, E element) 在指定索引处添加元素"></a><code>public void add(int index, E element)</code> 在指定索引处添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;长沙校区&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//添加范围检查</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//超出指定范围就报错</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确保明确的能力</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//增量++ (也就是实际修改集合的次数)</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//如果再调用 add(index,element) 方法之前已经扩容,那么源码跟踪到此结束</span></span><br><span class="line">        <span class="comment">//不会进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-addAll-Collection-c-将集合的所有元素一次性添加到集合"><a href="#public-boolean-addAll-Collection-c-将集合的所有元素一次性添加到集合" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c) 将集合的所有元素一次性添加到集合"></a><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code> 将集合的所有元素一次性添加到集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.addAll(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//把集合的元素转存到Object类型的数组中</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//记录数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//调用方法检验是否要扩容,且让增量++</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//调用方法将a数组的元素拷贝到elementData数组中</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        <span class="comment">//集合的长度+=a数组的长度</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//只要a数组的长度不等于0,即说明添加成功</span></span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-addAll-int-index-Collection-c-在指定的索引位置添加集合"><a href="#public-boolean-addAll-int-index-Collection-c-在指定的索引位置添加集合" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的索引位置添加集合"></a><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</code> 在指定的索引位置添加集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;传智大学&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;酷丁鱼&quot;</span>);</span><br><span class="line">        <span class="comment">//在指定索引处添加一个集合</span></span><br><span class="line">        list1.addAll(<span class="number">1</span>,list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//长度为0的空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//默认容量为空的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//集合存元素的数组</span></span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//校验索引</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">//将数据源转成数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//记录数据源的长度 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//目的就是为了给集合存储数据的数组进行扩容</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);</span><br><span class="line">        <span class="comment">//numMoved:代表要移动元素的个数 --&gt; 1个</span></span><br><span class="line">        <span class="comment">//numMoved: 数据目的(集合list1)的长度-调用addAll的第一个参数 (索引1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="comment">//判断需要移动的个数是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//使用System中的方法arraycopy进行移动</span></span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//才是真正将数据源(list)中的所有数据添加到数据目的(lsit1)</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    参数</span><br><span class="line">        src -源数组。</span><br><span class="line">        srcPos -源数组中的起始位置。</span><br><span class="line">        dest -目标数组。</span><br><span class="line">        destPos -目的地数据中的起始位置。</span><br><span class="line">        length -要复制的数组元素的数量。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-E-remove-int-index-根据索引删除元素"><a href="#public-E-remove-int-index-根据索引删除元素" class="headerlink" title="public E remove(int index) 根据索引删除元素"></a><code>public E remove(int index)</code> 根据索引删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引删除元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除的元素为: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//增量++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//将index对应的元素赋值给 oldValue</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        <span class="comment">//计算集合需要移动元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果需要移动元素个数大于0,就使用arrayCopy方法进行拷贝</span></span><br><span class="line">        <span class="comment">//注意:数据源和数据目的就是elementData</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//将源集合最后一个元素置为null,尽早让垃圾回收机制对其进行回收</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-remove-Object-o-根据元素删除元素"><a href="#public-boolean-remove-Object-o-根据元素删除元素" class="headerlink" title="public boolean remove(Object o) 根据元素删除元素"></a><code>public boolean remove(Object o)</code> 根据元素删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引删除元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> list.remove(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功: &quot;</span>+flag);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//判断要删除的元素是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">//判断集合的元素是否为null</span></span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">//用o对象的equals方法和集合每一个元素进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    <span class="comment">//如果相等,调用fastRemove方法快速删除</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果集合没有o该元素,那么就会返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//增量++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//计算集合需要移动元素的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果需要移动的个数大于0,调用arrayCopy方法进行拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//将集合最后一个元素置为null,尽早被释放</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><h5 id="public-E-set-int-index-E-element-根据索引修改集合元素"><a href="#public-E-set-int-index-E-element-根据索引修改集合元素" class="headerlink" title="public E set(int index, E element) 根据索引修改集合元素"></a><code>public E set(int index, E element)</code> 根据索引修改集合元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引修改集合元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.set(<span class="number">3</span>, <span class="string">&quot;花和尚鲁智深&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set方法返回值: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//先取出index对应的元素,且赋值给oldValue</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        <span class="comment">//将element直接覆盖index对应的元素</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回被覆盖的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-E-get-int-index-根据索引获取元素"><a href="#public-E-get-int-index-根据索引获取元素" class="headerlink" title="public E get(int index) 根据索引获取元素"></a><code>public E get(int index)</code> 根据索引获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        <span class="comment">//根据索引获取集合元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;get方法返回值: &quot;</span>+value);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//范围校验</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">//直接根据索引取出集合元素</span></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><h5 id="public-String-toString-把集合所有数据转换成字符串"><a href="#public-String-toString-把集合所有数据转换成字符串" class="headerlink" title="public String toString() 把集合所有数据转换成字符串"></a><code>public String toString()</code> 把集合所有数据转换成字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;山东大李逵&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天魁星宋江&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;天罡星卢俊义&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西门大人&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的元素: &quot;</span>+list);</span><br><span class="line">        <span class="comment">//将集合的元素转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList集合内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;    <span class="comment">//当前光标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将实际修改集合次数赋值给预期修改次数 ,注意只会赋值一次</span></span><br><span class="line">        <span class="comment">//以后在迭代器获取元素的时候,每次都会判断集合实际修改次数是否和预期修改次数一致</span></span><br><span class="line">        <span class="comment">//如果不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断光标 和 集合的大小 是否不相等</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList亲爹</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList亲爷爷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意:此时相当于用ArrayList对象在调用iterator()方法 获取迭代器</span></span><br><span class="line">        <span class="comment">//那么这个时候需要先看看ArrayList中的iterator()方法</span></span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="comment">//调用ArrayList中hasNext方法判断是否有元素,如果hasNext()方法返回false</span></span><br><span class="line">        <span class="comment">//那么就toString方法就返回一个 &quot;[]&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="comment">//创建StringBuilder,对集合的内容进行拼接,避免字符串频繁拼接产生很多无效对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//调用ArrayList中next方法取出元素</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (!it.hasNext())</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="public-Iterator-iterator-普通迭代器"><a href="#public-Iterator-iterator-普通迭代器" class="headerlink" title="public Iterator&lt;E&gt; iterator() 普通迭代器"></a><code>public Iterator&lt;E&gt; iterator()</code> 普通迭代器</h5><p>案例一: 已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;Java&quot;、&quot;PHP&quot;</code>，使用迭代器遍历获取集合的每一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二: 已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;Java&quot;、&quot;PHP&quot;</code>，使用迭代器遍历集合看有没有<code>&quot;PHP&quot;</code>这个元素，如果有，就使用集合对象删除该元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果:并发修改异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException at</span><br><span class="line">java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>) at</span><br><span class="line">java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>) at cn.itheima.method.Test01.main(Test01.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p>源码分析:(应该从获取迭代器的时候就进入到源代码中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line">        <span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line">        <span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line">        <span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的方法</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//每次获取元素,会先调用该方法校验 预期修改次数是否 == 实际修改次数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            tips:</span></span><br><span class="line"><span class="comment">            if(s.equals(&quot;hello&quot;)) &#123;</span></span><br><span class="line"><span class="comment">            list.remove(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            当if表达式的结果为true,那么集合就会调用remove方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//把下一个元素的索引赋值给i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="comment">//判断是否有元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//将集合底层存储数据的数组赋值给迭代器的局部变量 elementData</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//再次判断,如果下一个元素的索引大于集合底层存储元素的长度 并发修改异常</span></span><br><span class="line">            <span class="comment">//注意,尽管会产生并发修改异常,但是这里显示不是我们要的结果</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="comment">//每次成功获取到元素,下一个元素的索引都是当前索引+1</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回元素</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的remove方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速删除方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//最最最关键的一个操作,集合实际修改次数++,那么这个时候由原来的3变成4</span></span><br><span class="line">        <span class="comment">//but迭代器的预期修改次数还是3!!!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//还有一个很关键的操作,集合的长度也发生了改变</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例三:已知集合：<code>List list = new ArrayList()</code>;里面有三个元素：<code>&quot;hello&quot;、&quot;PHP&quot;、&quot;JavaSE&quot;</code>，使用迭代器遍历集合看有没有<code>&quot;PHP&quot;</code>这个元素，如果有，就使用集合对象删除该元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;PHP&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F333%E7%90%86.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F%E7%90%862222.jpg"></p>
<h5 id="default-void-remove-迭代器中的remove方法-删除集合中的元素"><a href="#default-void-remove-迭代器中的remove方法-删除集合中的元素" class="headerlink" title="default void remove() 迭代器中的remove方法,删除集合中的元素"></a><code>default void remove() </code>迭代器中的<code>remove</code>方法,删除集合中的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/ArrayList%E5%8E%9F%E7%90%86111.jpg"></p>
<p>源码分析(应该从获取迭代器的时候就进入到源代码中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList内部类</span></span><br><span class="line"><span class="comment">//一定要注意观察 Itr 类中的几个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor; <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引</span></span><br><span class="line">        <span class="comment">//将实际修改集合次数 赋值 给预期修改次数</span></span><br><span class="line">        <span class="comment">//在迭代的过程中,只要实际修改次数和预期修改次数不一致就会产生并发修改异常</span></span><br><span class="line">        <span class="comment">//由于expectedModCount是Itr的成员变量,那么只会被赋值一次!!!</span></span><br><span class="line">        <span class="comment">//同时由于集合调用了三次add方法,那么实际修改集合次数就是 3,因此expectedModCount的值也是 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的方法</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//把下一个元素的索引赋值给i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="comment">//判断是否有元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//将集合底层存储数据的数组赋值给迭代器的局部变量 elementDat</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//再次判断,如果下一个元素的索引大于集合底层存储元素的长度 并发修改异常</span></span><br><span class="line">            <span class="comment">//注意,尽管会产生并发修改异常,但是这里显示不是我们要的结果</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="comment">//每次成功获取到元素,下一个元素的索引都是当前索引+1</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回元素,且将i的值 赋值给 lastRet /*0*/</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器删除元素方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//判断最后返回元素的索引是否小于0,满足条件就产生 非法状态异常</span></span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="comment">//校验是否会产生并发修改异常,第一次调用不会,因为与其修改次数和实际修改次数一致</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正删除集合元素的方法,调用方法为ArrayList的方法remove,且将0作为参数进行传递</span></span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                <span class="comment">//将lastRet赋值给cursor</span></span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                <span class="comment">//再次等于-1</span></span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//再次将集合实际修改次数赋值给预期修改次数,那么这个时候不管集合自身是否删除成功</span></span><br><span class="line">                <span class="comment">//那么实际修改次数和预期修改次数又一致了,所以并不会产生并发修改异常</span></span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//如果预期修改次数 和 实际修改次数不相等 就产生并发修改异常</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的remove方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速删除方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//最最最关键的一个操作,集合实际修改次数++,那么这个时候由原来的3变成4</span></span><br><span class="line">        <span class="comment">//but迭代器的预期修改次数还是3!!!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="comment">//还有一个很关键的操作,集合的长度也发生了改变</span></span><br><span class="line">        elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="public-void-clear-清空集合所有数据"><a href="#public-void-clear-清空集合所有数据" class="headerlink" title="public void clear() 清空集合所有数据"></a><code>public void clear()</code> 清空集合所有数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;清空前的集合: &quot;</span>+list);</span><br><span class="line">        <span class="comment">//清空集合所有元素</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空后的集合: &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实际修改集合次数++</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//遍历集合,将集合每一个索引对应位置上的元素都置为null,尽早让其释放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//集合长度更改为0</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="public-boolean-contains-Object-o-判断集合是否包含指定元素"><a href="#public-boolean-contains-Object-o-判断集合是否包含指定元素" class="headerlink" title="public boolean contains(Object o) 判断集合是否包含指定元素"></a><code>public boolean contains(Object o)</code> 判断集合是否包含指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断之前集合的元素: &quot;</span> + list);</span><br><span class="line">        <span class="comment">//需求:如果集合中没有JavaSE该元素,请添加一个JavaSE元素</span></span><br><span class="line">        <span class="comment">//解决方式一:循环遍历集合,判断集合是否包含JavaSE,如果没有包含就调用集合的add方法进行添加操作</span></span><br><span class="line">        <span class="comment">//解决方式二:使用集合contains方法判断,根据判断的结果决定是否要添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (!list.contains(<span class="string">&quot;JavaSE&quot;</span>)) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;JavaSE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;判断之后集合的元素: &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//源码contains方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//调用indexOf方法进行查找</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//如果元素是null,也进行遍历操作</span></span><br><span class="line">        <span class="comment">//因为集合中有可能够会存储null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有走if,也没有走else,那么就说明o该元素在集合中不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h4><h5 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty()"></a><code>public boolean isEmpty()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> list.isEmpty();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h4><p>​    阿里开发规范里有一条：不要在<code>foreach</code>循环里进行元素的<code>remove/add</code>操作。<code>remove</code>元素请使用<code>Iterator</code>方式，如果并发操作，需要对<code>Iterator</code>对象加锁。这是为什么呢？看下面一个<code>Demo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(item)) &#123;</span><br><span class="line">            list.remove(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jbiuvtyrtuyiuoimponubiyvtu.png"></p>
<p>​	当我们使用<code>foreach</code>去遍历集合的同时执行<code>remove</code>（或者<code>add</code>）时，我们可以看到控制台抛出<code>ConcurrentModificationException</code>异常（在删除集合中倒数第二个元素的时候不会抛出此异常，这个问题先埋个坑，我们下面会解释），而我们使用迭代器去<code>remove</code>的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(item))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njbhuvtyctrcytvybuimp.png"></p>
<p>​	使用迭代器删除的时候就不会抛出<code>ConcurrentModificationException</code>异常，这是因为如果使用增强<code>for</code>遍历集合时，尝试对集合结构进行改变会触发<code>Java</code>集合的错误检测机制：<code>fail-fast</code> 。</p>
<h4 id="什么是fail-fast机制"><a href="#什么是fail-fast机制" class="headerlink" title="什么是fail-fast机制"></a>什么是fail-fast机制</h4><p>​	<code>fail-fast</code>即快速失败，它是<code>Java</code>集合的一种错误检测机制。当多个线程对集合（非<code>fail-safe</code>的集合类）进行结构上的改变的操作时，有可能会触发<code>fail-fast</code>机制，这时就会抛出<code>ConcurrentModificationException</code>（当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。注：即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。我们再仔细分析一下上面<code>foreach</code>控制台打印的堆栈信息：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/klmjnibyutycrxetrcytvubhi.png"></p>
<p>   两个报错是在<code>ArrayList</code>内部类<code>Itr</code>的<code>next()</code>和<code>checkForComodification()</code>方法，还有一个是笔者的测试类可忽略。我们进入<code>next</code>方法看一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/hjbgvycftxerxtrcytvyubino.png"></p>
<p>可以看到第一行就是这个<code>checkForComodification()</code>方法，我们点进去看一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/nibyuvtfr6dft7gyhuop.png"></p>
<p>​    找到抛出异常的位置了，**<code>modCount != expectedModCount</code>**时，就会抛出<code>ConcurrentModificationException</code>。想搞清楚为什么这两个值会不相等，我们首先要了解这两个变量都是什么，翻阅源码可知：</p>
<pre><code>（1）modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。

（2）expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator方法被调用的时候初始化的。只有通过迭代器对集合进行操作，该值才会改变。
</code></pre>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhuvyctxetrcfybhijn.png"></p>
<p>​    可以看到<code>ArrayList</code>的<code>remove()</code>只修改了<code>modCount</code>，并没有对<code>expectedModCount</code>做任何操作，<code>add</code>方法同理，在<code>ensureExplicitCapacity()</code>中对<code>modCount</code>进行了修改：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ljnbhugvycftxrcytvbiuo.png"></p>
<p><font color='red'> 	 总结：之所以会抛出<code>ConcurrentModificationException</code>异常，是因为我们的代码中使用了增强<code>for</code>去遍历集合，而在增强<code>for</code>底层是通过<code>iterator</code>进行遍历的，但是元素的<code>add()/remove()</code>却是直接使用的集合类自己的方法。这就导致<code>iterator</code>在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被添加或删除了，就会抛出此异常来提示用户，可能产生了并发修改。</font></p>
<h4 id="为什么使用foreach遍历集合删除倒数第二个元素不会报错"><a href="#为什么使用foreach遍历集合删除倒数第二个元素不会报错" class="headerlink" title="为什么使用foreach遍历集合删除倒数第二个元素不会报错"></a>为什么使用foreach遍历集合删除倒数第二个元素不会报错</h4><p>上面<code>foreach</code>遍历集合的那段代码改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(item)) &#123;</span><br><span class="line">            list.remove(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njbhuvcyrytvubinoi.png"></p>
<p>​	发现竟然不抛异常了，其实这个问题出在迭代器内部类的<code>hasNext()</code>方法上，先看一下迭代器的三个属性：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhugvyfcdtxcfygvubhikml.png"></p>
<p>（1）<code>cursor</code> –迭代器的游标，元素的索引值，初始值为<code>0</code></p>
<p>（2）<code>lastRet</code> –返回最后一个元素的索引值、如果没有找到则返回<code>-1</code></p>
<p>（3）<code>expectedModCount</code> –修改次数的期望值，可以看到在迭代器初始化时，这个属性就被赋值为当前修改次数的值了。</p>
<p>   在迭代过程中，每一次迭代<code>cursor</code>都会<code>+1</code>，而<code>itr.hasNext()</code>会判断是否存在下一个元素、<code>itr.next()</code>获取下一个元素的值，最终直到不存在下一个元素，则迭代结束。跟进源码发现，<code>itr.hasNext()</code>判断方法并不会调用<code>checkForComodification</code>方法来检查<code>list</code>在迭代中是否有被修改，只是判断游标和长度是否相等，不等时则认为存在下一个元素，只有在调用<code>next()</code>方法才会尝试抛出<code>checkForComodification</code>异常：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njihbutvycrtytvubyimpo.png"></p>
<p>   现在我们带入删除集合中倒数第二个元素的场景，当倒数第二个元素迭代完成，开始迭代最后一个元素时，此时<code>cursor</code>是<code>2</code>，<code>size</code>由于在迭代过程倒数第二个元素移除了，所以<code>size-1</code>也是<code>2</code>, 此时<code>cursor</code>和<code>size</code>相等，不会再进入下一个迭代，也就不会进入<code>next()</code>方法，因此不会触发<code>checkForComodification</code>方法的<code>fail-fast</code>机制。</p>
<h4 id="如何避免出现fail-fast"><a href="#如何避免出现fail-fast" class="headerlink" title="如何避免出现fail-fast"></a>如何避免出现fail-fast</h4><p>  （1）直接使用普通<code>for</code>循环进行操作</p>
<p>  （2）使用<code>Iterator</code>提供的<code>remove</code>方法进行操作</p>
<p>  （3）使用一些<code>fail-safe</code>的集合类，例如<code>CopyOnWriteArrayList</code></p>
<h3 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h3><p>​	<code>fail-safe</code>（安全失败）机制是指任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出<code>ConcurrentModificationException</code>。<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<p>但是<code>fail-safe</code>机制有两个问题：</p>
<ul>
<li>需要复制集合，产生大量的无效对象，开销大</li>
<li>无法保证读取的数据是目前原始数据结构中的数据，因为复制操作执行后，集合可能会发生改变</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Forlogen&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Kobe&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    map.put(<span class="string">&quot;James&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(map.get(iterator.next()));</span><br><span class="line">        map.put(<span class="string">&quot;Yao&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>fail-safe</code>的具体体现可见<code>java.util.concurrentx</code>中类的实现，例如使用 <code>CopyOnWriterArrayList</code>代替<code>ArrayList，CopyOnWriterArrayList</code>在是使用上跟<code>ArrayList</code>几乎一样，<code>CopyOnWriter</code>是写时复制的容器(<code>COW</code>)，在读写时是线程安全的。该容器在对<code>add</code>和<code>remove</code>等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于CopyOnWriterArrayList在迭代过程并不会发生<code>fail-fast</code>现象。但 <code>CopyOnWrite</code>容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><blockquote>
<ul>
<li>提供随机访问的功能：实现<code>RandomAcess</code>接口，这个接口主要是为<code>List</code>提供快速访问的功能，也就是通过元素的索引，可以快速访问到。</li>
<li>可克隆：实现了<code>Cloneable</code>接口</li>
<li>是一个支持新增，删除，修改，查询，遍历等功能。</li>
<li>可序列化和反序列化</li>
<li>容量不够，可以触发自动扩容</li>
<li>最大的特点是：线程安全的，相当于线程安全的<code>ArrayList</code>。</li>
</ul>
</blockquote>
<h3 id="Vector继承关系"><a href="#Vector继承关系" class="headerlink" title="Vector继承关系"></a>Vector继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	从上面的继承关系和实现的接口，可以看出和<code>ArrayList</code>一样。</p>
</blockquote>
<h3 id="Vector源码分析"><a href="#Vector源码分析" class="headerlink" title="Vector源码分析"></a>Vector源码分析</h3><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正保存数据的数组</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量增加系数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Vector()</code></td>
<td align="center">构造一个初始容量为<code>10</code>的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(int initialCapacity)</code></td>
<td align="center">构造具有指定初始容量的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(int initialCapacity, int capacityIncrement)</code></td>
<td align="center">构造具有指定初始容量和增长系数的空列表。</td>
</tr>
<tr>
<td align="center"><code>public Vector(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</td>
</tr>
</tbody></table>
<h5 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-Vector"><a href="#public-Vector" class="headerlink" title="public Vector()"></a><code>public Vector()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>this(10)</code> 这个本质上是调用 <code>Vector(int initialCapacity)</code>，然后<code>this(initialCapacity, 0)</code> 这个本质上是调用 <code>Vector(int initialCapacity, int capacityIncrement)</code></p>
</blockquote>
<blockquote>
<p><font color='red'><strong>重点：</strong>从上面的构造方法可知，<code>vector</code>在运行构造方法时，就已经指定的了容量，而<code>ArrayList</code>是在使用<code>add()</code>方法才指定容量</font></p>
</blockquote>
<h6 id="public-Vector-int-initialCapacity"><a href="#public-Vector-int-initialCapacity" class="headerlink" title="public Vector(int initialCapacity)"></a><code>public Vector(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	<code>this(initialCapacity, 0)</code> 这个本质上是调用 <code>Vector(int initialCapacity, int capacityIncrement)</code></p>
</blockquote>
<h6 id="public-Vector-int-initialCapacity-int-capacityIncrement"><a href="#public-Vector-int-initialCapacity-int-capacityIncrement" class="headerlink" title="public Vector(int initialCapacity, int capacityIncrement)"></a><code>public Vector(int initialCapacity, int capacityIncrement)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 非法判断</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="comment">// 指定增长系数</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-Vector-Collection-c"><a href="#public-Vector-Collection-c" class="headerlink" title="public Vector(Collection&lt;? extends E&gt; c)"></a><code>public Vector(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 转换成为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 大小为数组的大小</span></span><br><span class="line">    elementCount = a.length;</span><br><span class="line">    <span class="comment">// 如果是ArrayList，则直接复制</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">        elementData = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则需要进行拷贝</span></span><br><span class="line">        elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public synchronized void addElement(E obj)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public synchronized boolean add(E e)</code></td>
<td>将指定的元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public void add(int index, E element)</code></td>
<td>在此列表中的指定位置插入指定的元素。</td>
</tr>
<tr>
<td><code>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</code></td>
<td>按指定集合的<code>Iterator</code>返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td>
</tr>
</tbody></table>
<h5 id="public-synchronized-void-addElement-E-obj"><a href="#public-synchronized-void-addElement-E-obj" class="headerlink" title="public synchronized void addElement(E obj)"></a><code>public synchronized void addElement(E obj)</code></h5><blockquote>
<p>​	增加元素，默认是在最后添加，如果容量不够的时候会触发扩容机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 确保容量足够（如果需要，里面会有扩容，复制操作）</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新元素放在最后一个元素，个数增加</span></span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	那么它是如何确保容量的呢？可以看到<code>ensureCapacityHelper()</code>里面判断增加后的元素个数是否大于现在数组的长度，如果不满足，就需要扩容。调用<code>grow()</code>函数扩容。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容，传入的是需要最小的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 以前的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 现在的容量，是以前的容量加上扩展系数，如果扩展系数小于等于0，那么，就是以前的容量的两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="comment">// 如果新的容量大于最小需要容量，就满足了</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新的容量比最大的容量还要大（虚拟机的数组大小是有最大值的）</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 需要处理把最大的容量降低一些</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 拷贝数据</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-add-E-e"><a href="#public-synchronized-boolean-add-E-e" class="headerlink" title="public synchronized boolean add(E e)"></a><code>public synchronized boolean add(E e)</code></h5><blockquote>
<p>​	这个方法与<code>addElement(E obj)</code>几乎一样，只是返回值不同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 确保容量足够（如果需要，里面会有扩容，复制操作）</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新元素放在最后一个元素，个数增加</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element)"></a><code>public void add(int index, E element)</code></h5><blockquote>
<p>在指定的索引<code>index</code>，插入数据，实际上调用的是<code>insertElementAt(element, index)</code>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用插入元素的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insertElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断索引是否非法</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index</span><br><span class="line">                                                 + <span class="string">&quot; &gt; &quot;</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保容量足够</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 拷贝数据，将后面的元素，往后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    <span class="comment">// 将实际的数据插入</span></span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    <span class="comment">// 个数增加</span></span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-addAll-Collection-c"><a href="#public-synchronized-boolean-addAll-Collection-c" class="headerlink" title="public synchronized boolean addAll(Collection&lt;? extends E&gt; c)"></a><code>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</code></h5><blockquote>
<p>​	将一个集合所有元素添加进去</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 转成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 确保容量足够</span></span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="comment">// 返回添加的数组是不是有数据</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-boolean-addAll-int-index-Collection-c"><a href="#public-synchronized-boolean-addAll-int-index-Collection-c" class="headerlink" title="public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)"></a><code>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></h5><blockquote>
<p>​	指定<code>index</code>，插入一个集合，和前面不一样的地方在于复制之前，需要计算往后面移动多少位，不是用<code>for</code>循环去插入，而是一次性移动和写入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 合法判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 转换数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 插入数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// 确保数组的长度是否合法</span></span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    <span class="comment">// 移动的步长计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动后面的元素，腾出位置给插入的元素</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="comment">// 插入元素个数是否为0</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o) "></a><code>public boolean remove(Object o) </code></h5><blockquote>
<p>删除指定的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的是removeElement()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取第一个满足条件的元素缩影</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">// 索引如果满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将索引为i的元素从数组中移除</span></span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作数组删除元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index后面的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 往前面移动一位（复制，覆盖）</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新个数</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">// 原来最后一个元素的位置置空</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-remove-int-index"><a href="#public-synchronized-E-remove-int-index" class="headerlink" title="public synchronized E remove(int index)"></a><code>public synchronized E remove(int index)</code></h5><blockquote>
<p>按照索引删除元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 保存原来的数据</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 移动的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果移动个数大于0</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 后面的元素往前面移动一位，赋值，覆盖</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 最后一个元素置空</span></span><br><span class="line">    elementData[--elementCount] = <span class="literal">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="comment">// 返回旧的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改方法-1"><a href="#修改方法-1" class="headerlink" title="修改方法"></a>修改方法</h4><blockquote>
<p>​	下面两个<code>set</code>函数都是，修改索引为<code>index</code>的元素，区别就是一个会返回旧的元素，一个不会返回旧的元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 取出旧的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法哦性判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接更新</span></span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-synchronized-E-get-int-index"><a href="#public-synchronized-E-get-int-index" class="headerlink" title="public synchronized E get(int index)"></a><code>public synchronized E get(int index)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法判断</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="comment">// 返回数组的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-firstElement"><a href="#public-synchronized-E-firstElement" class="headerlink" title="public synchronized E firstElement()"></a><code>public synchronized E firstElement()</code></h5><blockquote>
<p>获取第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">firstElement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-synchronized-E-lastElement"><a href="#public-synchronized-E-lastElement" class="headerlink" title="public synchronized E lastElement()"></a><code>public synchronized E lastElement()</code></h5><blockquote>
<p>获取最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">lastElement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法-1"><a href="#包含方法-1" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a><code>public boolean contains(Object o)</code></h5><blockquote>
<p>​	是否包含某一个元素，其实里面是获取对象的索引，如果索引大于等于<code>0</code>，证明元素在里面，否则元素不在里面。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	返回元素的索引,分为两种情况，一种是元素是<code>null</code>的情况，不能使用<code>equals()</code>方法，另一种是非<code>null</code>，可以直接使用<code>equals()</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取索引位置"><a href="#获取索引位置" class="headerlink" title="获取索引位置"></a>获取索引位置</h4><h5 id="public-synchronized-int-lastIndexOf-Object-o"><a href="#public-synchronized-int-lastIndexOf-Object-o" class="headerlink" title="public synchronized int lastIndexOf(Object o)"></a><code>public synchronized int lastIndexOf(Object o)</code></h5><blockquote>
<p>​	获取元素最后出现的索引位置,和前面一个不一样的是，这个需要从最后一个元素往前面查找</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<p>​	<code>LinkedList</code>同时实现了<code>List</code>接口和<code>Deque</code>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<code>Queue</code>)，同时又可以看作一个栈(<code>Stack</code>)。这样看来，<code>LinkedList</code>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<code>LinkedList</code>，一方面是因为<code>Java</code>官方已经声明不建议使用<code>Stack</code>类，更遗憾的是，<code>Java</code>里根本没有一个叫做<code>Queue</code>的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比<code>LinkedList</code>(当作栈或队列使用时)有着更好的性能。</p>
</blockquote>
<h3 id="LinkedList构造方法"><a href="#LinkedList构造方法" class="headerlink" title="LinkedList构造方法"></a>LinkedList构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	继承了<code>AbstractSequentialList</code>，实现了<code>List</code>,<code>Queue</code>,<code>Cloneable</code>,<code>Serializable</code>，既可以当成列表使用，也可以当成队列，堆栈使用。主要特点有：</p>
<ul>
<li>线程不安全，不同步，如果需要同步需要使用<code>List list = Collections.synchronizedList(new LinkedList());</code></li>
<li>实现<code>List</code>接口，可以对它进行队列操作</li>
<li>实现<code>Queue</code>接口，可以当成堆栈或者双向队列使用</li>
<li>实现Cloneable接口，可以被克隆，浅拷贝</li>
<li>实现<code>Serializable</code>，可以被序列化和反序列化</li>
</ul>
</blockquote>
<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 最后一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">// 序列化uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	成员变量相对比较简单，因为不像<code>ArrayList</code>一样，需要使用数组保存元素，<code>LinkedList</code>是靠引用来关联前后节点，所以这里只有大小，第一个节点，最后一个节点,以及序列化的<code>uid</code>。</p>
</blockquote>
<p>Node作为内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 节点里面的数据</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 上一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数，重写之后，无参数构造器已经被覆盖，三个参数分别对应三个属性</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/229127715_1621003494347_5A9F6A51E994577B680762E995D412F0.png"></p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public LinkedList()</code></td>
<td align="center">无参构造器，构造一个空集合。</td>
</tr>
<tr>
<td align="center"><code>public LinkedList(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定集合元素的集合，其顺序由集合的迭代器返回。</td>
</tr>
</tbody></table>
<h5 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-LinkedList"><a href="#public-LinkedList" class="headerlink" title="public LinkedList()"></a><code>public LinkedList()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-LinkedList-Collection-c"><a href="#public-LinkedList-Collection-c" class="headerlink" title="public LinkedList(Collection&lt;? extends E&gt; c)"></a><code>public LinkedList(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用无参构造函数进行初始化</span></span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    <span class="comment">// 将集合 c 添加进集合</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用addAll(size,c)方法</span></span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入集合中的所有元素方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">   	<span class="comment">//检查位置是否合法</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//将集合c转换为数组</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="comment">//计算元素的个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="comment">//如果集合为空，就直接不进行插入</span></span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//创建前驱节点pred和当前节点succ</span></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//如果要插入的位置是最末尾</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">       	<span class="comment">//则当前节点为空</span></span><br><span class="line">           succ = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//前驱节点就是最末尾的元素</span></span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//否则，获取index上的元素</span></span><br><span class="line">           succ = node(index);</span><br><span class="line">           <span class="comment">//根据succ，获得index-1上的节点</span></span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//遍历数组中的元素</span></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">       	<span class="comment">//进行强制类型转化</span></span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">           <span class="comment">//创建一个节点</span></span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">           <span class="comment">//如果没有前驱节点，表明是一个空链表，就设置为头节点</span></span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           	<span class="comment">//否则设置pred的后继节点为newNode</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//如果当前节点为null，说明是要在末尾插值</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">       	<span class="comment">//设置为尾节点</span></span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//反之，将新加上的链表连上后面的链表，形成双向链表</span></span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//链表的长度需要修改</span></span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="comment">//修改次数+1</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查插入的位置是否合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//调用方法</span></span><br><span class="line">       <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">       	<span class="comment">//如果位置符合法，就抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查位置是否符合要求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//要求index必须&gt;=0或者&lt;=size</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取<code>index</code>位置上的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//通过移位操作，判断index位置离左端点近，还是右端点近</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       	<span class="comment">//如果是离左端点近，就从左向右遍历，首先获取头节点</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="comment">//通过for循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="comment">//返回index位置上的值</span></span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//如果是离右端点近，就从右向左遍历，首先获取尾节点的值</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="comment">//铜鼓for循环循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>首先是调用了<code>addAll (c)</code>方法，将集合c作为参数进行传递</li>
<li>然后又调用<code>addAll(size, c)</code>方法，将链表的长度和集合c作为参数进行传递</li>
<li>进入到<code>addAll()</code>方法中，又马上调用了<code>checkPositionIndex(index)</code>，这个方法主要是用来检查要插入的位置index是否合法。</li>
<li>紧接着，先将集合<code>c</code>转换为数组<code>a</code>。然后判断<code>index</code>位置的位置，获得当前节点<code>succ</code>以及前驱节点<code>pred</code></li>
<li>然后使用增强<code>for</code>循环从数组中取出元素，逐一创建一个新节点，然后将节点插入到链表中。</li>
<li><code>for</code>循环完了之后，判断<code>pred</code>节点是否已经是尾节点，如果是，就设置为尾节点。否则，将后续的链表连上。</li>
<li>最后，要记得把链表的长度增加，并且修改次数<code>+1</code></li>
</ol>
</blockquote>
<h4 id="增加方法-1"><a href="#增加方法-1" class="headerlink" title="增加方法"></a>增加方法</h4><h5 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a><code>public boolean add(E e)</code></h5><blockquote>
<p>在末尾添加单个元素的<code>add</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//调用linkLast在末尾添加上元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在最后一个位置插入元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点newNode</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//设置尾节点为newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原先的last为null,则说明是第一次添加，将first也指向这个新Node</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">//设置头节点为newNode</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则设置尾节点的后继为newNode</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//数目+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-add-int-index-E-element-1"><a href="#public-void-add-int-index-E-element-1" class="headerlink" title="public void add(int index, E element)"></a><code>public void add(int index, E element)</code></h5><blockquote>
<p>在指定位置添加上元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">      <span class="comment">//查看index位置是否合法</span></span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line"><span class="comment">//查看想插入的位置是否为最末尾</span></span><br><span class="line">      <span class="keyword">if</span> (index == size)</span><br><span class="line">      	<span class="comment">//调用linkLast在最末尾插入元素</span></span><br><span class="line">          linkLast(element);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      	<span class="comment">//调用linlBefore在index位置上插入元素</span></span><br><span class="line">          linkBefore(element, node(index));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查插入的位置是否合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//调用方法</span></span><br><span class="line">       <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">       	<span class="comment">//如果位置符合法，就抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查位置是否符合要求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//要求index必须&gt;=0或者&lt;=size</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>index</code>位置上插入元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">//通过当前节点succ蝴蝶前驱节点pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点newNode</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//设置newNode为succ的前驱节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果前驱节点为null，那么newNode就作为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则设置pred的后继节点为newNode</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">//数目加1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-addFirst-E-e"><a href="#public-void-addFirst-E-e" class="headerlink" title="public void addFirst(E e)"></a><code>public void addFirst(E e)</code></h5><blockquote>
<p>插入元素成为头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//在第一个位置插入元素</span></span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//获取头节点的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//根据元素e创建一个新的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">//设置头节点为newNode</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果f==null，代表原本是一个空链表</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">//同样设置尾节点为newNode</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//否则，设置f的前驱节点为newNode</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">//数目+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-void-addLast-E-e"><a href="#public-void-addLast-E-e" class="headerlink" title="public void addLast(E e)"></a><code>public void addLast(E e)</code></h5><blockquote>
<p>插入元素成为尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">//在最后一个位置插入元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offer-E-e"><a href="#public-boolean-offer-E-e" class="headerlink" title="public boolean offer(E e)"></a><code>public boolean offer(E e)</code></h5><blockquote>
<p>将指定的元素添加到集合的尾部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offerLast-E-e"><a href="#public-boolean-offerLast-E-e" class="headerlink" title="public boolean offerLast(E e)"></a><code>public boolean offerLast(E e)</code></h5><blockquote>
<p>插入特定元素到集合末尾，该方法和 addLast 作用一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-offerFirst-E-e"><a href="#public-boolean-offerFirst-E-e" class="headerlink" title="public boolean offerFirst(E e)"></a><code>public boolean offerFirst(E e)</code></h5><blockquote>
<p>将元素插入到集合的头部</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>add</code>方法返回值为 <code>void</code>, <code>offer</code>返回值为 <code>boolean</code></li>
<li>将指定的元素添加到集合的尾部，该方法的作用和 <code>add(E e)</code> ，<code>addLast(E e)</code> 一样。当使用容量受限的双端队列时，此方法通常比 <code>add</code> 方法更可取，当超出队列容量时，该方法返回 <code>false</code>，而 <code>add</code> 方法则会抛出异常。</li>
</ul>
</blockquote>
<h4 id="删除方法-2"><a href="#删除方法-2" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="public-E-remove"><a href="#public-E-remove" class="headerlink" title="public E remove()"></a><code>public E remove()</code></h5><blockquote>
<p>删除集合的第一个节点，并返回该元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除集合的第一个节点，并返回该元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 没有首节点抛出 NoSuchElementException</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 删除首节点</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除不为 <code>null</code> 的首节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧首节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="comment">// 获取旧首节点的下一个节点 next，next 为新首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 将旧首节点的值和下一个节点的指向赋为 null，帮助 GC</span></span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    f.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用新首节点 next 更新首节点 first</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果 next 节点为空，则代表原集合只有一个节点，将尾节点也指向 null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// next 不为空的话，将该新首节点的上一个节点指向 null</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的首节点元素</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a><code>public E remove(int index)</code></h5><blockquote>
<p>删除指定的<code>index</code>位置的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 删除指定下标所在的节点</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除指定不为 <code>null</code> 的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定节点的值，用于最后返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取该节点的下一个节点 next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取该节点的上一个节点 prev</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 prev 节点为 null，表示该节点为首节点，将 next 节点指向首节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prev 节点不为 null，则将 prev 的下一个节点指向 next</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将该节点的上一个节点置为 null，帮助 GC</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 next 节点为 null，表示该节点为尾节点，将 prev 节点指向尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// next 节点不为 null，将 next 的上一个节点指向 prev</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将该节点的下一个节点置为 null，帮助 GC</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该节点的值置为 null</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的元素的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-boolean-remove-Object-o-1"><a href="#public-boolean-remove-Object-o-1" class="headerlink" title="public boolean remove(Object o)"></a><code>public boolean remove(Object o)</code></h5><blockquote>
<p>删除指定元素的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="comment">//查看对象是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//for循环遍历每一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//如果为null</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//删除该节点</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//遍历每一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//如果节点的元素和o相等</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">            	<span class="comment">//删除该节点</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除失败，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-removeFirst"><a href="#public-E-removeFirst" class="headerlink" title="public E removeFirst()"></a><code>public E removeFirst()</code></h5><blockquote>
<p>删除头节点元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//获得头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//查看头节点是否为空，为空则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//否则，调用方法删除头节点</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-removeLast"><a href="#public-E-removeLast" class="headerlink" title="public E removeLast()"></a><code>public E removeLast()</code></h5><blockquote>
<p>删除尾节点的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 尾节点为 null 抛出 NoSuchElementException</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除不为 <code>null</code> 的尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧尾节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="comment">// 获取旧尾节点的上一个节点 prev，prev 为新尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 将旧尾节点的值和下一个节点的指向置为 null，帮助 GC</span></span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用新尾节点 prev 更新尾节点 last</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果新尾节点节点为空，则代表该集合只有一个节点，将首节点指向 null</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 新尾节点不为空，将新尾节点的下一个节点指向 null</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 集合长度 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数 +1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回删除的尾节点的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>unlink()</code>方法：</strong></p>
<ol>
<li>首先，获取<code>x</code>节点中的元素，并且获取<code>x</code>节点的后继节点<code>next</code>以及<code>x</code>节点的前驱节点<code>prev</code></li>
<li>然后，如果前驱节点为<code>null</code>，那就将后继节点<code>next</code>设置为头节点。否则，让前驱节点的后继节点指向<code>next</code></li>
<li>如果后继节点为<code>null</code>，设置前驱节点<code>prev</code>为尾节点。否则设置<code>next</code>的前驱节点为<code>prev</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
<p><strong><code>unlinkFirst()</code>方法：</strong></p>
<ol>
<li>因为这个节点是<code>private</code>修饰的，所以我们外部无法直接调用。它是有限制传入的节点必须为头节点的。</li>
<li>首先获得头节点中的元素，然后获得第二个位置上的元素<code>next</code>，设置<code>next</code>节点为头节点</li>
<li>然后判断是否删除了原来节点之后成为了空链表，如果是，将<code>last</code>也置为<code>null</code>。否则设置<code>next</code>的前驱节点为<code>null</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
<p><strong><code>unlinkLast()</code>方法：</strong></p>
<ol>
<li>因为这个节点是<code>private</code>修饰的，所以我们外部无法直接调用。它是有限制传入的节点必须为尾节点的。</li>
<li>首先获得尾节点中的元素，然后获得倒数第二个位置上的元素<code>pred</code>，设置<code>pred</code>节点为尾节点</li>
<li>然后判断是否删除了原来节点之后成为了空链表，如果是，将<code>first</code>也置为<code>null</code>。否则设置pred的后继节点为<code>null</code></li>
<li>最后长度<code>-1</code>，修改次数<code>+1</code></li>
</ol>
</blockquote>
<h5 id="public-E-poll"><a href="#public-E-poll" class="headerlink" title="public E poll()"></a><code>public E poll()</code></h5><blockquote>
<p>删除集合的头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-pollFirst"><a href="#public-E-pollFirst" class="headerlink" title="public E pollFirst()"></a><code>public E pollFirst()</code></h5><blockquote>
<p>删除集合头节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 如果该集合没有元素则返回 null，否则删除首节点</span></span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-pollLast"><a href="#public-E-pollLast" class="headerlink" title="public E pollLast()"></a><code>public E pollLast()</code></h5><blockquote>
<p>检删除链表的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 如果该集合没有元素则返回 null，否则删除尾节点</span></span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>删除集合的头节点，该方法的作用和 <code>remove()</code>一样，不过当两个方法对空集合使用时，<code>remove()</code> 方抛出异常，而 <code>poll()</code> 方返回 <code>null</code>。</li>
<li><code>pollFirst()</code> 方法和 <code>poll()</code> 方法的作用一样，当集合为空时返回 <code>null</code>。</li>
<li><code>pollLast()</code> 方法和 <code>removeLast()</code> 方法的作用一样，不过当集合为空时，<code>pollLast()</code> 方法回<code>null</code>，<code>removeLast()</code> 方法抛出异常。</li>
</ul>
</blockquote>
<h4 id="获取方法-2"><a href="#获取方法-2" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a><code>public E get(int index)</code></h5><blockquote>
<p>返回集合中指定位置的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// node(index) 返回节点</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取<code>index</code>位置上的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//通过移位操作，判断index位置离左端点近，还是右端点近</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       	<span class="comment">//如果是离左端点近，就从左向右遍历，首先获取头节点</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="comment">//通过for循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="comment">//返回index位置上的值</span></span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//如果是离右端点近，就从右向左遍历，首先获取尾节点的值</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="comment">//铜鼓for循环循环遍历</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-getFirst"><a href="#public-E-getFirst" class="headerlink" title="public E getFirst()"></a><code>public E getFirst()</code></h5><blockquote>
<p>返回集合中的第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-getLast"><a href="#public-E-getLast" class="headerlink" title="public E getLast()"></a><code>public E getLast()</code></h5><blockquote>
<p>返回集合中的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peek"><a href="#public-E-peek" class="headerlink" title="public E peek()"></a><code>public E peek()</code></h5><blockquote>
<p>返回集合的第一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peekFirst"><a href="#public-E-peekFirst" class="headerlink" title="public E peekFirst()"></a><code>public E peekFirst()</code></h5><blockquote>
<p>返回集合的第一个元素，作用和 peek() 一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="public-E-peekLast"><a href="#public-E-peekLast" class="headerlink" title="public E peekLast()"></a><code>public E peekLast()</code></h5><blockquote>
<p>返回集合的最后一个元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>get</code>方法返回首节点和尾节点的时候，如果为<code>null</code>，则会抛出异常。而</li>
<li><code>peek</code>方法返回首节点和尾节点的时候不会抛出异常。</li>
</ul>
</blockquote>
<h4 id="清空方法-1"><a href="#清空方法-1" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a><code>public void clear()</code></h5><blockquote>
<p>移除里面所有的元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">          <span class="comment">// 保存下一个</span></span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">          <span class="comment">// 当前元素置空</span></span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 首节点和尾节点全部置null</span></span><br><span class="line">    first = last = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<ul>
<li><p><code>HashMap</code> 基于哈希表的 <code>Map</code> 接口实现，是以 <code>key-value</code> 存储形式存在，即主要用来存放键值对。<code>HashMap</code> 的实现不是同步的，这意味着它不是线程安全的。它的 <code>key</code>、<code>value</code> 都可以为 <code>null</code>，此外，<code>HashMap</code> 中的映射不是有序的。</p>
</li>
<li><p><code>jdk1.8</code> 之前 <code>HashMap</code> 由 <strong>数组 + 链表</strong> 组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 <code>hashCode</code> 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）而存在的（“拉链法”解决冲突）。<code>jdk1.8</code> 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 <code>8</code> ）并且当前数组的长度大于 <code>64</code> 时，此时此索引位置上的所有数据改为使用红黑树存储。</p>
</li>
<li><p>补充：将链表转换成红黑树前会判断，即便阈值大于 <code>8</code>，但是数组长度小于 <code>64</code>，此时并不会将链表变为红黑树，而是选择逬行数组扩容。这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要逬行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于<code>64</code>时，搜索时间相对要快些。所以结上所述为了提高性能和减少搜索时间，<strong>底层阈值大于<code>8</code>并且数组长度大于<code>64</code>时</strong>，链表才转换为红黑树，具体可以参考 <code>treeifyBin()</code> 方法。</p>
</li>
<li><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于 <code>8</code> 并且数组长度大于<code>64</code>时，链表转换为红黑树时，效率也变的更高效。</p>
</li>
</ul>
</blockquote>
<h3 id="HashMap-特点"><a href="#HashMap-特点" class="headerlink" title="HashMap 特点"></a>HashMap 特点</h3><blockquote>
<ul>
<li>存储无序的。</li>
<li>键和值位置都可以是 <code>null</code>，但是键位置只能存在一个 <code>null</code>。</li>
<li>键位置是唯一的，是底层的数据结构控制的。</li>
<li><code>jdk1.8</code> 前数据结构是<strong>链表+数组</strong>，<code>jdk1.8</code> 之后是<strong>链表+数组+红黑树</strong>。</li>
<li>阈值（边界值）&gt; <code>8</code> 并且数组长度大于 <code>64</code>，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>说明：<code>HashMap</code>在未变成红黑树前，采用的单向链表，然后在即将变成红黑树时，先转化为双向链表，双向链表转化为红黑树</font></p>
</blockquote>
<h3 id="JDK1-7和JDK1-8区别"><a href="#JDK1-7和JDK1-8区别" class="headerlink" title="JDK1.7和JDK1.8区别"></a>JDK1.7和JDK1.8区别</h3><blockquote>
<ul>
<li><code>JDK1.7</code>用的是头插法，而<code>JDK1.8</code>及之后使用的都是尾插法，那么他们为什么要这样做呢？因为<code>JDK1.7</code>是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在<code>JDK1.8</code>之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</li>
<li>扩容后数据存储位置的计算方式也不一样：1. 在<code>JDK1.7</code>的时候是直接用<code>hash</code>值和需要扩容的二进制数进行<code>&amp;</code>（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是<code>1</code>，这样能最大程度减少<code>hash</code>碰撞）（<code>hash值 &amp; length-1</code>）</li>
<li>在<code>JDK1.7</code>的时候是<strong>先扩容后插入</strong>的，这样就会导致无论这一次插入是不是发生<code>hash</code>冲突都需要进行扩容，如果这次插入的并没有发生<code>Hash</code>冲突的话，那么就会造成一次无效扩容，但是在<code>JDK1.8</code>的时候是<strong>先插入再扩容</strong>的，优点其实是因为为了减少这一次无效的扩容，原因就是如果这次插入没有发生<code>Hash</code>冲突的话，那么其实就不会造成扩容，但是在<code>JDK1.7</code>的时候就会急造成扩容。（JDK1.7扩容条件：1、存放新值的时候当前已有元素的个数必须大于等于阈值；2、存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</li>
<li>而在<code>JDK1.8</code>的时候直接用了<code>JDK1.7</code>的时候计算的规律，也就是<code>扩容前的原始位置+扩容的大小值=JDK1.8</code>的计算方式，而不再是<code>JDK1.7</code>的那种异或的方法。但是这种方式就相当于只需要判断<code>Hash</code>值的新增参与运算的位是<code>0</code>还是<code>1</code>就直接迅速计算出了扩容后的储存方式。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20180905105129591.png"></p>
<h4 id="为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢？"><a href="#为什么在JDK1-7的时候是先进行扩容后进行插入，而在JDK1-8的时候则是先插入后进行扩容的呢？" class="headerlink" title="为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？"></a>为什么在<code>JDK1.7</code>的时候是先进行扩容后进行插入，而在<code>JDK1.8</code>的时候则是先插入后进行扩容的呢？</h4><blockquote>
<ul>
<li>在<code>JDK1.7</code>中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，如果不为空说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用</li>
</ul>
</blockquote>
<h3 id="HashMap-继承关系"><a href="#HashMap-继承关系" class="headerlink" title="HashMap 继承关系"></a>HashMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap-源码分析-JDK1-8"><a href="#HashMap-源码分析-JDK1-8" class="headerlink" title="HashMap 源码分析(JDK1.8)"></a>HashMap 源码分析(JDK1.8)</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628085432352.png"></p>
<h4 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的数组初始容量为16</span></span><br><span class="line"><span class="comment">    * 1&lt;&lt;4代表移位操作，左移动4位，相当于1*2*2*2*2=16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组的最大容量</span></span><br><span class="line"><span class="comment">    * 也就相当于最大容量为2的30次方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  默认的负载因子为0.75</span></span><br><span class="line"><span class="comment">    *  例如，默认的数组容量为16，默认的负载因子为0.75</span></span><br><span class="line"><span class="comment">    *  因此，当所有链表节点个数的 总合 &gt; 容量*负载因子 的时候，就需要进行扩容</span></span><br><span class="line"><span class="comment">    *  因为如果节点的个数过多的话，会造成大量的哈希冲突，链表过长，导致插入和查询效率低下</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当某个链表上的节点个数超过8的时候，就会将该链表转换为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当某个链表上的节点个数小于6的时候，又会将红黑树转化为链表。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当桶的容量最少为MIN_TREEIFY_CAPACITY，也就是64的时候，才会转换为红黑树</span></span><br><span class="line"><span class="comment">    * 如果没有达到64的话，优先选择是将桶扩容，而不是转换为红黑树</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里的table也就是相当于上面提到的桶，永远都是2的幂次方个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储具体元素的集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存放元素的个数，这个不是等于桶的个数，而是所有节点的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  阈值，元素的个数不能超过阈值</span></span><br><span class="line"><span class="comment">    * threshold = Capacity(容量)*loadFactor（负载因子）</span></span><br><span class="line"><span class="comment">    * 当实际个数超过threshold的时候，就会进行扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对应于上面的DEFAULT_LOAD_FACTOR，这个是实际的负载因子。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="Node节点类"><a href="#Node节点类" class="headerlink" title="Node节点类"></a>Node节点类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node节点类，继承自Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写hashCode()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equal方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public HashMap()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public HashMap(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public HashMap(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传入一个<code>Map</code>类型的<code>m</code>，将<code>m</code>中的所有元素放进<code>HashMap</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-HashMap"><a href="#public-HashMap" class="headerlink" title="public HashMap()"></a><code>public HashMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法</span></span><br><span class="line"><span class="comment"> * 使用默认的负载因子0.75</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-int-initialCapacity"><a href="#public-HashMap-int-initialCapacity" class="headerlink" title="public HashMap(int initialCapacity)"></a><code>public HashMap(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个参数的构造函数</span></span><br><span class="line"><span class="comment"> * 参数为初始容量initialCapacity</span></span><br><span class="line"><span class="comment"> * 调用上面的两个参数的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-int-initialCapacity-float-loadFactor"><a href="#public-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashMap(int initialCapacity, float loadFactor)"></a><code>public HashMap(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"><span class="comment">	 initialCapacity：指定的容量</span></span><br><span class="line"><span class="comment">	 loadFactor:指定的负载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    	<span class="comment">// 判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    	<span class="comment">// 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    	<span class="comment">// 判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">// 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     	<span class="comment">// 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 最后调用了tableSizeFor，来看一下方法实现：</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     	返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashMap-Map-m"><a href="#public-HashMap-Map-m" class="headerlink" title="public HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传入一个Map类型的m，将m中的所有元素放进HashMap中</span></span><br><span class="line"><span class="comment">    * 因为没有设置负载因子，所以设置负载因子为默认的负载因子</span></span><br><span class="line"><span class="comment">    * 这里先假设putMapEntries(m, false)是将m中的元素方式HashMap中的方法</span></span><br><span class="line"><span class="comment">    * 下面会具体解释这个方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这个方法相当于是将m中的元素添加到HashMap中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">   	<span class="comment">//获取m中实际有多少个元素</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">       <span class="comment">//如果个数大于0</span></span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       	<span class="comment">//如果table数组不是null，就是已经初始化过了</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">           	<span class="comment">//使用s/loadFactor计算出需要的数组容量是多少</span></span><br><span class="line">               <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">//查看ft是否超过了最大数组容量MAXIMUM_CAPACITY</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//查看t是否超过了最大装载量</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">               	<span class="comment">//如果超过了阈值，就初始化阈值</span></span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//table没有进行初始化过，就进行初始化</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">           	<span class="comment">//这里可以理解为一个扩容的方法，下面会解释</span></span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">//foreach循环遍历m中的每一个元素</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">               <span class="comment">//将m中的元素添加到HashMap中</span></span><br><span class="line">               putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>float ft = ((float)s / loadFactor) + 1.0F</code>; 这一行代码中为什么要加 <code>1.0F</code> ？</p>
<p>​	<code>s/loadFactor</code> 的结果是小数，加 <code>1.0F</code> 与 <code>(int)ft</code> 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 <code>resize</code> 的调用次数。所以 <code>+ 1.0F</code> 是为了获取更大的容量。</p>
<p>​	例如：原来集合的元素个数是 <code>6</code> 个，那么 <code>6/0.75</code> 是 <code>8</code>，是 <code>2</code> 的 <code>n</code>次幂，那么新的数组大小就是 <code>8</code> 了。然后原来数组的数据就会存储到长度是 <code>8</code> 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 <code>+1</code> 呢，数组长度直接变为<code>16</code>了，这样可以减少数组的扩容。</p>
</blockquote>
<h4 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a><code>tableSizeFor(int cap)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将参数cap转换为2的幂次方的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	这个方法主要是用来规范初始化容量的，因为构造方法中传入的<code>initialCapacity</code>可能并不是<code>2</code>的幂次方，但是规定了数组的容量必须是<code>2</code>的幂次方，所以需要此方法来找到大于或等于<code>initialCapacity</code>的<code>2</code>的幂次方。</p>
</blockquote>
<p>分析：</p>
<blockquote>
<ol>
<li><p><code>int n = cap - 1</code>;<br>防止 <code>cap</code> 已经是 <code>2</code> 的幂。如果 <code>cap</code> 已经是 <code>2</code> 的幂，又没有这个减 <code>1</code> 操作，则执行完后面的几条无符号操作之后，返回的 <code>capacity</code> 将是这个 <code>cap</code> 的 <code>2</code> 倍。</p>
</li>
<li><p>如果 <code>n</code> 这时为 <code>0</code> 了（经过了<code>cap - 1</code>后），则经过后面的几次无符号右移依然是 <code>0</code>，最后返回的 <code>capacity</code> 是<code>1</code>（最后有个 <code>n + 1</code> 的操作）。</p>
</li>
<li><p>注意：容量最大也就是 <code>32bit</code> 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>; 最多也就 <code>32</code> 个 <code>1</code>（但是这已经是负数了，在执行 <code>tableSizeFor</code> 之前，对 <code>initialCapacity</code> 做了判断，如果大于<code>MAXIMUM_CAPACITY(2 ^ 30)</code>，则取 <code>MAXIMUM_CAPACITY</code>。如果等于<code>MAXIMUM_CAPACITY</code>，会执行位移操作。所以这里面的位移操作之后，最大 <code>30</code> 个 <code>1</code>，不会大于等于 <code>MAXIMUM_CAPACITY</code>。<code>30</code> 个 <code>1</code>，加<code>1</code>后得 <code>2 ^ 30</code>）。</p>
</li>
</ol>
</blockquote>
<p>完整例子：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628085716417.png"></p>
<h4 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a><code>hash(Object key)</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>这是一个根据<code>key</code>来返回哈希值的方法</li>
<li>这个方法是传入一个<code>key</code>值，然后判断<code>key</code>是否为<code>null</code>，如果为<code>null</code>的话，就直接返回<code>0</code></li>
<li>如果不为<code>null</code>，先通过<code>hashCode()</code>方法获取哈希值，然后将<code>h</code>右移<code>16</code>位，并进行计算结果并返回，这样做的目的是尽量减少哈希冲突。</li>
</ol>
</blockquote>
<h4 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h4><h5 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a><code>put(K key, V value)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a><code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash  由key计算出来的 hash值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要存储的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  要存储的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent  如果当前位置已存在一个值，是否替换，false是替换，true是不替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict  表是否在创建模式，如果为false，则表是在创建模式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    	2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。</span></span><br><span class="line"><span class="comment">    	3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，</span></span><br><span class="line"><span class="comment">    	满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。</span></span><br><span class="line"><span class="comment">    	4）执行完n = (tab = resize()).length，数组tab每个空间都是null。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。</span></span><br><span class="line"><span class="comment">    	2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给结点p。</span></span><br><span class="line"><span class="comment">    	3) (p = tab[i = (n - 1) &amp; hash]) == null 判断结点位置是否等于null，</span></span><br><span class="line"><span class="comment">    	如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 创建一个新的结点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        	1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等。</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的。</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key比较两个key的地址值是否相等。</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，</span></span><br><span class="line"><span class="comment">             那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	1)如果是链表的话需要遍历到最后结点然后插入</span></span><br><span class="line"><span class="comment">            	2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	1)e = p.next 获取p的下一个元素赋值给e。</span></span><br><span class="line"><span class="comment">                	2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	1）创建一个新的结点插入到尾部</span></span><br><span class="line"><span class="comment">                    	 p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                    	 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。</span></span><br><span class="line"><span class="comment">                    	2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    	如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 尝试转换为红黑树，不一定会成功，因为还需要满足table的长度大于64</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                		要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                		直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                	*/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明新添加的元素和当前结点不相等，继续查找下一个结点。</span></span><br><span class="line"><span class="comment">                	用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        	也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        	这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 用新值替换旧值</span></span><br><span class="line">                <span class="comment">// e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="treeifyBin-Node-tab-int-hash"><a href="#treeifyBin-Node-tab-int-hash" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab, int hash) "></a><code>treeifyBin(Node&lt;K,V&gt;[] tab, int hash) </code></h4><blockquote>
<p>​	将链表转换为红黑树，结点添加完成之后判断此时结点个数是否大于 <code>TREEIFY_THRESHOLD</code> 临界值<code> 8</code>，如果大于则将链表转换为红黑树，转换红黑树的方法 <code>treeifyBin</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">	Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">	int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。</span></span><br><span class="line"><span class="comment">    	目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//扩容方法</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">        	2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// hd：红黑树的头结点   tl：红黑树的尾结点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 新创建一个树的结点，内容和当前链表结点e一致</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p; <span class="comment">// 将新创键的p结点赋值给红黑树的头结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl; <span class="comment">// 将上一个结点p赋值给现在的p的前一个结点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 将现在结点p作为树的尾结点的下一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null</span></span><br><span class="line"><span class="comment">            	则回到上面继续取出链表中结点转换为红黑树</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">        	而不是链表数据结构了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：上述操作一共做了如下几件事：</p>
<blockquote>
<ol>
<li>根据哈希表中元素个数确定是扩容还是树形化。</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。</li>
<li>然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。</li>
</ol>
</blockquote>
<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h4><h5 id="扩容时机："><a href="#扩容时机：" class="headerlink" title="扩容时机："></a>扩容时机：</h5><blockquote>
<ol>
<li><code>HashMap</code>实行了懒加载, 新建<code>HashMap</code>时不会对<code>table</code>进行赋值, 而是到第一次插入时, 进行<code>resize</code>时构建<code>table</code>;</li>
<li>当<code>HashMap.size</code> 大于 <code>threshold</code>时, 会进行<code>resize</code>；<code>threshold</code>的值我们在上一次分享中提到过: 当第一次构建时, 如果没有指定<code>HashMap.table</code>的初始长度, 就用默认值<code>16</code>, 否则就是指定的值; 然后不管是第一次构建还是后续扩容, <code>threshold = table.length * loadFactor</code></li>
</ol>
</blockquote>
<p>如何扩容：</p>
<blockquote>
<ul>
<li><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
</li>
<li><p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) &amp; hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。</p>
</li>
</ul>
</blockquote>
<p>例如我们从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628214503128.png"></p>
<p>因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628215948256.png"></p>
<p>说明：</p>
<blockquote>
<p>​	5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。</p>
<p>​	因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” 。</p>
</blockquote>
<p>可以看看下图为 16 扩充为 32 的 resize 示意图：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20200628220517981.png"></p>
<blockquote>
<p>​	正是因为这样巧妙的 <code>rehash</code> 方式，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 <code>1bit</code> 是 <code>0</code> 还是 <code>1</code> 可以认为是随机的，在 <code>resize</code> 的过程中保证了 <code>rehash</code> 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 <code>rehash</code> 之后不会出现更严重的 <code>hash</code> 冲突，均匀的把之前的冲突的结点分散到新的桶中了。</p>
</blockquote>
<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">// 开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        	1) (newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        	2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">// 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 通过上述讲解的原理来计算结点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     	<span class="comment">// 这里来判断如果等于true e这个结点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>首先需要获取旧桶以及旧桶的初始容量</li>
<li>如果旧桶已经初始化过了，并且旧桶已经是最大容量了，那就不进行扩容了，直接返回。如果不是的话，就将桶扩大一倍，并且阈值也扩大一倍。</li>
<li>如果旧桶没有被初始化过，那么就根据默认值对新桶的成员变量进行初始化</li>
<li>如果阈值为<code>0</code>的话，就需要重新确定阈值</li>
<li>然后根据新桶的成员变量，对新桶进行初始化</li>
<li>因为新桶的容量和旧桶的不一样，所以位置<code>index</code>也变了，因此需要重新计算<code>index</code>位置，将旧桶中的元素搬迁到新桶中。</li>
</ol>
</blockquote>
<h4 id="删除方法-3"><a href="#删除方法-3" class="headerlink" title="删除方法"></a>删除方法</h4><h5 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a><code>remove(Object key)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定key的remove方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">//调用下面的方法删除指定的key</span></span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">          <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">	<span class="comment">// 根据hash找到位置 </span></span><br><span class="line">	<span class="comment">// 如果当前key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果桶上的结点就是要找的key，则将node指向该结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明结点存在下一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 说明是以红黑树来处理的冲突，则获取红黑树要删除的结点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的结点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 通过调用红黑树的方法来删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 链表删除</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 记录修改次数</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 变动的数量</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>首先要查看数组是否已经初始化了，如果初始化了，才能进行下面的计算</li>
<li>要删除的节点分为三种情况。位于<code>index</code>桶中的第一个节点、红黑树节点、位于<code>index</code>桶中后面的节点。这三种情况需要进行判断，是属于哪一类情况，获得要删除的节点</li>
<li>确定属于哪一类情况之后，再根据三种不同的情况进行节点的删除。</li>
</ol>
</blockquote>
<h4 id="获取方法-3"><a href="#获取方法-3" class="headerlink" title="获取方法"></a>获取方法</h4><h5 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        	判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        	根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        	注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<ol>
<li>通过 <code>hash</code> 值获取该 <code>key</code> 映射到的桶</li>
<li>桶上的 <code>key</code> 就是要查找的 <code>key</code>，则直接找到并返回</li>
<li>桶上的 <code>key</code> 不是要找的 <code>key</code>，则查看后续的结点：<ul>
<li>如果后续结点是红黑树结点，通过调用红黑树的方法根据 <code>key</code> 获取 <code>value</code></li>
<li>如果后续结点是链表结点，则通过循环遍历链表根据 <code>key</code> 获取 <code>value</code></li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="清空方法-2"><a href="#清空方法-2" class="headerlink" title="清空方法"></a>清空方法</h4><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a><code>clear()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空每个桶的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab;</span><br><span class="line">      <span class="comment">//修改次数+1</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//遍历每一个桶</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//节点个数为0</span></span><br><span class="line">          size = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//将桶的第一个元素置为null，方便gc</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">              tab[i] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含方法-2"><a href="#包含方法-2" class="headerlink" title="包含方法"></a>包含方法</h4><h5 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue(Object value) "></a><code>containsValue(Object value) </code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  查看HashMap中是否含有指定的balue </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">       <span class="comment">//判断桶是否已经初始化了</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       	<span class="comment">//遍历每一个桶</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">               <span class="comment">//获得桶中的每一个节点</span></span><br><span class="line">               <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                   <span class="comment">//逐个比较s</span></span><br><span class="line">                   <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                       (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<ul>
<li><code>TreeMap</code>存储<code>K-V</code>键值对，通过红黑树<code>（R-B tree）</code>实现；</li>
<li><code>TreeMap</code>继承了<code>NavigableMap</code>接口，<code>NavigableMap</code>接口继承了<code>SortedMap</code>接口，可支持一系列的导航定位以及导航操作的方法，当然只是提供了接口，需要<code>TreeMap</code>自己去实现；</li>
<li><code>TreeMap</code>实现了<code>Cloneable</code>接口，可被克隆，实现了<code>Serializable</code>接口，可序列化；</li>
<li><code>TreeMap</code>因为是通过红黑树实现，红黑树结构天然支持排序，默认情况下通过<code>Key</code>值的自然顺序进行排序；</li>
</ul>
</blockquote>
<h3 id="TreeMap-继承关系"><a href="#TreeMap-继承关系" class="headerlink" title="TreeMap 继承关系"></a>TreeMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-源码分析"><a href="#TreeMap-源码分析" class="headerlink" title="TreeMap 源码分析"></a>TreeMap 源码分析</h3><h4 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   我们前面提到TreeMap是可以自动排序的，默认情况下comparator为null，这个时候</span></span><br><span class="line"><span class="comment">   按照key的自然顺序进行排序，然而并不是所有情况下都可以直接使用key的自然顺序，</span></span><br><span class="line"><span class="comment">   有时候我们想让Map的自动排序按照我们自己的规则，这个时候你就需要传递Comparator的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   TreeMap的存储结构既然是红黑树，那么必然会有唯一的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   Map中key-val对的数量，也即是红黑树中节点Entry的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   红黑树结构的修改次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry&lt;K,V&gt;"></a><code>Entry&lt;K,V&gt;</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//key,val是存储的原始数据</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了节点的左孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了节点的右孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过该节点可以反过来往上找到自己的父亲</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认情况下为黑色节点，可调整</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> (key==<span class="literal">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">valueHash</span> <span class="operator">=</span> (value==<span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY3NzkxNC8yMDE5MDcvMTY3NzkxNC0yMDE5MDcyMTE2MjY0ODEzMS0zMjY5OTYwMzAucG5n.png"></p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public TreeMap()</code></td>
<td align="center">默认构造函数，按照key的自然顺序排列</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></td>
<td align="center">传递<code>Comparator</code>具体实现，按照该实现规则进行排序</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传递一个<code>map</code>实体构建<code>TreeMap</code>,按照默认规则排序</td>
</tr>
<tr>
<td align="center"><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></td>
<td align="center">传递一个map实体构建<code>TreeMap</code>,按照传递的map的排序规则进行排序</td>
</tr>
</tbody></table>
<h5 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-TreeMap"><a href="#public-TreeMap" class="headerlink" title="public TreeMap()"></a><code>public TreeMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数，按照key的自然顺序排列</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-Comparator-comparator"><a href="#public-TreeMap-Comparator-comparator" class="headerlink" title="public TreeMap(Comparator&lt;? super K&gt; comparator)"></a><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递Comparator具体实现，按照该实现规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-Map-m"><a href="#public-TreeMap-Map-m" class="headerlink" title="public TreeMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照默认规则排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeMap-SortedMap-m"><a href="#public-TreeMap-SortedMap-m" class="headerlink" title="public TreeMap(SortedMap&lt;K, ? extends V&gt; m)"></a><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照传递的map的排序规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h4><p><code>put</code>方法步骤如下：</p>
<blockquote>
<ol>
<li>获取根节点，根节点为空，产生一个根节点，将其着色为黑色，退出余下流程；</li>
<li>获取比较器，如果传入的<code>Comparator</code>接口不为空，使用传入的<code>Comparator</code>接口实现类进行比较；如果传入的<code>Comparator</code>接口为空，将<code>Key</code>强转为<code>Comparable</code>接口进行比较；</li>
<li>从根节点开始逐一依照规定的排序算法进行比较，取比较值<code>cmp</code>，如果<code>cmp=0</code>，表示插入的<code>Key</code>已存在；如果<code>cmp&gt;0</code>，取当前节点的右子节点；如果<code>cmp&lt;0</code>，取当前节点的左子节点；</li>
<li>排除插入的<code>Key</code>已存在的情况，第（3）步的比较一直比较到当前节点<code>t</code>的左子节点或右子节点为<code>null</code>，此时<code>t</code>就是我们寻找到的节点，<code>cmp&gt;0</code>则准备往<code>t</code>的右子节点插入新节点，<code>cmp&lt;0</code>则准备往<code>t</code>的左子节点插入新节点；</li>
<li><code>new</code>出一个新节点，默认为黑色，根据<code>cmp</code>的值向<code>t</code>的左边或者右边进行插入；</li>
<li>插入之后进行修复，包括左旋、右旋、重新着色这些操作，让树保持平衡性；</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//用t表示二叉树的当前节点</span></span><br><span class="line">    Entry&lt;K, V&gt; t = root;</span><br><span class="line">    <span class="comment">//t为null表示一个空树，即TreeMap中没有任何元素，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">//将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//容器的size = 1，表示TreeMap集合中存在一个元素</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//修改次数 + 1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;     <span class="comment">//cmp表示key排序的返回结果</span></span><br><span class="line">    Entry&lt;K, V&gt; parent;   <span class="comment">//父节点</span></span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;    <span class="comment">//指定的排序算法</span></span><br><span class="line">    <span class="comment">//如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;      <span class="comment">//parent指向上次循环后的t</span></span><br><span class="line">            <span class="comment">//比较新增节点的key和当前节点key的大小</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">//cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">                <span class="comment">//cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">                <span class="comment">//cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cpr为空，则采用默认的排序算法进行创建TreeMap集合</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)     <span class="comment">//key值为空抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">/* 下面处理过程和上面一样 */</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新增节点当做parent的子节点</span></span><br><span class="line">    Entry&lt;K, V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="comment">//如果新增节点的key小于parent的key，则当做左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">        <span class="comment">//如果新增节点的key大于parent的key，则当做右子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置</span></span><br><span class="line"><span class="comment">     *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="comment">//TreeMap元素数量 + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//TreeMap容器修改次数 + 1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	第1~第5步都没有什么问题，红黑树最核心的应当是第6步插入数据之后进行的修复工作，对应的<code>Java</code>代码是<code>TreeMap</code>中的<code>fixAfterInsertion</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后的修复操作</span></span><br><span class="line"><span class="comment"> * x 表示新增节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K, V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;    <span class="comment">//新增节点的颜色为红色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环 直到 x不是根节点，且x的父节点不为红色</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">//如果X的父节点（P）是其父节点的父节点（G）的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">//获取X的叔节点(U)</span></span><br><span class="line">            Entry&lt;K, V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色（情况三）</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的叔节点（U）设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//右旋转</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//（情况五）</span></span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的父节点的父节点（G）为中心右旋转</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果X的父节点（P）是其父节点的父节点（G）的右节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取X的叔节点（U）</span></span><br><span class="line">            Entry&lt;K, V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果X的叔节点（U） 为红色（情况三）</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的叔节点（U）设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">//将X的父节点作为X</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//右旋转</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//（情况五）</span></span><br><span class="line">                <span class="comment">//将X的父节点（P）设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//将X的父节点的父节点（G）设置红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//以X的父节点的父节点（G）为中心右旋转</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将根节点G强制设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法-4"><a href="#获取方法-4" class="headerlink" title="获取方法"></a>获取方法</h4><p><code>get</code>方法步骤如下：</p>
<blockquote>
<ol>
<li>当<code>key</code>大于当前节点，把当前节点指针指向右孩子继续循环。</li>
<li>当<code>key</code>小于当前节点，把当前节点的指针指向左孩子继续循环。</li>
<li>当<code>key</code>等于当前节点，则返回当前节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从root节点开始遍历，通过二分查找逐步向下找</span></span><br><span class="line"><span class="comment"> * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过k.compareTo(p.key)比较传入的key和</span></span><br><span class="line"><span class="comment"> * 根节点的key值；</span></span><br><span class="line"><span class="comment"> * 如果传入的key&lt;root.key, 那么继续在root的左子树中找，从root的左孩子节点（root.left）开始；</span></span><br><span class="line"><span class="comment"> * 如果传入的key&gt;root.key, 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;</span></span><br><span class="line"><span class="comment"> * 如果恰好key==root.key，那么直接根据root节点的value值即可。</span></span><br><span class="line"><span class="comment"> * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//默认排序情况下的查找</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从root节点开始遍历，通过二分查找逐步向下找</span></span><br><span class="line"><span class="comment"> * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过自定义的排序算法</span></span><br><span class="line"><span class="comment"> * cpr.compare(key, t.key)比较传入的key和根节点的key值，如果传入的key&lt;root.key，那么</span></span><br><span class="line"><span class="comment"> * 继续在root的左子树中找，从root的左孩子节点（root.left）开始：如果传入的key&gt;root.key,</span></span><br><span class="line"><span class="comment"> * 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;如果恰好key==root.key，</span></span><br><span class="line"><span class="comment"> * 那么直接根据root节点的value值即可。</span></span><br><span class="line"><span class="comment"> * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//自定义排序规则下的查找</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntryUsingComparator</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> (K) key;</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<ol>
<li><p>是基于<code>HashMap</code>实现的，默认构造函数是构建一个初始容量为<code>16</code>，负载因子为<code>0.75</code> 的<code>HashMap</code>。封装了一个 <code>HashMap</code> 对象来存储所有的集合元素，所有放入 <code>HashSet</code> 中的集合元素实际上由 <code>HashMap</code> 的 <code>key</code> 来保存，而 <code>HashMap</code> 的 <code>value</code> 则存储了一个 <code>PRESENT</code>，它是一个静态的 <code>Object</code> 对象。</p>
</li>
<li><p>当我们试图把某个类的对象当成 <code>HashMap</code>的 <code>key</code>，或试图将这个类的对象放入 <code>HashSet</code>中保存时，重写该类的<code>equals(Object obj)</code>方法和 <code>hashCode()</code> 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 <code>hashCode()</code> 返回值相同时，它们通过 <code>equals()</code> 方法比较也应该返回 <code>true</code>。通常来说，所有参与计算 <code>hashCode()</code> 返回值的关键属性，都应该用于作为 <code>equals()</code> 比较的标准。</p>
</li>
<li><p><code>HashSet</code>的其他操作都是基于<code>HashMap</code>的。</p>
</li>
</ol>
</blockquote>
<h3 id="TreeMap-继承关系-1"><a href="#TreeMap-继承关系-1" class="headerlink" title="TreeMap 继承关系"></a>TreeMap 继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-源码分析-1"><a href="#TreeMap-源码分析-1" class="headerlink" title="TreeMap 源码分析"></a>TreeMap 源码分析</h3><h4 id="成员变量-5"><a href="#成员变量-5" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br></pre></td></tr></table></figure>

<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public HashSet()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public HashSet(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public HashSet(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public HashSet(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">构造一个包含指定<code>collection</code>中的元素的新<code>set</code></td>
</tr>
</tbody></table>
<h5 id="案例演示-5"><a href="#案例演示-5" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-HashSet"><a href="#public-HashSet" class="headerlink" title="public HashSet()"></a><code>public HashSet()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 默认的无参构造器，构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-int-initialCapacity"><a href="#public-HashSet-int-initialCapacity" class="headerlink" title="public HashSet(int initialCapacity)"></a><code>public HashSet(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-int-initialCapacity-float-loadFactor"><a href="#public-HashSet-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashSet(int initialCapacity, float loadFactor)"></a><code>public HashSet(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;  </span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="public-HashSet-Collection-c"><a href="#public-HashSet-Collection-c" class="headerlink" title="public HashSet(Collection&lt;? extends E&gt; c)"></a><code>public HashSet(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造一个包含指定collection中的元素的新set。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实际底层使用默认的加载因子0.75和足以包含指定 </span></span><br><span class="line"><span class="comment"> * collection中所有元素的初始容量来创建一个HashMap。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="添加方法-2"><a href="#添加方法-2" class="headerlink" title="添加方法"></a>添加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set中尚未包含指定元素，则添加指定元素。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </span></span><br><span class="line"><span class="comment"> * 的元素e2，则向此set 添加指定的元素e。 </span></span><br><span class="line"><span class="comment"> * 如果此set已包含该元素，则该调用不更改set并返回false。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际将将该元素作为key放入HashMap。 </span></span><br><span class="line"><span class="comment"> * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </span></span><br><span class="line"><span class="comment"> * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </span></span><br><span class="line"><span class="comment"> * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span></span><br><span class="line"><span class="comment"> * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span></span><br><span class="line"><span class="comment"> * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 将添加到此set中的元素。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-4"><a href="#删除方法-4" class="headerlink" title="删除方法"></a>删除方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果指定元素存在于此set中，则将其移除。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span></span><br><span class="line"><span class="comment"> * 则将其移除。如果此set已包含该元素，则返回true </span></span><br><span class="line"><span class="comment"> * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的remove方法删除指定Entry。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="包含方法-3"><a href="#包含方法-3" class="headerlink" title="包含方法"></a>包含方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span></span><br><span class="line"><span class="comment"> * 的e元素时，返回true。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="获取大小方法"><a href="#获取大小方法" class="headerlink" title="获取大小方法"></a>获取大小方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 返回此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.size();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="是否为空方法"><a href="#是否为空方法" class="headerlink" title="是否为空方法"></a>是否为空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> map.isEmpty();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote>
<ul>
<li><p><code>TreeSet</code> 是一个有序的集合，它的作用是提供有序的<code>Set</code>集合。它继承于<code>AbstractSet</code>抽象类，实现了<code>NavigableSet&lt;E&gt;</code>, <code>Cloneable</code>, <code>java.io.Serializable</code>接口。<br><code>TreeSet 继承于AbstractSet</code>，所以它是一个<code>Set</code>集合，具有<code>Set</code>的属性和方法。<br><code>TreeSet</code> 实现了<code>NavigableSet</code>接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br><code>TreeSet</code> 实现了<code>Cloneable</code>接口，意味着它能被克隆。<br><code>TreeSet</code> 实现了<code>java.io.Serializable</code>接口，意味着它支持序列化。</p>
</li>
<li><p><code>TreeSet</code>是基于<code>TreeMap</code>实现的。<code>TreeSet</code>中的元素支持<code>2</code>种排序方式：自然排序 或者 根据创建<code>TreeSet</code> 时提供的 <code>Comparator</code> 进行排序。这取决于使用的构造方法。</p>
</li>
<li><p><code>TreeSet</code>为基本操作（<code>add</code>、<code>remove</code> 和 <code>contains</code>）提供受保证的 <code>log(n)</code> 时间开销。<br>另外，<code>TreeSet</code>是非同步的。 它的<code>iterator</code> 方法返回的迭代器是<code>fail-fast</code>的。</p>
</li>
</ul>
</blockquote>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量-6"><a href="#成员变量-6" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet底层用的是NavigableMap来存储数据，而不是直接使用TreeMap</span></span><br><span class="line">   <span class="comment">// 我们知道TreeMap是实现类NavigableMap接口的，所以TreeSet默认构造了</span></span><br><span class="line">   <span class="comment">// 一个TreeMap来作为NavigableMap的一个实现类，提供给TreeSet存储数据</span></span><br><span class="line">   <span class="comment">// 注意它不一定就是TreeMap</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 虚拟元素, 用来作为value存储在map中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public TreeSet()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(SortedSet&lt;E&gt; s)</code></td>
<td align="center">将<code>SortedSet</code>中的所有元素添加到<code>TreeSet</code>中</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></td>
<td align="center">两使用带<code>comparator</code>的<code>TreeMap</code>初始化</td>
</tr>
<tr>
<td align="center"><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">将集合<code>c</code>中的所有元素添加的<code>TreeSet</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-6"><a href="#案例演示-6" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-TreeSet"><a href="#public-TreeSet" class="headerlink" title="public TreeSet()"></a><code>public TreeSet()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用TreeMap初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-SortedSet-s"><a href="#public-TreeSet-SortedSet-s" class="headerlink" title="public TreeSet(SortedSet&lt;E&gt; s)"></a><code>public TreeSet(SortedSet&lt;E&gt; s)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将SortedSet中的所有元素添加到TreeSet中</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-Comparator-comparator"><a href="#public-TreeSet-Comparator-comparator" class="headerlink" title="public TreeSet(Comparator&lt;? super E&gt; comparator)"></a><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用带comparator的TreeMap初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-TreeSet-Collection-c"><a href="#public-TreeSet-Collection-c" class="headerlink" title="public TreeSet(Collection&lt;? extends E&gt; c)"></a><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合c中的所有元素添加的TreeSet中</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法-2"><a href="#增加方法-2" class="headerlink" title="增加方法"></a>增加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素, 调用map的put()方法, value为PRESENT</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除方法-5"><a href="#删除方法-5" class="headerlink" title="删除方法"></a>删除方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="是否为空方法-1"><a href="#是否为空方法-1" class="headerlink" title="是否为空方法"></a>是否为空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取大小方法-1"><a href="#获取大小方法-1" class="headerlink" title="获取大小方法"></a>获取大小方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空方法-3"><a href="#清空方法-3" class="headerlink" title="清空方法"></a>清空方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap(JDK1.8)"></a>ConcurrentHashMap(JDK1.8)</h2><h3 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量-7"><a href="#成员变量-7" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 散列表数组最大限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 散列表默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发级别，jdk1.7遗留下来的，1.8只有在初始化的时候用了一用。</span></span><br><span class="line"><span class="comment"> * 不代表并发级别。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转化为链表的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容相关，计算扩容时生成的一个标识戳（虽然没有用final修饰，但是全文没有修改他，不改变）</span></span><br><span class="line"><span class="comment"> * 不管什么线程来 16扩容到32都是不变的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//node节点的hash为-1时，表示当前节点是FWD节点，已经迁移了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//node节点的hash为-2时，表示当前节点已经树化，</span></span><br><span class="line"><span class="comment">// 表示当前节点为TreeBin节点，TreeBin节点代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x7fffffff =》0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">//可以将一个负数 位与运算后得到正数，但是不是绝对值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8序列化 为了兼容jdk1.7的ConcurrentHashMap保存的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 散列表，长度一定是2次方数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 化整为零</span></span><br><span class="line"><span class="comment">  * LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">  * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">* sizeCtl 为0，代表数组未初始化， 且数组的初始容量为16</span></span><br><span class="line"><span class="comment">* sizeCtl 为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值</span></span><br><span class="line"><span class="comment">* sizeCtl 为-1，表示数组正在进行初始化</span></span><br><span class="line"><span class="comment">* sizeCtl 小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">  * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态）</span></span><br><span class="line"><span class="comment">  * 只有一个对象能持有加锁状态</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment">  * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment">  * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// views</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure>

<h5 id="sizeCtl含义解释"><a href="#sizeCtl含义解释" class="headerlink" title="sizeCtl含义解释"></a><code>sizeCtl</code>含义解释</h5><blockquote>
<p><strong>注意：以上这些构造方法中，都涉及到一个变量<code>sizeCtl</code>，这个变量是一个非常重要的变量，而且具有非常丰富的含义，它的值不同，对应的含义也不一样，这里我们先对这个变量不同的值的含义做一下说明，后续源码分析过程中，进一步解释</strong></p>
<p><code>sizeCtl</code>为<code>0</code>，代表数组未初始化， 且数组的初始容量为<code>16</code></p>
<p><code>sizeCtl</code>为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值</p>
<p><code>sizeCtl</code>为<code>-1</code>，表示数组正在进行初始化</p>
<p><code>sizeCtl</code>小于<code>0</code>，并且不是<code>-1</code>，表示数组正在扩容， <code>-(1+n)</code>，表示此时有<code>n</code>个线程正在共同完成数组的扩容操作</p>
</blockquote>
<h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><table>
<thead>
<tr>
<th align="center"><code>Constructor</code></th>
<th align="center"><code>Constructor</code>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public ConcurrentHashMap()</code></td>
<td align="center">无参构造方法</td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity)</code></td>
<td align="center">参数为初始容量<code>initialCapacity</code></td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></td>
<td align="center">两个参数的构造方法，参数的初始容量<code>initialCapacity</code>，负载因子<code>loadFactor</code></td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel)</code></td>
<td align="center">计算一个大于或者等于给定的容量值，该值是<code>2</code>的幂次方数作为初始容量</td>
</tr>
<tr>
<td align="center"><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="center">传入一个<code>Map</code>类型的<code>m</code>，将<code>m</code>中的所有元素放进<code>HashMap</code>中</td>
</tr>
</tbody></table>
<h5 id="案例演示-7"><a href="#案例演示-7" class="headerlink" title="案例演示"></a>案例演示</h5><h6 id="public-ConcurrentHashMap"><a href="#public-ConcurrentHashMap" class="headerlink" title="public ConcurrentHashMap()"></a><code>public ConcurrentHashMap()</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有维护任何变量的操作，如果调用该方法，数组长度默认是16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-int-initialCapacity"><a href="#public-ConcurrentHashMap-int-initialCapacity" class="headerlink" title="public ConcurrentHashMap(int initialCapacity)"></a><code>public ConcurrentHashMap(int initialCapacity)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递进来一个初始容量，ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>注意，调用这个方法，得到的初始容量和我们之前讲的<code>HashMap</code>以及<code>jdk7</code>的<code>ConcurrentHashMap</code>不同，即使你传递的是一个<code>2</code>的幂次方数，该方法计算出来的初始容量依然是比这个值大的<code>2</code>的幂次方数</font></p>
</blockquote>
<h6 id="public-ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#public-ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, float loadFactor)"></a><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用四个参数的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-int-initialCapacity-loadFactor-int-concurrencyLevel"><a href="#public-ConcurrentHashMap-int-initialCapacity-loadFactor-int-concurrencyLevel" class="headerlink" title="public ConcurrentHashMap(int initialCapacity, loadFactor, int concurrencyLevel)"></a><code>public ConcurrentHashMap(int initialCapacity, loadFactor, int concurrencyLevel)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一个大于或者等于给定的容量值，该值是2的幂次方数作为初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="public-ConcurrentHashMap-Map-m"><a href="#public-ConcurrentHashMap-Map-m" class="headerlink" title="public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于一个Map集合，构建一个ConcurrentHashMap</span></span><br><span class="line"><span class="comment">//初始容量为16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加方法-3"><a href="#增加方法-3" class="headerlink" title="增加方法"></a>增加方法</h4><h5 id="put-K-key-V-value-添加"><a href="#put-K-key-V-value-添加" class="headerlink" title="put(K key, V value) 添加"></a><code>put(K key, V value)</code> 添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());   <span class="comment">//返回一个正值</span></span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">	    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//普通链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树节点，将元素添加到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁图解</strong>（针对这句 <code>synchronized (f)</code> ）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/Snipaste_2020-05-16_12-04-08.jpg"></p>
<h5 id="Node-initTable-数组初始化"><a href="#Node-initTable-数组初始化" class="headerlink" title="Node&lt;K,V&gt;[] initTable() 数组初始化"></a><code>Node&lt;K,V&gt;[] initTable()</code> 数组初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="transfer-Node-tab-Node-nextTab-扩容"><a href="#transfer-Node-tab-Node-nextTab-扩容" class="headerlink" title="transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) 扩容"></a><code>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</code> 扩容</h5><h6 id="什么时候出发扩容？"><a href="#什么时候出发扩容？" class="headerlink" title="什么时候出发扩容？"></a>什么时候出发扩容？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增元素时，也就是在调用 putVal 方法后，为了通用，增加了个 check 入参，用于指定是否可能会出现扩容的情况</span></span><br><span class="line"><span class="comment">//check &gt;= 0 即为可能出现扩容的情况，例如 putVal方法中的调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">//检查当前集合元素个数 s 是否达到扩容阈值 sizeCtl ，扩容时 sizeCtl 为负数，依旧成立，同时还得满足数组非空且数组长度不能大于允许的数组最大长度这两个条件才能继续</span></span><br><span class="line">        <span class="comment">//这个 while 循环除了判断是否达到阈值从而进行扩容操作之外还有一个作用就是当一条线程完成自己的迁移任务后，如果集合还在扩容，则会继续循环，继续加入扩容大军，申请后面的迁移任务</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// sc &lt; 0 说明集合正在扩容当中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断扩容是否结束或者并发扩容线程数是否已达最大值，如果是的话直接结束while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//扩容还未结束，并且允许扩容线程加入，此时加入扩容大军中</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果集合还未处于扩容状态中，则进入扩容方法，并首先初始化 nextTab 数组，也就是新数组</span></span><br><span class="line">            <span class="comment">//(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 为首个扩容线程所设置的特定值，后面扩容时会根据线程是否为这个值来确定是否为最后一个线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容状态下其他线程对集合进行插入、修改、删除、合并、compute等操作时遇到 ForwardingNode 节点会调用该帮助扩容方法 (ForwardingNode 后面介绍)</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">//此处的 while 循环是上面 addCount 方法的简版，可以参考上面的注释</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//putAll批量插入或者插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会调用到这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//如果不满足条件，也就是 sizeCtl &lt; 0 ，说明有其他线程正在扩容当中，这里也就不需要自己去扩容了，结束该方法</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">//如果数组初始化则进行初始化，这个选项主要是为批量插入操作方法 putAll 提供的</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">//初始化时将 sizeCtl 设置为 -1 ，保证单线程初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//初始化完成后 sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容会进入到下面这个 else if 分支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">//下面的内容基本跟上面 addCount 方法的 while 循环内部一致，可以参考上面的注释</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<blockquote>
<p>(1) 在调用 <code>addCount</code> 方法增加集合元素计数后发现当前集合元素个数到达扩容阈值时就会触发扩容。<br>(2) 扩容状态下其他线程对集合进行插入、修改、删除、合并、<code>compute</code> 等操作时遇到 <code>ForwardingNode</code> 节点会触发协助扩容。<br>(3) <code>putAll</code> 批量插入或者插入节点后发现存在链表长度达到 <code>8</code> 个或以上，但数组长度为 <code>64</code> 以下时会触发扩容。<br>注意：桶上链表长度达到 <code>8</code> 个或者以上，并且数组长度为 <code>64</code> 以下时只会触发扩容而不会将链表转为红黑树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该扩容方法的地方有：</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#addCount        向集合中插入新数据后更新容量计数时发现到达扩容阈值而触发的扩容</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#helpTransfer    扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode 节点时触发的扩容</span></span><br><span class="line"><span class="comment">//java.util.concurrent.ConcurrentHashMap#tryPresize      putAll批量插入或者插入后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//计算每条线程处理的桶个数，每条线程处理的桶数量一样，如果CPU为单核，则使用一条线程处理所有桶</span></span><br><span class="line">    <span class="comment">//每条线程至少处理16个桶，如果计算出来的结果少于16，则一条线程处理16个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// 初始化新数组(原数组长度的2倍)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//将 transferIndex 指向最右边的桶，也就是数组索引下标最大的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">//新建一个占位对象，该占位对象的 hash 值为 -1 该占位对象存在时表示集合正在扩容状态，</span></span><br><span class="line">    <span class="comment">//key、value、next 属性均为 null ，nextTable 属性指向扩容后的数组</span></span><br><span class="line">    <span class="comment">//该占位对象主要有两个用途：</span></span><br><span class="line">    <span class="comment">//   1、占位作用，用于标识数组该位置的桶已经迁移完毕，处于扩容中的状态。</span></span><br><span class="line">    <span class="comment">//   2、作为一个转发的作用，扩容期间如果遇到查询操作，遇到转发节点，会把该查询操作转发到新的数组上去，不会阻塞查询操作。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//该标识用于控制是否继续处理下一个桶，为 true 则表示已经处理完当前桶，可以继续迁移下一个桶的数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//该标识用于控制扩容何时结束，该标识还有一个用途是最后一个扩容线程会负责重新检查一遍数组查看是否有遗漏的桶</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//这个循环用于处理一个 stride 长度的任务，i 后面会被赋值为该 stride 内最大的下标，而 bound 后面会被赋值为该 stride 内最小的下标</span></span><br><span class="line">    <span class="comment">//通过循环不断减小 i 的值，从右往左依次迁移桶上面的数据，直到 i 小于 bound 时结束该次长度为 stride 的迁移任务</span></span><br><span class="line">    <span class="comment">//结束这次的任务后会通过外层 addCount、helpTransfer、tryPresize 方法的 while 循环达到继续领取其他任务的效果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//每处理完一个hash桶就将 bound 进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明数组的hash桶已被线程分配完毕，没有了待分配的hash桶，</span></span><br><span class="line">                <span class="comment">//将 i 设置为 -1 ，后面的代码根据这个数值退出当前线的扩容操作</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有首次进入for循环才会进入这个判断里面去，设置 bound 和 i 的值，也就是领取到的迁移任务的数组区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后做后续工作，将 nextTable 设置为 null，表示扩容已结束，将 table 指向新数组，sizeCtl 设置为扩容阈值</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每当一条线程扩容结束就会更新一次 sizeCtl 的值，进行减 1 操作</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 成立，说明该线程不是</span></span><br><span class="line">                <span class="comment">//扩容大军里面的最后一条线程，直接return回到上层while循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//(sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明这条线程是最后一条扩容线程</span></span><br><span class="line">                <span class="comment">//之所以能用这个来判断是否是最后一条线程，因为第一条扩容线程进行了如下操作：</span></span><br><span class="line">                <span class="comment">//    U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">//除了修改结束标识之外，还得设置 i = n; 以便重新检查一遍数组，防止有遗漏未成功迁移的桶</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//遇到数组上空的位置直接放置一个占位对象，以便查询操作的转发和标识当前处于扩容状态</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//数组上遇到hash值为MOVED，也就是 -1 的位置，说明该位置已经被其他线程迁移过了，</span></span><br><span class="line">            <span class="comment">//将 advance 设置为 true ，以便继续往下一个桶检查并进行迁移操作</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//该节点为链表结构</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//遍历整条链表，找出 lastRun 节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//根据 lastRun 节点的高位标识(0 或 1)，首先将 lastRun设置为 ln </span></span><br><span class="line">                        <span class="comment">//或者 hn 链的末尾部分节点，后续的节点使用头插法拼接</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//使用高位和低位两条链表进行迁移，使用头插法拼接链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，</span></span><br><span class="line">                        <span class="comment">//并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，该占位对象的用途是</span></span><br><span class="line">                        <span class="comment">//标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//该节点为红黑树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//lo 为低位链表头结点，loTail 为低位链表尾结点，hi 和 hiTail 为高位链表头尾结点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//同样也是使用高位和低位两条链表进行迁移</span></span><br><span class="line">                        <span class="comment">//使用for循环以链表方式遍历整棵红黑树，使用尾插法拼接 ln 和 hn 链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            <span class="comment">//这里面形成的是以 TreeNode 为节点的链表</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//形成中间链表后会先判断是否需要转换为红黑树：</span></span><br><span class="line">                        <span class="comment">//1、如果符合条件则直接将 TreeNode 链表转为红黑树，再设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//2、如果不符合条件则将 TreeNode 转换为普通的 Node 节点，再将该普通链表设置到新数组中去</span></span><br><span class="line">                        <span class="comment">//(hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t 这行代码的用意在于，如果原来的红黑树</span></span><br><span class="line">                        <span class="comment">//没有被拆分成两份，那么迁移后它依旧是红黑树，可以直接使用原来的 TreeBin 对象</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">//setTabAt方法调用的是 Unsafe 类的 putObjectVolatile 方法</span></span><br><span class="line">                        <span class="comment">//使用 volatile 方式的 putObjectVolatile 方法，能够将数据直接更新回主内存，</span></span><br><span class="line">                        <span class="comment">//并使得其他线程工作内存的对应变量失效，达到各线程数据及时同步的效果</span></span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 ln 链设置到新数组下标为 i 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//使用 volatile 的方式将 hn 链设置到新数组下标为 i + n(n为原数组长度) 的位置上</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//迁移完成后使用 volatile 的方式将占位对象设置到该 hash 桶上，</span></span><br><span class="line">                        <span class="comment">//该占位对象的用途是标识该hash桶已被处理过，以及查询请求的转发作用</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//advance 设置为 true 表示当前 hash 桶已处理完，可以继续处理下一个 hash 桶</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="扩容过程图解"><a href="#扩容过程图解" class="headerlink" title="扩容过程图解"></a>扩容过程图解</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510092825539.png"></p>
<p>小结：</p>
<blockquote>
<p>(1) 元素个数达到扩容阈值。</p>
<p>(2) 调用 <code>putAll</code> 方法，但目前容量不足以存放所有元素时。</p>
<p>(3) 某条链表长度达到<code>8</code>，但数组长度却小于<code>64</code>时。</p>
</blockquote>
<p><strong><font color ='blue'><code>CPU</code>核数与迁移任务<code>hash</code>桶数量分配的关系</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093016265.png"></p>
<p><strong><font color ='blue'>单线程下线程的任务分配与迁移操作</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093338545.png"></p>
<p><strong><font color ='blue'>多线程如何分配任务？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093435247.png"></p>
<p><strong><font color ='blue'>普通链表如何迁移？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093520878.png"></p>
<p><strong><font color ='blue'>什么是 <code>lastRun</code> 节点？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093610941.png"></p>
<p><strong><font color ='blue'>红黑树如何迁移？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093656144.png"></p>
<p><strong><font color ='blue'><code>hash</code>桶迁移中以及迁移后如何处理存取请求？</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190602184408984.png"></p>
<p><strong><font color ='blue'>多线程迁移任务完成后的操作</font></strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/20190510093843462.png"></p>
<h5 id="addCount-long-x-int-check"><a href="#addCount-long-x-int-check" class="headerlink" title="addCount(long x, int check)"></a><code>addCount(long x, int check)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 1， binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果计数盒子不是空 或者</span></span><br><span class="line">    <span class="comment">// 如果修改 baseCount 失败</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）</span></span><br><span class="line">        <span class="comment">// 如果随机取余一个数组位置为空 或者</span></span><br><span class="line">        <span class="comment">// 修改这个槽位的变量失败（出现并发了）</span></span><br><span class="line">        <span class="comment">// 执行 fullAddCount 方法。并结束</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">         <span class="comment">//上面我贴出来了介绍ThreadLocalRandom的文章，这里如果是首次获取，其实就是0</span></span><br><span class="line">         <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为0，就初始化，这里其实就是把种子和随机数设置到（Thread）线程中</span></span><br><span class="line">            ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">            h = ThreadLocalRandom.getProbe();</span><br><span class="line">            wasUncontended = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//死循环，保证计数一定成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            CounterCell[] as; CounterCell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">            <span class="comment">//说明数组已经初始化，在后面有判断数组没有初始化的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这里是不是和ConcurrentHashMap定位桶的位置很像，其实是一摸一样的</span></span><br><span class="line">               <span class="comment">//说明数组中这个位置没有元素</span></span><br><span class="line">               <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//这个字段保证数组新增节点，扩容只有一个线程在进行，防止多线程并发</span></span><br><span class="line">                    <span class="comment">//这里限制一个线程处理只是在数组新增节点和扩容的时候，修改对象的值并不需要限制这个变量</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        <span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x); <span class="comment">// Optimistic create</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果为0表示没有别的线程在修改数组，通过CAS修改为1，表示当前线程在修改数组</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                CounterCell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                                <span class="comment">//再次校验，确保数组没有变化</span></span><br><span class="line">                                <span class="comment">//rs[j = (m - 1) &amp; h] == null，再次确认该位置是否为null，防止别的线程插入了</span></span><br><span class="line">                                <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">//插入数组</span></span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="comment">//释放CAS锁</span></span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="comment">//如果新节点插入成功，表示计数已经成功，这里直接break了</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                           <span class="comment">//如果失败会一直重试</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//定位到桶中有值，然后通过CAS修改其值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">//下面的两个elseif其实是为了防止数组一直扩容使用的，数组的最大容量就是CPU的核数</span></span><br><span class="line">               <span class="comment">//因为核数就是并发数，数组太大没有意义，没有那么多线程可以同时操作</span></span><br><span class="line">               <span class="comment">//就是说上面的新建节点或者CAS修改值事变了，就会到这里，然后拦截住，不让执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                    collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//先竞争到CAS锁，然后执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">//每次扩容成原来的两倍</span></span><br><span class="line">                            CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="comment">//复制元素，看过ConcurrentHashMap的扩容，再看这个，简直就跟一个大学生看小学数学题一样，😄</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            counterCells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里是重新生成一个随机数，换个位置试试，比如上面新增节点失败了，换个位置试试，或者通过CAS修改值失败，也换个位置再试试</span></span><br><span class="line">                h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里就是判断数组没有初始化的情况，搞不明白没啥放在这里，不放在开头</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                        <span class="comment">//初始化的数组大小是2，非常小</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                        init = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果以上CAS修改，创建新节点都失败了，这里还有一道防线，通过CAS修改baseCount</span></span><br><span class="line">            <span class="comment">//这也是再addCount中，当判断数组不为空，不先修改下baseCount试试，而是直接跳到这个方法中，因为在这个方法中也会修改baseCount</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p><code>x </code>参数表示的此次需要对表中元素的个数加几。<code>check</code> 参数表示是否需要进行扩容检查，大于等于<code>0</code> 需要进行检查，而我们的 <code>putVal</code> 方法的 <code>binCount</code> 参数最小也是 <code>0</code> ，因此，每次添加元素都会进行检查。（除非是覆盖操作）</p>
<ol>
<li>判断计数盒子属性是否是空，如果是空，就尝试修改 <code>baseCount</code> 变量，对该变量进行加 <code>X</code>。</li>
<li>如果计数盒子不是空，或者修改 <code>baseCount</code> 变量失败了，则放弃对 <code>baseCount</code> 进行操作。</li>
<li>如果计数盒子是 <code>null</code> 或者计数盒子的 <code>length</code> 是 <code>0</code>，或者随机取一个位置取于数组长度是 <code>null</code>，那么就对刚刚的元素进行 <code>CAS</code> 赋值。</li>
<li>如果赋值失败，或者满足上面的条件，则调用 <code>fullAddCount</code> 方法重新死循环插入。</li>
<li>这里如果操作 <code>baseCount</code> 失败了（或者计数盒子不是 <code>Null</code>），且对计数盒子赋值成功，那么就检查 <code>check</code> 变量，如果该变量小于等于 <code>1</code>. 直接结束。否则，计算一下 <code>count</code> 变量。</li>
<li>如果 <code>check</code> 大于等于 <code>0</code> ，说明需要对是否扩容进行检查。</li>
<li>如果 <code>map</code> 的 <code>size</code> 大于 <code>sizeCtl</code>（扩容阈值），且 <code>table</code> 的长度小于 <code>1 &lt;&lt; 30</code>，那么就进行扩容。</li>
<li>根据 <code>length</code> 得到一个标识符，然后，判断 <code>sizeCtl</code> 状态，如果小于 <code>0</code> ，说明要么在初始化，要么在扩容。</li>
<li>如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，<code>break</code>。</li>
<li>如果校验数据通过了，那么将 <code>sizeCtl</code> 加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li>如果没有在扩容，但是需要扩容。那么就将 <code>sizeCtl</code> 更新，赋值为标识符左移 <code>16</code> 位 —— 一个负数。然后加 <code>2</code>。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 <code>count</code>，看看是否还需要扩容。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn">初学者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn/2021/12/30/Java%E9%9B%86%E5%90%88/">https://www.wyy-blog.cn/2021/12/30/Java%E9%9B%86%E5%90%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wyy-blog.cn" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/vzbgnhgmjujydhstgra5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉树</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/22/%E6%99%BA%E5%8A%9B%E9%A2%98/" title="智力题"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/wafesdsuikj49615 (2).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">智力题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-04</div><div class="title">Java反射</div></div></a></div><div><a href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-02</div><div class="title">二叉树</div></div></a></div><div><a href="/2021/11/17/%E6%95%B0%E7%BB%84array%E4%B8%8E%E9%9B%86%E5%90%88List%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/" title="数组array与集合List互相转换"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/loiukmjn66h130.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">数组array与集合List互相转换</div></div></a></div><div><a href="/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="牛客网编程遇到的问题"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/umtjnyrhbgvsfcad.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">牛客网编程遇到的问题</div></div></a></div><div><a href="/2021/08/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/wafesdsuikj49615 (1).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-18</div><div class="title">正则表达式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初学者</div><div class="author-info__description">虽千万人，吾往矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">Java 集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">常用集合的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E3%80%81Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">List、Set、Map的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">ArrayList继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serializable%E6%A0%87%E8%AE%B0%E6%80%A7%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">Serializable标记性接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cloneable-%E6%A0%87%E8%AE%B0%E6%80%A7%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">Cloneable 标记性接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RandomAccess%E6%A0%87%E8%AE%B0%E6%80%A7%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.3.</span> <span class="toc-text">RandomAccess标记性接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">ArrayList源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A9%BA%E5%8F%82%E6%9E%84%E9%80%A0ArrayList"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">空参构造ArrayList()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AE%B9%E9%87%8FArrayList-int-initialCapacity"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">指定容量ArrayList(int initialCapacity)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList-Collection-c"><span class="toc-number">4.2.2.1.3.</span> <span class="toc-text">ArrayList(Collection&lt;? extends E&gt; c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text">添加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-add-E-e-%E6%B7%BB%E5%8A%A0%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">public boolean add(E e) 添加单个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-add-int-index-E-element-%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E5%A4%84%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">public void add(int index, E element) 在指定索引处添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-addAll-Collection-c-%E5%B0%86%E9%9B%86%E5%90%88%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%9B%86%E5%90%88"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">public boolean addAll(Collection&lt;? extends E&gt; c) 将集合的所有元素一次性添加到集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-addAll-int-index-Collection-c-%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E9%9B%86%E5%90%88"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">public boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的索引位置添加集合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-remove-int-index-%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">public E remove(int index) 根据索引删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-remove-Object-o-%E6%A0%B9%E6%8D%AE%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">public boolean remove(Object o) 根据元素删除元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.5.</span> <span class="toc-text">修改方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-set-int-index-E-element-%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E4%BF%AE%E6%94%B9%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">public E set(int index, E element) 根据索引修改集合元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.6.</span> <span class="toc-text">获取方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-get-int-index-%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">public E get(int index) 根据索引获取元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.7.</span> <span class="toc-text">转换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-String-toString-%E6%8A%8A%E9%9B%86%E5%90%88%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">public String toString() 把集合所有数据转换成字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.8.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-Iterator-iterator-%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.8.1.</span> <span class="toc-text">public Iterator&lt;E&gt; iterator() 普通迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#default-void-remove-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%AD%E7%9A%84remove%E6%96%B9%E6%B3%95-%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.8.2.</span> <span class="toc-text">default void remove() 迭代器中的remove方法,删除集合中的元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.9.</span> <span class="toc-text">清空方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-clear-%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.9.1.</span> <span class="toc-text">public void clear() 清空集合所有数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.10.</span> <span class="toc-text">包含方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-contains-Object-o-%E5%88%A4%E6%96%AD%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.10.1.</span> <span class="toc-text">public boolean contains(Object o) 判断集合是否包含指定元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">4.2.11.</span> <span class="toc-text">判断集合是否为空</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-isEmpty"><span class="toc-number">4.2.11.1.</span> <span class="toc-text">public boolean isEmpty()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast"><span class="toc-number">4.3.</span> <span class="toc-text">fail-fast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%94%B1%E6%9D%A5"><span class="toc-number">4.3.1.</span> <span class="toc-text">问题由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">什么是fail-fast机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8foreach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">4.3.3.</span> <span class="toc-text">为什么使用foreach遍历集合删除倒数第二个元素不会报错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0fail-fast"><span class="toc-number">4.3.4.</span> <span class="toc-text">如何避免出现fail-fast</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-safe"><span class="toc-number">4.4.</span> <span class="toc-text">fail-safe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-number">5.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.</span> <span class="toc-text">Vector继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">Vector源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-1"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-Vector"><span class="toc-number">5.2.2.1.1.</span> <span class="toc-text">public Vector()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-Vector-int-initialCapacity"><span class="toc-number">5.2.2.1.2.</span> <span class="toc-text">public Vector(int initialCapacity)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-Vector-int-initialCapacity-int-capacityIncrement"><span class="toc-number">5.2.2.1.3.</span> <span class="toc-text">public Vector(int initialCapacity, int capacityIncrement)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-Vector-Collection-c"><span class="toc-number">5.2.2.1.4.</span> <span class="toc-text">public Vector(Collection&lt;? extends E&gt; c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">增加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-void-addElement-E-obj"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">public synchronized void addElement(E obj)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-boolean-add-E-e"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">public synchronized boolean add(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-add-int-index-E-element"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">public void add(int index, E element)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-boolean-addAll-Collection-c"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-boolean-addAll-int-index-Collection-c"><span class="toc-number">5.2.3.5.</span> <span class="toc-text">public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.4.</span> <span class="toc-text">删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-remove-Object-o"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">public boolean remove(Object o) </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-E-remove-int-index"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">public synchronized E remove(int index)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.5.</span> <span class="toc-text">修改方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.6.</span> <span class="toc-text">获取方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-E-get-int-index"><span class="toc-number">5.2.6.1.</span> <span class="toc-text">public synchronized E get(int index)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-E-firstElement"><span class="toc-number">5.2.6.2.</span> <span class="toc-text">public synchronized E firstElement()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-E-lastElement"><span class="toc-number">5.2.6.3.</span> <span class="toc-text">public synchronized E lastElement()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.7.</span> <span class="toc-text">包含方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-contains-Object-o"><span class="toc-number">5.2.7.1.</span> <span class="toc-text">public boolean contains(Object o)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.2.8.</span> <span class="toc-text">获取索引位置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-synchronized-int-lastIndexOf-Object-o"><span class="toc-number">5.2.8.1.</span> <span class="toc-text">public synchronized int lastIndexOf(Object o)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-number">6.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">LinkedList构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">LinkedList源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">6.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-2"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-LinkedList"><span class="toc-number">6.2.2.1.1.</span> <span class="toc-text">public LinkedList()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-LinkedList-Collection-c"><span class="toc-number">6.2.2.1.2.</span> <span class="toc-text">public LinkedList(Collection&lt;? extends E&gt; c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">增加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-add-E-e"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">public boolean add(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-add-int-index-E-element-1"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">public void add(int index, E element)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-addFirst-E-e"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">public void addFirst(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-addLast-E-e"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">public void addLast(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-offer-E-e"><span class="toc-number">6.2.3.5.</span> <span class="toc-text">public boolean offer(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-offerLast-E-e"><span class="toc-number">6.2.3.6.</span> <span class="toc-text">public boolean offerLast(E e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-offerFirst-E-e"><span class="toc-number">6.2.3.7.</span> <span class="toc-text">public boolean offerFirst(E e)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-2"><span class="toc-number">6.2.4.</span> <span class="toc-text">删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-remove"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">public E remove()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-remove-int-index"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">public E remove(int index)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-boolean-remove-Object-o-1"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">public boolean remove(Object o)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-removeFirst"><span class="toc-number">6.2.4.4.</span> <span class="toc-text">public E removeFirst()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-removeLast"><span class="toc-number">6.2.4.5.</span> <span class="toc-text">public E removeLast()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-poll"><span class="toc-number">6.2.4.6.</span> <span class="toc-text">public E poll()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-pollFirst"><span class="toc-number">6.2.4.7.</span> <span class="toc-text">public E pollFirst()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-pollLast"><span class="toc-number">6.2.4.8.</span> <span class="toc-text">public E pollLast()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-2"><span class="toc-number">6.2.5.</span> <span class="toc-text">获取方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-get-int-index"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">public E get(int index)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-getFirst"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">public E getFirst()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-getLast"><span class="toc-number">6.2.5.3.</span> <span class="toc-text">public E getLast()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-peek"><span class="toc-number">6.2.5.4.</span> <span class="toc-text">public E peek()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-peekFirst"><span class="toc-number">6.2.5.5.</span> <span class="toc-text">public E peekFirst()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-E-peekLast"><span class="toc-number">6.2.5.6.</span> <span class="toc-text">public E peekLast()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.2.6.</span> <span class="toc-text">清空方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-void-clear"><span class="toc-number">6.2.6.1.</span> <span class="toc-text">public void clear()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">7.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">HashMap 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-7%E5%92%8CJDK1-8%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">JDK1.7和JDK1.8区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8JDK1-7%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%85%88%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E8%80%8C%E5%9C%A8JDK1-8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%99%E6%98%AF%E5%85%88%E6%8F%92%E5%85%A5%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">7.2.1.</span> <span class="toc-text">为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.</span> <span class="toc-text">HashMap 继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK1-8"><span class="toc-number">7.4.</span> <span class="toc-text">HashMap 源码分析(JDK1.8)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-3"><span class="toc-number">7.4.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-number">7.4.2.</span> <span class="toc-text">Node节点类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">7.4.3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-3"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashMap"><span class="toc-number">7.4.3.1.1.</span> <span class="toc-text">public HashMap()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashMap-int-initialCapacity"><span class="toc-number">7.4.3.1.2.</span> <span class="toc-text">public HashMap(int initialCapacity)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashMap-int-initialCapacity-float-loadFactor"><span class="toc-number">7.4.3.1.3.</span> <span class="toc-text">public HashMap(int initialCapacity, float loadFactor)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashMap-Map-m"><span class="toc-number">7.4.3.1.4.</span> <span class="toc-text">public HashMap(Map&lt;? extends K, ? extends V&gt; m)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tableSizeFor-int-cap"><span class="toc-number">7.4.4.</span> <span class="toc-text">tableSizeFor(int cap)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-Object-key"><span class="toc-number">7.4.5.</span> <span class="toc-text">hash(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">7.4.6.</span> <span class="toc-text">添加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#put-K-key-V-value"><span class="toc-number">7.4.6.1.</span> <span class="toc-text">put(K key, V value)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><span class="toc-number">7.4.6.2.</span> <span class="toc-text">putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeifyBin-Node-tab-int-hash"><span class="toc-number">7.4.7.</span> <span class="toc-text">treeifyBin(Node&lt;K,V&gt;[] tab, int hash) </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.8.</span> <span class="toc-text">扩容方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="toc-number">7.4.8.1.</span> <span class="toc-text">扩容时机：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#resize"><span class="toc-number">7.4.8.2.</span> <span class="toc-text">resize()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-3"><span class="toc-number">7.4.9.</span> <span class="toc-text">删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-Object-key"><span class="toc-number">7.4.9.1.</span> <span class="toc-text">remove(Object key)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-3"><span class="toc-number">7.4.10.</span> <span class="toc-text">获取方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#get-Object-key"><span class="toc-number">7.4.10.1.</span> <span class="toc-text">get(Object key)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%96%B9%E6%B3%95-2"><span class="toc-number">7.4.11.</span> <span class="toc-text">清空方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#clear"><span class="toc-number">7.4.11.1.</span> <span class="toc-text">clear()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95-2"><span class="toc-number">7.4.12.</span> <span class="toc-text">包含方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#containsValue-Object-value"><span class="toc-number">7.4.12.1.</span> <span class="toc-text">containsValue(Object value) </span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-number">8.</span> <span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.</span> <span class="toc-text">TreeMap 继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.2.</span> <span class="toc-text">TreeMap 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-4"><span class="toc-number">8.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Entry"><span class="toc-number">8.2.2.</span> <span class="toc-text">Entry&lt;K,V&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-4"><span class="toc-number">8.2.3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-4"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeMap"><span class="toc-number">8.2.3.1.1.</span> <span class="toc-text">public TreeMap()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeMap-Comparator-comparator"><span class="toc-number">8.2.3.1.2.</span> <span class="toc-text">public TreeMap(Comparator&lt;? super K&gt; comparator)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeMap-Map-m"><span class="toc-number">8.2.3.1.3.</span> <span class="toc-text">public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeMap-SortedMap-m"><span class="toc-number">8.2.3.1.4.</span> <span class="toc-text">public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">插入方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-4"><span class="toc-number">8.2.5.</span> <span class="toc-text">获取方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">9.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-1"><span class="toc-number">9.1.</span> <span class="toc-text">TreeMap 继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">9.2.</span> <span class="toc-text">TreeMap 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-5"><span class="toc-number">9.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-5"><span class="toc-number">9.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-5"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashSet"><span class="toc-number">9.2.2.1.1.</span> <span class="toc-text">public HashSet()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashSet-int-initialCapacity"><span class="toc-number">9.2.2.1.2.</span> <span class="toc-text">public HashSet(int initialCapacity)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashSet-int-initialCapacity-float-loadFactor"><span class="toc-number">9.2.2.1.3.</span> <span class="toc-text">public HashSet(int initialCapacity, float loadFactor)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-HashSet-Collection-c"><span class="toc-number">9.2.2.1.4.</span> <span class="toc-text">public HashSet(Collection&lt;? extends E&gt; c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">9.2.3.</span> <span class="toc-text">添加方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-4"><span class="toc-number">9.2.4.</span> <span class="toc-text">删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95-3"><span class="toc-number">9.2.5.</span> <span class="toc-text">包含方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%A7%E5%B0%8F%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.6.</span> <span class="toc-text">获取大小方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.7.</span> <span class="toc-text">是否为空方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet"><span class="toc-number">10.</span> <span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">10.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-6"><span class="toc-number">10.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-6"><span class="toc-number">10.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-6"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeSet"><span class="toc-number">10.2.2.1.1.</span> <span class="toc-text">public TreeSet()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeSet-SortedSet-s"><span class="toc-number">10.2.2.1.2.</span> <span class="toc-text">public TreeSet(SortedSet&lt;E&gt; s)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeSet-Comparator-comparator"><span class="toc-number">10.2.2.1.3.</span> <span class="toc-text">public TreeSet(Comparator&lt;? super E&gt; comparator)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-TreeSet-Collection-c"><span class="toc-number">10.2.2.1.4.</span> <span class="toc-text">public TreeSet(Collection&lt;? extends E&gt; c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">10.2.3.</span> <span class="toc-text">增加方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-5"><span class="toc-number">10.2.4.</span> <span class="toc-text">删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E6%96%B9%E6%B3%95-1"><span class="toc-number">10.2.5.</span> <span class="toc-text">是否为空方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%A7%E5%B0%8F%E6%96%B9%E6%B3%95-1"><span class="toc-number">10.2.6.</span> <span class="toc-text">获取大小方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%96%B9%E6%B3%95-3"><span class="toc-number">10.2.7.</span> <span class="toc-text">清空方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-JDK1-8"><span class="toc-number">11.</span> <span class="toc-text">ConcurrentHashMap(JDK1.8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-1"><span class="toc-number">11.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">11.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-7"><span class="toc-number">11.2.1.</span> <span class="toc-text">成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sizeCtl%E5%90%AB%E4%B9%89%E8%A7%A3%E9%87%8A"><span class="toc-number">11.2.1.1.</span> <span class="toc-text">sizeCtl含义解释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-7"><span class="toc-number">11.2.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-7"><span class="toc-number">11.2.2.1.</span> <span class="toc-text">案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#public-ConcurrentHashMap"><span class="toc-number">11.2.2.1.1.</span> <span class="toc-text">public ConcurrentHashMap()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-ConcurrentHashMap-int-initialCapacity"><span class="toc-number">11.2.2.1.2.</span> <span class="toc-text">public ConcurrentHashMap(int initialCapacity)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-ConcurrentHashMap-int-initialCapacity-float-loadFactor"><span class="toc-number">11.2.2.1.3.</span> <span class="toc-text">public ConcurrentHashMap(int initialCapacity, float loadFactor)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-ConcurrentHashMap-int-initialCapacity-loadFactor-int-concurrencyLevel"><span class="toc-number">11.2.2.1.4.</span> <span class="toc-text">public ConcurrentHashMap(int initialCapacity, loadFactor, int concurrencyLevel)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#public-ConcurrentHashMap-Map-m"><span class="toc-number">11.2.2.1.5.</span> <span class="toc-text">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">11.2.3.</span> <span class="toc-text">增加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#put-K-key-V-value-%E6%B7%BB%E5%8A%A0"><span class="toc-number">11.2.3.1.</span> <span class="toc-text">put(K key, V value) 添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Node-initTable-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.2.3.2.</span> <span class="toc-text">Node&lt;K,V&gt;[] initTable() 数组初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transfer-Node-tab-Node-nextTab-%E6%89%A9%E5%AE%B9"><span class="toc-number">11.2.3.3.</span> <span class="toc-text">transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) 扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E5%8F%91%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">11.2.3.3.1.</span> <span class="toc-text">什么时候出发扩容？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">11.2.3.3.2.</span> <span class="toc-text">扩容过程图解</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addCount-long-x-int-check"><span class="toc-number">11.2.3.4.</span> <span class="toc-text">addCount(long x, int check)</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="发表于 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="发表于 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="发表于 2022-01-13 20:15:31">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2022-01-04T09:01:41.000Z" title="发表于 2022-01-04 17:01:41">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-01-02T11:57:45.000Z" title="发表于 2022-01-02 19:57:45">2022-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 初学者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>