<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM基础知识 | Blog</title><meta name="author" content="初学者"><meta name="copyright" content="初学者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录Java虚拟机的基础知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM基础知识">
<meta property="og:url" content="https://www.wyy-blog.cn/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="记录Java虚拟机的基础知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/3.png">
<meta property="article:published_time" content="2021-12-08T12:29:21.000Z">
<meta property="article:modified_time" content="2023-12-17T15:06:42.838Z">
<meta property="article:author" content="初学者">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/3.png"><link rel="shortcut icon" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg"><link rel="canonical" href="https://www.wyy-blog.cn/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-17 23:06:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-08T12:29:21.000Z" title="发表于 2021-12-08 20:29:21">2021-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-17T15:06:42.838Z" title="更新于 2023-12-17 23:06:42">2023-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>123分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴<a target="_blank" rel="noopener" href="https://pdai.tech/">https://pdai.tech/</a></p>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/kmjnhbgvfcdx5612.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>​	程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。这里，并非是广义上所指的物理寄存器，叫程序计数器（或<code> PC</code> 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。**<code>JVM</code> 中的 <code>PC</code> 寄存器是对物理 <code>PC</code> 寄存器的一种抽象模拟**。</p>
<p>​	另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>通过对程序执行命令<code>javap -verbose -p xxx.class</code>反编译查看字节码文件</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc5kmznm1sj31m50u0wph.jpg"></p>
<p>注意：<strong>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p><strong>问题：</strong>使用 <code>PC</code> 寄存器存储字节码指令地址有什么用呢？为什么使用 <code>PC</code> 寄存器记录当前线程的执行地址呢？</p>
<p><strong>答：</strong>因为 <code>CPU</code> 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 <code>JVM</code> 的字节码解释器就需要通过改变 <code>PC</code> 寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><strong>问题：</strong><code>PC</code> 寄存器为什么会被设定为线程私有的？</p>
<p><strong>答：</strong>多线程在一个特定的时间段内只会执行其中某一个线程方法， <code>CPU</code> 会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个 <code>PC</code> 寄存器，每个线程都独立计算，不会互相影响。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域；</li>
</ul>
<ul>
<li>在 <code>JVM</code> 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致；</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 <code>Java</code> 方法，程序计数器记录的是 <code>JVM</code> 字节码指令地址，<strong>如果是执行 <code>native</code> 方法，则是未指定值（<code>undefined</code>）</strong>；</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成；</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；</li>
<li><strong>它是唯一一个在 <code>JVM</code> 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域；</strong></li>
</ul>
</blockquote>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote>
<p><code>Java</code>虚拟机栈也称为<code>Java</code>栈，每个方法被执行的时候，<code>Java</code>虚拟机都会同步创建一个栈帧（<code>Stack Frame</code>）</p>
<ol>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。</li>
<li>栈帧包括局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息。</li>
<li>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
</ol>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li><code>JVM</code> 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈&#x2F;压栈），方法执行结束<strong>出栈</strong></li>
<li><strong>栈不存在垃圾回收问题</strong></li>
</ul>
</blockquote>
<h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><blockquote>
<ul>
<li><code>Java</code> 虚拟机规范允许 <strong><code>Java</code>虚拟机栈的大小是动态的或者是固定不变的</strong></li>
</ul>
<ul>
<li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 <code>Java</code> 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 <code>Java</code> 虚拟机栈允许的最大容量，<code>Java</code> 虚拟机将会抛出一个 <strong><code>StackOverflowError</code></strong> 异常</li>
<li>如果 <code>Java</code> 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 <code>Java</code> 虚拟机将会抛出一个**<code>OutOfMemoryError</code>**异常</li>
</ul>
</blockquote>
<h4 id="栈中存储什么"><a href="#栈中存储什么" class="headerlink" title="栈中存储什么"></a>栈中存储什么</h4><blockquote>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（<code>Stack Frame</code>）</strong>的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
</blockquote>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><blockquote>
<ul>
<li><p><code>JVM</code> 直接对 <code>Java</code> 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出&#x2F;后进先出”原则</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（<code>Current Frame</code>），与当前栈帧对应的方法就是<strong>当前方法</strong>（<code>Current Method</code>），定义这个方法的类就是<strong>当前类</strong>（<code>Current Class</code>）</p>
</li>
<li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧中引用另外一个线程的栈帧</strong></p>
</li>
<li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
</li>
<li><p><code>Java</code> 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 <code>return</code> 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></p>
</li>
</ul>
<p><code>IDEA</code> 在 <code>debug</code> 时候，可以在 <code>debug</code> 窗口看到 <code>Frames</code> 中各种方法的压栈和出栈情况，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc9lezaxrbj319v0u0k4w.jpg"></p>
</blockquote>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><blockquote>
<ul>
<li>局部变量表（<code>Local Variables</code>）</li>
<li>操作数栈（<code>Operand Stack</code>）(或称为表达式栈)</li>
<li>动态链接（<code>Dynamic Linking</code>）：指向运行时常量池的方法引用</li>
<li>方法返回地址（<code>Return Address</code>）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc8tjehg8bj318m0lbtbu.jpg"></p>
</blockquote>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote>
<p>​	局部变量表也被称为局部变量数组或者本地变量表，是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 <code>Java</code> 虚拟机<strong>基本数据类型</strong>（<code>boolean、byte、char、short、int、float、long、double</code>）、<strong>对象引用</strong>（<code>reference</code> 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</p>
<p>​	由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
<p>​	<strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 <code>Code</code> 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
<p>​	方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>​	<strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<p>参数值的存放总是在局部变量数组的 <code>index0</code> 开始，到数组长度 <code>-1</code> 的索引结束</p>
</blockquote>
<h6 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽 Slot"></a>槽 <code>Slot</code></h6><blockquote>
<ul>
<li>局部变量表最基本的存储单元是 <code>Slot</code>（变量槽）</li>
<li>在局部变量表中，<code>32</code> 位以内的类型只占用一个 <code>Slot</code>(包括 <code>returnAddress</code> 类型)，<code>64</code> 位的类型（<code>long</code> 和 <code>double</code>）占用两个连续的 <code>Slot</code></li>
<li><code>byte</code>、<code>short</code>、<code>char</code> 在存储前被转换为 <code>int</code>，<code>boolean</code> 也被转换为 <code>int</code>，<code>0</code> 表示 <code>false</code>，非 <code>0</code> 表示 <code>true</code></li>
<li><code>long</code> 和 <code>double</code> 则占据两个 <code>Slot</code></li>
<li><code>JVM</code> 会为局部变量表中的每一个 <code>Slot</code> 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 <code>0</code> 开始到局部变量表最大的 <code>Slot</code> 数量</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 <code>Slot</code> 上</li>
<li><strong>如果需要访问局部变量表中一个 <code>64bit</code> 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 <code>long</code> 或 <code>double</code> 类型变量，不允许采用任何方式单独访问其中的某一个 <code>Slot</code>）</li>
<li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 <code>this</code> 将会存放在 <code>index</code> 为 <code>0 </code>的 <code>Slot</code> 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 <code>this</code>，就是因为在静态方法的局部变量表中并不存在this变量，所以在静态方法中不能使用；而在构造方法和实例方法中，<code>this</code> 变量会存放在局部变量表中 <code>index</code> 为 <code>0</code> 的位置。）</li>
<li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，<code>this</code>、<code>a</code>、<code>b</code>、<code>c</code> 理论上应该有 <code>4</code> 个变量，<code>c</code> 复用了 <code>b</code> 的槽）</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gc9s12g5wlj31li0owdm9.jpg"></p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
</blockquote>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><blockquote>
<ul>
<li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（<code>Last-In-First-Out</code>）的操作数栈，也可以称为<strong>表达式栈</strong>（<code>Expression Stack</code>）</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（<code>push</code>）、出栈（<code>pop</code>）</strong></li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li>
</ul>
</blockquote>
<h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><blockquote>
<ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>操作数栈就是 <code>JVM</code> 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 <code>Code</code> 属性的 <code>max_stack</code> 数据项中</li>
<li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul>
<li><code>32bit</code> 的类型占用一个栈单位深度</li>
<li><code>64bit</code> 的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 <code>PC</code> 寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>另外，我们说 <strong><code>Java</code> 虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li>
</ul>
</blockquote>
<h6 id="栈顶缓存（Top-of-stack-Cashing）"><a href="#栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="栈顶缓存（Top-of-stack-Cashing）"></a>栈顶缓存（<code>Top-of-stack-Cashing</code>）</h6><blockquote>
<p>​		<code>HotSpot</code> 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 <code>HotSpot VM</code> 的实现并没有间接利用到寄存器资源。寄存器是物理 <code>CPU</code> 中的组成部分之一，它同时也是 <code>CPU</code> 中非常重要的高速存储资源。一般来说，寄存器的读&#x2F;写速度非常迅速，甚至可以比内存的读&#x2F;写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 <code>CPU</code> 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p>
<p>​		基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（<code>instruction dispatch</code>）次数和内存读&#x2F;写次数。由于操作数是存储在内存中的，因此频繁的执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，<code>HotSpot JVM</code> 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 <code>CPU</code> 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</strong></p>
</blockquote>
<h5 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h5><blockquote>
<p>​	<strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(<code>Dynamic Linking</code>)。</p>
<p>​	在 <code>Java</code> 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（<code>Symbolic Reference</code>）保存在 <code>Class</code> 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0082zybply1gca4k4gndgj31d20o2td0.jpg"></p>
</blockquote>
<h6 id="JVM-是如何执行方法调用的"><a href="#JVM-是如何执行方法调用的" class="headerlink" title="JVM 是如何执行方法调用的"></a><code>JVM</code> 是如何执行方法调用的</h6><blockquote>
<p>​	方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。<code>Class</code> 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 <code>Class</code> 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>
<p>在 <code>JVM</code> 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p>
<ul>
<li><strong>静态链接</strong>：当一个字节码文件被装载进 <code>JVM</code> 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（<code>Early Binding</code>）和晚期绑定（<code>Late Binding</code>）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p>
<ul>
<li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li>
</ul>
</blockquote>
<h6 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h6><blockquote>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、<code>final</code> 方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法称为虚方法</li>
</ul>
</blockquote>
<h6 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h6><blockquote>
<p>​	在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法 元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，<code>JVM</code> 采用在类的方法区建立一个虚方法表（<code>virtual method table</code>），使用索引表来代替查找。非虚方法不会出现在表中。</p>
<p>​	每个类中都有一个虚方法表，<strong>表中存放着各个方法的实际入口</strong>。</p>
<p>​	虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，<code>JVM</code> 会把该类的方法表也初始化完毕。</p>
</blockquote>
<h5 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（<code>return address</code>）</h5><blockquote>
<p>用来存放调用该方法的 <code>PC</code> 寄存器的值。</p>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 <code>PC</code> 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。<strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息</strong>。</p>
</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p>
<p>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定；</p>
<p>在字节码指令中，返回指令包含 <code>ireturn</code>(当返回值是 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code> 和 <code>int</code> 类型时使用)、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code> 以及 <code>areturn</code>，另外还有一个 <code>return</code> 指令供声明为 <code>void</code> 的方法、实例初始化方法、类和接口的初始化方法使用。</p>
</li>
<li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 <code>PC</code> 寄存器值等，让调用者方法继续执行下去。</p>
</li>
</ol>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p>
</blockquote>
<h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><blockquote>
<p>​	栈帧中还允许携带与 <code>Java</code> 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><blockquote>
<p>简单的讲，一个 <code>Native Method</code> 就是一个 <code>Java</code> 调用非 <code>Java</code> 代码的接口。我们知道的 <code>Unsafe </code>类就有很多本地方法。</p>
</blockquote>
<blockquote>
<p>为什么要使用本地方法（<code>Native Method</code>）?</p>
<ul>
<li>与 <code>Java</code> 环境外交互：有时 <code>Java</code> 应用需要与 <code>Java</code> 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：<code>JVM</code> 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 <code>Java</code> 与实现了 <code>JRE</code> 的底层系统交互，<code> JVM</code> 的一些部分就是 <code>C</code> 语言写的。</li>
<li><code>Sun&#39;s Java</code>：<code>Sun</code> 的解释器就是 <code>C</code> 实现的，这使得它能像一些普通的 <code>C</code>一样与外部交互。<code>JRE</code> 大部分都是用 <code>Java</code> 实现的，它也通过一些本地方法与外界交互。比如，类 &#96;&#96;java.lang.Thread<code>的</code>setPriority() <code>的方法是用 </code>Java<code>实现的，但它实现调用的是该类的本地方法</code>setPrioruty()<code>，该方法是 </code>C<code>实现的，并被植入</code>JVM&#96; 内部。</li>
</ul>
</blockquote>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（<code>Native Method Stack</code>）</h4><blockquote>
<ul>
<li><code>Java</code> 虚拟机栈用于管理 <code>Java</code> 方法的调用，而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈也是线程私有的</li>
<li>允许线程固定或者可动态扩展的内存大小<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，<code>Java</code> 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 <code>Java</code> 虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
</li>
<li><strong>本地方法是使用 C 语言实现的</strong></li>
<li>它的具体做法是 <code>Native Method Stack</code> 中登记 <code>native</code> 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li>
<li>并不是所有 <code>JVM</code> 都支持本地方法。因为 <code>Java</code> 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 <code>JVM</code> 产品不打算支持 <code>native</code> 方法，也可以无需实现本地方法栈</li>
<li>在 <code>Hotspot JVM</code> 中，直接将本地方法栈和虚拟机栈合二为一</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>
<ul>
<li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p>
</li>
<li><p>堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</li>
</ul>
</blockquote>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><blockquote>
<p>​	对于大多数应用，<code>Java</code> 堆是 <code>Java</code> 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 <code>GC</code> 性能）：</p>
<ul>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（<code>JDK1.8</code> 之前叫永久代）：像一些方法中的操作临时对象等，<code>JDK1.8</code> 之前是占用 <code>JVM</code> 内存，<code>JDK1.8</code> 之后直接使用物理内存</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg"></p>
<p>​	<code>Java</code> 虚拟机规范规定，<code>Java</code> 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h5 id="年轻代-Young-Generation"><a href="#年轻代-Young-Generation" class="headerlink" title="年轻代 (Young Generation)"></a>年轻代 (<code>Young Generation</code>)</h5><blockquote>
<p>​	年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 **<code>Minor GC</code><strong>。年轻一代被分为三个部分——伊甸园（</strong><code>Eden Memory</code><strong>）和两个幸存区（</strong><code>Survivor Memory</code>**，被称为 <code>from/to</code> 或 <code>s0/s1</code>），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 <code>Eden</code> 内存空间中</li>
<li>当 <code>Eden</code> 空间被对象填充时，执行 **<code>Minor GC</code>**，并将所有幸存者对象移动到一个幸存者空间中</li>
<li><code>Minor GC</code> 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 <code>GC</code> 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ul>
</blockquote>
<h5 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(<code>Old Generation</code>)</h5><blockquote>
<p>​	旧的一代内存包含那些经过许多轮小型 <code>GC</code> 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 <code>GC</code>（<code>Major GC</code>），通常需要更长的时间。</p>
<p>​	大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 <code>Eden</code> 区和两个 <code>Survivor</code> 区之间发生大量的内存拷贝</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg"></p>
</blockquote>
<h5 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h5><blockquote>
<p>​	不管是 <code>JDK8</code> 之前的永久代，还是 <code>JDK8</code> 及以后的元空间，都可以看作是 <code>Java</code> 虚拟机规范中方法区的实现。</p>
<p>​	虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <code>Non-Heap</code>（非堆），目的应该是与 <code>Java</code> 堆区分开。</p>
</blockquote>
<h4 id="设置堆内存大小和-OOM"><a href="#设置堆内存大小和-OOM" class="headerlink" title="设置堆内存大小和 OOM"></a>设置堆内存大小和 <code>OOM</code></h4><blockquote>
<p><code>Java</code> 堆用于存储 <code>Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 </code>-Xmx<code>和</code>-Xms&#96; 来设定</p>
<ul>
<li><p><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></p>
</li>
<li><p><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></p>
<p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p>
</li>
<li><p>默认情况下，初始堆内存大小为：电脑内存大小 <code>/64</code></p>
</li>
<li><p>默认情况下，最大堆内存大小为：电脑内存大小 <code>/4</code></p>
</li>
</ul>
<p>可以通过代码获取到我们的设置值，当然也可以模拟 <code>OOM</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//返回 JVM 堆大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//返回 JVM 堆的最大内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initalMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + initalMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="查看-JVM-堆内存分配"><a href="#查看-JVM-堆内存分配" class="headerlink" title="查看 JVM 堆内存分配"></a>查看 <code>JVM</code> 堆内存分配</h4><blockquote>
<ol>
<li><p>在默认不配置 <code>JVM</code> 堆内存大小的情况下，<code>JVM</code> 根据默认值来配置当前内存大小</p>
</li>
<li><p>默认情况下新生代和老年代的比例是 <code>1:2</code>，可以通过 <code>–XX:NewRatio</code> 来配置</p>
<ul>
<li>新生代中的 <strong><code>Eden</code></strong>:<strong><code>From Survivor</code></strong>:<strong><code>To Survivor</code></strong> 的比例是 **<code>8:1:1</code>**，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li>
</ul>
</li>
<li><p>若在 <code>JDK 7</code> 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，<code>JVM</code> 会动态调整 <code>JVM</code> 堆中各个区域的大小以及进入老年代的年龄</p>
<p>此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code>  将会失效，而 <code>JDK 8</code> 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code></p>
<p>在 <code>JDK 8</code> 中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划</p>
</li>
</ol>
<p>每次 <code>GC</code> 后都会重新计算 <code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code> 的大小</p>
<p>计算依据 是 <strong><code>GC</code>过程</strong>中统计的**<code>GC</code>时间<strong>、</strong>吞吐量<strong>、</strong>内存占用量**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">ErgoHeapSizeLimit</span>                         <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">HeapSizePerGCThread</span>                       <span class="operator">=</span> <span class="number">87241520</span>                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := <span class="number">134217728</span>                           &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">LargePageHeapSizeThreshold</span>                <span class="operator">=</span> <span class="number">134217728</span>                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := <span class="number">2147483648</span>                          &#123;product&#125;</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 进程号</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h4><blockquote>
<ol>
<li>在 <code>JVM</code> 内存模型的堆中，堆被划分为新生代和老年代<ul>
<li>新生代又被进一步划分为 <strong><code>Eden</code> 区</strong> 和 <strong><code>Survivor</code></strong> 区，**<code>Survivor</code>** 区由 **<code>From Survivor</code>**和 <strong><code>To Survivor</code></strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 <code>Eden</code> 区<ul>
<li>此时 <code>JVM</code> 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 <code>Eden</code> 空间不足时，<code>JVM</code> 将执行新生代的垃圾回收（<code>Minor GC</code>）<ul>
<li><code>JVM</code> 会把存活的对象转移到 <code>Survivor</code> 中，并且对象年龄 <code>+1</code></li>
<li>对象在 <code>Survivor</code> 中同样也会经历 <code>Minor GC</code>，每经历一次 <code>Minor GC</code>，对象年龄都会<code>+1</code></li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，默认的阈值是 <code>16</code> 次，从 <code>0</code> 开始算，当计算器是 <code>15</code> 时，，对象会<strong>直接被分配到老年代</strong></li>
</ol>
</blockquote>
<h4 id="对象的分配过程"><a href="#对象的分配过程" class="headerlink" title="对象的分配过程"></a>对象的分配过程</h4><blockquote>
<p>​	为对象分配内存是一件非常严谨和复杂的任务，<code>JVM</code> 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 <code>GC</code> 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><code>Minor GC</code> 触发条件：<code>Eden</code> 区满时</p>
<p><code>Full GC</code> 触发条件：<br>（1）调用 <code>System.gc</code> 时，系统建议执行 <code>Full GC</code>，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过 <code>Minor GC</code> 后进入老年代的平均大小大于老年代的可用内存<br>（5）由 <code>Eden</code> 区、<code> From Space</code> 区向 <code>To Space</code> 区复制时，对象大小大于 <code>To Space</code> 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>
<p><code>Minor GC</code> 过程：</p>
<ol>
<li>在初始阶段，新创建的对象被分配到 <code>Eden </code>区，<code>survivor</code> 的两块空间都为空。</li>
<li>当 <code>Eden</code> 区满了的时候，<code>minor garbage</code> 被触发 。</li>
<li>经过扫描与标记，存活的对象被复制到 <code>S0 </code>，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</li>
<li>在下一次的 <code>Minor GC</code> 中，<code>Eden</code> 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 <code>survivor</code> 区。当 <code>Eden</code>  和 <code> S0</code> 区空间满了，<code>S0</code> 的所有的数据都被复制到 <code>S1</code>，需要注意的是，在上次 <code>minor GC </code>过程中移动到 <code>S0</code> 中的对象在复制到 <code>S1</code> 后其年龄要加1。此时 <code>Eden</code> 区 <code>S0</code> 区被清空，所有存活的数据都复制到了 <code>S1</code> 区，并且 <code>S1</code> 区存在着年龄不一样的对象</li>
<li>再下一次 <code>MinorGC</code> 则重复这个过程，这一次 <strong><code>survivor</code> 的两个区对换</strong>，存活的对象被复制到 <code>S0</code>，存活的对象年龄加 <code>1</code> <code> Eden</code> 区和另一个 <code>survivor</code> 区被清空。</li>
<li>再经过几次 <code>Minor GC</code> 之后，当存活对象的年龄达到一个阈值之后（<code>-XX：MaxTenuringThreshold</code> 默认是<code>15</code>），就会被从年轻代 <code>Promotion</code> 到老年代。</li>
<li>随着 <code>MinorGC</code> 一次又一次的进行，不断会有新的对象被 <code>promote</code> 到老年代。</li>
<li>什么时候才会去养老区呢？ 默认是 <code>15</code> 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 <code>Major GC</code>，进行养老区的内存清理</li>
<li>若养老区执行了 <code>Major GC</code>  之后发现依然无法进行对象的保存，就会产生 <code>OOM</code> 异常</li>
</ol>
</blockquote>
<h4 id="GC-垃圾回收简介"><a href="#GC-垃圾回收简介" class="headerlink" title="GC 垃圾回收简介"></a><code>GC</code> 垃圾回收简介</h4><blockquote>
<h6 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a><code>Minor GC、Major GC、Full GC</code></h6><p><code>JVM</code> 在进行 <code>GC</code> 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 <code>HotSpot VM</code> 的实现，它里面的 <code>GC</code> 按照回收区域又分为两大类：部分收集（<code>Partial GC</code>），整堆收集（<code>Full  GC</code>）</p>
<ul>
<li>部分收集：不是完整收集整个 <code>Java</code> 堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（<code>Minor GC/Young GC</code>）：只是新生代的垃圾收集</li>
<li>老年代收集（<code>Major GC/Old GC</code>）：只是老年代的垃圾收集<ul>
<li>目前，只有 <code>CMS GC</code> 会有单独收集老年代的行为</li>
<li>很多时候 <code>Major GC</code> 会和 <code>Full GC</code>  混合使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（<code>Mixed GC</code>）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前只有 <code>G1 GC</code> 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（<code>Full GC</code>）：收集整个 <code>Java</code> 堆和方法区的垃圾</li>
</ul>
</blockquote>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a><code>TLAB</code></h5><h6 id="TLAB-（Thread-Local-Allocation-Buffer）"><a href="#TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB （Thread Local Allocation Buffer）"></a><code>TLAB</code> （<code>Thread Local Allocation Buffer</code>）</h6><blockquote>
<ul>
<li>从内存模型而不是垃圾回收的角度，对 <code>Eden</code> 区域继续进行划分，<code>JVM</code> 为每个线程分配了一个私有缓存区域，它包含在 <code>Eden</code> 空间内</li>
<li>多线程同时分配内存时，使用 <code>TLAB</code> 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li>
<li><code>TLAB</code>是虚拟机在堆内存的 <code>Eden</code> 划分出来的一块专用空间，是线程专属的。在虚拟机的<code>TLAB</code> 功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块 <code>TLAB</code> 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。这里值得注意的是，我们说<code>TLAB </code>是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的，而且在使用上也没有什么区别<strong>。</strong></li>
</ul>
</blockquote>
<h6 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 <code>TLAB</code> ?</h6><blockquote>
<ul>
<li><p>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在 <code>JVM</code> 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
<p>尽管不是所有的对象实例都能够在 <code>TLAB</code> 中成功分配内存，但<code> JVM</code> 确实是将 <code>TLAB</code> 作为内存分配的首选。</p>
<p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 <code>TLAB</code> 空间。</p>
<p>默认情况下，<code>TLAB</code> 空间的内存非常小，仅占有整个 <code>Eden</code> 空间的 <code>1%</code>，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 <code>TLAB</code> 空间所占用 <code>Eden</code> 空间的百分比大小。</p>
<p>一旦对象在 <code>TLAB</code> 空间分配内存失败时，<code>JVM</code> 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 <code>Eden</code> 空间中分配内存。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82ZnVUM2VtV0k1SjNRWHFEaWM1SVJoQzIxRmdKUTVJclNHMlhpYW1JSkFRYVpYeURQZVN0RHZQT0l0UTJpYnN3V2hTZmE3Nk1OMExhNjEzazl1dHdxemNHQS82NDA.png"></p>
<ul>
<li><p>也就是说，虽然每个线程在初始化时都会去堆内存中申请一块<code> TLAB</code> ，并不是说这个 <code>TLAB</code>区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。</p>
</li>
<li><p>并且，在 <code>TLAB</code> 分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过 <code>TLAB</code> 分配内存，存放在 <code>Eden</code> 区，但是还是会被垃圾回收或者被移到 <code>Survivor Space、Old Gen</code>等。</p>
</li>
<li><p>还有一点需要注意的是，我们说 <code>TLAB</code> 是在 <code>Eden</code> 区分配的，因为 <code>Eden</code> 区域本身就不太大，而且 <code>TLAB</code> 空间的内存也非常小，默认情况下仅占有整个 <code>Eden</code> 空间的 <code>1%</code> 。所以，必然存在一些大对象是无法在 <code>TLAB</code> 直接分配。</p>
</li>
<li><p>遇到 <code>TLAB</code> 中无法分配的大对象，对象还是可能在 <code>Eden</code> 区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。</p>
</li>
</ul>
</blockquote>
<h6 id="TLAB-带来的问题"><a href="#TLAB-带来的问题" class="headerlink" title="TLAB 带来的问题"></a><code>TLAB</code> 带来的问题</h6><blockquote>
<p>​	虽然在一定程度上，<code> TLAB</code>大大的提升了对象的分配速度，但是 <code>TLAB</code> 并不是就没有任何问题的。</p>
<p>前面我们说过，因为 <code>TLAB</code> 内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：</p>
<p>​	比如一个线程的TLAB空间有 <code>100KB</code> ，其中已经使用了 <code>80KB</code> ，当需要再分配一个 <code>30KB</code> 的对象时，就无法直接在 <code>TLAB</code> 中分配，遇到这种情况时，有两种处理方案：</p>
<ul>
<li><p>1、如果一个对象需要的空间大小超过<code> TLAB</code> 中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。</p>
</li>
<li><p>2、如果一个对象需要的空间大小超过 <code>TLAB</code> 中剩余的空间大小，则废弃当前 <code>TLAB</code> ，重新申请<code>TLAB</code> 空间再次进行内存分配。</p>
</li>
</ul>
<p>以上两个方案各有利弊，如果采用方案 <code>1</code>，那么就可能存在着一种极端情况，就是 <code>TLAB</code> 只剩下<code>1KB</code>，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。</p>
<p>如果采用方案 <code>2</code> ，也有可能存在频繁废弃 <code>TLAB</code> ，频繁申请 <code>TLAB</code> 的情况，而我们知道，虽然在<code>TLAB</code> 上分配内存是线程独享的，但是 <code>TLAB</code> 内存自己从堆中划分出来的过程确实可能存在冲突的，所以，<code>TLAB</code> 的分配过程其实也是需要并发控制的。而频繁的 <code>TLAB</code> 分配就失去了使用 <code>TLAB </code>的意义。</p>
<p>为了解决这两个方案存在的问题，虚拟机定义了一个**<code>refill_waste</code>**的值，这个值可以翻译为“最大浪费空间”。</p>
<blockquote>
<p>当请求分配的内存大于 <code>refill_waste</code> 的时候，会选择在堆内存中分配。若小于 <code>refill_waste</code> 值，则会废弃当前 <code>TLAB</code> ，重新创建 <code>TLAB</code> 进行对象内存分配。</p>
<p>前面的例子中，<code>TLAB</code> 总空间<code> 100KB</code>，使用了 <code>80KB</code> ，剩余 <code>20KB</code>，如果设置的<code>refill_waste</code> 的值为 <code>25KB</code> ，那么如果新对象的内存大于 <code>25KB</code> ，则直接堆内存分配，如果小于 <code>25KB</code>，则会废弃掉之前的那个 <code>TLAB</code> ，重新分配一个 <code>TLAB</code> 空间，给新对象分配内存。</p>
</blockquote>
</blockquote>
<h6 id="堆是分配对象存储的唯一选择吗"><a href="#堆是分配对象存储的唯一选择吗" class="headerlink" title="堆是分配对象存储的唯一选择吗"></a>堆是分配对象存储的唯一选择吗</h6><blockquote>
<blockquote>
<p>​	随着 <code>JIT</code> 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。  ——《深入理解 <code>Java</code> 虚拟机》</p>
</blockquote>
</blockquote>
<h6 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h6><blockquote>
<p>​	<strong>逃逸分析(<code>Escape Analysis</code>)是目前 <code>Java</code> 虚拟机中比较前沿的优化技术</strong>。这是一种可以有效减少 <code>Java</code> 程序中同步负载和内存堆分配压力的<strong>跨函数全局数据流分析算法</strong>。通过逃逸分析，<code>Java Hotspot</code> 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将 <code>sb</code> 返回，这样这个 <code>StringBuffer</code> 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 <code>StringBuffer</code>，那么 <code>StringBuffer</code> 将不会逃逸出方法。</p>
<h6 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h6><blockquote>
<p>1、全局逃逸（<code>GlobalEscape</code>）<br>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p>
<ul>
<li><p>对象是一个静态变量</p>
</li>
<li><p>对象是一个已经发生逃逸的对象</p>
</li>
<li><p>对象作为当前方法的返回值</p>
</li>
</ul>
<p>2、参数逃逸（<code>ArgEscape</code>）<br>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p>
<p>3、没有逃逸<br>即方法中的对象没有发生逃逸。</p>
</blockquote>
<p>逃逸分析优化<br>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p>
<ol>
<li>锁消除<br>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</li>
<li>标量替换<br>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</li>
<li>栈上分配<br>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 <code>GC</code> 压力，提高了应用程序性能。</li>
</ol>
<h6 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h6><ul>
<li>在 <code>JDK 6u23</code> 版本之后，<code>HotSpot</code> 中默认就已经开启了逃逸分析</li>
<li>如果使用较早版本，可以通过<code>-XX&quot;+DoEscapeAnalysis</code>显式开启</li>
</ul>
<p>开发中使用局部变量，就不要在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做优化：</p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 <code>CPU</code> 寄存器</li>
</ul>
<p><code>JIT</code> 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p>
<p>代码优化之同步省略（消除）</p>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li>
<li>在动态编译同步块的时候，<code>JIT</code> 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 <code>JIT</code> 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (keeper) &#123;</span><br><span class="line">        System.out.println(keeper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如上代码，代码中对 <code>keeper</code> 这个对象进行加锁，但是 <code>keeper</code> 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 <code>JIT</code> 编译阶段就会被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化之标量替换</p>
<p>​	<strong>标量</strong>（<code>Scalar</code>）是指一个无法再分解成更小的数据的数据。<code>Java</code> 中的原始数据类型就是标量。</p>
<p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（<code>Aggregate</code>），<code>Java</code> 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p>
<p>​	在 <code>JIT</code> 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<code>JVM</code> 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p>
<p>​	通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>, <span class="number">2</span>）;</span><br><span class="line">        System.out.println(<span class="string">&quot;point.x=&quot;</span> + point.x + <span class="string">&quot;; point.y=&quot;</span> + point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以上代码中，<code>point</code> 对象并没有逃逸出 <code>alloc()</code> 方法，并且 <code>point</code> 对象是可以拆解成标量的。那么，<code>JIT</code> 就不会直接创建 <code>Point </code>对象，而是直接使用两个标量 <code>int x ，int y</code> 来替代 <code>Point</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化之栈上分配</p>
<p>​	我们通过 <code>JVM</code> 内存分配可以知道 <code>JAVA</code> 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 <code>GC</code> 进行回收内存，如果对象数量较多的时候，会给<code> GC</code> 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，<code>JVM</code> 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>​	方法区（<code>Method Area</code>）与 <code>Java</code> 堆一样，是所有线程共享的内存区域。</p>
<p>​	虽然 <code>Java</code> 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <code>Non-Heap</code>（非堆），目的应该是与 <code>Java</code> 堆区分开。</p>
<p>​	运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<code>Class</code> 文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（<code>Constant Pool Table</code>），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>​	方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</p>
<p>​	<code>JVM</code> 关闭后方法区即被释放</p>
<p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？</p>
<ul>
<li><strong>方法区（<code>method area</code>）只是 JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、<strong>静态变量</strong>、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（<code>PermGen</code>）是 <code>Hotspot</code>虚拟机特有的概念， <code>Java8</code> 的时候又被元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li>
<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 <code>JVM</code> 限制了，也比较难发生 <code>OOM</code>（都会有溢出异常）</li>
<li><code>Java7</code> 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，<code>Java8</code> 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li>
<li>存储内容不同，<strong>元空间存储类的元信息，静态变量和常量池等并入堆中</strong>。相当于永久代的数据被分到了堆和元空间中</li>
<li>如果方法区域中的内存不能用于满足分配请求，则 <code>Java</code> 虚拟机抛出 <code>OutOfMemoryError</code></li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 <code>Java</code> 堆分开的（<code>Non-Heap</code>）</li>
</ul>
<p>所以对于方法区，<code>Java8</code> 之后的变化：</p>
<ul>
<li>移除了永久代（<code>PermGen</code>），替换为元空间（<code>Metaspace</code>）；</li>
<li>永久代中的 <code>class metadata</code> 转移到了 <code>native memory</code>（本地内存，而不是虚拟机）；</li>
<li>永久代中的 <code>interned Strings</code> 和 <code>class static variables</code> 转移到了 <code>Java heap</code>；</li>
<li>永久代参数 （<code>PermSize MaxPermSize</code>） -&gt; 元空间参数（<code>MetaspaceSize MaxMetaspaceSize</code>）</li>
</ul>
</blockquote>
<h4 id="设置方法区内存的大小"><a href="#设置方法区内存的大小" class="headerlink" title="设置方法区内存的大小"></a>设置方法区内存的大小</h4><blockquote>
<p>JDK8 及以后：</p>
<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。<code>Windows</code> 下，<code>-XX:MetaspaceSize</code> 是 <code>21M</code>,-XX:MaxMetaspacaSize<code>的值是</code>-1&#96;，即没有限制</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 <code>64</code> 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为<code>20.75MB</code>，这就是初始的高水位线，一旦触及这个水位线，<code>Full GC</code> 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 <code>GC</code> 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 <code>Full GC</code> 多次调用。为了避免频繁 <code>GC</code>，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li>
</ul>
</blockquote>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><blockquote>
<p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
</blockquote>
<h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><blockquote>
<p>​	对每个加载的类型（类 <code>class</code>、接口 <code>interface</code>、枚举 <code>enum</code>、注解 <code>annotation</code>），<code>JVM </code>必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 <code>interface</code>或是 <code>java.lang.Object</code>，都没有父类）</li>
<li>这个类型的修饰符（<code>public，abstract，final</code> 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</blockquote>
<h5 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h5><blockquote>
<ul>
<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（<code>public、private、protected、static、final、volatile、transient</code> 的某个子集）</li>
</ul>
</blockquote>
<h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><blockquote>
<p>JVM 必须保存所有方法的</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（<code>public，private，protected，static，final，synchronized，native，abstract</code> 的一个子集）</li>
<li>方法的字符码（<code>bytecodes</code>）、操作数栈、局部变量表及大小（<code>abstract</code> 和 <code>native</code> 方法除外）</li>
<li>异常表（<code>abstract</code> 和 <code>native</code> 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/db050d0052a44605a13043a0bec204f0.png"></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote>
<p>​	运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（<code>Class</code> 文件）中的常量池（常量池表）</p>
</blockquote>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><blockquote>
<p>​	一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（<code>Constant Pool Table</code>），包含各种字面量和对类型、域和方法的符号引用。</p>
</blockquote>
<h5 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h5><blockquote>
<p>​	一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p>
<p>​	如下，我们通过 <code>jclasslib</code> 查看一个只有 <code>Main</code> 方法的简单类，字节码中的 <code>#2</code> 指向的就是 <code>Constant Pool</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/007S8ZIlly1gg9i91ze2gj320i0riahe.jpg"></p>
<p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
</blockquote>
<h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><blockquote>
<ul>
<li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li>
<li>常量池表（<code>Constant Pool Table</code>）是 <code>Class</code> 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li>
<li><code>JVM</code> 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul>
<li>运行时常量池，相对于 <code>Class</code> 文件常量池的另一个重要特征是：<strong>动态性</strong>，<code>Java</code> 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，<code>String</code> 类的 <code>intern()</code> 方法就是这样的</li>
</ul>
</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 <code>JVM</code> 会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
</blockquote>
<h5 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h5><blockquote>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ul>
<li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>（2）节省运行时间：比较字符串时，<code>==</code> 比 <code>equals()</code> 快。对于两个引用变量，只用 <code>==</code> 判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<blockquote>
<p>双等号&#x3D;&#x3D;的含义</p>
<ul>
<li>基本数据类型之间应用双等号，比较的是他们的数值。</li>
<li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li>
</ul>
</blockquote>
</blockquote>
<h5 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h5><blockquote>
<p><code>java</code>中基本类型的包装类的大部分都实现了常量池技术，即<code>Byte,Short,Integer,Long,Character,Boolean</code>。</p>
<p>这 <code>5</code> 种包装类默认创建了数值 <code>[-128，127]</code> 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 <code>Float,Double</code> 并没有实现常量池技术。</p>
<p>Integer与常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));  </span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>(1) <code>Integer i1=40</code> ；<code>Java</code>在编译的时候会直接将代码封装成<code>Integer i1=Integer.valueOf(40)</code>;，从而使用常量池中的对象。</li>
<li>(2) <code>Integer i1 = new Integer(40)</code>;这种情况下会创建新的对象。</li>
<li>(3)语句 <code>i4 == i5 + i6</code> ，因为 <code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>i5</code> 和 <code>i6</code> 进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。然后 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4 </code>自动拆箱转为 <code>int</code> 值 <code>40</code> ，最终这条语句转为 <code>40 == 40</code> 进行数值比较。</li>
</ul>
<p>String与常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>(1) <code>new String(&quot;abcd&quot;)</code> 是在常量池中拿对象，<code>&quot;abcd&quot;</code>  是直接在堆内存空间创建一个新的对象。只要使用 <code>new</code> 方法，便需要创建新的对象。</li>
<li>(2)连接表达式 <code>+</code><br>只有使用引号包含文本的方式创建的 <code>String</code> 对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含 <code>new</code> 方式新建对象（包括 <code>null</code> ）的 <code>“+”</code> 连接表达式，它所产生的新对象都不会被加入字符串池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B;    <span class="comment">// 常量B</span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">   A = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">   B = <span class="string">&quot;cd&quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"><span class="comment">// 将两个常量用+连接对s进行初始化  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> A + B;  </span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;  </span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>s</code> 不等于 <code>t</code> ，它们不是同一个对象。</p>
<p><code>A</code> 和 <code>B</code> 虽然被定义为常量，但是它们都没有马上被赋值。在运算出 <code>s</code> 的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此 <code>A</code> 和 <code>B</code> 在被赋值之前，性质类似于一个变量。那么 <code>s</code> 就不能在编译期被确定，而只能在运行时被创建了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>考虑类加载阶段和实际执行时。</p>
<ul>
<li>（1）类加载对一个类只会进行一次。<code>”xyz”</code> 在类加载时就已经创建并驻留了（如果该类被加载之前已经有 <code>”xyz”</code> 字符串被驻留过则不需要重复创建用于驻留的 <code>”xyz”</code> 实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li>
<li>（2）在这段代码后续被运行的时候，<code>”xyz”</code> 字面量对应的 <code>String</code> 实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到 <code>heap</code> 中，并且把 <code>heap</code> 中的这个对象的引用交给 <code>s1</code> 持有。</li>
</ul>
<p>这条语句创建了 <code>2</code> 个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s1 == s2? &quot;</span> + (s1 == s2));</span><br><span class="line">    System.out.println(<span class="string">&quot;s3 == s2? &quot;</span> + (s3 == s2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 ==s2 ? <span class="literal">false</span></span><br><span class="line">s3 ==s2 ? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>String</code> 的 <code>intern()</code> 方法会查找在常量池中是否存在一份 <code>equal</code> 相等的字符串,如果有则返回该字符串的引用，如果没有则添加自己的字符串进入常量池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>, lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">            System.out.println((hello == <span class="string">&quot;Hello&quot;</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((Other.hello == hello) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((other.Other.hello == hello) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((hello == (<span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>)) + <span class="string">&quot; &quot;</span>); <span class="comment">//true</span></span><br><span class="line">            System.out.println((hello == (<span class="string">&quot;Hel&quot;</span> + lo)) + <span class="string">&quot; &quot;</span>); <span class="comment">//false</span></span><br><span class="line">            System.out.println(hello == (<span class="string">&quot;Hel&quot;</span> + lo).intern()); <span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><p>在同包同类下,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在同包不同类下,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在不同包不同类下,依然引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在编译成.class时能够识别为同一字符串的,自动优化成常量,引用自同一 <code>String</code> 对象.</p>
</li>
<li><p>在运行时创建的字符串具有独立的内存地址,所以不引用自同一 <code>String</code> 对象.</p>
</li>
</ul>
</blockquote>
<h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p> ​	引用计数算法在每个对象都维护着一个内存字段来统计它被多少”部分”使用—引用计数器,每当有一个新的引用指向该对象时,引用计数器就 <code>+1</code>  ,每当指向该引用对象失效时该计数器就 <code>-1</code> ,当引用数量为 <code>0</code> 的时候,则说明对象没有被任何引用指向,可以认定是”垃圾”对象。</p>
</blockquote>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote>
<ol>
<li>可以立即回收垃圾。因为每个对象在被引用次数为 <code>0</code> 的时候，是立即就可以知道的。</li>
<li>没有暂停时间。这个很容易理解，对象的回收根本不需要另外的 <code>GC</code> 线程专门去做，业务线程自己就搞定了。所以不需要 <code>stop the world</code>，当然，在多线程的情况下，必要的同步和互斥操作还是需要的。</li>
</ol>
</blockquote>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ol>
<li><p>在每次赋值操作的时候都要做相当大的计算，尤其这里面还有<strong>递归调用</strong>。这是比较麻烦的。</p>
</li>
<li><p>一个致命缺陷是循环引用，就是， <code>objA</code> 引用了 <code>objB</code> ，<code>objB</code> 也引用了 <code>objA </code>，但是除此之外，再没有其他的地方引用这两个对象了，这两个对象的引用计数就都是 <code>1</code>。这种情况下，这两个对象是不能被回收的。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">GcObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GcObject</span>(); <span class="comment">//Step1</span></span><br><span class="line">  GcObject obj <span class="number">2</span> = <span class="keyword">new</span> <span class="title class_">GcObject</span>();<span class="comment">//Step2</span></span><br><span class="line">  obj1.instance = obj2; <span class="comment">//Step3</span></span><br><span class="line">  obj2.instance = obj1;<span class="comment">// //Step4</span></span><br><span class="line">  obj1 = <span class="literal">null</span>; <span class="comment">//Step5</span></span><br><span class="line">  obj2 = <span class="literal">null</span>; <span class="comment">//Step6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步: <code>GcObject</code>  实例 <code>1</code> 被 <code>obj1</code> 引用,所以它的引用数 <code>+1</code> ,为 <code>1</code></p>
</li>
<li><p>第二步: <code>GcObject</code> 实例 <code>2</code> 被 <code>obj2</code> 引用,所以它的引用数<code> +1</code> ,为 <code>1</code></p>
</li>
<li><p>第三步: <code>obj1</code> 的 <code>instance</code> 属性指向 <code>obj2 </code>,而 <code>obj2</code> 指向 <code>GcObject</code> 实例 <code>2</code> ,故 <code>GcObject</code>实例<code> 2</code> 引用 <code>+1 </code>,为 <code>2</code></p>
</li>
<li><p>第四步: <code>obj2</code> 的 <code>instance</code> 属性指向 <code>obj1 </code>,而 <code>obj1</code> 指向 <code>GcOjbect</code> 实例 <code>1</code> ,故 <code>GcObject</code>实例 <code>1</code> 引用 <code>+1 </code>,为 <code>2</code></p>
<p>到此前4步, <code>GcOjbect</code> 实例<code> 1</code> 和 <code>GcOjbect </code>实例 <code>2</code> 的引用数量均为 <code>2</code> ,此时结果图如下.</p>
<p><code>PS</code>：注意想一下,为什么是 <code>obj</code> 的 <code>instance</code> 属性,而不是写成 <code>obj </code>本身?</p>
</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/647994-20170218225201894-1235824981.png"></p>
<ol start="5">
<li>第五步:<code>obj1</code>不再指向 <code>GcOjbect</code> 实例 <code>1</code> ,其引用计数减 <code>1</code> ,结果为 <code>1</code> .</li>
<li>第六步:<code>obj2</code>不再指向 <code>GcOjbect</code> 实例 <code>2</code> ,其引用计数减 <code>1</code> ,结果为 <code>1</code> .</li>
</ol>
<p>​    到此,发现<code>GcObject</code> 实例 <code>1</code> 和实例 <code>2</code> 的计数引用都不为 <code>0</code> ,那么如果采用的引用计数算法的话,那么这两个实例所占的内存将得不到释放,这便产生了内存泄露。</p>
</blockquote>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过 <code>GC Roots</code> 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/0635cbe8.png"></p>
</blockquote>
<h5 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a><code>GC Roots</code> 对象</h5><blockquote>
<ul>
<li><p>虚拟机栈中引用的对象 </p>
</li>
<li><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><p>本地方法栈内 <code>JNI</code>（通常说的本地方法）引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象 </p>
</li>
<li><ul>
<li>比如：<code>Java</code> 类的引用类型静态变量</li>
</ul>
</li>
<li><p>方法区中常量引用的对象 </p>
</li>
<li><ul>
<li>比如：字符串常量池（<code>String Table</code>）里的引用</li>
</ul>
</li>
<li><p>所有被同步锁 <code>synchronized</code> 持有的对象</p>
</li>
<li><p>Java虚拟机内部的引用。 </p>
</li>
<li><ul>
<li>基本数据类型对应的 <code>Class</code> 对象，一些常驻的异常对象（如：<code>NullPointerException</code>、<code>OutOfMemoryError</code>），系统类加载器。</li>
</ul>
</li>
<li><p>反映 <code>java</code> 虚拟机内部情况的 <code>JMXBean</code>、<code>JVMTI</code> 中注册的回调、本地代码缓存等。</p>
</li>
</ul>
</blockquote>
<h5 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h5><blockquote>
<ul>
<li>Java语言提供了对象终止（<code>finalization</code>）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 <code>finalize()</code> 方法。</li>
<li><code>finalize()</code>  方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li>
</ul>
</blockquote>
<h6 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a><code>finalize()</code></h6><blockquote>
<p>永远不要主动调用某个对象的 <code>finalize()</code> 方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ol>
<li><code>在finalize()</code> 时可能会导致对象复活。</li>
<li><code>finalize()</code> 方法的执行时间是没有保障的，它完全由 <code>GC</code> 线程决定，极端情况下，若不发生 <code>GC</code> ，则 <code>finalize()</code> 方法将没有执行机会。</li>
<li>一个糟糕的 <code>finalize()</code> 会严重影响 <code>GC</code> 的性能。</li>
</ol>
</blockquote>
<p>虚拟机中的对象一般处于三种可能的状态</p>
<blockquote>
<p>​	由于 <code>finalize()</code> 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<p>​	如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><p><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</p>
</li>
<li><p><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 <code>finalize()</code> 中复活。</p>
</li>
<li><p><strong>不可触及的</strong>：对象的 <code>finalize()</code> 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 <strong><code>finalize()</code> 只会被调用一次</strong>。</p>
</li>
</ul>
<p>以上3种状态中，是由于 <code>finalize()</code> 方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</blockquote>
<h5 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h5><blockquote>
<p>判定一个对象 <code>objA</code> 是否可回收，至少要经历两次标记过程：</p>
<ol>
<li><p>如果对象 <code>objA</code> 到 <code>GC Roots</code> 没有引用链，则进行第一次标记。</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行 <code>finalize()</code> 方法</p>
</li>
<li><p>如果对象 <code>objA</code> 没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，<code>objA</code> 被判定为不可触及的。</p>
</li>
<li><p>如果对象 <code>objA </code>重写了 <code>finalize()</code> 方法，且还未执行过，那么 <code>objA</code> 会被插入到 <code>F-Queue</code> 队列中，由一个虚拟机自动创建的、低优先级的 <code>Finalizer</code> 线程触发其 <code>finalize()</code>方法执行。</p>
</li>
<li><p><code>finalize()</code> 方法是对象逃脱死亡的最后机会，稍后 <code>GC</code> 会对 <code>F-Queue</code> 队列中的对象进行第二次标记。如果 <code>objA</code> 在 <code>finalize()</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，<code>objA</code> 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，<code>finalize</code> 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 <code>finalize </code>方法只会被调用一次。</p>
</li>
</ol>
</blockquote>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote>
<p>​	无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p><code>Java</code> 具有四种强度不同的引用类型：</p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>​	被强引用关联的对象不会被回收。</p>
<p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>​	被软引用关联的对象只有在内存不够的情况下才会被回收。软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真实来源中查询数据，可以显著地提升网站性能。当内存不足时，能让 <code>JVM</code> 进行内存回收，从而删除缓存，这时候只能从真实来源查询数据。</p>
<p>使用 <code>SoftReference</code> 类来创建软引用。</p>
<p>​	软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>​	被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。弱引用可以在回调函数防止内存泄露。因为回调函数往往是匿名内部类，<strong>一个非静态的内部类会隐式地持有外部类的一个强引用</strong>，当 <code>JVM</code> 在回收外部类的时候，此时回调函数在某个线程里面被回调的时候，<code>JVM</code> 就无法回收外部类，造成内存泄漏。在安卓 <code>activity</code> 内声明一个非静态的内部类时，如果考虑防止内存泄露的话，应当显示地声明此内部类持有外部类的一个弱引用。</p>
<p>​	弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。  </p>
<p>使用 <code>WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><ul>
<li>虚引用也称为 幽灵引用 或者 幻影引用；</li>
<li>虚引用并不会决定对象的生命周期，<strong>在任何时间都会被回收掉</strong>；</li>
<li>在使用虚引用的时候，<strong>必须和引用队列一起使用</strong>，虚引用的 <strong>构造器必须传入一个该类型的引用队列</strong>；</li>
</ul>
<p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知</strong>。</p>
<p>​	虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列 （<code>ReferenceQueue</code>）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。  </p>
<p>使用 <code>PhantomReference</code> 来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（<code>Mark-Sweep</code>）</h4><blockquote>
<p>​	当堆中的有效内存空间（<code>available memory</code>）被耗尽的时候，就会停止整个程序（也被称为<code>stop the world</code>），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li><p>标记：<code>Collector</code> 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 </p>
</li>
<li><p>清除：<code>Collector</code> <strong>对堆内存从头到尾进行线性的遍历</strong>，如果发现某个对象在其<code>Header</code>中没有标记为可达对象，则将其回收 。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/fc6c84a5-8946-4a42-bc40-287d1492aaf4.png"></p>
</blockquote>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>标记清除算法的效率不算高</p>
</li>
<li><p>在进行 <code>GC</code> 的时候，需要停止整个应用程序(<code>STW</code>)，用户体验较差</p>
</li>
<li><p>这种方式清理出来的空闲内存是不连续的，产生内碎片，<strong>因此需要维护一个空闲列表</strong></p>
</li>
</ul>
</blockquote>
<h5 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h5><blockquote>
<p>​	这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
</blockquote>
<h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（<code>Copying</code>）算法</h4><blockquote>
<p>​	将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg"></p>
<p>​	现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 空间和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象一次性复制到另一块 <code>Survivor</code> 空间上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p>
<p>​	<code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 的大小比例默认为 <code>8:1:1</code>，保证了内存的利用率达到 <code>90%</code>。如果每次回收有多于 <code>10%</code> 的对象存活，那么一块 <code>Survivor</code> 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
</blockquote>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>此算法的缺点也是很明显的，就是需要<strong>两倍的内存空间</strong>。</p>
</li>
<li><p>对于 <code>G1</code> 这种分拆成为大量 <code>region</code> 的 <code>GC</code> ，复制而不是移动，意味着 <code>GC</code>需要维护<code>region</code> 之间对象引用关系，不管是内存占用或者时间开销也不小</p>
</li>
</ul>
</blockquote>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><blockquote>
<p>​	在新生代，对常规应用的垃圾回收，一次通常可以回收 <code>70% - 99%</code> 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
</blockquote>
<h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、<code>Mark-Compact</code>）算法</h4><blockquote>
<p>​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>​	标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 <code>JVM</code> 的设计者需要在此基础之上进行改进。标记-压缩（<code>Mark-Compact</code>）算法由此诞生。</p>
<ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 </li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 </li>
<li>清理边界外所有的空间。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1d2df46e-b7a2-4cb2-81cb-d41110838ae8.png"></p>
</blockquote>
<blockquote>
<p>​	二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
</blockquote>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote>
<ul>
<li><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，<code>JVM</code> 只需要持有一个内存的起始地址即可。</p>
</li>
<li><p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
</blockquote>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<ul>
<li><p>从效率上来说，标记-整理算法要低于复制算法。</p>
</li>
<li><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</p>
</li>
<li><p>移动过程中，需要全程暂停用户应用程序。即：<code>STW</code></p>
</li>
</ul>
</blockquote>
<h4 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><code>Mark-Sweep</code></th>
<th align="center"><code>Mark-Compact</code></th>
<th align="center"><code>Copying</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>速率</strong></td>
<td align="center">中等</td>
<td align="center">最慢</td>
<td align="center">最快</td>
</tr>
<tr>
<td align="center"><strong>空间开销</strong></td>
<td align="center">少（但会堆积碎片）</td>
<td align="center">少（不堆积碎片）</td>
<td align="center">通常需要活对象的 <code>2</code> 倍空间（不堆积碎片）</td>
</tr>
<tr>
<td align="center"><strong>移动对象</strong></td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>效率：复制算法&gt;标记&#x2F;整理算法&gt;标记&#x2F;清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</strong></p>
<p><strong>内存整齐度：复制算法&#x3D;标记&#x2F;整理算法&gt;标记&#x2F;清除算法。</strong></p>
<p>*<em>内存利用率：*<em>标记&#x2F;整理算法&#x3D;*</em>*<em>标记&#x2F;清除算法*</em>&gt;复制算法。</em>*</p>
</blockquote>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><blockquote>
<p>​	现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>​	一般将堆分为新生代和老年代,还有元空间（持久代：代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，<code>Java</code> 虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。<strong>元空间存储类的元信息，静态变量和常量池等并入堆中</strong>。）</p>
<ul>
<li>新生代使用: <strong>复制算法</strong></li>
<li>老年代使用: <strong>标记 - 清除</strong> 或者 <strong>标记 - 整理</strong> 算法</li>
</ul>
</blockquote>
<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><blockquote>
<p>​	由于 <code>GC</code> 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 <code>OOM</code> 的情况。</p>
<p>​	大多数情况下，<code>GC</code> 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 <code>Full GC</code>操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>​	<code>javadoc</code> 中对 <code>OutOfMemoryError</code> 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
<p>首先说没有空闲内存的情况：说明 <code>Java </code>虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><code>Java</code>虚拟机的堆内存设置不够。</li>
</ol>
<p>​       比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 <code>JVM</code> 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code>、<code>-Xmx</code>来调整。 </p>
<ol start="2">
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ol>
<p>​       对于老版本的 <code>Oracle JDK</code>，因为永久代的大小是有限的，并且 <code>JVM</code> 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code> 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 <code>intern</code> 字符串缓存占用太多空间，也会导致 <code>OOM</code> 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。<br>   随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 <code>OOM</code> 有所改观，出现 <code>OOM</code>，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 <code>OOM</code>。 </p>
<p>这里面隐含着一层意思是，在抛出 <code>OutOfMemoryError</code> 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li><p>例如：在引用机制分析中，涉及到 <code>JVM</code> 会去尝试回收软引用指向的对象等。</p>
</li>
<li><p>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</p>
</li>
</ul>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，<code>JVM</code> 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 <code>OutOfMemoryError</code>。</li>
</ul>
</blockquote>
<h4 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（<code>Memory Leak</code>）</h4><blockquote>
<p>​	也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 <code>GC</code>又不能回收他们的情况，才叫内存泄漏。</p>
<p>​	但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 <code>00M</code> ，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>​	尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 <code>OutOfMemory</code> 异常，导致程序崩溃。</p>
<p>​	注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><ol>
<li>单例模式</li>
</ol>
<p>  单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 </p>
<ol start="2">
<li>一些提供 <code>close</code> 的资源未关闭导致内存泄漏<br> 数据库连接（<code>dataSourse.getConnection()</code> ），网络连接（<code>socket</code>）和 <code>IO</code> 连接必须手动close，否则是不能被回收的。</li>
</ol>
</blockquote>
<h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a><code>Stop The World</code></h3><blockquote>
<ol>
<li><code>Stop-the-World</code>，简称 <code>STW</code>，指的是 <code>GC</code> 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 <code>STW</code>。</li>
</ol>
<p>2.可达性分析算法中枚举根节点（<code>GC Roots</code>）会导致所有 <code>Java</code> 执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
</ul>
<ul>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p>
</li>
</ul>
<ol start="3">
<li><p>被 <code>STW</code> 中断的应用程序线程会在完成 <code>GC</code> 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 <code>STW</code> 的发生。</p>
</li>
<li><p><code>STW</code> 事件和采用哪款 <code>GC</code> 无关，所有的 <code>GC</code> 都有这个事件。哪怕是 <code>G1</code> 也不能完全避免<code>Stop-the-World</code> 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p><code>STW</code> 是 <code>JVM</code> 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li><p>开发中不要用 <code>System.gc()</code> 会导致 <code>Stop-the-World</code> 的发生。</p>
</li>
</ol>
</blockquote>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（<code>Concurrent</code>）</h4><blockquote>
<ul>
<li><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
</li>
<li><p>并发不是真正意义上的“同时进行”，只是<code>CPU</code>把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于<code>CPU</code>处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
</li>
<li><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/b8043d6d-32e2-4a7b-929b-1ae733372a20.png"></p>
</li>
</ul>
</blockquote>
<h4 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（<code>Parallel</code>）</h4><blockquote>
<ul>
<li>当系统有一个以上<code>CPU</code>时，当一个<code>CPU</code>执行一个进程时，另一个<code>CPU</code>可以执行另一个进程，两个进程互不抢占<code>CPU</code>资源，可以同时进行，我们称之为并行（<code>Parallel</code>）。</li>
<li>其实决定并行的因素不是<code>CPU</code>的数量，而是<code>CPU</code>的核心数量，比如一个<code>CPU</code>多个核也可以并行。</li>
<li>适合科学计算，后台处理等弱交互场景</li>
<li><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/6916a4ba-74ee-4078-bef9-3681a564c8b5.png"></li>
</ul>
</blockquote>
<h4 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h4><blockquote>
<ul>
<li><p>并发，指的是多个事情，在同一时间段内同时发生了。 </p>
</li>
<li><p>并行，指的是多个事情，在同一时间点上同时发生了。 </p>
</li>
<li><p>并发的多个任务之间是互相抢占资源的。 </p>
</li>
<li><p>并行的多个任务之间是不互相抢占资源的。 </p>
</li>
<li><p>只有在多 <code>CPU</code>或者一个<code>CPU</code>多核的情况中，才会发生并行。 </p>
</li>
<li><p>否则，看似同时发生的事情，其实都是并发执行的。</p>
</li>
</ul>
</blockquote>
<h4 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h4><blockquote>
<h6 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（<code>Parallel</code>）</h6><p>​	<strong>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</strong>。如<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Parallel Old</code>；</p>
<h6 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（<code>Serial</code>）</h6><p>​	相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动<code>JVM</code>垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/786e856c-3dfb-4346-9f6f-2740eab133af.png"></p>
<h6 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（<code>Concurrent</code>）</h6><p>​	指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个 <code>CPU</code> 上；如：<code>CMS</code>、<code>G1</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/eed9d7bb-322e-4259-981f-ace5cfc6e1c9.png"></p>
</blockquote>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg"></p>
<p>以上是 <code>HotSpot</code> 虚拟机中的 <code>7</code> 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
</ul>
</blockquote>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><blockquote>
<ul>
<li>多线程堆内存较大，多核 <code>CPU</code></li>
<li>让单位时间内，<code>STW</code> 的时间最短    </li>
<li>例如一个小时发生了 <code>2</code> 次 <code>STW</code>，每次 <code>0.2</code> 秒，共 <code>0.4</code> 秒，强调总的时间最短</li>
</ul>
</blockquote>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 <code>CPU</code> </li>
<li>尽可能让单次 <code>STW</code> 的时间最短</li>
<li>例如一个小时发生了 <code>5</code> 次 <code>STW</code>，每次 <code>0.1</code> 秒，共 <code>0.5</code> 秒，强调单次时间最短</li>
</ul>
</blockquote>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a><code>Serial</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg"></p>
<ul>
<li><code>Serial</code> 翻译为串行，也就是说它以串行的方式执行。</li>
<li>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</li>
<li>它的优点是简单高效，对于单个 <code>CPU</code> 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li>
<li>它是 <strong><code>Client</code> 模式下的默认新生代收集器</strong>，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</li>
</ul>
</blockquote>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a><code>ParNew</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg"></p>
<ul>
<li>它是 <code>Serial</code> 收集器的多线程版本。</li>
<li>是 <strong><code>Server</code> 模式下的虚拟机首选新生代收集器</strong>，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</li>
<li><strong>默认开启的线程数量与 <code>CPU</code> 数量相同</strong>，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</li>
</ul>
</blockquote>
<p><code>Parallel Scavenge</code> 收集器</p>
<blockquote>
<ul>
<li><p>与 <code>ParNew</code> 一样是多线程收集器。</p>
</li>
<li><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为<strong>“吞吐量优先”收集器</strong>。这里的吞吐量指 <code>CPU</code> 用于运行用户代码的时间占总时间的比值。</p>
</li>
<li><p>吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)</p>
</li>
<li><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 <code>CPU</code> 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
</li>
<li><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
</li>
<li><p>可以通过一个开关参数打卡 <code>GC</code> 自适应的调节策略(<code>GC Ergonomics</code>)，就不需要手工指定新生代的大小(<code>-Xmn</code>)、<code>Eden</code> 和 <code>Survivor</code> 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</li>
</ul>
</blockquote>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><code>Serial Old</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg"></p>
<p>​	是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在 <code>Server</code> 模式下，它有两大用途:</p>
<ul>
<li>在 <code>JDK 1.5</code> 以及之前版本(<code>Parallel Old</code> 诞生以前)中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li>
<li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li>
</ul>
</blockquote>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><code>Parallel Old</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/278fe431-af88-4a95-a895-9c3b80117de3.jpg"></p>
<ul>
<li><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p>
</li>
<li><p>在注重吞吐量以及 <code>CPU</code> 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p>
</li>
</ul>
</blockquote>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a><code>CMS</code> 收集器</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/46c061c6-8a27-4222-9ff7-6cf71b63b40a.png"></p>
<p>​	<code>CMS</code>(<code>Concurrent Mark Sweep</code>)，<code>Mark Sweep</code> 指的是标记 - 清除算法。</p>
<p>​	<code>CMS</code>收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>​	不幸的是，<code>CMS</code> 作为老年代的收集器，却无法与 <code>JDK1.4.0</code> 中已经存在的新生代收集器 <code>Parallel Scavenge</code> 配合工作，所以在 <code>JDK1.5</code>中使用<code>CMS</code>来收集老年代的时候，新生代只能选择<code>ParNew</code>或者<code>Serial</code>收集器中的一个。</p>
<p>分为以下四个流程:</p>
<ul>
<li><p><strong>初始标记</strong>（<code>Initial-Mark</code>）阶段：在这个阶段中，程序中所有的工作线程都将会因为“<code>Stop-the-World</code>”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出<code>GCRoots</code>能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p><strong>并发标记</strong>（<code>Concurrent-Mark</code>）阶段：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p><strong>重新标记</strong>（<code>Remark</code>）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间(<code>STW</code>)通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</strong>。</p>
</li>
<li><p><strong>并发清除</strong>（<code>Concurrent-Sweep</code>）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
</ul>
<p>​    尽管<code>CMS</code>收集器采用的是并发回收（非独占式），但是在其初始化标记和重新标记这两个阶段中仍然需要执行“<code>Stop-the-World</code>”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“<code>stop-the-World</code>”，只是尽可能地缩短暂停时间。 </p>
<p>​	由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。  </p>
<p>​	另外，由于在垃圾收集阶段用户线程没有中断，所以在<code>CMS</code>回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，**<code>CMS</code>收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在<code>CMS</code>工作过程中依然有足够的空间支持应用程序运行。**要是<code>CMS</code>运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用<code>Serial Old</code>收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>​	<code>CMS</code>收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么<code>CMS</code>在为新对象分配内存空间时，将无法使用指针碰撞（<code>Bump the Pointer</code>）技术，而只能够选择空闲列表（<code>Free List</code>）执行内存分配。</p>
<p>​	指针碰撞：<code>Java</code>堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：<code>Serial、ParNew</code>等收集器。指针碰撞技术会跟踪在<code>Eden</code>空间创建的最后一个对象，这个对象会被放在伊甸园空间的顶部。如果之后再需要创建对象，只需要检查伊甸园空间是否有足够的剩余空间。如果有足够的空间，对象就会被创建在伊甸园空间，并且被放置在顶部。这样一来，每次创建新的对象时，只需要检查最后被创建的对象。这将极大地加快内存分配速度。但是，如果我们在多线程的情况下，事情将截然不同。如果想要以线程安全的方式以多线程在伊甸园空间存储对象，不可避免的需要加锁，而这将极大地的影响性能。**<code>TLAB</code>** 是<code>HotSpot</code>虚拟机针对这一问题的解决方案。该方案为每一个线程在伊甸园空间分配一块独享的空间，这样每个线程只访问他们自己的<code>TLAB</code>空间，再与<code>bump-the-pointer</code>技术结合可以在不加锁的情况下分配内存。</p>
<h6 id="并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？"><a href="#并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？" class="headerlink" title="并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？"></a>并发垃圾收集器（<code>CMS</code>）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？</h6><p>答案：分代式<code>GC</code>里，年老代常用<code>mark-sweep</code>；或者是<code>mark-sweep/mark-compact</code>的混合方式，一般情况下用<code>mark-sweep</code>，统计估算碎片量达到一定程度时用<code>mark-compact</code>。<strong>这是因为传统上大家认为年老代的对象可能会长时间存活且存活率高，或者是比较大，这样拷贝起来不划算，还不如采用就地收集的方式。</strong>因为<code>CMS</code>作为第一款实现用户线程和收集线程并发执行的收集器！当时的设计理念是减少停顿时间，最好是能并发执行！但是问题来了，<strong>如要用户线程也在执行，那么就不能轻易的改变堆中对象的内存地址！不然会导致用户线程无法定位引用对象，从而无法正常运行！而标记整理算法和复制算法都会移动存活的对象，</strong>这就与上面的策略不符！因此<code>CMS</code>采用的是标记清理算法！</p>
<h6 id="CMS-出现Full-GC的原因："><a href="#CMS-出现Full-GC的原因：" class="headerlink" title="CMS 出现Full GC的原因："></a><code>CMS</code> 出现<code>Full GC</code>的原因：</h6><p><strong>1、年轻代晋升到老年代没有足够的连续空间，很有可能是内存碎片导致的，因此会触发<code>FULL GC</code></strong></p>
<p>2、在并发过程中<code>JVM</code>觉得在并发过程结束之前堆就会满，需要提前触发<code>Full GC</code></p>
<h6 id="CMS的优点"><a href="#CMS的优点" class="headerlink" title="CMS的优点"></a><code>CMS</code>的优点</h6><ul>
<li><p>并发收集</p>
</li>
<li><p>低延迟</p>
</li>
</ul>
<h6 id="CMS的弊端"><a href="#CMS的弊端" class="headerlink" title="CMS的弊端"></a><code>CMS</code>的弊端</h6><ul>
<li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发<code>Full GC</code>。</p>
</li>
<li><p><code>CMS</code>收集器对<code>CPU</code>资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p><code>CMS</code>收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次<code>Full GC</code>的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，<code>CMS</code>将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行<code>GC</code>时释放这些之前未被回收的内存空间。</p>
</li>
</ul>
</blockquote>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a><code>G1</code> 收集器</h4><blockquote>
<p>​	<code>G1</code>收集器伴随<code>JAVA9</code>于<code>2017-9-21</code>发布,<code>G1</code>收集器兼顾低延迟和高吞吐在服务端运行,<code>HotSpot</code>团队期望取代<code>CMS</code>收集器。也就是在满足停顿时间的情况下获取最大的吞度量。有两种收集模式<code>Young GC</code>和<code>Mixed GC</code>。<code>G1</code>收集器将堆内存划分成大小相等的<code>Region</code>,新生代,老年代也就成了逻辑概念。整体上采用的是标记-整理算法,局部采用了复制算法。</p>
</blockquote>
<h5 id="G1回收器的特点（优势）"><a href="#G1回收器的特点（优势）" class="headerlink" title="G1回收器的特点（优势）"></a><code>G1</code>回收器的特点（优势）</h5><h6 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h6><blockquote>
<ul>
<li><p>并行性：<code>G1</code>在回收期间，可以有多个<code>GC</code>线程同时工作，有效利用多核计算能力。此时用户线程STW</p>
</li>
<li><p>并发性：<code>G1</code>拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>
</li>
</ul>
</blockquote>
<h6 id="分代收集-1"><a href="#分代收集-1" class="headerlink" title="分代收集"></a>分代收集</h6><blockquote>
<ul>
<li><p>从分代上看，<code>G1</code>依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有<code>Eden</code>区和Survivor区。但从堆的结构上看，它不要求整个<code>Eden</code>区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p>将堆空间分为若干个区域（<code>Region</code>），这些区域中包含了逻辑上的年轻代和老年代。</p>
</li>
<li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</p>
</li>
<li><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/4c820316-e12f-42ff-943d-e56286de1d7b.png"></p>
</li>
</ul>
</blockquote>
<h6 id="G1的内存模型空间整合"><a href="#G1的内存模型空间整合" class="headerlink" title="G1的内存模型空间整合"></a><code>G1</code>的内存模型空间整合</h6><blockquote>
<ul>
<li><p><code>CMS</code>：“标记-清除”算法、内存碎片、若干次<code>GC</code>后进行一次碎片整理</p>
</li>
<li><p><code>G1</code>将内存划分为一个个的<code>region</code>。内存的回收是以<code>region</code>作为基本单位的。<code>Region</code>之间是复制算法，但整体上实际可看作是标记-压缩（<code>Mark-Compact</code>）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次<code>GC</code>。尤其是当Java堆非常大的时候，<code>G1</code>的优势更加明显。</p>
</li>
</ul>
</blockquote>
<h6 id="可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时soft real-time）"></a>可预测的停顿时间模型（即：软实时<code>soft real-time</code>）</h6><blockquote>
<p>这是<code>G1</code>相对于<code>CMS</code>的另一大优势，<code>G1</code>除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为<code>M</code>毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li><p>由于分区的原因，<code>G1</code>可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p>
</li>
<li><p><code>G1</code>跟踪各个<code>Region</code>里面的垃圾堆积的价值大小（<strong>回收所获得的空间大小以及回收所需时间的经验值</strong>），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的<code>Region</code>。保证了<code>G1</code>收集器在有限的时间内可以获取尽可能高的收集效率。</p>
</li>
<li><p>相比于<code>CMS GC</code>，<code>G1</code>未必能做到<code>CMS</code>在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
</ul>
</blockquote>
<h5 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a><code>G1</code>垃圾收集器的缺点</h5><blockquote>
<p>相较于<code>CMS</code>，<code>G1</code>还不具备全方位、压倒性优势。比如在用户程序运行过程中，<code>G1</code>无论是为了垃圾收集产生的内存占用（<code>Footprint</code>）还是程序运行时的额外执行负载（<code>Overload</code>）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上<code>CMS</code>的表现大概率会优于<code>G1</code>，而<code>G1</code>在大内存应用上则发挥其优势。平衡点在<code>6-8 GB</code>之间。</p>
</blockquote>
<h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><blockquote>
<p>1、<code>G1</code>分区示意图</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-1.jpeg"></p>
<p>2、分区<code>Region</code></p>
<p>​	<code>G1</code>采用了分区(<code>Region</code>)的思路，将整个堆空间分成若干个<strong>大小相等</strong>的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，<code>G1</code>并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数&#96;&#96;-XX:G1HeapRegionSize&#x3D;n<code>可指定分区大小(</code>1MB~32MB<code>，且必须是</code>2<code>的幂)，默认将整堆划分为</code>2048&#96;个分区。</p>
<p>3、卡片<code>Card</code></p>
<p>​	在每个分区内部又被分成了若干个大小为<code>512Byte</code>卡片(<code>Card</code>)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(<code>Global Card Table</code>)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见<code>RSet</code>)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<p>4、堆<code>Heap</code></p>
<p>​	<code>G1</code>同样可以通过<code>-Xms/-Xmx</code>来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算<code>GC</code>与应用的耗费时间比，自动调整堆空间大小。如果<code>GC</code>频率太高，则通过增加堆尺寸，来减少<code>GC</code>频率，相应地<code>GC</code>占用的时间也随之降低；目标参数<code>-XX:GCTimeRatio</code>即为<code>GC</code>与应用的耗费时间比，<code>G1</code>默认为<code>9</code>，而<code>CMS</code>默认为<code>99</code>，因为<code>CMS</code>的设计原则是耗费在<code>GC</code>上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，<code>G1</code>会首先尝试增加堆空间，如果扩容失败，则发起担保的<code>Full GC</code>。<code>Full GC</code>后，堆尺寸计算结果也会调整堆空间。</p>
</blockquote>
<h5 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-2.jpeg"></p>
<p>1、分代垃圾收集</p>
<p>​	分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但<code>G1</code>依然使用了分代的思想。与其他垃圾收集器类似，<code>G1</code>将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为<code>Eden</code>空间和<code>Survivor</code>空间。<strong>但年轻代空间并不是固定不变的，当现有年轻代分区占满时，<code>JVM</code>会分配新的空闲分区加入到年轻代空间。</strong></p>
<p>​	整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆<code>5%</code>)与最大空间(默认<code>60%</code>)之间动态变化，且由参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认<code>200ms</code>)、需要扩缩容的大小以<code>-XX:G1MaxNewSizePercent</code>及分区的已记忆集合(<code>RSet</code>)计算得到。当然，<code>G1</code>依然可以设置固定的年轻代大小(参数<code>-XX:NewRatio、-Xmn</code>)，但同时暂停目标将失去意义.</p>
<p>2、本地分配缓冲 <code>Local allocation buffer (Lab)</code></p>
<p>​	值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和<code>GC</code>线程都会独立的使用分区，进而减少同步时间，提升<code>GC</code>效率，这个分区称为本地分配缓冲区(<code>Lab</code>)。</p>
<p>其中，应用线程可以独占一个本地缓冲区(<code>TLAB</code>)来创建的对象，而大部分都会落入<code>Eden</code>区域(巨型对象或分配失败除外)，因此<code>TLAB</code>的分区属于<code>Eden</code>空间；而每次垃圾收集时，每个<code>GC</code>线程同样可以独占一个本地缓冲区(<code>GCLAB</code>)用来转移对象，每次回收会将对象复制到<code>Suvivor</code>空间或老年代空间；对于从<code>Eden/Survivor</code>空间晋升(<code>Promotion</code>)到<code>Survivor</code>&#x2F;老年代空间的对象，同样有<code>GC</code>独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(<code>PLAB</code>)。</p>
</blockquote>
<h5 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a>分区模型</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-3.jpeg"></p>
<p>​	<strong><code>G1</code>对内存的使用以分区(<code>Region</code>)为单位，而对对象的分配则以卡片(<code>Card</code>)为单位。</strong></p>
<p>1、巨形对象(<code>Humongous Region</code>)</p>
<p>​	一个大小达到甚至超过分区大小一半的对象称为巨型对象(<code>Humongous Object</code>)。当线程为巨型分配空间时，不能简单在<code>TLAB</code>进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(<code>Humongous Region</code>)。**<code>G1</code>内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。**</p>
<p>​	巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(<code>StartsHumongous</code>)，相邻连续分区被标记为连续巨型(<code>ContinuesHumongous</code>)。由于无法享受<code>Lab</code>带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<p>2、已记忆集合<code>Remember Set (RSet)</code></p>
<p>​	在串行和并行收集器中，<code>GC</code>通过整堆扫描，来确定对象是否处于可达路径中。然而<code>G1</code>为了避免<code>STW</code>式的整堆扫描，在每个分区记录了一个已记忆集合(<code>RSet</code>)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的<code>RSet</code>，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>​	事实上，并非所有的引用都需要记录在<code>RSet</code>中，如果一个分区确定需要扫描，那么无需<code>RSet</code>也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入<code>RSet</code>中；同时，<code>G1 GC</code>每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在<code>RSet</code>中记录。最后只有老年代的分区可能会有<code>RSet</code>记录，这些分区称为拥有<code>RSet</code>分区。</p>
<p>3、<code>Per Region Table (PRT)</code></p>
<p>​	<code>RSet</code>在内部使用<code>Per Region Table(PRT)</code>记录分区的引用情况。由于<code>RSet</code>的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么<code>RSet</code>占用的空间会上升，从而降低分区的可用空间。<code>G1</code>应对这个问题采用了改变<code>RSet</code>的密度的方式，在<code>PRT</code>中将会以三种模式记录引用：</p>
<ul>
<li><p>稀少：直接记录引用对象的卡片索引</p>
</li>
<li><p>细粒度：记录引用对象的分区索引</p>
</li>
<li><p>粗粒度：只记录引用情况，每个分区对应一个比特位</p>
</li>
</ul>
<p>由上可知，粗粒度的<code>PRT</code>只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
</blockquote>
<h5 id="收集集合-CSet"><a href="#收集集合-CSet" class="headerlink" title="收集集合 (CSet)"></a>收集集合 (<code>CSet</code>)</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-4.jpeg"></p>
<p>​	收集集合(<code>CSet</code>)代表每次<code>GC</code>暂停时回收的一系列目标分区。在任意一次收集暂停中，<code>CSet</code>所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集<code>CSet</code>只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到<code>CSet</code>中。</p>
<p>​	候选老年代分区的<code>CSet</code>准入条件，可以通过活跃度阈值<code>-XX:G1MixedGCLiveThresholdPercent</code>(默认<code>85%</code>)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据<code>CSet</code>对堆的总大小占比<code>-XX:G1OldCSetRegionThresholdPercent</code>(默认<code>10%</code>)设置数量上限。</p>
<p>由上述可知，<code>G1</code>的收集都是根据<code>CSet</code>进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<p>1、年轻代收集集合 （<code>CSet of Young Collection</code>）</p>
<p>​	应用线程不断活动后，年轻代空间会被逐渐填满。当<code>JVM</code>分配对象到<code>Eden</code>区域失败(<code>Eden</code>区已满)时，便会触发一次<code>STW</code>式的年轻代收集。在年轻代收集中，<code>Eden</code>分区存活的对象将被拷贝到<code>Survivor</code>分区；原有<code>Survivor</code>分区存活的对象，将根据任期阈值(<code>tenuring threshold</code>)分别晋升到<code>PLAB</code>中，新的<code>survivor</code>分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>​	同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(<code>tenuring</code>)对象晋升的时候是到<code>Survivor</code>分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、<code>Survivor</code>尺寸、<code>Survivor</code>填充容量<code>-XX:TargetSurvivorRatio</code>(默认<code>50%</code>)、最大任期阈值<code>-XX:MaxTenuringThreshold</code>(默认<code>15</code>)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<p>2、混合收集集合 （<code>CSet of Mixed Collection</code>）</p>
<p>​	年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比<code>IHOP</code>阈值<code>-XX:InitiatingHeapOccupancyPercent</code>(默认<code>45%</code>)时，<code>G1</code>就会启动一次混合垃圾收集周期。为了满足暂停目标，<code>G1</code>可能不能一口气将所有的候选分区收集掉，因此<code>G1</code>可能会产生连续多次的混合收集与应用线程交替执行，每次<code>STW</code>的混合收集与年轻代收集过程相类似。</p>
<p>​	为了确定包含到年轻代收集集合<code>CSet</code>的老年代分区，JVM通过参数混合周期的最大总次数<code>-XX:G1MixedGCCountTarget</code>(默认<code>8</code>)、堆废物百分比<code>-XX:G1HeapWastePercent</code>(默认<code>5%</code>)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到<code>CSet</code>的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到<code>CSet</code>的分区，则通过计算得到的<code>GC</code>效率进行安排。</p>
<p>并发标记算法（三色标记法）</p>
<p><code>CMS</code>和<code>G1</code>在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p>
<p><strong>白色</strong>：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚举完仍是白色的对象将会被当做垃圾对象被清理。 </p>
<p><strong>灰色</strong>：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有一个没有被访问到，表示这个对象正在枚举中。 </p>
<p><strong>黑色</strong>：对象和它所直接引用的所有对象都被访问过。这里只要访问过就行，比如<code>A</code>只引用了<code>B</code>，<code>B</code>引用了<code>C</code>、<code>D</code>，那么只要<code>A</code>和<code>B</code>都被访问过，<code>A</code>就是黑色，即使<code>B</code>所引用的<code>C</code>或<code>D</code>还没有被访问到，此时<code>B</code>就是灰色。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-5.png"></p>
<p><strong>根据这些定义，我们可以得出：</strong></p>
<p>​	在可达性分析的初始阶段，所有对象都是白色，一旦访问了这个对象，那么就变成灰色，一旦这个对象所有直接引用的对象都访问过（或者没有引用其它对象），那么就变成黑色 初始标记之后，<code>GC Root</code>节点变为黑色（<code>GC Root</code>不会是垃圾），<code>GC Root</code>直接引用的对象变为灰色 正常情况下，一个对象如果是黑色，那么其直接引用的对象要么是黑色，要么是灰色，不可能是白色（如果出现了黑色对象直接引用白色对象的情况，就说明漏标了，就会导致对象误删，后面会介绍如何解决），这个特性也可以说是三色标记算法正确性保障的前提条件。</p>
<p><strong>算法大致的流程是（初始状态所有对象都是白色）：</strong></p>
<p>​	首先我们从<code>GC Roots</code>开始枚举，它们所有的直接引用变为灰色，自己变为黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个队列中 然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没有直接引用，那么直接变成黑色 继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直重复直到灰色队列为空 分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理 最后重置标记状态</p>
</blockquote>
<p>前面的描述都比较抽象，这里以一个例子进行说明，假设现在有以下引用关系：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jhbugvyfctdxtcfygubhij.png"></p>
<p>首先，所有<code>GC Root</code>的直接引用（<code>A</code>、<code>B</code>、<code>E</code>）变为灰色，放入队列中，<code>GC Root</code>变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/nibuvcrtybyuiompo,[..png"></p>
<p>然后从队列中取出一个灰色对象进行分析，比如取出<code>A</code>对象，将它的直接引用<code>C</code>、<code>D</code>变为灰色，放入队列，<code>A</code>对象变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnihbugvfcdxrctfvybhj.png"></p>
<p>继续从队列中取出一个灰色对象，比如取出<code>B</code>对象，将它的直接引用<code>F</code>变为灰色，放入队列，<code>B</code>对象变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibhugvycftxetcryybiimop.png"></p>
<p>继续从队列中取出一个灰色对象<code>E</code>，但是E对象没有直接引用，变为黑色：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhugvyfcdtfyvbhijnom,l.png"></p>
<p>同理依次取出<code>C</code>、<code>D</code>、<code>F</code>对象，他们都没有直接引用，那么变成黑色（这里就不一个一个的画了）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jkhjghftdrxtcfvgubhim.png"></p>
<blockquote>
<p><code>GC</code> 开始前所有对象都是白色，<code>GC</code> 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 <code>GC</code> 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-5-1.gif"></p>
<p>漏标问题</p>
<p>在<code>remark</code>过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标。会把白色<code>D</code>对象当作没有新引用指向从而回收掉。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java-jvm-gc-g1-6.png"></p>
<p>并发标记过程中，<code>Mutator</code>删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p>
<p>产生漏标问题的条件有两个：</p>
<ul>
<li>黑色对象指向了白色对象</li>
<li>灰色对象指向白色对象的引用消失</li>
</ul>
<p>所以要解决漏标问题，打破两个条件之一即可：</p>
<ul>
<li><strong>跟踪黑指向白的增加</strong> <code>incremental update</code>：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。<code>CMS</code>采用该方法。</li>
<li><strong>记录灰指向白的消失</strong> <code>SATB snapshot at the beginning</code>：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到<code>GC</code>的堆栈，保证白还能被<code>GC</code>扫描到。<code>G1</code>采用该方法。</li>
</ul>
<p>**为什么<code>G1</code>采用<code>SATB</code>而不用<code>incremental update</code>**？</p>
<p>因为采用<code>incremental update</code>把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。<code>G1</code>有<code>RSet</code>与<code>SATB</code>相配合。<code>Card Table</code>里记录了<code>RSet</code>，<code>RSet</code>里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描<code>RSet</code>就可以了。</p>
<p>也就是说 灰色–&gt;白色 引用消失时，如果没有 黑色–&gt;白色，引用会被<code>push</code>到堆栈，下次扫描时拿到这个引用，由于有<code>RSet</code>的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。<code>SATB</code>配合<code>RSet</code>浑然天成。</p>
</blockquote>
<h5 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a><code>G1</code>收集器的常见操作步骤</h5><blockquote>
<p><code>G1</code>的设计原则就是简化<code>JVM</code>性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li><p>第一步：开启<code>G1</code>垃圾收集器</p>
</li>
<li><p>第二步：设置堆的最大内存</p>
</li>
<li><p>第三步：设置最大的停顿时间</p>
</li>
</ul>
<p><code>G1</code>中提供了三种垃圾回收模式：<code>Young GC</code>、<code>Mixed GC</code>和<code>Full GC</code>，在不同的条件下被触发。</p>
</blockquote>
<h5 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a><code>G1</code>收集器的适用场景</h5><blockquote>
<p>​	面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>​	最主要的应用是需要低<code>GC</code>延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约<code>6GB</code>或更大时，可预测的暂停时间可以低于<code>0.5</code>秒；（<code>G1</code>通过每次只清理一部分而不是全部的<code>Region</code>的增量式清理来保证每次<code>GC</code>停顿时间不会过长）。</p>
<p>用来替换掉<code>JDK1.5</code>中的<code>CMS</code>收集器；在下面的情况时，使用<code>G1</code>可能比<code>CMS</code>好：</p>
<ul>
<li><p>超过<code>50%</code>的<code>Java</code>堆被活动数据占用；</p>
</li>
<li><p>对象分配频率或年代提升频率变化很大；</p>
</li>
<li><p><code>GC</code>停顿时间过长（长于<code>0.5</code>至<code>1</code>秒）</p>
</li>
</ul>
<p><strong><code>HotSpot</code>垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的<code>JVM</code>线程执行<code>GC</code>的多线程操作，而<code>G1 GC</code>可以采用应用线程承担后台运行的<code>GC</code>工作，即当<code>JVM</code>的<code>GC</code>线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</strong></p>
</blockquote>
<h5 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区<code>Region</code>：化整为零</h5><blockquote>
<p>​	使用<code>G1</code>收集器时，它将整个<code>Java</code>堆划分成约**<code>2048</code><strong>个大小相同的独立<code>Region</code>块，每个<code>Region</code>块大小根据堆空间的实际大小而定，</strong>整体被控制在<code>1MB</code>到<code>32MB</code>之间，且为<code>2</code>的<code>N</code>次幂**，即<code>1MB，2MB，4MB，8MB，16MB，32MB</code>。可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的<code>Region</code>大小相同，且在<code>JVM</code>生命周期内不会被改变。</p>
<p>​	虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分<code>Region</code>（不需要连续）的集合。通过<code>Region</code>的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/a5e91275-9f8c-4ea8-a34e-e20d3624a88a.png"></p>
<p>​	一个<code>region</code>有可能属于<code>Eden</code>，<code>Survivor</code>或者<code>Old/Tenured</code>内存区域。但是一个<code>region</code>只可能属于一个角色。图中的<code>E</code>表示该<code>region</code>属于<code>Eden</code>内存区域，<code>S</code>表示属于<code>survivor</code>内存区域，<code>O</code>表示属于<code>Old</code>内存区域。图中空白的表示未使用的内存空间。</p>
<p>​	<code>G1</code>垃圾收集器还增加了一种新的内存区域，叫做<code>Humongous</code>内存区域，如图中的H块。主要用于存储大对象，<strong>如果超过<code>1.5</code>个<code>region</code>，就放到<code>Humongous</code>。</strong></p>
<p>​	设置<code>Humongous</code>的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，<code>G1</code>划分了一个<code>Humongous</code>区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么<code>G1</code>会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动<code>Full GC</code>。**<code>G1</code>的大多数行为都把<code>Humongous</code>区作为老年代的一部分来看待。**</p>
<p>​	每个<code>Region</code>都是通过指针碰撞来分配空间</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/96f629bc-62b5-45ca-8fa5-553a099ca2b5.png"></p>
</blockquote>
<h5 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a><code>G1</code>垃圾回收器的回收过程</h5><blockquote>
<p><code>G1 GC</code>的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代<code>GC（Young GC） </code></p>
</li>
<li><p>老年代并发标记过程<code>（Concurrent Marking） </code></p>
</li>
<li><p>混合回收<code>（Mixed GC）</code><br>（如果需要，单线程、独占式、高强度的<code>Full GC</code>还是继续存在的。它针对<code>GC</code>的评估失败提供了一种失败保护机制，即强力回收。）</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/96bc3935-7c03-4e0e-bece-57f0eee1303e.png"></p>
<p>​	顺时针，<code>Young gc</code> -&gt; <code>Young gc</code> + <code>Concurrent mark</code>-&gt;<code>Mixed GC</code>顺序，进行垃圾回收。</p>
<p>​	应用程序分配内存，当年轻代的<code>Eden</code>区用尽时开始年轻代回收过程；<code>G1</code>的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，<code>G1 GC</code>暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到<code>Survivor</code>区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>​	当堆内存使用达到一定值（默认<code>45%</code>）时，开始老年代并发标记过程。</p>
<p>​	标记完成马上开始混合回收过程。对于一个混合回收期，<code>G1 GC</code>从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的<code>G1</code>回收器和其他<code>GC</code>不同，<code>G1</code>的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的<code>Region</code>就可以了。同时，这个老年代<code>Region</code>是和年轻代一起被回收的。</p>
<p>​	举个例子：一个<code>Web</code>服务器，<code>Java</code>进程最大堆内存为<code>4G</code>，每分钟响应<code>1500</code>个请求，每<code>45</code>秒钟会新分配大约<code>2G</code>的内存。<code>G1</code>会每<code>45</code>秒钟进行一次年轻代回收，每<code>31</code>个小时整个堆的使用率会达到<code>45%</code>，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
</blockquote>
<h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a><code>Remembered Set</code></h5><blockquote>
<ul>
<li><p>一个对象被不同区域引用的问题 </p>
</li>
<li><p>一个<code>Region</code>不可能是孤立的，一个<code>Region</code>中的对象可能被其他任意<code>Region</code>中对象引用，判断对象存活时，是否需要扫描整个<code>Java</code>堆才能保证准确？ </p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而<code>G1</code>更突出）回收新生代也不得不同时扫描老年代？ </p>
</li>
<li><p>这样的话会降低<code>Minor GC</code>的效率；</p>
</li>
</ul>
<h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><ul>
<li><p>无论<code>G1</code>还是其他分代收集器，<code>JVM</code>都是使用<code>Remembered Set</code>来避免全局扫描：</p>
</li>
<li><p>每个<code>Region</code>都有一个对应的<code>Remembered Set</code>； </p>
</li>
<li><p>每次<code>Reference</code>类型数据写操作时，都会产生一个<code>Write Barrier</code>暂时中断操作；</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该<code>Reference</code>类型数据在不同的<code>Region</code>（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li><p>如果不同，通过<code>Card Table</code>把相关引用信息记录到引用指向对象的所在<code>Region</code>对应的<code>Remembered Set</code>中；</p>
</li>
<li><p>当进行垃圾收集时，在<code>GC</code>根节点的枚举范围加入<code>Remembered Set</code>；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1c48bcfc-fa6f-4309-b0a6-92820e401504.png"></p>
</blockquote>
<h5 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a><code>G1</code>回收过程一：年轻代<code>GC</code></h5><blockquote>
<p>​	<code>JVM</code>启动时，<code>G1</code>先准备好<code>Eden</code>区，程序在运行过程中不断创建对象到<code>Eden</code>区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>​	<strong>年轻代垃圾回收只会回收<code>Eden</code>区和<code>Survivor</code>区。</strong>	</p>
<p>​	首先<code>G1</code>停止应用程序的执行（<code>Stop-The-World</code>），<code>G1</code>创建回收集（<code>Collection Set</code>），回收集是指需要被回收的内存分段的集合，<strong>年轻代回收过程的回收集包含年轻代<code>Eden</code>区和<code>Survivor</code>区所有的内存分段。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/b22d93c2-2a69-46e0-88b0-4130dea1d2d6.png"></p>
<p>然后开始如下回收过程：</p>
<p><strong>第一阶段，扫描<code>GCRoot</code>寻找可达对象</strong><br>    根是指<code>static</code>变量指向的对象，正在执行的方法调用链条上的局部变量等。<br>    根据扫描到的可达对象, 以及关联的<code>RSet</code>的外部对象都作为 可达对象。<br><strong>第二阶段，更新<code>RSet</code></strong><br>    处理<code>dirty card queue</code>（见备注）中的<code>card</code>，更新<code>RSet</code>。<br>    此阶段完成后，<code>RSet</code>可以准确的反映老年代对所在的内存分段中对象的引用。<br><strong>第三阶段，处理<code>RSet</code></strong><br>    识别被老年代对象指向的<code>Eden</code>中的对象，这些被指向的<code>Eden</code>中的对象被认为是存活的对象。<br><strong>第四阶段，复制对象。(<code>Eden</code>中的对象复制到<code>Survivor</code>中)</strong><br>    此阶段，对象树被遍历，<code>Eden</code>区内存段中存活的对象会被复制到<code>Survivor</code>区中空的内存分段，<code>Survivor</code>区内存段中存活的对象<br>    如果年龄未达阈值，年龄会加<code>1</code>，达到阀值会被会被复制到<code>Old</code>区中空的内存分段。<br>    如果<code>Survivor</code>空间不够，<code>Eden</code>空间的部分数据会直接晋升到老年代空间。<br><strong>第五阶段，处理引用</strong><br>    处理<code>Soft，Weak，Phantom，Final，JNI Weak</code> 等引用。最终<code>Eden</code>空间的数据为空，<code>GC</code>停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
</blockquote>
<blockquote>
<p>备注：增加对象引用, 通过<code>Region</code>的记忆集</p>
<ol>
<li>对于应用程序的引用赋值语句 <code>oldObject.field=new Object()</code>，<code>JVM</code>会在之前和之后执行特殊的操作以在<code>dirty card queue</code>中入队一个保存了对象引用信息的<code>card</code> (卡表)。</li>
<li>在年轻代回收的时候，<code>G1</code>会对<code>Dirty Card Queue</code>中所有的<code>card</code>进行处理，以更新<code>RSet</code>，保证<code>RSet</code>实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新<code>RSet</code>呢？这是为了性能的需要，<code>RSet</code>的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ol>
</blockquote>
<h5 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a><code>G1</code>回收过程二：并发标记过程</h5><blockquote>
<p>​	当越来越多的对象晋升到老年代<code>Old Region</code>时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即<code>Mixed GC</code>， 该算法并不是一个<code>Old GC</code>，除了回收整个<code>Young Region</code>，还会回收一部分的<code>Old Region</code>。<br>​	这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些<code>Old Region</code>进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<code>Mixed GC</code>并不是<code>Full GC</code>。</p>
</blockquote>
<blockquote>
<p><strong>初始标记阶段：</strong>标记从根节点直接可达的对象。这个阶段是<code>STW</code>的，并且会触发一次年轻代<code>GC</code>。正是由于该阶段时<code>STW</code>的，所以我们只扫描根节点可达的对象，以节省时间。<br><strong>根区域扫描（<code>Root Region Scanning</code>）：</strong><code>G1 GC</code>扫描<code>Survivor</code>区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在<code>Young GC</code>之前完成，因为<code>Young GC</code>会使用复制算法对<code>Survivor</code>区进行<code>GC</code>。<br><strong>并发标记（<code>Concurrent Marking</code>）：</strong>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被<code>Young GC</code>中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。(为了选择性回收<code>Region</code>)<br><strong>再次标记（<code>Remark</code>）：</strong>由于应用程序持续进行，需要修正上一次的标记结果。是<code>STW</code>的。<code>G1</code>中采用了比<code>CMS</code>更快的初始快照算法：<code>Snapshot-At-The-Beginning（SATB）</code>。<br><strong>独占清理（<code>cleanup，STW</code>）：</strong>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是<code>STW</code>的。这个阶段并不会实际上去做垃圾的收集<br><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p>
</blockquote>
<h5 id="G1回收过程三：混合回收"><a href="#G1回收过程三：混合回收" class="headerlink" title="G1回收过程三：混合回收"></a><code>G1</code>回收过程三：混合回收</h5><blockquote>
<p>​	当越来越多的对象晋升到老年代<code>old region</code>时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即<code>Mixed GC</code>，该算法并不是一个<code>Old GC</code>，除了回收整个<code>Young Region</code>，还会回收一部分的<code>Old Region</code>。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些<code>Old Region</code>进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<code>Mixed GC</code>并不是<code>Full GC</code>。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1476cd19-28a1-46c5-a469-b4837ce165a4.png"></p>
<blockquote>
<p>​	并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。<br>​	默认情况下，这些老年代的内存分段会分<code>8</code>次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收<br>​	混合回收的回收集（<code>Collection Set</code>）包括八分之一的老年代内存分段，<code>Eden</code>区内存分段，<code>Survivor</code>区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。<br>​	由于老年代中的内存分段默认分<code>8</code>次回收，<code>G1</code>会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。<br>​	<code>XX:G1MixedGCLiveThresholdPercent</code>，默认为<code>65%</code>，意思是垃圾占内存分段比例要达到<code>65%</code>才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。<br>​	混合回收并不一定要进行<code>8</code>次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为<code>10%</code>，意思是允许整个堆内存中有<code>10%</code>的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于<code>10%</code>，则不再进行混合回收。因为<code>GC</code>会花费很多的时间但是回收到的内存却很少。</p>
</blockquote>
<h5 id="G1回收可选的过程四：Full-GC"><a href="#G1回收可选的过程四：Full-GC" class="headerlink" title="G1回收可选的过程四：Full GC"></a><code>G1</code>回收可选的过程四：<code>Full GC</code></h5><blockquote>
<p>​	<code>G1</code>的初衷就是要避免<code>Full GC</code>的出现。但是如果上述方式不能正常工作，<code>G1</code>会停止应用程序的执行（<code>Stop-The-World</code>），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>​	要避免<code>Full GC</code>的发生，一旦发生需要进行调整。什么时候会发生<code>Full GC</code>呢？比如堆内存太小，当<code>G1</code>在复制存活对象的时候没有空的内存分段可用，则会回退到<code>Full GC</code>，这种情况可以通过增大内存解决。</p>
<p>导致<code>G1 Full GC</code>的原因可能有两个：</p>
<ul>
<li><p><code>Evacuation</code>的时候没有足够的<code>to-space</code>来存放晋升的对象；</p>
</li>
<li><p>并发处理过程完成之前空间耗尽。</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">分类</th>
<th align="center">作用位置</th>
<th align="center">使用算法</th>
<th align="center">特点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Serial</code></td>
<td align="center">串行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单<code>CPU</code>环境下的<code>client</code>模式</td>
</tr>
<tr>
<td align="center"><code>ParNew</code></td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多<code>CPU</code>环境<code>Server</code>模式下与<code>CMS</code>配合使用</td>
</tr>
<tr>
<td align="center"><code>Parallel</code></td>
<td align="center">并行运行</td>
<td align="center">作用于新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="center"><code>Serial Old</code></td>
<td align="center">串行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-压缩算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于单<code>CPU</code>环境下的<code>Client</code>模式</td>
</tr>
<tr>
<td align="center"><code>Parallel Old</code></td>
<td align="center">并行运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-压缩算法</td>
<td align="center">吞吐量优先</td>
<td align="center">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="center"><code>CMS</code></td>
<td align="center">并发运行</td>
<td align="center">作用于老年代</td>
<td align="center">标记-清除算法</td>
<td align="center">响应速度优先</td>
<td align="center">适用于互联网或<code>B／S</code>业务</td>
</tr>
<tr>
<td align="center"><code>G1</code></td>
<td align="center">并发、并行运行</td>
<td align="center">作用于新生代、老年代</td>
<td align="center">标记-压缩算法、复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用</td>
</tr>
</tbody></table>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><blockquote>
<p><code>JVM</code>将类的加载分为<code>3</code>个步骤：</p>
<p>​	装载（<code>Load</code>）</p>
<p>​	链接（<code>Link</code>）</p>
<p>​	初始化（<code>Initialize</code>）</p>
<p>其中 链接（<code>Link</code>）又分<code>3</code>个步骤，如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_2.png"></p>
<p>​	在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持<code>Java</code>语言的运行时绑定（也成为动态绑定或晚期绑定）。<strong>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</strong></p>
</blockquote>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote>
<p>​	加载：指的是将类的<code>class</code>文件读入到内存，并为之创建一个<code>java.lang.Class</code>对象，也就是说，当程序中使用任何类时，系统都会为之建立一个<code>java.lang.Class</code>对象。</p>
<p>​	类的加载由类加载器完成，类加载器通常由<code>JVM</code>提供，这些类加载器也是前面所有程序运行的基础，<code>JVM</code>提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承<code>ClassLoader</code>基类来创建自己的类加载器。</p>
<p><strong>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载<code>.class</code>文件</li>
<li>从<code>zip，jar</code>等归档文件中加载<code>.class</code>文件</li>
<li>从专有数据库中提取<code>.class</code>文件</li>
<li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li>
</ul>
<p><strong>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</strong></p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。（<strong>全限定类名：</strong>就是类名全称，带包路径的用点隔开，例如: <code>java.lang.String。</code>）</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在<code>Java</code>堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_1.png"></p>
<p>​	相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>​	加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在<code>Java</code>堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>​	类加载器并不需要等到某个类被“首次主动使用”时再加载它，<code>JVM</code>规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(<code>LinkageError</code>错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote>
<p>验证：是连接阶段的第一步，这一阶段的目的是为了确保<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成<code>4</code>个阶段的检验动作:</p>
<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合<code>Class</code>文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合<code>Java</code>语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p>
</blockquote>
</blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>为类的静态变量分配内存，并将其初始化为默认值</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p>
<ul>
<li><p>这时候进行内存分配的<strong>仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</strong></p>
</li>
<li><p><strong>这里所设置的初始值通常情况下是数据类型默认的零值</strong>(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何<code>Java</code>方法，而把<code>value</code>赋值为<code>3</code>的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把<code>value</code>赋值为<code>3</code>的动作将在初始化阶段才会执行。</p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>对基本数据类型来说，对于类变量<code>(static)</code>和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</strong></li>
<li><strong>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</strong></li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量<code>value</code>就会被初始化为<code>ConstValue</code>属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时<code>Javac</code>将会为<code>value</code>生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将<code>value</code>赋值为<code>3</code>。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
</blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
</blockquote>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote>
<p>初始化，为类的静态变量赋予正确的初始值，<code>JVM</code>负责对类进行初始化，主要对类变量进行初始化。在<code>Java</code>中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>类访问方法区内的数据结构的接口， 对象是<code>Heap</code>区的数据。</p>
</blockquote>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><blockquote>
<p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致<code>Java</code>虚拟机进程终止</li>
</ul>
</blockquote>
<h3 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h3><blockquote>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h4><blockquote>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/java_jvm_classload_3.png"></p>
<p>​	站在<code>Java</code>虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用<code>C++</code>实现(这里仅限于<code>Hotspot</code>，也就是<code>JDK1.5</code>之后默认的虚拟机，有很多其他的虚拟机是用<code>Java</code>语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
</blockquote>
<h5 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，<code>Bootstrap ClassLoader</code>）</h5><blockquote>
<ul>
<li><p>这个类加载使用<code>C/C++</code>语言实现的，嵌套在<code>JVM</code>内部。</p>
</li>
<li><p>它用来加载<code>Java</code>的核心库（<code>JAVA_HOME/jre/lib/rt.jar、resources.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供<code>JVM</code>自身需要的类</p>
</li>
<li><p>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，<code>Bootstrap</code>启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类</p>
</li>
</ul>
</blockquote>
<h5 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（<code>Extension ClassLoader</code>）</h5><blockquote>
<ul>
<li><p><code>Java</code>语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</p>
</li>
<li><p>派生于<code>ClassLoader</code>类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从<code>JDK</code>的安装目录的<code>jre/1ib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的<code>JAR</code>放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
</blockquote>
<h5 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，<code>AppClassLoader</code>）</h5><blockquote>
<ul>
<li><p><code>java</code>语言编写，由<code>sun.misc.LaunchersAppClassLoader</code>实现</p>
</li>
<li><p>派生于<code>ClassLoader</code>类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</p>
</li>
<li><p>该类加载是程序中默认的类加载器，一般来说，<code>Java</code>应用的类都是由它来完成加载</p>
</li>
<li><p>通过<code>ClassLoader#getSystemclassLoader()</code> 方法可以获取到该类加载器</p>
</li>
</ul>
</blockquote>
<h5 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h5><blockquote>
<p>​	在<code>Java</code>的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p>
<ul>
<li><p>隔离加载类</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>扩展加载源</p>
</li>
<li><p>防止源码泄漏</p>
</li>
</ul>
</blockquote>
<p>用户自定义类加载器实现步骤：</p>
<blockquote>
<ul>
<li><p>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</p>
</li>
<li><p>在<code>JDK1.2</code>之前，在自定义类加载器时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass()</code> 方法，从而实现自定义的类加载类，但是在<code>JDK1.2</code>之后已不再建议用户去覆盖<code>loadclass()</code> 方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中</p>
</li>
<li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
</li>
</ul>
</blockquote>
<h4 id="获取ClassLoader的途径"><a href="#获取ClassLoader的途径" class="headerlink" title="获取ClassLoader的途径"></a>获取<code>ClassLoader</code>的途径</h4><h5 id="获取当前ClassLoader"><a href="#获取当前ClassLoader" class="headerlink" title="获取当前ClassLoader"></a>获取当前<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取当前线程上下文的ClassLoader"><a href="#获取当前线程上下文的ClassLoader" class="headerlink" title="获取当前线程上下文的ClassLoader "></a>获取当前线程上下文的<code>ClassLoader </code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取系统的ClassLoader"><a href="#获取系统的ClassLoader" class="headerlink" title="获取系统的ClassLoader"></a>获取系统的<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<h5 id="获取调用者的ClassLoader"><a href="#获取调用者的ClassLoader" class="headerlink" title="获取调用者的ClassLoader"></a>获取调用者的<code>ClassLoader</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>

<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><h4 id="类加载有三种方式"><a href="#类加载有三种方式" class="headerlink" title="类加载有三种方式"></a>类加载有三种方式</h4><blockquote>
<ul>
<li>命令行启动应用时候由<code>JVM</code>初始化加载</li>
<li>通过<code>Class.forName()</code>方法动态加载</li>
<li>通过<code>ClassLoader.loadClass()</code>方法动态加载</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loaderTest</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;, false, loader); </span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别?"></a><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>区别?</h4><blockquote>
<ul>
<li><code>Class.forName()</code>: 将类的<code>.class</code>文件加载到<code>jvm</code>中之外，还会对类进行解释，执行类中的<code>static</code>块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将<code>.class</code>文件加载到<code>jvm</code>中，不会执行static中的内容,只有在<code>newInstance</code>才会去执行<code>static</code>块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载<code>static</code>块。并且只有调用了<code>newInstance()</code>方法采用调用构造函数，创建类的对象 。</li>
</ul>
</blockquote>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote>
<p>​	<code>Java</code>虚拟机对<code>class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>class</code>文件加载到内存生成<code>class</code>对象。而且加载某个类的<code>class</code>文件时，<code>Java</code>虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
</blockquote>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><blockquote>
<ul>
<li>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个<code>class</code>时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ul>
</blockquote>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                         <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = findBootstrapClass0(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tomcat如何破坏双亲委派机制"><a href="#Tomcat如何破坏双亲委派机制" class="headerlink" title="Tomcat如何破坏双亲委派机制"></a>Tomcat如何破坏双亲委派机制</h4><h5 id="为什么要打破双亲委派"><a href="#为什么要打破双亲委派" class="headerlink" title="为什么要打破双亲委派"></a>为什么要打破双亲委派</h5><blockquote>
<p>​	Tomcat中会部署多个应用(webapp)，每个应用可能会出现相同的类名，或者引用相同的jar包但<strong>版本不同</strong>，若使用双亲委派，一个类只会加载一次，项目就互相之间有冲突，若打破双亲委派，可以实现各自的应用加载自己应用的类，互不影响。</p>
</blockquote>
<h5 id="Tomcat如何实现多个Web应用的隔离"><a href="#Tomcat如何实现多个Web应用的隔离" class="headerlink" title="Tomcat如何实现多个Web应用的隔离"></a>Tomcat如何实现多个Web应用的隔离</h5><p>Tomcat作为一个Web服务器需要解决以下问题：</p>
<ul>
<li>多个Web应用隔离类库：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当可以保证两个应用程序的类库可以互相独立使用</li>
<li>多个Web应用共享类库：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。例如用户可能有10个使用Spring的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区很容易就会出现过度膨胀的风险</li>
<li>隔离Tomcat与Web应用的类：Tomcat服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响，服务器所使用的类库应该与应用程序的类库互相独立</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/jnibugvyfexrtcyubiomkjniuvyctrtyuio.webp"></p>
<p><strong>WebAppClassLoader：</strong></p>
<blockquote>
<p>​	为了解决多个Web应用隔离类库的问题，Tomcat自定义了一个类加载器WebAppClassLoader，并且给每个Web应用创建一个WebAppClassLoader加载器实例，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。这背后的原理是，不同的加载器实例加载的类被认为是不同的类，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离</p>
</blockquote>
<p><strong>SharedClassLoader：</strong></p>
<blockquote>
<p>​	多个Web应用共享类库的问题本质是多个Web应用之间共享类库并且不能重复加载相同的类。在双亲委派模型里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗。SharedClassLoader作为WebAppClassLoader的父加载器专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，来解决共享的问题</p>
</blockquote>
<p><strong>CatalinaClassLoader：</strong></p>
<blockquote>
<p>​	如何隔离Tomcat与Web应用的类？要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此Tomcat又设计一个类加载器CatalinaClassLoader专门来加载Tomcat自身的类</p>
</blockquote>
<p><strong>CommonClassLoader：</strong></p>
<blockquote>
<p>​	如果Tomcat和各Web应用之间需要共享一些类时该怎么办呢？CommonClassLoader作为CatalinaClassLoader和SharedClassLoader的父加载器</p>
<p>​	CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离</p>
</blockquote>
<h5 id="顺序：Bootstrap-ClassLoader-Extension-ClassLoader-CatalinaClassLoader-WebAppClassLoader-CommonClassLoader"><a href="#顺序：Bootstrap-ClassLoader-Extension-ClassLoader-CatalinaClassLoader-WebAppClassLoader-CommonClassLoader" class="headerlink" title="顺序：Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt; CatalinaClassLoader -&gt; WebAppClassLoader -&gt; CommonClassLoader"></a>顺序：Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt; CatalinaClassLoader -&gt; WebAppClassLoader -&gt; CommonClassLoader</h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn">初学者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://www.wyy-blog.cn/2021/12/08/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wyy-blog.cn" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/11/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="Linux操作系统"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/ChMkJ1bKzZSIIs6lABaR-QrYQkAAALJCQCh1KQAFpIR208.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux操作系统</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="牛客网编程遇到的问题"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/umtjnyrhbgvsfcad.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">牛客网编程遇到的问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/13/StringTable%E8%AE%B2%E8%A7%A3/" title="StringTable讲解"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/hgdnfbzdbdzf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-13</div><div class="title">StringTable讲解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img18/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初学者</div><div class="author-info__description">虽千万人，吾往矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.2.</span> <span class="toc-text">栈中可能出现的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈中存储什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">栈运行原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A7%BD-Slot"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">槽 Slot</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%EF%BC%88Top-of-stack-Cashing%EF%BC%89"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">栈顶缓存（Top-of-stack-Cashing）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">动态链接（指向运行时常量池的方法引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JVM-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84"><span class="toc-number">1.2.5.3.1.</span> <span class="toc-text">JVM 是如何执行方法调用的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.5.3.2.</span> <span class="toc-text">虚方法和非虚方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">1.2.5.3.3.</span> <span class="toc-text">虚方法表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%88return-address%EF%BC%89"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">方法返回地址（return address）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">附加信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">本地方法接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">本地方法栈（Native Method Stack）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">堆内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3-Young-Generation"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">年轻代 (Young Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3-Old-Generation"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">老年代(Old Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">元空间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C-OOM"><span class="toc-number">1.4.2.</span> <span class="toc-text">设置堆内存大小和 OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-JVM-%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text">查看 JVM 堆内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象在堆中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.5.</span> <span class="toc-text">对象的分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">GC 垃圾回收简介</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="toc-number">1.4.6.0.1.</span> <span class="toc-text">Minor GC、Major GC、Full GC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLAB"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#TLAB-%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89"><span class="toc-number">1.4.6.1.1.</span> <span class="toc-text">TLAB （Thread Local Allocation Buffer）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-TLAB"><span class="toc-number">1.4.6.1.2.</span> <span class="toc-text">为什么要有 TLAB ?</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TLAB-%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.6.1.3.</span> <span class="toc-text">TLAB 带来的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="toc-number">1.4.6.1.4.</span> <span class="toc-text">堆是分配对象存储的唯一选择吗</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">1.4.6.1.5.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%83%E9%80%B8%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.6.1.6.</span> <span class="toc-text">对象逃逸状态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">1.4.6.1.7.</span> <span class="toc-text">参数设置：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">设置方法区内存的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">方法区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%9F%EF%BC%88Field%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">域（Field）信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">方法（Method）信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">栈、堆、方法区的交互关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.5.3.</span> <span class="toc-text">运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">为什么需要常量池？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-1"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">常量池的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">基本类型的包装类和常量池</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">Java 垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">2.1.</span> <span class="toc-text">判断一个对象是否可被回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GC-Roots-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">GC Roots 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">对象的finalization机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#finalize"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">finalize()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">具体过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.0.0.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.0.0.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.0.0.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.0.0.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">标记-清除算法（Mark-Sweep）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E6%B8%85%E9%99%A4%EF%BC%9F"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">何为清除？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%88Copying%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">复制（Copying）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%EF%BC%88%E6%88%96%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E3%80%81Mark-Compact%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">标记-压缩（或标记-整理、Mark-Compact）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.4.</span> <span class="toc-text">三种算法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-number">2.3.5.</span> <span class="toc-text">分代收集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">2.4.</span> <span class="toc-text">内存溢出与内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.4.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">内存泄漏（Memory Leak）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.4.2.0.1.</span> <span class="toc-text">举例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stop-The-World"><span class="toc-number">2.5.</span> <span class="toc-text">Stop The World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.6.</span> <span class="toc-text">垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">并发（Concurrent）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="toc-number">2.6.2.</span> <span class="toc-text">并行（Parallel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-vs-%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.6.3.</span> <span class="toc-text">并发 vs 并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.6.4.</span> <span class="toc-text">垃圾回收的并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89-1"><span class="toc-number">2.6.4.0.1.</span> <span class="toc-text">并行（Parallel）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%EF%BC%88Serial%EF%BC%89"><span class="toc-number">2.6.4.0.2.</span> <span class="toc-text">串行（Serial）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89-1"><span class="toc-number">2.6.4.0.3.</span> <span class="toc-text">并发（Concurrent）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">2.7.1.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">2.7.2.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.3.</span> <span class="toc-text">Serial 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.4.</span> <span class="toc-text">ParNew 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.5.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.6.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.7.</span> <span class="toc-text">CMS 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88CMS%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%87%87%E7%94%A8%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86-%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E6%98%AF%E9%87%87%E7%94%A8%E7%9A%84%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">2.7.7.0.1.</span> <span class="toc-text">并发垃圾收集器（CMS）为什么没有采用标记整理-算法来实现，而是采用的标记-清除算法？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CMS-%E5%87%BA%E7%8E%B0Full-GC%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.7.7.0.2.</span> <span class="toc-text">CMS 出现Full GC的原因：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CMS%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.7.7.0.3.</span> <span class="toc-text">CMS的优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CMS%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">2.7.7.0.4.</span> <span class="toc-text">CMS的弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.8.</span> <span class="toc-text">G1 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="toc-number">2.7.8.1.</span> <span class="toc-text">G1回收器的特点（优势）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.7.8.1.1.</span> <span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86-1"><span class="toc-number">2.7.8.1.2.</span> <span class="toc-text">分代收集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E6%95%B4%E5%90%88"><span class="toc-number">2.7.8.1.3.</span> <span class="toc-text">G1的内存模型空间整合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8D%B3%EF%BC%9A%E8%BD%AF%E5%AE%9E%E6%97%B6soft-real-time%EF%BC%89"><span class="toc-number">2.7.8.1.4.</span> <span class="toc-text">可预测的停顿时间模型（即：软实时soft real-time）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.7.8.2.</span> <span class="toc-text">G1垃圾收集器的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.8.3.</span> <span class="toc-text">分区概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.8.4.</span> <span class="toc-text">分代模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.8.5.</span> <span class="toc-text">分区模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88-CSet"><span class="toc-number">2.7.8.6.</span> <span class="toc-text">收集集合 (CSet)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.7.8.7.</span> <span class="toc-text">G1收集器的常见操作步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.8.8.</span> <span class="toc-text">G1收集器的适用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BARegion%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="toc-number">2.7.8.9.</span> <span class="toc-text">分区Region：化整为零</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.8.10.</span> <span class="toc-text">G1垃圾回收器的回收过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Remembered-Set"><span class="toc-number">2.7.8.11.</span> <span class="toc-text">Remembered Set</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.7.8.11.1.</span> <span class="toc-text">解决方法：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BB%A3GC"><span class="toc-number">2.7.8.12.</span> <span class="toc-text">G1回收过程一：年轻代GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.8.13.</span> <span class="toc-text">G1回收过程二：并发标记过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9A%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-number">2.7.8.14.</span> <span class="toc-text">G1回收过程三：混合回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E5%8F%AF%E9%80%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9AFull-GC"><span class="toc-number">2.7.8.15.</span> <span class="toc-text">G1回收可选的过程四：Full GC</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.1.5.</span> <span class="toc-text">卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">JVM初始化步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">类加载器的层次</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CBootstrap-ClassLoader%EF%BC%89"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader%EF%BC%89"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CAppClassLoader%EF%BC%89"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">应用程序类加载器（系统类加载器，AppClassLoader）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96ClassLoader%E7%9A%84%E9%80%94%E5%BE%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">获取ClassLoader的途径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8DClassLoader"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">获取当前ClassLoader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84ClassLoader"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">获取当前线程上下文的ClassLoader </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9A%84ClassLoader"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">获取系统的ClassLoader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E8%80%85%E7%9A%84ClassLoader"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">获取调用者的ClassLoader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.4.</span> <span class="toc-text">类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">类加载有三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.2.</span> <span class="toc-text">Class.forName()和ClassLoader.loadClass()区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.2.</span> <span class="toc-text">Tomcat如何破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">为什么要打破双亲委派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tomcat%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AAWeb%E5%BA%94%E7%94%A8%E7%9A%84%E9%9A%94%E7%A6%BB"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">Tomcat如何实现多个Web应用的隔离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%EF%BC%9ABootstrap-ClassLoader-Extension-ClassLoader-CatalinaClassLoader-WebAppClassLoader-CommonClassLoader"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">顺序：Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt; CatalinaClassLoader -&gt; WebAppClassLoader -&gt; CommonClassLoader</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="发表于 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="发表于 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="发表于 2022-01-13 20:15:31">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2022-01-04T09:01:41.000Z" title="发表于 2022-01-04 17:01:41">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-01-02T11:57:45.000Z" title="发表于 2022-01-02 19:57:45">2022-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 初学者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>