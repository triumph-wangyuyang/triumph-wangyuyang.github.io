<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题 | Blog</title><meta name="author" content="初学者"><meta name="copyright" content="初学者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录比较常见的面试题。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://www.wyy-blog.cn/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="记录比较常见的面试题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ChMkJ1bKzZSICF95AAMQ9kMccxcAALJCQByq1gAAxEO818.jpg">
<meta property="article:published_time" content="2021-11-25T03:33:06.000Z">
<meta property="article:modified_time" content="2022-07-06T03:26:23.683Z">
<meta property="article:author" content="初学者">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ChMkJ1bKzZSICF95AAMQ9kMccxcAALJCQByq1gAAxEO818.jpg"><link rel="shortcut icon" href="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg"><link rel="canonical" href="https://www.wyy-blog.cn/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-06 11:26:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ChMkJ1bKzZSICF95AAMQ9kMccxcAALJCQByq1gAAxEO818.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T03:33:06.000Z" title="发表于 2021-11-25 11:33:06">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-06T03:26:23.683Z" title="更新于 2022-07-06 11:26:23">2022-07-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h1 id="问题：Java和C-的区别"><a href="#问题：Java和C-的区别" class="headerlink" title="问题：Java和C++的区别"></a>问题：Java和C++的区别</h1><blockquote>
<ol>
<li><code>Java</code>源码会先经过一次编译，成为中间码，中间码再被解释器解释成机器码。对于<code>Java</code>而言，中间码就是字节码<code>(.class)</code>，而解释器在<code>JVM</code>中内置了。</li>
<li><code>C++</code>源码一次编译，直接在编译的过程中链接了，形成了机器码。</li>
<li><code>C++</code>比<code>Java</code>执行速度快，但是<code>Java</code>可以利用<code>JVM</code>跨平台。</li>
<li><code>C++</code>中有指针，<code>Java</code>中没有，但是有引用。</li>
<li><code>C++</code>支持多继承，<code>Java</code>中类都是单继承的。但是继承都有传递性，同时<code>Java</code>中的接口是多继承，类对接口的实现也是多实现。</li>
<li><code>C++</code>中，开发需要自己去管理内存，但是<code>Java</code>中<code>JVM</code>有自己的<code>GC</code>机制，虽然有自己的<code>GC</code>机制，但是也会出现<code>OOM</code>和内存泄漏的问题。<code>C++</code>中有析构函数，<code>Java</code>中<code>Object</code>的<code>finalize</code>方法。</li>
<li><code>C++</code>运算符可以重载，但是<code>Java</code>中不可以。同时<code>C++</code>中支持强制自动转型，<code>Java</code>中不行，会出现<code>ClassCastException</code>（类型不匹配）。</li>
</ol>
</blockquote>
<h1 id="问题：Java是编译型语言还是解释型语言"><a href="#问题：Java是编译型语言还是解释型语言" class="headerlink" title="问题：Java是编译型语言还是解释型语言"></a>问题：Java是编译型语言还是解释型语言</h1><blockquote>
<p>​	由<code>Java</code>的代码执行过程 ，一个<code>Java</code> 代码的执行过程是由</p>
<p><code>.Java</code>–&gt;<code>.class</code>–&gt;<code>对应平台机器码</code>; <code>.Java</code>–&gt;<code>.class</code>是由 <code>Javac</code> 编译，这个过程符合编译型语言的特点（一次性编译，注意 并未编译为实际平台的机器码）</p>
<p><code>.class</code>–&gt;<code>对应平台机器码</code>的这一过程是由<code>JVM</code>解释执行（逐行解释为特定平台机器码）这一过程符合解释语言的特点 ；</p>
<p>所以我认为 <strong><code>Java</code>既是编译语言 ，又是解释语言</strong>。</p>
</blockquote>
<h1 id="问题：面向对象特性"><a href="#问题：面向对象特性" class="headerlink" title="问题：面向对象特性"></a>问题：面向对象特性</h1><blockquote>
<p>​	面向对象和面向过程是一种软件开发思想。</p>
<ul>
<li>面向过程就是<strong>分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了</strong>。</li>
<li>面向对象是<strong>把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成系统</strong>。</li>
<li>简而言之面向过程只用函数实现，面向对象是用类实现各个功能模块。</li>
</ul>
<p>面向对象的基本要素：封装、继承、多态。</p>
<p><strong>封装</strong>的目的是隐藏类的实现细节，对外只公布需要公开的属性和行为。在java中能使用private、default、protected、public四种访问修饰符来对外部的访问做限制。</p>
<p><strong>继承</strong>是子类可以继承父类的属性和行为。</p>
<p>　　构造方法不能继承</p>
<p>　　被private修饰的数据不能继承外</p>
<p>　　其他的都可以被继承</p>
<p><strong>多态</strong>是指<strong>父类对象中的同一个行为能在其多个子类对象中有不同的表现</strong>。继承、重写、父类引用指向子类对象是多态存在的必要条件。<strong>多态有两种机制：编译时多态、运行时多态</strong>，对应重载（overload）和重写（override）。简单说，重写是父子类中相同名字和参数的方法，但是拥有不同的实现；重载是指同一类中有多个同名的方法，但这些方法有着不同的参数（返回值随便相不相同），本质上这些方法签名是不一样的。</p>
</blockquote>
<h1 id="问题：JVM、JDK-和-JRE-有什么区别"><a href="#问题：JVM、JDK-和-JRE-有什么区别" class="headerlink" title="问题：JVM、JDK 和 JRE 有什么区别"></a>问题：JVM、JDK 和 JRE 有什么区别</h1><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/src=http___www.pianshen.com_images_862_a08d9ee969fcaa90eededee0c0fbcb8e.png&refer=http___www.pianshen.webp">	</p>
<p>​	JDK是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。</p>
<ul>
<li><code>JVM</code>(<code>JAVA</code>虚拟机)是运行<code>Java</code>字节码的虚拟机,通过编译<code>.java</code>文件为<code>.class</code>文件得到字节码文件<code>.class</code>文件包含<code>JVM</code>可以理解的字节码。</li>
<li>JDK(Java Development Kit) 是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar），JDK是java开发工具包。</li>
<li>JRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），JRE是指java运行环境。</li>
</ul>
</blockquote>
<h1 id="问题：Java如何实现跨平台"><a href="#问题：Java如何实现跨平台" class="headerlink" title="问题：Java如何实现跨平台"></a>问题：Java如何实现跨平台</h1><blockquote>
<p>​	同一个.class文件在不同的虚拟机会得到不同的机器指令（Windows和Linux的机器指令不同），但是最终执行的结果却是相同的</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/kmjnibuvfcdtxretyvubjomk,l.png"></p>
</blockquote>
<h1 id="问题：装箱与拆箱"><a href="#问题：装箱与拆箱" class="headerlink" title="问题：装箱与拆箱"></a>问题：装箱与拆箱</h1><blockquote>
<h6 id="1、何为包装类型"><a href="#1、何为包装类型" class="headerlink" title="1、何为包装类型"></a>1、何为包装类型</h6><p>​	Java是一种面向对象的语言，但是它不是纯面向对象的。Java中存在基本数据类型，谈不上对象。为了向纯面向对象靠拢，Java5的时候推出了基本数据类型的包装类型。</p>
<p>​	基本数据类型与包装类型的对应关系如下： </p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/kbhjghcfhhbkjnkvgucygvhbjnklmnbh.png"></p>
<hr>
<h6 id="2、何为装箱与拆箱"><a href="#2、何为装箱与拆箱" class="headerlink" title="2、何为装箱与拆箱"></a>2、何为装箱与拆箱</h6><p>​	装箱就是将基本数据类型转化为包装类型，那么拆箱就是将包装类型转化为基本数据类型。</p>
<p>​	以基本数据类型int为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//自动装箱，底层其实执行了Integer a=Integer.valueOf(1);</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//自动拆箱，底层其实执行了int b=a.intValue();</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	Integer的valueOf（int i）方法可以将一个基本数据类型转化为对应的包装类型，即装箱方法。</p>
<p>​	而Integer的intValue（）方法则可以将一个包装类型转化为对应的基本数据类型，即拆箱方法。</p>
<hr>
<h6 id="3、装箱与自动装箱的区别"><a href="#3、装箱与自动装箱的区别" class="headerlink" title="3、装箱与自动装箱的区别"></a>3、装箱与自动装箱的区别</h6><p>​	装箱：利用Integer的构造方法Integer（int value），即Integer c &#x3D; new Integer(1);</p>
<p>​	自动装箱：或者叫隐式装箱，直接给Integer赋值，即Integer d&#x3D;1,在编译的时候，会调用Integer.valueOf（）方法完成装箱。</p>
<p>​	相比而言，自动装箱可能比装箱具有更高的效率，体现在自动装箱的缓存上，下面从几道题目来讲自动装箱的缓存。</p>
<hr>
<h6 id="4、相关面试题目"><a href="#4、相关面试题目" class="headerlink" title="4、相关面试题目"></a>4、相关面试题目</h6><p>第一题：以下代码的输出结果为？（&#x3D;&#x3D;号两边如果都是引用类型的话，则判断它们是否指向同一个对象。如果都是基本数据类型的话，则判断它们的数值是否相等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 结果</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>​	为什么一个是true，一个是false呢？</p>
<p>​	刚才我们知道，Integer a&#x3D;100这条语句会触发自动装箱，而自动装箱的方法为Integer.valueOf（）方法，让我们去寻找这个方法，一探究竟。</p>
<p>​	观察Integer类的源码中的valueOf（）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">  return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以看得出，当i的值位于[-128,127]的时候，会直接返回Integer缓存数组中相应对象的引用，如果i大于127或小于-128，会重新创建一个Integer实例，并返回。</p>
<p>​	那么第一条式子a和b的值都在缓存范围内，因此他们指向同一个对象，因此返回true。c和d的值不在范围内，都是通过new创建出来的，因此不是同一个对象，返回false。</p>
<p>​	注意：Byte、Short、Integer、Long、Character的valueOf（）实现机制类似。</p>
<p>​	其中相同值的Byte比较永远返回true，因为byte取值范围就是[-128,127]。</p>
<p>​	Short、Integer、Long的valueOf（）基本一样，i的范围都需要在[-128,127]。</p>
<p>​	Character中i的范围只要小于等于127即可，因为char最小值为0，本来就大于等于-128。</p>
<p>​	但是Float、Double中的valueOf（），永远返回新创建的对象，因为一个范围内的整数是有限的，但是小数却是无限的，无法保存在缓存中。</p>
<p>​	Boolean中只有两个对象，要么是true的Boolean，要么是false的Boolean，只要boolean的值相同，Boolean就相等。</p>
<hr>
<p>第二题：以下代码的输出结果为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和数值类型判断==时，则触发包装类型的自动拆箱，转为数值类型的比较</span></span><br><span class="line">  System.out.println(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">300</span>) == <span class="number">300</span>);<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和数值类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算</span></span><br><span class="line">  System.out.println(c == (a + f));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和包装类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算</span></span><br><span class="line">  System.out.println(c == (a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只有对象类型才有equals方法，因此首先a,b触发包装类型的自动拆箱，转为数值类型的运算。</span></span><br><span class="line">  <span class="comment">//运算完，再将结果3自动装箱，Integer重写了equals,因此可以转为包装类型与包装类型的比较。</span></span><br><span class="line">  <span class="comment">//当两边的包装类型不一致时，必定返回false。</span></span><br><span class="line">  <span class="comment">//当两边的包装类型一致时,再进行拆箱，判断两者代表的数值是否相等。</span></span><br><span class="line">  System.out.println(c.equals(a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//不同数据类型的数值进行运算，首先会将低精度的数据类型转化为高精度的数据类型，即自动类型转换。</span></span><br><span class="line">  <span class="comment">//比如现在的int+long,会提升到long+long,再进行运算。</span></span><br><span class="line">  System.out.println(e == (a + d));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//==号两边类型不一致时，直接执行自动拆箱，比较之后的数值</span></span><br><span class="line">  System.out.println(e == (a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，拆箱，数值比较</span></span><br><span class="line">  System.out.println(e.equals(a + d));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，两边类型不一致，直接返回false</span></span><br><span class="line">  System.out.println(c.equals(a + d));<span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h6><p>​	如果想要深入了解自动装箱拆箱的过程，必须得反编译class文件，了解底层编译的细节，才可以解除自己此方面的疑问。1</p>
</blockquote>
<h1 id="问题：重载和重写的区别"><a href="#问题：重载和重写的区别" class="headerlink" title="问题：重载和重写的区别"></a>问题：重载和重写的区别</h1><blockquote>
<h6 id="1、overload（重载）"><a href="#1、overload（重载）" class="headerlink" title="1、overload（重载）"></a>1、overload（重载）</h6><ul>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li>
</ul>
<hr>
<h6 id="2、override（重写）"><a href="#2、override（重写）" class="headerlink" title="2、override（重写）"></a>2、override（重写）</h6><ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为final不能被重写。</li>
</ul>
</blockquote>
<h1 id="问题：a-a-b与a-b的区别"><a href="#问题：a-a-b与a-b的区别" class="headerlink" title="问题：a&#x3D;a+b与a+&#x3D;b的区别"></a>问题：a&#x3D;a+b与a+&#x3D;b的区别</h1><blockquote>
<p>​	<code>a=a+b</code>是加法运算，需要两次寻找地址，而<code>a+=b</code>是增量运算，有寄存器优先时 只有一次地址查找。</p>
<p>**<code>a += b</code>**执行实际过程实际是 <strong>是先计算出<code>a</code>的值，然后用一个temp对象存储，之后和b进行相加，然后将值赋值给a引用。</strong></p>
<p><strong><code>a = a+b</code> 的执行过程则是先计算 <code>a + b</code>，然后再赋值给a引用，给a引用的时候如果 引用a 有计算过程，则会再次计算。</strong></p>
<p><strong><code>+=</code>如果两边的操作数的精度不一样时会自动向低转化，如：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/20180607195102802.png"></p>
<p><strong>实际上和 <code>a = (short)（a+ 65536）</code>;是一样的。</strong></p>
<p><strong>而<code>a = a+b</code>则不会自动转化，需要手动进行强制类型转化。</strong></p>
</blockquote>
<h1 id="问题：String-equals-源码分析"><a href="#问题：String-equals-源码分析" class="headerlink" title="问题：String.equals()源码分析"></a>问题：String.equals()源码分析</h1><blockquote>
<p>​	String.equals()方法简单说就是判断地址值是否相等，如果相等，则返回true，如果不相等，则继续判断内容是否相同，如果存在任意一个字符不相同（区分大小写），则返回false。如果长度相同而且所有字符均相同，才被认定为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">		<span class="comment">//判断地址值是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">		<span class="comment">//判断对象类型是否为String</span></span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">			<span class="comment">//判断长度是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">          <span class="type">char</span> v1[] = value;</span><br><span class="line">          <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//每一个字符都必须相同</span></span><br><span class="line">              <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题：this关键字有什么作用"><a href="#问题：this关键字有什么作用" class="headerlink" title="问题：this关键字有什么作用"></a>问题：this关键字有什么作用</h1><blockquote>
<p>this是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。 </p>
<p>this的用法在Java中大体可以分为3种： </p>
<ul>
<li>普通的直接引用，this相当于是指向当前对象本身 </li>
<li>形参与成员变量名字重名，用this来区分：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.name=name; </span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用本类的构造函数</li>
</ul>
</blockquote>
<h1 id="问题：equals-和hashCode-区别"><a href="#问题：equals-和hashCode-区别" class="headerlink" title="问题：equals()和hashCode()区别"></a>问题：equals()和hashCode()区别</h1><blockquote>
<p>​	因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存,地址则相等，否则不相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。</p>
<p>​	对于Object类来说，不同Object对象的hashCode值是不同的（Object类的hashcode值表示的是对象的地址）</p>
<p>​	object对象中的 <code>public boolean equals(Object obj)</code>，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；</p>
<hr>
<p>​	注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p>
<ul>
<li>当<code>obj1.equals(obj2)</code>为<code>true</code>时，<code>obj1.hashCode() == obj2.hashCode()</code>必须为<code>true</code> </li>
<li>当<code>obj1.hashCode() == obj2.hashCode()</code>为<code>false</code>时，<code>obj1.equals(obj2)</code>必须为<code>false</code></li>
</ul>
<p>​	如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址hashcode是用于散列数据的快速存取，如利用HashSet&#x2F;HashMap&#x2F;Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p>
<p>​	这样如果我们对一个对象重写了<code>equals</code>，意思是只要对象的成员变量值都相等那么<code>euqals</code>就等于<code>true</code>，但不重写hashcode，那么我们再new一个新的对象，当<code>原对象.equals（新对象）</code>等于<code>true</code>时，两者的<code>hashcode</code>却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写<code>hashcode()</code></p>
</blockquote>
<h1 id="问题：equals-和-的区别"><a href="#问题：equals-和-的区别" class="headerlink" title="问题：equals 和 &#x3D;&#x3D; 的区别"></a>问题：equals 和 &#x3D;&#x3D; 的区别</h1><blockquote>
<p>对于 <code>==</code> 和 <code>!=</code> 这两个关系运算符来说，它们有两种使用场景：</p>
<ul>
<li>作用于基本数据类型： 比较的是值</li>
<li>作用于对象：比较的是内存地址</li>
</ul>
<p>它们的使用经常困扰 Java 的初学者。下面是代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    System.out.println(n1 == n2);</span><br><span class="line">    System.out.println(n1 != n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>尽管对象的内容一样，<code>n1</code> 和 <code>n2</code> 对象的引用却不一样。看到这输出结果估计很多同学都懵了，应该是先输出 <code>false</code>，再输出 <code>true</code> 啊。</p>
<p>你可以把上面的 47 都改成 128，你就会发现打印的结果变成了 <code>false true</code> 了。那么为什么会这样呢？</p>
<p>⭐ <strong>因为 <code>Integer</code> 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 <code>==</code> 和 <code>!=</code> 比较也能得到正确的结果，但是不推荐用关系运算符比较</strong>。</p>
<p>那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 <code>equals()</code> 方法，<strong>该方法用于判断两个对象是否具有相同的引用（地址）</strong>。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(n1.equals(n2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例的结果看起来是我们所期望的。但其实事情并非那么简单。下面我们来创建自己的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 equals() 方法没有比较内容</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsMethod2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        <span class="type">Value</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        v1.i = v2.i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(v1.equals(v2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例的结果再次令人困惑：结果是 <code>false</code>。</p>
<p>原因： <strong><code>Object</code> 类默认的 <code>equals()</code> 的行为是比较对象的引用而非具体内容</strong>。虽然 <code>v1</code> 和 <code>v2</code> 的内容相等，但是它们并不指向同一个地址。那为什么上述 Integer 类中的 equals 方法看起来比较的是值呢？</p>
<p>答：因为 Integer 类中重写了 equals 方法，它实际比较的就是值而不是引用。事实上，大部分类都会选择重写 equals 方法让其变成基于值的比较。</p>
<p>所以总结一下 <code>equals()</code>的两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 <code>equals()</code> 方法。则通过 <code>equals()</code> 比较该类的两个对象时，等价于通过 “&#x3D;&#x3D;” 比较这两个对象。</li>
<li>情况 2：类覆盖了 <code>equals()</code> 方法。一般来说，我们都会覆盖 <code>equals()</code> 方法来比较两个对象的内容而不是其引用</li>
</ul>
</blockquote>
<h1 id="问题：JDK8新特性"><a href="#问题：JDK8新特性" class="headerlink" title="问题：JDK8新特性"></a>问题：JDK8新特性</h1><blockquote>
<h6 id="1、Java-8-Lambda-表达式"><a href="#1、Java-8-Lambda-表达式" class="headerlink" title="1、Java 8 Lambda 表达式"></a>1、Java 8 Lambda 表达式</h6><p>​	Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p>
<hr>
<h6 id="2、接口的默认方法和静态方法"><a href="#2、接口的默认方法和静态方法" class="headerlink" title="2、接口的默认方法和静态方法"></a>2、接口的默认方法和静态方法</h6><p>​	Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>​	默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line"><span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line"><span class="comment">// may not implement (override) them.</span></span><br><span class="line"><span class="keyword">default</span> String <span class="title function_">notRequired</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Default implementation&quot;</span>; </span><br><span class="line">&#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OverridableImpl</span> <span class="keyword">implements</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">notRequired</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Overridden implementation&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Defaulable</strong>接口使用关键字<strong>default</strong>定义了一个默认方法<strong>notRequired()<strong>。</strong>DefaultableImpl</strong>类实现了这个接口，同时默认继承了这个接口中的默认方法；<strong>OverridableImpl</strong>类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">DefaulableFactory</span> &#123;</span><br><span class="line"><span class="comment">// Interfaces now allow static methods</span></span><br><span class="line"><span class="keyword">static</span> Defaulable <span class="title function_">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> &#123;</span><br><span class="line"><span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="3、使用元空间代替永久代"><a href="#3、使用元空间代替永久代" class="headerlink" title="3、使用元空间代替永久代"></a>3、使用元空间代替永久代</h6></blockquote>
<h1 id="问题：接口和抽象类的区别"><a href="#问题：接口和抽象类的区别" class="headerlink" title="问题：接口和抽象类的区别"></a>问题：接口和抽象类的区别</h1><blockquote>
<ol>
<li>接口使用关键字 interface 来定义。 抽象类使用关键字 abstract 来定义。</li>
<li>接口使用 implements 关键字定义其具体实现。 </li>
<li>抽象类使用 extends 关键字实现继承。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量。</li>
<li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li>
<li>抽象类中的抽象方法的访问类型可以是public，protected和默认类型。 </li>
<li>接口中方法的默认控制符是 public，并且不能定义为其他控制符。</li>
</ol>
</blockquote>
<h1 id="问题：静态变量和实例变量区别"><a href="#问题：静态变量和实例变量区别" class="headerlink" title="问题：静态变量和实例变量区别"></a>问题：静态变量和实例变量区别</h1><blockquote>
<ul>
<li><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。 </li>
<li><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</li>
</ul>
</blockquote>
<h1 id="问题：静态方法和实例方法区别"><a href="#问题：静态方法和实例方法区别" class="headerlink" title="问题：静态方法和实例方法区别"></a>问题：静态方法和实例方法区别</h1><blockquote>
<ul>
<li><strong>静态方法</strong>：static修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。 </li>
<li><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法。</li>
</ul>
</blockquote>
<h1 id="问题：深拷贝和浅拷贝"><a href="#问题：深拷贝和浅拷贝" class="headerlink" title="问题：深拷贝和浅拷贝"></a>问题：深拷贝和浅拷贝</h1><blockquote>
<ul>
<li><strong>浅拷贝：</strong>浅拷贝会创建一个新的对象，这个对象拥有被拷贝对象的一个精确的副本。在该类的成员变量中，对于基本数据类型，拷贝的就是其值；对于引用数据类型，拷贝的就是其内存地址。如果其中一个对象改变了这个引用数据类型的变量的数据，相应地，另一个对象地该引用数据类型地数据也会随之改变。</li>
<li><strong>深拷贝：</strong>深拷贝不仅会为拷贝新建对象，也会对该对象中任何的引用类型变量建立新的对象，这样，拷贝对象和原对象就是两个完全相同的对象，两者各自的成员变量也互不受影响了。</li>
</ul>
</blockquote>
<h1 id="问题：Java是值传递，还是引用传递"><a href="#问题：Java是值传递，还是引用传递" class="headerlink" title="问题：Java是值传递，还是引用传递"></a>问题：Java是值传递，还是引用传递</h1><blockquote>
<p><strong>Java是值传递</strong></p>
<p><strong>值传递：</strong>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p><strong>引用传递：</strong>“引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向同一块内存地址，对形参的操作会影响的真实内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      update(user);</span><br><span class="line">      System.out.println(user.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">  	user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/njbugcftdxcgbhjnivguyc.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">seven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">          user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">          update(user);</span><br><span class="line">          System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">          temp.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">          user = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/QQ%E6%88%AA%E5%9B%BE20220401145237.png"></p>
<p><strong>值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。</strong></p>
<p>实参：真实传给函数的参数</p>
<p>形参：函数名后括号中的变量</p>
</blockquote>
<h1 id="问题：Java-创建对象有哪几种方式"><a href="#问题：Java-创建对象有哪几种方式" class="headerlink" title="问题：Java 创建对象有哪几种方式"></a>问题：Java 创建对象有哪几种方式</h1><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/78b5dad5942e431c8c217b4b41024530.png"></p>
</blockquote>
<h1 id="问题：static关键字"><a href="#问题：static关键字" class="headerlink" title="问题：static关键字"></a>问题：static关键字</h1><blockquote>
<p>static 修饰的资源是属于类级别的，可以在没有对象的时候调用，只有一个副本，全局共享</p>
<p><strong>static</strong> <strong>修饰方法</strong>：静态方法。不依赖于对象就可以访问，可以直接类名.静态方法访问。静态方法不可以访问对象的非静态方法和非静态变量。</p>
<p><strong>static</strong> <strong>变量</strong>：静态变量被所有的对象所共享，在内存中只有一个副本，存在方法区中，当且仅当 在类初次加载时会被初始化。</p>
<p><strong>static</strong> <strong>静态代码块</strong>：在类被初次加载时执行，比如某个方法会new一个固定内容的对象，那么每次调用该方法就会new一次对象，于是可以将该对象放到 static 代码块里面提前初始化好，让该方法直接使用，这就提升了程序的性能了。</p>
<p><strong>static</strong> <strong>静态内部类</strong>:静态内部类和一般的类一致可以定义静态变量、方法、构造方法。静态内部类可以访问外部类所有的静态变量和方法。外部类可以用“this.静态内部类”方式可以在外部类访问静态内部类。</p>
</blockquote>
<h1 id="问题：final关键字"><a href="#问题：final关键字" class="headerlink" title="问题：final关键字"></a>问题：final关键字</h1><blockquote>
<p>final可以修饰变量、方法、类。</p>
<ul>
<li>final修饰变量：如果是基础数据类型的变量那么初始化后值不可改变，如果是引用类型则该变量不能在初始化后不可再指向其他对象。</li>
<li>final修饰方法：final修饰方法表示方法不可以被重写。private方法也是final的，final方法在编译时静态绑定，所以比非final方法快。</li>
<li>final修饰类：表示类不可被继承。（我们也可以将类的构造方法声明为private使得类不可被继承，若被继承，子类没法调用父类的构造方法出错）</li>
</ul>
</blockquote>
<h1 id="问题：Exception与Error"><a href="#问题：Exception与Error" class="headerlink" title="问题：Exception与Error"></a>问题：Exception与Error</h1><blockquote>
</blockquote>
<h1 id="问题：Java中的内部类"><a href="#问题：Java中的内部类" class="headerlink" title="问题：Java中的内部类"></a>问题：Java中的内部类</h1><blockquote>
</blockquote>
<h1 id="问题：RESTful"><a href="#问题：RESTful" class="headerlink" title="问题：RESTful"></a>问题：RESTful</h1><blockquote>
</blockquote>
<h1 id="问题：序列化与反序列化"><a href="#问题：序列化与反序列化" class="headerlink" title="问题：序列化与反序列化"></a>问题：序列化与反序列化</h1><blockquote>
<h4 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h4><blockquote>
<p><strong>序列化：</strong>把Java对象转换为字节序列的过程。对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p>
<p><strong>反序列化：</strong>把字节序列恢复为Java对象的过程。客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
</blockquote>
<h4 id="为什么需要序列化与反序列化"><a href="#为什么需要序列化与反序列化" class="headerlink" title="为什么需要序列化与反序列化"></a>为什么需要序列化与反序列化</h4><blockquote>
<p>​	我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p>
<p>​	那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！</p>
<p>​	换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p>
<p>​	当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<p>总的来说可以归结为以下几点：</p>
<p>（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br>（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；<br>（3）通过序列化在进程间传递对象；</p>
</blockquote>
<h4 id="序列化算法一般会按步骤做如下事情"><a href="#序列化算法一般会按步骤做如下事情" class="headerlink" title="序列化算法一般会按步骤做如下事情"></a>序列化算法一般会按步骤做如下事情</h4><blockquote>
<p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
</blockquote>
<blockquote>
<p>   1、实现序列化的必备要求：</p>
<pre><code>   只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） 
</code></pre>
<p>   2、JDK中序列化和反序列化的API：</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①java.io.ObjectInputStream：对象输入流。</span><br><span class="line"></span><br><span class="line">   该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</span><br><span class="line"></span><br><span class="line">②java.io.ObjectOutputStream：对象输出流。</span><br><span class="line"></span><br><span class="line">   该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</span><br></pre></td></tr></table></figure>

<p>   3、实现序列化和反序列化的三种实现：</p>
<p>   ①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 </span><br><span class="line">ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。</span><br></pre></td></tr></table></figure>

<p>   ②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。</span><br></pre></td></tr></table></figure>

<p>   ③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="序列化和反序列化的注意点"><a href="#序列化和反序列化的注意点" class="headerlink" title="序列化和反序列化的注意点"></a>序列化和反序列化的注意点</h4><blockquote>
<ol>
<li><p>序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
</li>
<li><p>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
</li>
<li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
</li>
<li><p>并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<ul>
<li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li>
<li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li>
</ul>
</li>
<li><p>声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
</li>
<li><p>序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ul>
</li>
<li><p>Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
</li>
<li><p>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
</li>
</ol>
<p>注意：浅拷贝请使用Clone接口的原型模式。</p>
</blockquote>
</blockquote>
<h1 id="问题：-Resource和-Autowire的区别"><a href="#问题：-Resource和-Autowire的区别" class="headerlink" title="问题：@Resource和@Autowire的区别"></a>问题：@Resource和@Autowire的区别</h1><blockquote>
<ul>
<li><p><code>@Resource</code>和<code>@Autowired</code>都可以用来装配<code>bean</code>，都可以用于字段或<code>setter</code>方法。</p>
</li>
<li><p><code>@Autowired</code><strong>默认按类型装配</strong>，默认情况下必须要求依赖对象必须存在，如果要允许<code>null</code>值，可以设置它的<code>required</code>属性为<code>false</code>。</p>
</li>
<li><p><code>@Resource</code><strong>默认按名称装配</strong>，当找不到与名称匹配的<code>bean</code>时才按照类型进行装配。名称可以通过<code>name</code>属性指定，如果没有指定<code>name</code>属性，当注解写在字段上时，默认取字段名，当注解写在<code>setter</code>方法上时，默认取属性名进行装配。</p>
</li>
</ul>
<hr>
<p><code>@Autowire</code>和<code>@Qualifier</code>配合使用效果和<code>@Resource</code>一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Autowired(required = false)</span> <span class="meta">@Qualifier(&quot;example&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Example example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource(name = &quot;example&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Example example;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="Resource装配顺序"><a href="#Resource装配顺序" class="headerlink" title="@Resource装配顺序"></a>@Resource装配顺序</h6><ol>
<li>如果同时指定name和type，则从容器中查找唯一匹配的bean装配，找不到则抛出异常</li>
<li>如果指定name属性，则从容器中查找名称匹配的bean装配，找不到则抛出异常</li>
<li>如果指定type属性，则从容器中查找类型唯一匹配的bean装配，找不到或者找到多个抛出异常</li>
<li>如果都不指定，则自动按照byName方式装配，如果没有匹配，则回退一个原始类型进行匹配，如果匹配则自动装配</li>
</ol>
</blockquote>
<h1 id="问题：count-1-、count-与count-列名-的执行区别"><a href="#问题：count-1-、count-与count-列名-的执行区别" class="headerlink" title="问题：count(1)、count(*)与count(列名)的执行区别"></a>问题：count(1)、count(*)与count(列名)的执行区别</h1><blockquote>
<ul>
<li><strong>count(*)包括了所有的列，相当于行数</strong>，在统计结果的时候， <strong>不会忽略列值为NULL</strong> </li>
<li>**count(1)**包括了忽略所有列，用1代表代码行，在统计结果的时候， <strong>不会忽略列值为NULL</strong>  </li>
<li>**count(列名)**只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， <strong>即某个字段值为NULL时，不统计</strong>。</li>
<li>列名为主键，count(列名)会比count(1)快  </li>
<li>列名不为主键，count(1)会比count(列名)快</li>
</ul>
</blockquote>
<h1 id="问题：new一个对象的过程"><a href="#问题：new一个对象的过程" class="headerlink" title="问题：new一个对象的过程"></a>问题：new一个对象的过程</h1><blockquote>
<ul>
<li><strong>之前没有进行类加载</strong></li>
</ul>
<ol>
<li>类加载,同时初始化类中静态的属性(赋默认值)</li>
<li>执行静态代码块</li>
<li>分配内存空间,同时初始化非静态的属性(赋默认值)</li>
<li>调用父类构造器</li>
<li>父类构造器执行完后,如果自己声明属性的同时有显示的赋值,那么进行显示赋值把默认值覆盖</li>
<li>执行匿名代码块</li>
<li>执行构造器</li>
<li>返回内存地址</li>
</ol>
<hr>
<ul>
<li><strong>之前已经进行了类加载</strong></li>
</ul>
<ol>
<li>分配内存空间,同时初始化非静态的属性(赋默认值)</li>
<li>调用父类构造器</li>
<li>父类构造器执行完后,如果自己声明属性的同时有显示的赋值,那么进行显示赋值把默认值覆盖</li>
<li>执行匿名代码块</li>
<li>执行构造器</li>
<li>返回内存地址</li>
</ol>
<hr>
<ol>
<li><p>当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能 <strong>在常量池中能否定位到一个类的符号引用</strong> （即类的带路径全名），并且检查这个符号引用代表的类是否已被加载、解析和初始化过，即<strong>验证是否是第一次使用该类</strong>。如果没有（不是第一次使用），那必须先执行相应的类加载过程（class.forname()）。</p>
</li>
<li><p>在类加载检查通过后，接下来虚拟机将 <strong>为新生的对象分配内存</strong> 。对象所需的内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式，根据使用的垃圾收集器的不同使用不同的分配机制：</p>
</li>
</ol>
<p>　　2.1. <strong>指针碰撞</strong>（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<p>　　2.2. <strong>空闲列表</strong>（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。</p>
<ol start="3">
<li><p>内存分配完后，虚拟机需要将分配到的内存空间中的数据类型都 <strong>初始化为零值（不包括对象头）</strong>；</p>
</li>
<li><p>虚拟机要 <strong>对对象头进行必要的设置</strong> ，例如这个对象是哪个类的实例（即所属类）、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。</p>
</li>
</ol>
<p>至此，从虚拟机视角来看，一个新的对象已经产生了。但是在Java程序视角来看，执行new操作后会接着执行如下步骤：</p>
<ol start="5">
<li><p><strong>调用对象的init()方法</strong> ,根据传入的属性值给对象属性赋值。</p>
</li>
<li><p>在线程 <strong>栈中新建对象引用</strong> ，并指向堆中刚刚新建的对象实例。</p>
</li>
</ol>
</blockquote>
<h1 id="问题：多进程与多线程"><a href="#问题：多进程与多线程" class="headerlink" title="问题：多进程与多线程"></a>问题：多进程与多线程</h1><blockquote>
<table>
<thead>
<tr>
<th align="center">对比维度</th>
<th align="center">多进程</th>
<th align="center">多线程</th>
<th align="center">总结</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据共享、同步</td>
<td align="center">数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td align="center">因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td align="center">各有优势</td>
</tr>
<tr>
<td align="center">内存、CPU</td>
<td align="center">占用内存多，切换复杂，CPU利用率低</td>
<td align="center">占用内存少，切换简单，CPU利用率高</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td align="center">创建销毁、切换</td>
<td align="center">创建销毁、切换复杂，速度慢</td>
<td align="center">创建销毁、切换简单，速度很快</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td align="center">编程、调试</td>
<td align="center">编程简单，调试简单</td>
<td align="center">编程复杂，调试复杂</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">进程间不会互相影响</td>
<td align="center">一个线程挂掉将导致整个进程挂掉</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">分布式</td>
<td align="center">适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td align="center">适应于多核分布式</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">nginx主流的工作模式是多进程模式（也支持多线程模型） <br/>几乎所有的web server服务器服务都有多进程</td>
<td align="center">需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）<br/>需要进行大量计算的优先使用线程（CPU频繁切换）</td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
<h1 id="问题：HTTP-1-0、HTTP-1-1、HTTP-2-0"><a href="#问题：HTTP-1-0、HTTP-1-1、HTTP-2-0" class="headerlink" title="问题：HTTP 1.0、HTTP 1.1、HTTP 2.0"></a>问题：HTTP 1.0、HTTP 1.1、HTTP 2.0</h1><blockquote>
<h4 id="HTTP-1-0-HTTP-1-1区别"><a href="#HTTP-1-0-HTTP-1-1区别" class="headerlink" title="HTTP 1.0 HTTP 1.1区别"></a>HTTP 1.0 HTTP 1.1区别</h4><blockquote>
<h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>​	HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>​	HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p>
<h5 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h5><p>​	HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>​	这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>​	另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<h5 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h5><p>​	现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>​	HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
</blockquote>
<h4 id="HTTP1-1-HTTP-2-0区别"><a href="#HTTP1-1-HTTP-2-0区别" class="headerlink" title="HTTP1.1 HTTP 2.0区别"></a>HTTP1.1 HTTP 2.0区别</h4><blockquote>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>​	HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>​	当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>​	TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/cfvgbhnfjmnhgdfsfvggtrhytujtyrter.jpg"></p>
<h5 id="头部数据压缩"><a href="#头部数据压缩" class="headerlink" title="头部数据压缩"></a>头部数据压缩</h5><p>​	在HTTP1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
<p>​	HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p>​	服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p>
<p>​	为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/gthytrytuilkrtytrgethyjuydcfgthyujy.jpg"></p>
</blockquote>
</blockquote>
<h1 id="问题：HTTP请求方法"><a href="#问题：HTTP请求方法" class="headerlink" title="问题：HTTP请求方法"></a>问题：HTTP请求方法</h1><blockquote>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/11-07-58-fcdctfybhnjmk,l0wNV4a.png"></p>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>GET 是最常用的 HTTP 请求方***显示请求指定的资源，并返回响应主体，一般对它的期望是安全且幂等的。</p>
<p>所谓安全是指该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改和增加数据，不会影响资源的状态。</p>
<blockquote>
<p>这里安全的含义仅仅是指是非修改信息。</p>
</blockquote>
<p>幂等的概念简单点来说，就是指对同一个 URL 的多个请求应该返回同样的结果。</p>
<p>查询字符串（名称&#x2F;值对）是在 GET 请求的 URL 中发送的，在 URL 后加 <code>?</code> 连接查询字符串，多条查询字符串通过 <code>&amp;</code> 来连接，比如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;https://cn.bing.com/search?q=%E7%BC%96%E7%A8%8B%E4%B8%89%E6%98%A7&amp;PC=U316&amp;FORM=CHROMN</span><br></pre></td></tr></table></figure>

<h3 id="GET-请求的一些其他特性："><a href="#GET-请求的一些其他特性：" class="headerlink" title="GET 请求的一些其他特性："></a>GET 请求的一些其他特性：</h3><ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据（不修改）</li>
</ul>
<h2 id="HEAD-方法"><a href="#HEAD-方法" class="headerlink" title="HEAD 方法"></a>HEAD 方法</h2><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回头部消息。</p>
<p>它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据），对资源的首部进行检查，比如：</p>
<ul>
<li>如果 GET &#x2F;users 返回用户列表，</li>
<li>那么 HEAD &#x2F;users 将发出相同的请求，但不会返回用户列表。</li>
</ul>
<h3 id="HEAD-方法的使用场景"><a href="#HEAD-方法的使用场景" class="headerlink" title="HEAD 方法的使用场景"></a>HEAD 方法的使用场景</h3><ul>
<li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li>
<li>通过查看响应中的状态码，可以确定资源是否存在；</li>
<li>通过查看首部，测试资源是否被修改。</li>
</ul>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>POST 方法用于向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件），数据被包含在请求本文中。</p>
<p>POST 请求可能会创建新的资源或修改现有资源，或二者皆有。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。</p>
<h3 id="浏览器发出的POST请求的body的主要格式"><a href="#浏览器发出的POST请求的body的主要格式" class="headerlink" title="浏览器发出的POST请求的body的主要格式"></a>浏览器发出的POST请求的body的主要格式</h3><ul>
<li><strong>application&#x2F;x-www-form-urlencoded</strong> 用来传输简单的数据，如 “key1&#x3D;value1&amp;key2&#x3D;value2” 这样的格式。</li>
<li><strong>multipart&#x2F;form-data</strong> 主要用来传输文件内容。</li>
<li><strong>application&#x2F;json</strong> 告诉服务端消息主体是序列化后的 JSON 字符串。</li>
<li><strong>text&#x2F;plain</strong> 纯文本格式</li>
</ul>
<blockquote>
<p>采用 multipart&#x2F;form-data 是因为 application&#x2F;x-www-form-urlencoded 的编码方式对于文件这种二进制的数据非常低效。</p>
</blockquote>
<blockquote>
<p>除了原生的content-type，开发人员也可以完全自定义数据提交格式！</p>
</blockquote>
<h3 id="POST-请求的其他特性："><a href="#POST-请求的其他特性：" class="headerlink" title="POST 请求的其他特性："></a>POST 请求的其他特性：</h3><ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h2><p>PUT 方法用于将数据发送到服务器来创建&#x2F;更新资源。</p>
<p>PUT 与 POST 方法的区别在于，PUT 方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次 POST 方法可能会有副作用，比如将一个订单重复提交多次。</p>
<h3 id="PUT-方法可能的响应"><a href="#PUT-方法可能的响应" class="headerlink" title="PUT 方法可能的响应"></a>PUT 方法可能的响应</h3><ul>
<li>如果目标资源不存在，并且PUT方法成功创建了一份，那么源头服务器必须返回 201(<code>Created</code>) 来通知客户端资源已创建。</li>
<li>如果目标资源已经存在，并且依照请求中封装的表现形式成功进行了更新，那么，源头服务器必须返回 200 (<code>OK</code>) 或者 204 (<code>No Content</code>) 来表示请求的成功完成。</li>
</ul>
<h2 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h2><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。但是，客户端无法保证删除操作一定会被执行，因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。</p>
<h3 id="DELETE-方法可能的响应码"><a href="#DELETE-方法可能的响应码" class="headerlink" title="DELETE 方法可能的响应码"></a>DELETE 方法可能的响应码</h3><p>如果 DELETE 方法成功执行，那么可能会有以下几种状态码：</p>
<ul>
<li>状态码 202 (Accepted) 表示请求的操作可能会成功执行，但是尚未开始执行。</li>
<li>状态码 204 (No Content) 表示操作已执行，但是无进一步的相关信息。</li>
<li>状态码 200 (OK) 表示操作已执行，并且响应中提供了相关状态的描述信息。</li>
</ul>
<h2 id="TRACE-方法"><a href="#TRACE-方法" class="headerlink" title="TRACE 方法"></a>TRACE 方法</h2><p>TRACE 方法实现沿通向目标资源的路径的消息“回环”（loop-back）测试 ，提供了一种实用的 debug 机制。</p>
<p>请求的最终接收者应当原样反射（reflect）它接收到的消息，作为一个 Content-Type 为 message&#x2F;http 的200（OK）响应的消息的主体（body）返回给客户端 。</p>
<blockquote>
<p>最终接收者是指初始（origin）服务器，或者第一个接收到 Max-Forwards 值为 0的请求的服务器。</p>
</blockquote>
<p>我们都知道，客户端在发起一个请求时，这个请求可能要穿过***、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的 HTTP 请求。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看 HTTP 请求报文在发送的途中，是否被修改过了。</p>
<h2 id="PATCH-方法"><a href="#PATCH-方法" class="headerlink" title="PATCH 方法"></a>PATCH 方法</h2><p>在HTTP协议中，请求方法 PATCH 用于对资源进行部分修改。</p>
<p>在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于 PUT 方法，而与 POST 方法类似，PATCH 方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p>
<p>要判断一台服务器是否支持 PATCH 方法，那么就看它是否将其添加到了响应首部 Allow 或者 Access-Control-Allow-Methods （在跨域访问的场合，CORS）的方法列表中 。</p>
<p>另外一个支持 PATCH 方法的隐含迹象是 Accept-Patch 首部的出现，这个首部明确了服务器端可以接受的补丁文件的格式。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>204 状态码表示这是一个操作成功的响应，因为响应中不带有消息主体。</p>
<h2 id="OPTIONS-方法"><a href="#OPTIONS-方法" class="headerlink" title="OPTIONS 方法"></a>OPTIONS 方法</h2><p>OPTIONS 方法用于获取目的资源所支持的通信选项。</p>
<p>客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</p>
<p>若请求成功，则它会在 HTTP 头中包含一个名为 “Allow” 的头，值是所支持的方法，如 “GET, POST”。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>可以使用 OPTIONS 方法对服务器发起请求，以检测服务器支持哪些 HTTP 方法，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;HTTP/1.1 200 OK``Allow: OPTIONS, GET, HEAD, POST``Cache-Control: max-age=604800``Date: Thu, 13 Oct 2016 11:45:00 GMT``Expires: Thu, 20 Oct 2016 11:45:00 GMT``Server: EOS (lax004/2813)``x-ec-custom-error: 1``Content-Length: 0</span><br></pre></td></tr></table></figure>

<h2 id="CONNECT-方法"><a href="#CONNECT-方法" class="headerlink" title="CONNECT 方法"></a>CONNECT 方法</h2><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 HTTP 方法的内容总结，根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</p>
</blockquote>
<h1 id="问题：GET-和-POST-的区别"><a href="#问题：GET-和-POST-的区别" class="headerlink" title="问题：GET 和 POST 的区别"></a>问题：GET 和 POST 的区别</h1><blockquote>
<p>（1）GET 参数通过 <strong>url</strong> 传递，POST 放在 <strong>request body</strong> 中。</p>
<p>（2）GET 请求在 url 中传递的参数是有长度限制的，而 post 没有。</p>
<p>（3）<strong>GET 比 POST 更不安全</strong>，因为参数直接暴露在 url 中，所以不能用来传递敏感信息；POST 不会作为 url 的一部分，不会被缓存，保存在服务器日志以及在浏览器浏览记录中。</p>
<p>（4）GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</p>
<p>（5）GET 请求会浏览器主动缓存。</p>
<p>（6）<strong>GET 请求参数会被完整保留在浏览历史记录里</strong>，而 post 中的参数不会被保留。</p>
<p>（7）GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。<strong>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包</strong>。浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p>
<p>GET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存；</p>
<p>POST 不同，POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此，GET 请求适合于做请求缓存。</p>
</blockquote>
<h1 id="问题：HTTP状态码"><a href="#问题：HTTP状态码" class="headerlink" title="问题：HTTP状态码"></a>问题：HTTP状态码</h1><blockquote>
<h4 id="一、状态码告知从服务器端返回的请求结果"><a href="#一、状态码告知从服务器端返回的请求结果" class="headerlink" title="一、状态码告知从服务器端返回的请求结果"></a>一、状态码告知从服务器端返回的请求结果</h4><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p>表：状态码的类别</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>只要遵守状态码类别的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<p>仅记录在RFC2616上的HTTP状态码就达40种，若再加上WebDAV（Web-based DistributedAuthoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842）和附加HTTP状态码（RFC6585）等扩展，数量就达60余种。别看种类繁多，实际上经常使用的大概只有14种。接下来，我们就介绍一下这些具有代表性的14个状态码。</p>
<h4 id="二、2XX成功"><a href="#二、2XX成功" class="headerlink" title="二、2XX成功"></a>二、2XX成功</h4><p>2XX的响应结果表明请求被正常处理了。</p>
<h5 id="2-1、-200-OK"><a href="#2-1、-200-OK" class="headerlink" title="2.1、 200 OK"></a>2.1、 200 OK</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/dfsgsbtarfgtynumytrty.png"></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。</p>
<h5 id="2-2、-204-No-Content"><a href="#2-2、-204-No-Content" class="headerlink" title="2.2、 204 No Content"></a>2.2、 204 No Content</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435001563_2B8Cdsafasd.png"></p>
<p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<h5 id="2-3、-206-Partial-Content"><a href="#2-3、-206-Partial-Content" class="headerlink" title="2.3、 206 Partial Content"></a>2.3、 206 Partial Content</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_15914350.fdsfd.png"></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
<h4 id="三、3XX重定向"><a href="#三、3XX重定向" class="headerlink" title="三、3XX重定向"></a>三、3XX重定向</h4><p>​	3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h5 id="3-1、301-Moved-Permanently"><a href="#3-1、301-Moved-Permanently" class="headerlink" title="3.1、301 Moved Permanently"></a>3.1、301 Moved Permanently</h5><p>​	永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</p>
<p>像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠“&#x2F;”，就会产生301状态码。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200606/321375129_1591435001715_DE0B2B36D620C93C14CD95A779FF2F96" alt="img"></p>
<h5 id="3-2、302-Found"><a href="#3-2、302-Found" class="headerlink" title="3.2、302 Found"></a>3.2、302 Found</h5><p>​	临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。</p>
<p>​	和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI。</p>
<h5 id="3-3、303-See-Other"><a href="#3-3、303-See-Other" class="headerlink" title="3.3、303 See Other"></a>3.3、303 See Other</h5><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p>
<p>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<p>301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。</p>
<h5 id="3-4、-304-Not-Modified"><a href="#3-4、-304-Not-Modified" class="headerlink" title="3.4、 304 Not Modified"></a>3.4、 304 Not Modified</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435001817_8dvbryntuyrtere.png"></p>
<p>​	该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</p>
<h5 id="3-5、-307-Temporary-Redirect"><a href="#3-5、-307-Temporary-Redirect" class="headerlink" title="3.5、 307 Temporary Redirect"></a>3.5、 307 Temporary Redirect</h5><p>​	临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h4 id="四、4XX客户端错误"><a href="#四、4XX客户端错误" class="headerlink" title="四、4XX客户端错误"></a>四、4XX客户端错误</h4><p>​	4XX的响应结果表明客户端是发生错误的原因所在。</p>
<h5 id="4-1、-400-Bad-Request"><a href="#4-1、-400-Bad-Request" class="headerlink" title="4.1、 400 Bad Request"></a>4.1、 400 Bad Request</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_15914350019yrterfgthyuyky.png"></p>
<p>​	该状态示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码。</p>
<h5 id="4-2、-401-Unauthorized"><a href="#4-2、-401-Unauthorized" class="headerlink" title="4.2、 401 Unauthorized"></a>4.2、 401 Unauthorized</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002039_2856B3352hyejtyteres.png"></p>
<p>​	该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p>
<p>​	返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p>
<h5 id="4-3、-403-Forbidden"><a href="#4-3、-403-Forbidden" class="headerlink" title="4.3、 403 Forbidden"></a>4.3、 403 Forbidden</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002136_93B3D78FEEEA80vfdcasx.png"></p>
<p>​	该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。</p>
<h5 id="4-4、-404-Not-Found"><a href="#4-4、-404-Not-Found" class="headerlink" title="4.4、 404 Not Found"></a>4.4、 404 Not Found</h5><p>​	该状态码表明服务器上无法找到请求的资源或是服务器无法回应且不知原因。。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<h4 id="五、5XX服务器错误"><a href="#五、5XX服务器错误" class="headerlink" title="五、5XX服务器错误"></a>五、5XX服务器错误</h4><p>5XX的响应结果表明服务器本身发生错误。</p>
<h5 id="5-1、-500-Internal-Server-Error"><a href="#5-1、-500-Internal-Server-Error" class="headerlink" title="5.1、 500 Internal Server Error"></a>5.1、 500 Internal Server Error</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002223_FB81F7gfvdcasdf.png"></p>
<p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p>
<h5 id="5-2、-503-Service-Unavailable"><a href="#5-2、-503-Service-Unavailable" class="headerlink" title="5.2、 503 Service Unavailable"></a>5.2、 503 Service Unavailable</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002223_FB81F7gfvdcasdf.png"></p>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p>
<h4 id="状态码和状况的不一致"><a href="#状态码和状况的不一致" class="headerlink" title="状态码和状况的不一致"></a>状态码和状况的不一致</h4><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到。</p>
<h4 id="HTTP状态码大全"><a href="#HTTP状态码大全" class="headerlink" title="HTTP状态码大全"></a>HTTP状态码大全</h4><p>基本涵盖了所有问题<br>HTTP 400 – 请求无效<br>HTTP 401.1 – 未授权：登录失败<br>HTTP 401.2 – 未授权：服务器配置问题导致登录失败<br>HTTP 401.3 – ACL 禁止访问资源<br>HTTP 401.4 – 未授权：授权被筛选器拒绝<br>HTTP 401.5 – 未授权：ISAPI 或 CGI 授权失败</p>
<p>HTTP 403 – 禁止访问<br>HTTP 403 – 对 Internet 服务管理器 的访问仅限于 Localhost<br>HTTP 403.1 禁止访问：禁止可执行访问<br>HTTP 403.2 – 禁止访问：禁止读访问<br>HTTP 403.3 – 禁止访问：禁止写访问<br>HTTP 403.4 – 禁止访问：要求 SSL<br>HTTP 403.5 – 禁止访问：要求 SSL 128<br>HTTP 403.6 – 禁止访问：IP 地址被拒绝<br>HTTP 403.7 – 禁止访问：要求客户证书<br>HTTP 403.8 – 禁止访问：禁止站点访问<br>HTTP 403.9 – 禁止访问：连接的用户过多<br>HTTP 403.10 – 禁止访问：配置无效<br>HTTP 403.11 – 禁止访问：密码更改<br>HTTP 403.12 – 禁止访问：映射器拒绝访问<br>HTTP 403.13 – 禁止访问：客户证书已被吊销<br>HTTP 403.15 – 禁止访问：客户访问许可过多<br>HTTP 403.16 – 禁止访问：客户证书不可信或者无效<br>HTTP 403.17 – 禁止访问：客户证书已经到期或者尚未生效 HTTP 404.1 -</p>
<p>无法找到 Web 站点<br>HTTP 404- 无法找到文件<br>HTTP 405 – 资源被禁止<br>HTTP 406 – 无法接受<br>HTTP 407 – 要求***身份验证<br>HTTP 410 – 永远不可用<br>HTTP 412 – 先决条件失败<br>HTTP 414 – 请求 – URI 太长</p>
<p>HTTP 500 – 内部服务器错误<br>HTTP 500.100 – 内部服务器错误 – ASP 错误<br>HTTP 500-11 服务器关闭<br>HTTP 500-12 应用程序重新启动<br>HTTP 500-13 – 服务器太忙<br>HTTP 500-14 – 应用程序无效<br>HTTP 500-15 – 不允许请求 global.asa<br>Error 501 – 未实现<br>HTTP 502 – 网关错误</p>
</blockquote>
<h1 id="问题：HTTP请求的完全过程"><a href="#问题：HTTP请求的完全过程" class="headerlink" title="问题：HTTP请求的完全过程"></a>问题：HTTP请求的完全过程</h1><blockquote>
<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h4><p>在浏览器的地址栏输入一个 URL 后回车，背后到底发生了什么才能使得一个界面完美的展现在我们眼前？</p>
<p>今天讲解的这道题目，由于其涉及大量网络协议，可以非常直观的看出诸位小伙伴对计算机网络体系的整体把握程度，所以自然成为了各大公司的面试常客。</p>
<p>在浏览中输入 URL 并且获取响应的过程，其实就是浏览器和该 URL 对应的服务器的网络通信过程。比如我们输入 <code>www.baidu.com</code>，那么会返回一个百度搜索的界面，这其实就是浏览器和百度服务器之间的网络通信过程。浏览器就是客户端，用于发出请求，而百度的服务器就是服务端，用于接收并响应请求。</p>
<p>下面我们就来详细讲解这个庞大的网络通信过程。</p>
<h4 id="1-解析-URL"><a href="#1-解析-URL" class="headerlink" title="1. 解析 URL"></a>1. 解析 URL</h4><p>不知道有没有同学会混淆域名和 URL 的概念，可以这样理解，URL 就是我们输入的网址，而网址里面含有域名。举个例子：<code>www.baidu.com/veal98</code> 是一个网址，而 <code>www.baidu.com</code> 就是服务器的域名。</p>
<p>URL 各元素的组成如下（当然，下述请求文件的路径名可以省略）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020dfgbfhngfbdbgnumnhg7210245.png"></p>
<p>这个 URL 请求的目标服务器上的文件路径就是：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210207bghngbdfnhngbfdgnhmhngbdfv210750.png"></p>
<p>那么首先，浏览器做的第一步就是解析 URL 得到里面的参数，将域名和需要请求的资源分离开来，从而了解需要请求的是哪个服务器，请求的是服务器上什么资源等等。</p>
<h4 id="2-浏览器封装-HTTP-请求报文"><a href="#2-浏览器封装-HTTP-请求报文" class="headerlink" title="2. 浏览器封装 HTTP 请求报文"></a>2. 浏览器封装 HTTP 请求报文</h4><p>对 <code>URL</code> 进行解析之后，浏览器确定了目标服务器和文件名，接下来就需要根据这些消息<strong>封装</strong>成一个 HTTP 请求报文发送出去。举个 HTTP 请求报文的例子：</p>
<blockquote>
<p>关于 HTTP 协议详细可见 HTTP 协议的前世今生 这篇文章，这里不再赘述</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020721bgnbgvvbnbtrecrvtbynt2035.png"></p>
<p>解释一下<strong>封装</strong>，这是一个贯穿整个计算机网络的概念。就是说发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层就会把该层对应的首部信息消去。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020fvgytrfegtsyumyiuytrertytu7230329.png"></p>
<h4 id="3-DNS-域名解析获取-IP-地址"><a href="#3-DNS-域名解析获取-IP-地址" class="headerlink" title="3. DNS 域名解析获取 IP 地址"></a>3. DNS 域名解析获取 IP 地址</h4><p>封装好 HTTP 请求报文后，在正式还有一项准备工作没有做，那就是获取目标服务器的 IP 地址。</p>
<p>虽然解析得到了域名，理论浏览器已经知道目标服务器是谁了。但是实际上，域名并不是目标服务器真正意义上的地址，互联网上每一台计算机都被全世界唯一 IP 地址标识着，但是 IP 地址并不方便记忆，所以才设计出了域名。</p>
<p>那么就需要解析域名获取目标服务器的 IP 地址。不然空有一个方便记忆的域名咋知道这个请求到底发送到哪里去呢。由域名转换得到 IP 地址就是 DNS 协议做的事情，如下：</p>
<blockquote>
<p>关于 DNS 详细的内容各位可以回顾 超详细 DNS 协议解析 这篇文章，比如什么是域名，域名服务器，递归查询和迭代查询等等，写的已经足够详细，此处只列出 DNS 的解析过程。</p>
</blockquote>
<p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护着一张域名与 IP 地址的对应表；</p>
<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>
<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>
<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>
<ul>
<li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>
<li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>
<p>配合下图直观理解：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021vfrytujjtrhtergtryjtukyikutjrtegr0120123619.png"></p>
<p>需要注意的是，DNS 使用的是 UDP 协议，也就是说上面各种请求的转发，都是基于 UDP 这个无连接协议的。</p>
<h4 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h4><p>获取到了目标服务器的 IP 地址之后，浏览器就知道我等下请求要发给谁了，这个时候就可以开始发送封装好了的 HTTP 请求报文了，那么既然需要发送请求，必然就需要 TCP 通过三次握手为浏览器和服务器之间建立可靠的连接，<strong>保证双方都具有可靠的接收和发送能力</strong>。</p>
<blockquote>
<p>这里又是一道经典的面试题：TCP 三次握手和四次挥手，详细可见 关于 TCP 三次握手和四次挥手，满分回答在此 这篇文章。</p>
</blockquote>
<p>三次握手过程如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210dvfbrytujyikyujhrterewfgethryjuk107175526.png"></p>
<h4 id="5-浏览器发送请求"><a href="#5-浏览器发送请求" class="headerlink" title="5. 浏览器发送请求"></a>5. 浏览器发送请求</h4><p>TCP 三次握手完成后，浏览器与目标服务器之间就建立了一个可靠的虚拟通道，于是浏览器就可以发送自己的 HTTP 请求了。</p>
<p>需要注意的是，HTTP 请求报文或者响应报文在 TCP 连接通道上进行传输的时候，由于这些报文比较大，为了更容易和准确可靠的传输，<strong>TCP 会将 HTTP 报文按序号分割成若干报文段并加上 TCP 首部，分别进行传输。接收方在收到这些报文段后，按照序号以原来的顺序重组 HTTP 报文</strong>。</p>
<h4 id="6-负责传输的-IP-协议"><a href="#6-负责传输的-IP-协议" class="headerlink" title="6. 负责传输的 IP 协议"></a>6. 负责传输的 IP 协议</h4><p>实际上，TCP 在三次握手建立连接、四次握手断开连接、以及连接建立过程中的收发数据（TCP 报文段）等各阶段操作时，都是通过 IP 协议进行传输的，IP 协议将这些阶段的数据添加 IP 首部封装成 IP 数据报再进行传输。</p>
<p>IP 数据报的首部存有<strong>源 IP 地址</strong>和 <strong>目标 IP 地址</strong>。所谓源 IP 地址 就是发送方的 IP 地址；目标 IP 地址就是通过 DNS 域名解析得到的目标服务器的 IP 地址。</p>
<p>事实上，<strong>IP 协议身处的网络层规定的是：数据报要通过怎样的路径（传输路线）才能到达对方计算机，并传送给对方</strong>。不理解这句话的详细解释马上就来，继续往下读。</p>
<h4 id="7-使用-ARP-协议凭借-MAC-地址通信"><a href="#7-使用-ARP-协议凭借-MAC-地址通信" class="headerlink" title="7. 使用 ARP 协议凭借 MAC 地址通信"></a>7. 使用 ARP 协议凭借 MAC 地址通信</h4><blockquote>
<p>关于 IP 协议、IP 地址、MAC 地址等详细请看 别再恐惧 IP 协议（万字长文 | 多图预警） 这篇文章。</p>
</blockquote>
<p>上面说了，IP 协议的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中必要的两个就是 IP 地址 和 MAC 地址。</p>
<p>MAC 地址也是用来唯一标识一个接入互联网的设备的，可能不禁有小伙伴要问，既然网络层已经有了唯一标识的 IP 地址，为啥还需要 MAC 地址？</p>
<p>看下面这幅图，在网络上，<strong>通信的双方在同一局域网内的情况是很少见的，通常是需要多台计算机和网络设备的中转才能连接到对方。而在进行中转时，就需要利用下一站中转设备的 MAC 地址来搜索下一个中转目标</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021011414sdvrthryjukloikyuyterefr3919.png"></p>
<ul>
<li><p>网络层指定了从哪个主机（「源 IP 地址」）发送到哪个主机（「目的 IP 地址」）。<strong>源 IP 地址和目标 IP 地址在传输过程中是不会变化的</strong></p>
</li>
<li><p>而数据链路层则是根据 MAC 地址在一个接一个的区间中进行传输的，每个区间内的出发地址即「源 MAC 地址」，每个区间内的目的地址即「目的 MAC 地址」。显然，随着数据的传输，<strong>源 MAC 地址和目的 MAC 地址会不断的发生变化</strong></p>
<p>比如上图，<strong>网络层告知了 1-2-3 路线，也就是说指明了这几个路由器的 IP 地址。那么数据链路层就会根据这几个 IP 地址对应的 MAC 地址依次找到 1、2、3，并在他们之间传输数据</strong>。</p>
</li>
</ul>
<p>🍉 这么说吧，举个形象点的例子：我们把数据链路层当成乘坐高铁从苏州到南京，再在南京转乘到北京，再在北京转乘到西藏的旅客，那么网络层就相当于每个车站的工作人员，<strong>在数据链路层每次转乘时，网络层为其购买了一张标有下一个 MAC 地址的车票</strong>。因此，即使旅客（数据链路层）不知道其最终目的地也没有关系，工作人员（网络层）会给你做出指引。</p>
<p>实际上，网络层做出指引的过程，我们将其称为<strong>路由控制</strong>，其中又涉及到了路由协议比如 OSPF 等</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202101dvfbnyuyiotuiutrthgwef15151809.png"></p>
<p>那么，<strong>将 IP 地址转化为 MAC 地址</strong>，从而在数据链路层精确的传输数据的协议就是 <strong>ARP 协议</strong>。</p>
<p>ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。并且每个主机都有一个 <strong>ARP 高速缓存</strong>，里面有本局域网上的各主机和路由器的 <strong>IP 地址到 MAC 地址的映射表</strong>。</p>
<p>如下图所示，假定主机 A 向同一链路上的主机 B 发送 IP 数据报，已知主机 A 和主机 B 的 IP 地址，它们互不知道对方的 MAC 地址：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021cadvethyukilutyuhtewef0123213052.png"></p>
<p>1）首先，主机 A 为了获得主机 B 的 MAC 地址，它会先去查询自己的 ARP 高速缓存中有没有主机 B 的相关记录；</p>
<p>2）如果主机 A 的 ARP 高速缓存中没有主机 B 的 IP 地址到 MAC 地址的映射，主机 A 就会通过<strong>广播</strong>的方式发送 <strong>ARP 请求包</strong>（该包携带自己的 IP 地址 和 MAC 地址 以及 目标主机的 IP 地址），表明自己想要获得主机 B 的 MAC 地址；</p>
<p>2） 由于广播请求可以被同一个链路上的所有主机或路由器接收，因此如果这条链路上某个主机或路由的 IP 地址与这个 ARP 请求包中包含的目标主机的 IP 地址相同，那么这个节点就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>中返回给主机 A；</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021012322vrtryjuykiuytegrwgthryjuyki0759.png"></p>
<blockquote>
<p>当然，ARP 响应包是以单播的形式进行发送的，毕竟 ARP 请求包中已经包含了主机 A 的 IP 地址，所以主机 B 非常清楚这个响应包应该发送给谁。</p>
<p>大部分网络协议在设计的时候，都是保持极度克制的，不需要的交互就砍掉，能合并的信息就合并，能不用广播就用单播，以此让带宽变得更多让网络变得更快。</p>
</blockquote>
<p>3）主机 A 在收到主机 B 发过来的 ARP 响应包后，向其 ARP 高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202004272scdvfbytumi,yutytegrwgethryjt10248.png"></p>
<p>当然，缓存是有一定期限的，超过这个期限，缓存的内容将被清空。这也使得即使 MAC 地址和 IP 地址的映射关系发生了变化，也依然能够正确的将数据包发送给目标地址。</p>
<h4 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8. 服务器响应请求"></a>8. 服务器响应请求</h4><p>浏览器的 HTTP 请求报文通过 TCP 三次握手建立的连接通道被切分成若干报文段分别发送给服务器，服务器在收到这些报文段后，按照序号以原来的顺序重组 HTTP 请求报文。然后处理并返回一个 HTTP 响应。当然，HTTP 响应报文也要经过和 HTTP 请求报文一样的过程。</p>
<p>看下方这个图回顾一下（图片来源《图解 HTTP》）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210srgtrhyuyiluyutyterewfgethyju207224444.png"></p>
<h4 id="9-断开-TCP-连"><a href="#9-断开-TCP-连" class="headerlink" title="9. 断开 TCP 连"></a>9. 断开 TCP 连</h4><p>浏览器和服务器都不再需要发送数据后，四次挥手断开 TCP 连接</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/fafsdvsfvfsbfgndgftrytuyty.png"></p>
<h4 id="10-浏览器显示界面"><a href="#10-浏览器显示界面" class="headerlink" title="10. 浏览器显示界面"></a>10. 浏览器显示界面</h4><p>浏览器接收到服务器返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>屏蔽掉底层细节，笼统的总结一下上述过程：</p>
<p>应用层：</p>
<ul>
<li>浏览器封装 HTTP 请求报文</li>
<li>DNS 解析域名获得目标服务器地址</li>
</ul>
<p>传输层：</p>
<ul>
<li>建立连接</li>
<li>把应用层传过来的 HTTP 请求报文进行分割，并在各个报文上打上标记序号及端口号转发给网络层</li>
</ul>
<p>网络层：</p>
<ul>
<li>利用 ARP 协议根据 IP 地址获取作为通信目的地的 MAC 地址后转发给链路层</li>
</ul>
<p>服务端在链路层收到数据，按序往上层发送，一直到应用层接收到浏览器发送来的 HTTP 请求报文，然后处理该请求并返回 HTTP 响应报文，浏览器接收到响应报文之后解析渲染界面。最后 TCP 断开连接。</p>
</blockquote>
<h1 id="问题：B树-B-树"><a href="#问题：B树-B-树" class="headerlink" title="问题：B树 B+树"></a>问题：B树 B+树</h1><blockquote>
<ul>
<li>B+树中只有叶子节点会带有指向记录的指针（<code>ROWID</code>），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<p>B+树的优点：<strong>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</strong></p>
<p>B树的优点：<strong>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位</strong></p>
</blockquote>
<h1 id="问题：进程间通信方式"><a href="#问题：进程间通信方式" class="headerlink" title="问题：进程间通信方式"></a>问题：进程间通信方式</h1><blockquote>
<p>全文脉络思维导图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022522003cdvfbgnhmj,k.l.png"></p>
<h2 id="1-什么是进程通信"><a href="#1-什么是进程通信" class="headerlink" title="1. 什么是进程通信"></a><strong>1. 什么是进程通信</strong></h2><p>​	顾名思义，进程通信（ InterProcess Communication，IPC）就是指<strong>进程之间的信息交换</strong>。实际上，<strong>进程的同步与互斥本质上也是一种进程通信</strong>（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它<strong>缺乏传递数据的能力</strong>。</p>
<p>​	虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，<strong>进程之间需要交换大批数据</strong>，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。</p>
<p>​	再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以<strong>进程之间想要进行信息交换就必须通过内核</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210223112csadvfbgnhmj,k14.png"></p>
<p>下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：</p>
<ul>
<li>管道（也称作共享文件）</li>
<li>消息队列（也称作消息传递）</li>
<li>共享内存（也称作共享存储）</li>
<li>信号量和 PV 操作</li>
<li>信号</li>
<li>套接字（Socket）</li>
</ul>
<h2 id="2-管道"><a href="#2-管道" class="headerlink" title="2. 管道"></a><strong>2. 管道</strong></h2><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a><strong>匿名管道</strong></h3><p>​	各位如果学过 Linux 命令，那对管道肯定不陌生，Linux 管道使用竖线 <code>|</code> 连接多个命令，这被称为管道符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxxxxxxxxx  $ command1 | command2	</span><br></pre></td></tr></table></figure>

<p>​	以上这行代码就组成了一个管道，它的功能是将前一个命令（<code>command1</code>）的输出，作为后一个命令（<code>command2</code>）的输入，从这个功能描述中，我们可以看出<strong>管道中的数据只能单向流动</strong>，也就是半双工通信，如果想实现相互通信（全双工通信），我们需要创建两个管道才行。</p>
<p>​	另外，通过管道符 <code>|</code> 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，<strong>匿名管道只能用于父子进程之间的通信</strong>。</p>
<p>​	在 Linux 的实际编码中，是通过 <code>pipe</code> 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe (int fd[2]);</span><br></pre></td></tr></table></figure>

<p>该函数拥有一个存储空间为 2 的文件描述符数组：</p>
<ul>
<li><code>fd[0]</code> 指向管道的读端，<code>fd[1]</code> 指向管道的写端</li>
<li><code>fd[1]</code> 的输出是 <code>fd[0]</code> 的输入</li>
</ul>
<p>粗略的解释一下通过匿名管道实现进程间通信的步骤：</p>
<p>1）父进程创建两个匿名管道，管道 1（<code>fd1[0]</code>和 <code>fd1[1]</code>）和管道 2（<code>fd2[0]</code> 和 <code>fd2[1]</code>）；</p>
<blockquote>
<p>因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个。</p>
</blockquote>
<p>2）父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</p>
<p>3）父进程关闭管道 1 的读端 <code>fd1[0]</code> 和 管道 2 的写端 <code>fd2[1]</code>，子进程关闭管道 1 的写端 <code>fd1[1]</code> 和 管道 2 的读端 <code>fd2[0]</code>，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用<strong>环形队列</strong>实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314csdvfbgnhmj,k.l2402.png"></p>
<p>​	看完上面这些讲述，我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了），但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>​	简单来说，<strong>管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作</strong>。</p>
<h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a><strong>有名管道</strong></h3><p>​	匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
<p>​	所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。</p>
<p>使用 Linux 命令 <code>mkfifo</code> 来创建有名管道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure>

<p>​	<code>myPipe</code> 就是这个管道的名称，接下来，我们往 myPipe 这个有名管道中写入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxxxxxxxxx  $ echo &quot;hello&quot; &gt; myPipe	</span><br></pre></td></tr></table></figure>

<p>​	执行这行命令后，你会发现它就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个有名管道里的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe</span><br><span class="line"> hello</span><br></pre></td></tr></table></figure>

<h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a><strong>3. 消息队列</strong></h2><p>​	可以看出，<strong>管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流</strong>。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314dvfbgfhmj,jmhngbnhm2747.png"></p>
<p><strong>消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong>。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：</p>
<ul>
<li><p>消息队列允许一个或多个进程向它写入或读取消息。</p>
</li>
<li><p>消息队列可以实现消息的<strong>随机查询</strong>，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。</p>
</li>
<li><p>对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。</p>
</li>
<li><p>消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</p>
<p>需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
</li>
</ul>
<h2 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a><strong>4. 共享内存</strong></h2><p>​	为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。</p>
<p>​	顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将<strong>立即</strong>影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​	集合内存管理的内容，我们来深入理解下共享内存的原理。首先，每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。<strong>两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314csdvfbgnhmjh,khjmhngbdf4949.png"></p>
<p>​	不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2cdsvgfhjkj.khjndfds0210223142910.png"></p>
<h2 id="5-信号量和-PV-操作"><a href="#5-信号量和-PV-操作" class="headerlink" title="5. 信号量和 PV 操作"></a><strong>5. 信号量和 PV 操作</strong></h2><p>​	实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为<strong>消息队列无需避免冲突，而共享内存机制可能会发生冲突</strong>。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。</p>
<p>​	并且，在多道批处理系统中，多个进程是可以并发执行的，但由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进（异步性）。但有时候我们又希望多个进程能密切合作，按照某个特定的顺序依次执行，以实现一个共同的任务。</p>
<p>​	举个例子，如果有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210scdvfgnhj,kj.k,jgfgbvdcs222182849.png"></p>
<p>​	因此，为了解决上述这两个问题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。</p>
<p>​	<strong>进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信</strong>。</p>
<blockquote>
<p>下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。</p>
</blockquote>
<p>​	信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
<p>​	用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：</p>
<p>1）<strong>P 操作</strong>：将信号量值减 1，表示<strong>申请占用一个资源</strong>。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。</p>
<p>可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。</p>
<p>2）<strong>V 操作</strong>：将信号量值加 1，表示<strong>释放一个资源</strong>，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。</p>
<p>我觉得已经讲的足够通俗了，不过对于 V 操作大家可能仍然有困惑，下面再来看两个关于 V 操作的问答：</p>
<p>问：<strong>信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程</strong>？</p>
<p>答：所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。</p>
<p>问：<strong>信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程</strong>？</p>
<p>答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。</p>
<p>信号量和 PV 操作具体的定义如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202102scdvfbhmj,kjmhnt22182011.png"></p>
<h3 id="互斥访问共享内存"><a href="#互斥访问共享内存" class="headerlink" title="互斥访问共享内存"></a><strong>互斥访问共享内存</strong></h3><p>两步走即可实现不同进程对共享内存的互斥访问：</p>
<ul>
<li>定义一个互斥信号量，并初始化为 1</li>
<li>把对共享内存的访问置于 P 操作和 V 操作之间</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202102231532cdvfbfhmj,kj.,hjhfgbvdc21.png"></p>
<p>​	<strong>P 操作和 V 操作必须成对出现</strong>。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022315csdsvdghjh,kjhgbef3236.png"></p>
<h3 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a><strong>实现进程同步</strong></h3><p>回顾一下进程同步，就是要各并发进程按要求有序地运行。</p>
<p>​	举个例子，以下两个进程 P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。假设 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022cdvsfdgfhmj,k.,jmnt2181857.png"></p>
<p>如果 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p>使用信号量和 PV 操作实现进程的同步也非常方便，三步走：</p>
<ul>
<li>定义一个同步信号量，并初始化为当前可用资源的数量</li>
<li>在优先级较<strong>高</strong>的操作的<strong>后</strong>面执行 V 操作，释放资源</li>
<li>在优先级较<strong>低</strong>的操作的<strong>前</strong>面执行 P 操作，申请占用资源</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210222csdvfbgngdjfk.jmhnbfv181925.png"></p>
<p>配合下面这张图直观理解下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210222cdsvdgfhjmhggbdfds171312.png"></p>
<h2 id="6-信号"><a href="#6-信号" class="headerlink" title="6. 信号"></a><strong>6. 信号</strong></h2><p>​	注意！<strong>信号和信号量是完全不同的两个概念</strong>！</p>
<p>​	信号是进程通信机制中唯一的<strong>异步</strong>通信机制，它可以在任何时候发送信号给某个进程。<strong>通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行</strong>。用户、内核和进程都能生成和发送信号。</p>
<p>​	信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；而软件来源就是通过 <code>kill</code> 系列的命令给进程发送信号，比如 <code>kill -9 1111</code> ，表示给 PID 为 1111 的进程发送 <code>SIGKILL</code> 信号，让其立即结束。我们来查看一下 Linux 中有哪些信号：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022315dvfgfhjhk,hjgfgbvds4622.png"></p>
<h4 id="7-Socket"><a href="#7-Socket" class="headerlink" title="7. Socket"></a>7. Socket</h4><p>​	至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要<strong>跨网络与不同主机上的进程进行通信</strong>，那该怎么做呢？这就是 Socket 通信做的事情了（<strong>当然，Socket 也能完成同主机上的进程通信</strong>）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202012defwgtrhjuymujdhnfdfgb05112439.png"></p>
<p>​	Socket 起源于 Unix，原意是<strong>插座</strong>，在计算机通信领域，Socket 被翻译为<strong>套接字</strong>，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>​	从计算机网络层面来说，<strong>Socket 套接字是网络通信的基石</strong>，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。</p>
<p>​	Socket 的本质其实是一个编程接口（API），是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它对 TCP&#x2F;IP 进行了封装。它<strong>把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面</strong>。对用户来说，只要通过一组简单的 API 就可以实现网络的连接。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202ghtsdgrsdfdsgdsgdf10223163258.png"></p>
<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>简单总结一下上面六种 Linux 内核提供的进程通信机制：</p>
<p>1）首先，最简单的方式就是<strong>管道</strong>，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。</p>
<p>2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此<strong>消息队列</strong>应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。</p>
<p>3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，<strong>共享内存</strong>可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p>4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。</p>
<p>5）<strong>信号</strong>和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。</p>
<p>6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 <strong>Socket</strong> 通信。另外，Socket 也能完成同主机上的进程通信。</p>
</blockquote>
<h1 id="问题：time-wait状态存在的原因"><a href="#问题：time-wait状态存在的原因" class="headerlink" title="问题：time_wait状态存在的原因"></a>问题：time_wait状态存在的原因</h1><blockquote>
<p><strong>第一个理由：</strong>如果客户端的ACK丢失了，服务器将确保最后一个确认报文能够到达。如果没能到达，服务端就会会重发FIN请求释放连接。等待一段时间没有收到重发就说明服务的已经CLOSE了。如果有重发，则客户端再发送一次LAST ack信号。</p>
<p><strong>第二个理由：</strong>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</blockquote>
<h1 id="问题：既然MAC地址是唯一的，为什么还需要IP地址？"><a href="#问题：既然MAC地址是唯一的，为什么还需要IP地址？" class="headerlink" title="问题：既然MAC地址是唯一的，为什么还需要IP地址？"></a>问题：既然MAC地址是唯一的，为什么还需要IP地址？</h1><blockquote>
<ul>
<li><p>因为如果我们只用MAC地址的话，我们会发现路由器需要记住每个MAC地址所在的子网是哪一个(不然每一次收到数据包的时候路由 器都要重新满世界地去找这个MAC地址的位置)。而世界上有248个MAC地址，这就意味着即使我们给每个MAC地址只留1字节的储存空间，每个路由器也需要256 TB的内存!这显然是不可能实现的。</p>
</li>
<li><p>和MAC不同的是，IP 地址是和地域相关的。对于位于同一个子网上的设备，我们给他们分配的IP地址前缀都是一样的。 这个前缀就像邮政编码一样。这样，路由器过IP地址的前缀就能知道这个设备在哪个子网上了。现在，路由器只需要记住每个子网的位置即可，大大减少了路由器所需要的内存。</p>
</li>
<li><p>只拥有MAC地址的话，只有在同一网络区域内，才能进行数据传输，不能跨网络区域。</p>
</li>
<li><p>如果不使用IP地址，那么就需要维护一个极其庞大的MAC地址表，在查找目的机器的时候，就需要向全世界发送数据包，可想而知会造成多大的网络流量。</p>
</li>
</ul>
</blockquote>
<h1 id="问题：String-s-与-String-s-null"><a href="#问题：String-s-与-String-s-null" class="headerlink" title="问题：String s 与 String s &#x3D; null"></a>问题：String s 与 String s &#x3D; null</h1><blockquote>
<p><code>String s</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/dassadcdscdscdscdsvdbh09104705.png"></p>
<hr>
<p><code>String s = null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：s <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn">初学者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wyy-blog.cn/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/">https://www.wyy-blog.cn/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wyy-blog.cn" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ChMkJ1bKzZSICF95AAMQ9kMccxcAALJCQByq1gAAxEO818.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="常见的设计模式"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/olkijhfgbvf9485.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见的设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/17/%E6%95%B0%E7%BB%84array%E4%B8%8E%E9%9B%86%E5%90%88List%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/" title="数组array与集合List互相转换"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/loiukmjn66h130.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数组array与集合List互相转换</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/zesxrdcfvgbuhijn.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初学者</div><div class="author-info__description">虽千万人，吾往矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">问题：Java和C++的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">问题：Java是编译型语言还是解释型语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">问题：面向对象特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJVM%E3%80%81JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">问题：JVM、JDK 和 JRE 有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">5.</span> <span class="toc-text">问题：Java如何实现跨平台</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">6.</span> <span class="toc-text">问题：装箱与拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E4%BD%95%E4%B8%BA%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.0.0.0.0.1.</span> <span class="toc-text">1、何为包装类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E4%BD%95%E4%B8%BA%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">6.0.0.0.0.2.</span> <span class="toc-text">2、何为装箱与拆箱</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.0.0.0.0.3.</span> <span class="toc-text">3、装箱与自动装箱的区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="toc-number">6.0.0.0.0.4.</span> <span class="toc-text">4、相关面试题目</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.0.0.0.0.5.</span> <span class="toc-text">5、总结</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">问题：重载和重写的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81overload%EF%BC%88%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">7.0.0.0.0.1.</span> <span class="toc-text">1、overload（重载）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81override%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89"><span class="toc-number">7.0.0.0.0.2.</span> <span class="toc-text">2、override（重写）</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Aa-a-b%E4%B8%8Ea-b%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">问题：a&#x3D;a+b与a+&#x3D;b的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AString-equals-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">问题：String.equals()源码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Athis%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">问题：this关键字有什么作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Aequals-%E5%92%8ChashCode-%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">问题：equals()和hashCode()区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Aequals-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">问题：equals 和 &#x3D;&#x3D; 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJDK8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">13.</span> <span class="toc-text">问题：JDK8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81Java-8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.0.0.0.0.1.</span> <span class="toc-text">1、Java 8 Lambda 表达式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.0.0.0.2.</span> <span class="toc-text">2、接口的默认方法和静态方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E4%BB%A3%E6%9B%BF%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-number">13.0.0.0.0.3.</span> <span class="toc-text">3、使用元空间代替永久代</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">问题：接口和抽象类的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">问题：静态变量和实例变量区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">问题：静态方法和实例方法区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">17.</span> <span class="toc-text">问题：深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">18.</span> <span class="toc-text">问题：Java是值传递，还是引用传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">问题：Java 创建对象有哪几种方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Astatic%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">20.</span> <span class="toc-text">问题：static关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Afinal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.</span> <span class="toc-text">问题：final关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AException%E4%B8%8EError"><span class="toc-number">22.</span> <span class="toc-text">问题：Exception与Error</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">问题：Java中的内部类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9ARESTful"><span class="toc-number">24.</span> <span class="toc-text">问题：RESTful</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">25.</span> <span class="toc-text">问题：序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">什么是序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">25.0.0.2.</span> <span class="toc-text">为什么需要序列化与反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E4%BC%9A%E6%8C%89%E6%AD%A5%E9%AA%A4%E5%81%9A%E5%A6%82%E4%B8%8B%E4%BA%8B%E6%83%85"><span class="toc-number">25.0.0.3.</span> <span class="toc-text">序列化算法一般会按步骤做如下事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">25.0.0.4.</span> <span class="toc-text">序列化和反序列化的注意点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A-Resource%E5%92%8C-Autowire%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">问题：@Resource和@Autowire的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Resource%E8%A3%85%E9%85%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">26.0.0.0.0.1.</span> <span class="toc-text">@Resource装配顺序</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Acount-1-%E3%80%81count-%E4%B8%8Ecount-%E5%88%97%E5%90%8D-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">问题：count(1)、count(*)与count(列名)的执行区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Anew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">28.</span> <span class="toc-text">问题：new一个对象的过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">问题：多进程与多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AHTTP-1-0%E3%80%81HTTP-1-1%E3%80%81HTTP-2-0"><span class="toc-number">30.</span> <span class="toc-text">问题：HTTP 1.0、HTTP 1.1、HTTP 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-0-HTTP-1-1%E5%8C%BA%E5%88%AB"><span class="toc-number">30.0.0.1.</span> <span class="toc-text">HTTP 1.0 HTTP 1.1区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">30.0.0.1.1.</span> <span class="toc-text">长连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%BA%A6%E5%B8%A6%E5%AE%BD"><span class="toc-number">30.0.0.1.2.</span> <span class="toc-text">节约带宽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HOST%E5%9F%9F"><span class="toc-number">30.0.0.1.3.</span> <span class="toc-text">HOST域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-1-HTTP-2-0%E5%8C%BA%E5%88%AB"><span class="toc-number">30.0.0.2.</span> <span class="toc-text">HTTP1.1 HTTP 2.0区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">30.0.0.2.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">30.0.0.2.2.</span> <span class="toc-text">头部数据压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-number">30.0.0.2.3.</span> <span class="toc-text">服务器推送</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AHTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">31.</span> <span class="toc-text">问题：HTTP请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E6%96%B9%E6%B3%95"><span class="toc-number">31.1.</span> <span class="toc-text">GET 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">31.1.1.</span> <span class="toc-text">GET 请求的一些其他特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HEAD-%E6%96%B9%E6%B3%95"><span class="toc-number">31.2.</span> <span class="toc-text">HEAD 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">31.2.1.</span> <span class="toc-text">HEAD 方法的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST-%E6%96%B9%E6%B3%95"><span class="toc-number">31.3.</span> <span class="toc-text">POST 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E5%87%BA%E7%9A%84POST%E8%AF%B7%E6%B1%82%E7%9A%84body%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">31.3.1.</span> <span class="toc-text">浏览器发出的POST请求的body的主要格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">31.3.2.</span> <span class="toc-text">POST 请求的其他特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PUT-%E6%96%B9%E6%B3%95"><span class="toc-number">31.4.</span> <span class="toc-text">PUT 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PUT-%E6%96%B9%E6%B3%95%E5%8F%AF%E8%83%BD%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">31.4.1.</span> <span class="toc-text">PUT 方法可能的响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DELETE-%E6%96%B9%E6%B3%95"><span class="toc-number">31.5.</span> <span class="toc-text">DELETE 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DELETE-%E6%96%B9%E6%B3%95%E5%8F%AF%E8%83%BD%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81"><span class="toc-number">31.5.1.</span> <span class="toc-text">DELETE 方法可能的响应码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TRACE-%E6%96%B9%E6%B3%95"><span class="toc-number">31.6.</span> <span class="toc-text">TRACE 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATCH-%E6%96%B9%E6%B3%95"><span class="toc-number">31.7.</span> <span class="toc-text">PATCH 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-number">31.7.1.</span> <span class="toc-text">响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OPTIONS-%E6%96%B9%E6%B3%95"><span class="toc-number">31.8.</span> <span class="toc-text">OPTIONS 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">31.8.1.</span> <span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CONNECT-%E6%96%B9%E6%B3%95"><span class="toc-number">31.9.</span> <span class="toc-text">CONNECT 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">31.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AGET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">问题：GET 和 POST 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">33.</span> <span class="toc-text">问题：HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%91%8A%E7%9F%A5%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%9A%84%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C"><span class="toc-number">33.0.0.1.</span> <span class="toc-text">一、状态码告知从服务器端返回的请求结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%812XX%E6%88%90%E5%8A%9F"><span class="toc-number">33.0.0.2.</span> <span class="toc-text">二、2XX成功</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81-200-OK"><span class="toc-number">33.0.0.2.1.</span> <span class="toc-text">2.1、 200 OK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E3%80%81-204-No-Content"><span class="toc-number">33.0.0.2.2.</span> <span class="toc-text">2.2、 204 No Content</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E3%80%81-206-Partial-Content"><span class="toc-number">33.0.0.2.3.</span> <span class="toc-text">2.3、 206 Partial Content</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%813XX%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">33.0.0.3.</span> <span class="toc-text">三、3XX重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81301-Moved-Permanently"><span class="toc-number">33.0.0.3.1.</span> <span class="toc-text">3.1、301 Moved Permanently</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81302-Found"><span class="toc-number">33.0.0.3.2.</span> <span class="toc-text">3.2、302 Found</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E3%80%81303-See-Other"><span class="toc-number">33.0.0.3.3.</span> <span class="toc-text">3.3、303 See Other</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4%E3%80%81-304-Not-Modified"><span class="toc-number">33.0.0.3.4.</span> <span class="toc-text">3.4、 304 Not Modified</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5%E3%80%81-307-Temporary-Redirect"><span class="toc-number">33.0.0.3.5.</span> <span class="toc-text">3.5、 307 Temporary Redirect</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%814XX%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="toc-number">33.0.0.4.</span> <span class="toc-text">四、4XX客户端错误</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81-400-Bad-Request"><span class="toc-number">33.0.0.4.1.</span> <span class="toc-text">4.1、 400 Bad Request</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E3%80%81-401-Unauthorized"><span class="toc-number">33.0.0.4.2.</span> <span class="toc-text">4.2、 401 Unauthorized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E3%80%81-403-Forbidden"><span class="toc-number">33.0.0.4.3.</span> <span class="toc-text">4.3、 403 Forbidden</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E3%80%81-404-Not-Found"><span class="toc-number">33.0.0.4.4.</span> <span class="toc-text">4.4、 404 Not Found</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%815XX%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="toc-number">33.0.0.5.</span> <span class="toc-text">五、5XX服务器错误</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E3%80%81-500-Internal-Server-Error"><span class="toc-number">33.0.0.5.1.</span> <span class="toc-text">5.1、 500 Internal Server Error</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E3%80%81-503-Service-Unavailable"><span class="toc-number">33.0.0.5.2.</span> <span class="toc-text">5.2、 503 Service Unavailable</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E7%8A%B6%E5%86%B5%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">33.0.0.6.</span> <span class="toc-text">状态码和状况的不一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8"><span class="toc-number">33.0.0.7.</span> <span class="toc-text">HTTP状态码大全</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%8C%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">34.</span> <span class="toc-text">问题：HTTP请求的完全过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-number">34.0.0.1.</span> <span class="toc-text">0. 前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A7%A3%E6%9E%90-URL"><span class="toc-number">34.0.0.2.</span> <span class="toc-text">1. 解析 URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%81%E8%A3%85-HTTP-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">34.0.0.3.</span> <span class="toc-text">2. 浏览器封装 HTTP 请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">34.0.0.4.</span> <span class="toc-text">3. DNS 域名解析获取 IP 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">34.0.0.5.</span> <span class="toc-text">4. 建立 TCP 连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">34.0.0.6.</span> <span class="toc-text">5. 浏览器发送请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%B4%9F%E8%B4%A3%E4%BC%A0%E8%BE%93%E7%9A%84-IP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">34.0.0.7.</span> <span class="toc-text">6. 负责传输的 IP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8-ARP-%E5%8D%8F%E8%AE%AE%E5%87%AD%E5%80%9F-MAC-%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1"><span class="toc-number">34.0.0.8.</span> <span class="toc-text">7. 使用 ARP 协议凭借 MAC 地址通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82"><span class="toc-number">34.0.0.9.</span> <span class="toc-text">8. 服务器响应请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%96%AD%E5%BC%80-TCP-%E8%BF%9E"><span class="toc-number">34.0.0.10.</span> <span class="toc-text">9. 断开 TCP 连</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2"><span class="toc-number">34.0.0.11.</span> <span class="toc-text">10. 浏览器显示界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">34.0.0.12.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AB%E6%A0%91-B-%E6%A0%91"><span class="toc-number">35.</span> <span class="toc-text">问题：B树 B+树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">36.</span> <span class="toc-text">问题：进程间通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">36.1.</span> <span class="toc-text">1. 什么是进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%A1%E9%81%93"><span class="toc-number">36.2.</span> <span class="toc-text">2. 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">36.2.1.</span> <span class="toc-text">匿名管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">36.2.2.</span> <span class="toc-text">有名管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">36.3.</span> <span class="toc-text">3. 消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">36.4.</span> <span class="toc-text">4. 共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C-PV-%E6%93%8D%E4%BD%9C"><span class="toc-number">36.5.</span> <span class="toc-text">5. 信号量和 PV 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">36.5.1.</span> <span class="toc-text">互斥访问共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">36.5.2.</span> <span class="toc-text">实现进程同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BF%A1%E5%8F%B7"><span class="toc-number">36.6.</span> <span class="toc-text">6. 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Socket"><span class="toc-number">36.6.0.1.</span> <span class="toc-text">7. Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">36.6.0.2.</span> <span class="toc-text">8. 总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Atime-wait%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">37.</span> <span class="toc-text">问题：time_wait状态存在的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E6%97%A2%E7%84%B6MAC%E5%9C%B0%E5%9D%80%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81IP%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">问题：既然MAC地址是唯一的，为什么还需要IP地址？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9AString-s-%E4%B8%8E-String-s-null"><span class="toc-number">39.</span> <span class="toc-text">问题：String s 与 String s &#x3D; null</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="发表于 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="发表于 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="发表于 2022-01-13 20:15:31">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2022-01-04T09:01:41.000Z" title="发表于 2022-01-04 17:01:41">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-01-02T11:57:45.000Z" title="发表于 2022-01-02 19:57:45">2022-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 初学者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>