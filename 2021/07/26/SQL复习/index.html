<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SQL复习 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录SQL（Structured Query Language）结构化查询语言一些知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL复习">
<meta property="og:url" content="http://example.com/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="记录SQL（Structured Query Language）结构化查询语言一些知识。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/fthcgjjgfcjgft.jpg">
<meta property="article:published_time" content="2021-07-26T10:04:19.000Z">
<meta property="article:modified_time" content="2022-05-07T04:26:32.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="SQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/fthcgjjgfcjgft.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SQL复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-07 12:26:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/fthcgjjgfcjgft.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SQL复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-26T10:04:19.000Z" title="Created 2021-07-26 18:04:19">2021-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-07T04:26:32.000Z" title="Updated 2022-05-07 12:26:32">2022-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SQL/">SQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SQL复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<p>说明：本文主要借鉴尚硅谷的MySQL底层原理课程资料与<a target="_blank" rel="noopener" href="https://www.runoob.com/sql/sql-intro.html">https://www.runoob.com/sql/sql-intro.html</a></p>
<h2 id="结构化查询语言包含6个部分"><a href="#结构化查询语言包含6个部分" class="headerlink" title="结构化查询语言包含6个部分"></a>结构化查询语言包含6个部分</h2><blockquote>
<p><strong><code>DDL</code>：</strong>数据定义语言</p>
<p>关键字：<code>create</code>、<code>drop</code>、<code>truncate</code>、<code>alter</code></p>
<p><strong><code>DQL</code>：</strong>数据查询语言</p>
<p>关键字：<code>select</code></p>
<p><strong><code>DML</code>：</strong>数据操作语言</p>
<p>关键字：<code>insert</code>、<code>update</code>、<code>delete</code></p>
<p><strong><code>DCL</code>：</strong>数据控制语言</p>
<p>关键字：<code>grant</code>、<code>revoke</code>、<code>deny</code></p>
<p><strong><code>TCL</code>：</strong>事务控制语言</p>
<p>关键字：<code>commit</code>、<code>savepoint</code>、<code>rollback</code></p>
<p><strong><code>CCL</code>：</strong>指针控制语言</p>
</blockquote>
<h2 id="提交数据有三种类型"><a href="#提交数据有三种类型" class="headerlink" title="提交数据有三种类型"></a>提交数据有三种类型</h2><blockquote>
<p><strong>显式提交：</strong>用<code>COMMIT</code>命令直接完成的提交为显式提交。其格式为：</p>
<p>​	<code>SQL&gt;commit</code>；</p>
<p><strong>隐式提交：</strong>用<code>SQL</code>命令间接完成的提交为隐式提交。这些命令是：</p>
<p>​	<code>alter</code>，<code>audit</code>，<code>comment</code>，<code>connect</code>，<code>create</code>，<code>disconnext</code>，<code>drop</code>，<code>exit</code>，<code>grant</code>，<code>noaudit</code>，<code>quit</code>，<code>revoke</code>，<code>rename</code>；</p>
<p><strong>自动提交：</strong>若把<code>AUTOCOMMIT</code>设置为<code>ON</code>，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：</p>
<p>​	<code>SQL&gt;set autocommit on</code>；</p>
</blockquote>
<h2 id="SQL基础教程"><a href="#SQL基础教程" class="headerlink" title="SQL基础教程"></a><code>SQL</code>基础教程</h2><h3 id="select：查询"><a href="#select：查询" class="headerlink" title="select：查询"></a><code>select</code>：查询</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称`;   #查询出所有的列</span><br></pre></td></tr></table></figure>

<h3 id="distinct：返回唯一不同的值"><a href="#distinct：返回唯一不同的值" class="headerlink" title="distinct：返回唯一不同的值"></a><code>distinct</code>：返回唯一不同的值</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `列名称` <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p><code>order</code>表</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
</tbody></table>
<p><code>persons</code>表</p>
<table>
<thead>
<tr>
<th align="center">id_p</th>
<th align="center">lastName</th>
<th align="center">firstName</th>
<th align="center">address</th>
<th align="center">city</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Adams</td>
<td align="center">John</td>
<td align="center">Oxford Street</td>
<td align="center">London</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Bush</td>
<td align="center">George</td>
<td align="center">Fifth Avenue</td>
<td align="center">New York</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Carter</td>
<td align="center">Thomas</td>
<td align="center">Changan Street</td>
<td align="center">Beijing</td>
</tr>
</tbody></table>
<p><code>orders</code>表</p>
<table>
<thead>
<tr>
<th align="center">id_o</th>
<th align="center">orderNo</th>
<th align="center">id_p</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">77895</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">44678</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">22456</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">24562</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">34764</td>
<td align="center">65</td>
</tr>
</tbody></table>
<p><code>employees_China</code>表</p>
<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Zhang, Hua</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Wang, Wei</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Yang, Ming</td>
</tr>
</tbody></table>
<p><code>employees_USA</code>表</p>
<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Adams, John</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Bush, George</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Gates, Bill</td>
</tr>
</tbody></table>
<p><strong>执行：</strong><code>select distinct company from order;</code></p>
<table>
<thead>
<tr>
<th align="center">company</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IBM</td>
</tr>
<tr>
<td align="center">Apple</td>
</tr>
<tr>
<td align="center">W3School</td>
</tr>
</tbody></table>
<h3 id="where：规定选择的标准"><a href="#where：规定选择的标准" class="headerlink" title="where：规定选择的标准"></a><code>where</code>：规定选择的标准</h3><p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> `表名称` <span class="keyword">where</span> 列 运算符 值;</span><br></pre></td></tr></table></figure>

<p><strong>运算符：</strong></p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;     在某些版本SQL，可以写成 !&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在某个范围内</td>
</tr>
<tr>
<td align="center">LIKE</td>
<td align="center">搜索某种模式</td>
</tr>
</tbody></table>
<h4 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h4><p>1、空值判断：<code>is null</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 company 列中的空值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `company` <span class="keyword">is</span> <span class="keyword">null</span>;   </span><br></pre></td></tr></table></figure>

<p>2、<code>between and</code> (在 之间的值)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 orderNumber 列中在 <span class="number">199</span> 到 <span class="number">699</span> 之间的值，包括 <span class="number">199</span> 与 <span class="number">699</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `orderNumber` <span class="keyword">between</span> <span class="number">199</span> <span class="keyword">and</span> <span class="number">699</span>;</span><br></pre></td></tr></table></figure>

<p>3、<code>in</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 <span class="keyword">order</span> 表中 orderNumber 列中等于 <span class="number">100</span>、<span class="number">200</span>、<span class="number">300</span>的值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `orderNumber` <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>4、<code>like</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">like</span> 规则：</span><br><span class="line">#    <span class="operator">%</span> 表示多个字值</span><br><span class="line">#    _ 表示一个字值</span><br><span class="line">#    M<span class="operator">%</span> 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的</span><br><span class="line">#    <span class="operator">%</span>M<span class="operator">%</span> 表示查询包含 M 的所有内容</span><br><span class="line"></span><br><span class="line"># 查询 <span class="keyword">order</span> 表中 company 列中包含小写字符的值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> `company` <span class="keyword">like</span> <span class="string">&#x27;%[a-z]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>5、不带比较运算符的<code>where</code>子句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">where</span> 子句并不一定带比较运算符，当不带运算符时，会执行一个隐式转换。</span><br><span class="line"># 当 <span class="number">0</span> 时转化为 <span class="literal">false</span>，<span class="number">1</span> 转化为 <span class="literal">true</span>。例如：</span><br><span class="line"></span><br><span class="line"># 会返回一个空集，因为每一行记录 <span class="keyword">where</span> 都返回 <span class="literal">false</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> <span class="number">0</span></span><br><span class="line"># 会返回一个全集，因为每一行记录 <span class="keyword">where</span> 都返回 <span class="literal">true</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="and-or：作为过滤的运算符"><a href="#and-or：作为过滤的运算符" class="headerlink" title="and &amp; or：作为过滤的运算符"></a><code>and &amp; or</code>：作为过滤的运算符</h4><h3 id="Order-by：用于对结果集进行排序"><a href="#Order-by：用于对结果集进行排序" class="headerlink" title="Order by：用于对结果集进行排序"></a><code>Order by</code>：用于对结果集进行排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 默认按照升序 <span class="keyword">asc</span> 对记录进行排序</span><br><span class="line">关键字 <span class="keyword">desc</span> 降序         <span class="keyword">asc</span> 升序</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对 company 降序，对 orderNumber 降序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `company`,`orderNmuber`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对 company 降序，对 orderNumber 升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> `company` <span class="keyword">desc</span> , `orderNmuber` <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询 company 为 W3School ，对 orderNumber 升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">where</span> `company` <span class="operator">=</span> <span class="string">&#x27;W3School&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> `orderNmuber`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<h3 id="insert：插入"><a href="#insert：插入" class="headerlink" title="insert：插入"></a><code>insert</code>：插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `表名称` <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `表名称`(列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....);</span><br></pre></td></tr></table></figure>

<h3 id="update：修改"><a href="#update：修改" class="headerlink" title="update：修改"></a><code>update</code>：修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> `表名称` <span class="keyword">set</span> `列名称` <span class="operator">=</span> 新值 <span class="keyword">where</span> `列名称` <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>

<h3 id="delete：删除"><a href="#delete：删除" class="headerlink" title="delete：删除"></a><code>delete</code>：删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除某行</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `表名称` <span class="keyword">where</span> `列名称` <span class="operator">=</span> 值;</span><br><span class="line"># 删除所有行</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `表名称`;      </span><br><span class="line"><span class="keyword">delete</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称`;</span><br></pre></td></tr></table></figure>

<h3 id="top：返回指定的记录"><a href="#top：返回指定的记录" class="headerlink" title="top：返回指定的记录"></a><code>top</code>：返回指定的记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># limit 子句可以被用于强制 <span class="keyword">select</span> 语句返回指定的记录数。</span><br><span class="line"># limit 可以接受一个或两个数字参数。参数必须是一个整数常量。</span><br><span class="line"># 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</span><br><span class="line"># 初始记录行的偏移量是 <span class="number">0</span>(而不是 <span class="number">1</span>)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # <span class="keyword">OFFSET</span> #。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `表名称` LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回最上面的 <span class="number">2</span> 条记录</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回 从 <span class="number">2</span> 条开始之后的 <span class="number">2</span> 条记录</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` limit <span class="number">1</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">company</th>
<th align="center">orderNumber</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
</tbody></table>
<h3 id="Alias：别名"><a href="#Alias：别名" class="headerlink" title="Alias：别名"></a><code>Alias</code>：别名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">as</span> `列的别名` <span class="keyword">from</span> `表名称` <span class="keyword">as</span> `表的别名`;</span><br><span class="line"><span class="keyword">select</span> `列名称` `列的别名` <span class="keyword">from</span> `表名称` `表的别名`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `company` <span class="keyword">as</span> `com`, `orderNmuber` `number`</span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">as</span> `<span class="keyword">or</span>`;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">com</th>
<th align="center">number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IBM</td>
<td align="center">3532</td>
</tr>
<tr>
<td align="center">Apple</td>
<td align="center">4698</td>
</tr>
<tr>
<td align="center">W3School</td>
<td align="center">6953</td>
</tr>
<tr>
<td align="center">W3School</td>
<td align="center">2356</td>
</tr>
</tbody></table>
<h3 id="join：连接"><a href="#join：连接" class="headerlink" title="join：连接"></a><code>join</code>：连接</h3><p><code>JOIN</code> 按照功能可分为如下三类：</p>
<blockquote>
<p><code>INNER JOIN</code>（内连接，或等值连接）：获取两个表中字段匹配关系的记录；<br><code>LEFT JOIN</code>（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；<br><code>RIGHT JOIN</code>（右连接）：与 <code>LEFT JOIN</code> 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/sql-join.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `persons`.lastName, `persons`.address, `persons`.id_p</span><br><span class="line"><span class="keyword">from</span> persons</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> `orders`</span><br><span class="line">                    <span class="keyword">on</span> persons.id_p <span class="operator">=</span> orders.id_p</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id_p <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">lastName</th>
<th align="center">address</th>
<th align="center">id_p</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Carter</td>
<td align="center">Changan Street</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Carter</td>
<td align="center">Changan Street</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Adams</td>
<td align="center">Oxford Street</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Adams</td>
<td align="center">Oxford Street</td>
<td align="center">1</td>
</tr>
</tbody></table>
<h3 id="union：合并"><a href="#union：合并" class="headerlink" title="union：合并"></a><code>union</code>：合并</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 会把重复的列删除，只留一个</span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 允许重复的列</span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> `列名称` <span class="keyword">from</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e_id,e_name <span class="keyword">from</span> employees_china</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> e_id,e_name <span class="keyword">from</span> employees_USA;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">e_id</th>
<th align="center">e_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">Zhang, Hua</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Wang, Wei</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Yang, Ming</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">Adams, John</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">Bush, George</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">Carter, Thomas</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">Gates, Bill</td>
</tr>
</tbody></table>
<h3 id="select-into：从一个表复制数据，然后把数据插入到另一个新表中"><a href="#select-into：从一个表复制数据，然后把数据插入到另一个新表中" class="headerlink" title="select into：从一个表复制数据，然后把数据插入到另一个新表中"></a><code>select into</code>：从一个表复制数据，然后把数据插入到另一个新表中</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MySql 不支持 select...into 语句，但支持<span class="keyword">insert</span> <span class="keyword">into</span>...<span class="keyword">select</span></span><br><span class="line"># 可以使用以下语句进行表格复制：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `新表名称`</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `旧表名称`;</span><br></pre></td></tr></table></figure>

<h3 id="insert-into-select：插入"><a href="#insert-into-select：插入" class="headerlink" title="insert into select：插入"></a><code>insert into select</code>：插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 向 table1 中拆入一些 table2 的数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `table1` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `table2`;</span><br></pre></td></tr></table></figure>

<h3 id="create-datbase：创建数据库"><a href="#create-datbase：创建数据库" class="headerlink" title="create datbase：创建数据库"></a><code>create datbase</code>：创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database `库名称`;</span><br></pre></td></tr></table></figure>

<h3 id="create-table：创建表"><a href="#create-table：创建表" class="headerlink" title="create table：创建表"></a><code>create table</code>：创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名称`</span><br><span class="line">(</span><br><span class="line">     `列名称<span class="number">1</span>` 数据类型,</span><br><span class="line">     `列名称<span class="number">2</span>` 数据类型,</span><br><span class="line">     `列名称<span class="number">3</span>` 数据类型,</span><br><span class="line">     ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>数据类型：</p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">integer(size) <br/> int(size)  <br/>smallint(size)<br/>  tinyint(size)</td>
<td align="center">仅容纳整数。在括号内规定数字的最大位数。</td>
</tr>
<tr>
<td align="center">decimal(size,d)<br/>    numeric(size,d)</td>
<td align="center">容纳带有小数的数字。  “size”  规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td align="center">char(size)</td>
<td align="center">容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。  在括号中规定字符串的长度。</td>
</tr>
<tr>
<td align="center">varchar(size)</td>
<td align="center">容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。  在括号中规定字符串的最大长度。</td>
</tr>
<tr>
<td align="center">date(yyyymmdd)</td>
<td align="center">容纳日期。</td>
</tr>
</tbody></table>
<h3 id="constraints：约束"><a href="#constraints：约束" class="headerlink" title="constraints：约束"></a><code>constraints</code>：约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">not</span> <span class="keyword">null</span> : 指示某列不能存储 <span class="keyword">null</span> 值。</span><br><span class="line"># <span class="keyword">unique</span> : 保证某列的每行必须有唯一的值。</span><br><span class="line"># <span class="keyword">primary</span> key : <span class="keyword">not</span> <span class="keyword">null</span> 和 <span class="keyword">unique</span> 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</span><br><span class="line"># <span class="keyword">foreign</span> key : 保证一个表中的数据匹配另一个表中的值的参照完整性。</span><br><span class="line"># <span class="keyword">check</span> : 保证列中的值符合指定的条件。</span><br><span class="line"># <span class="keyword">default</span> : 规定没有给列赋值时的默认值。</span><br></pre></td></tr></table></figure>

<h4 id="not-null：不为空值"><a href="#not-null：不为空值" class="headerlink" title="not null：不为空值"></a><code>not null</code>：不为空值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加 <span class="keyword">not</span> <span class="keyword">null</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` modify `age` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"># 删除 <span class="keyword">not</span> <span class="keyword">null</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` modify `age` <span class="type">int</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="unique：唯一标识数据库表中的每条记录"><a href="#unique：唯一标识数据库表中的每条记录" class="headerlink" title="unique：唯一标识数据库表中的每条记录"></a><code>unique</code>：唯一标识数据库表中的每条记录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">primary</span> key 拥有自动定义 <span class="keyword">unique</span> 约束</span><br><span class="line"># 添加 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">unique</span>(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加多个 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">constraint</span> <span class="keyword">unique</span>(`id`,`age`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">add</span> <span class="keyword">unique</span> (`age`);</span><br><span class="line"></span><br><span class="line"># 撤销 <span class="keyword">unique</span> 约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">drop</span> index (`age`);</span><br></pre></td></tr></table></figure>

<h4 id="primary-key：主键"><a href="#primary-key：主键" class="headerlink" title="primary key：主键"></a><code>primary key</code>：主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `age` <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `persons`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 撤销主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"># 添加主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `persons` <span class="keyword">add</span> <span class="keyword">primary</span> key (`id`);</span><br></pre></td></tr></table></figure>

<h4 id="foreign-key：外键"><a href="#foreign-key：外键" class="headerlink" title="foreign key：外键"></a><code>foreign key</code>：外键</h4> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `orders`(</span><br><span class="line">	`id_o` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `orderNo` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `id_p` <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`id_o`),</span><br><span class="line">    <span class="keyword">foreign</span> key (`id_p`) <span class="keyword">references</span> `persons`(`id_p`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 撤销外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `orders` <span class="keyword">drop</span> <span class="keyword">foreign</span> key</span><br><span class="line"></span><br><span class="line"># 添加外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `orders` <span class="keyword">add</span> <span class="keyword">foreign</span> key (`id_p`) <span class="keyword">references</span> `persons`(`id_p`);</span><br></pre></td></tr></table></figure>

<h4 id="check：限制列中的值的范围"><a href="#check：限制列中的值的范围" class="headerlink" title="check：限制列中的值的范围"></a><code>check</code>：限制列中的值的范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如果对单个列定义 <span class="keyword">check</span> 约束，那么该列只允许特定的值</span><br><span class="line"># 如果对一个表定义 <span class="keyword">check</span> 约束，那么此约束在特定的列中对值进行限制</span><br><span class="line"># mysql不同的版本，有的支持，有的不支持</span><br><span class="line"># 对单列进行约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    <span class="keyword">check</span> (`id` <span class="operator">&gt;</span> <span class="number">0</span>)   #规定 id 必须要大于 <span class="number">0</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 对多列进行约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    <span class="keyword">constraint</span> ch_aa <span class="keyword">check</span> ( id <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;wang&#x27;</span>)  #规定 id 必须要大于 <span class="number">0</span>，且 name 为 wang</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aa <span class="keyword">add</span> <span class="keyword">check</span> (id <span class="operator">&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"># 撤销约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aa <span class="keyword">drop</span> <span class="keyword">check</span> ch_aa;</span><br></pre></td></tr></table></figure>

<h4 id="default：默认值"><a href="#default：默认值" class="headerlink" title="default：默认值"></a><code>default</code>：默认值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 用于向列中插入默认值</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `aa`(</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;wang&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `aa` <span class="keyword">alter</span> `name` <span class="keyword">set</span> <span class="keyword">default</span> <span class="string">&#x27;yu&#x27;</span>; # 将 name 默认值改为 yu</span><br><span class="line"></span><br><span class="line"># 撤销默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `aa` <span class="keyword">alter</span> `name` <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL高级教程"><a href="#MySQL高级教程" class="headerlink" title="MySQL高级教程"></a>MySQL高级教程</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>说明：树的知识点来自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></p>
<h4 id="BST树-—-二叉搜索树"><a href="#BST树-—-二叉搜索树" class="headerlink" title="BST树 — 二叉搜索树"></a>BST树 — 二叉搜索树</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111144689465326549652342955.png"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li><p>根节点的值大于其左子树中任意一个节点的值</p>
</li>
<li><p>根结点的值小于其右节点中任意一节点的值</p>
</li>
<li><p>这一规则适用于二叉查找树中的每一个节点</p>
</li>
</ol>
</blockquote>
<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><blockquote>
<p>​	查询的时间复杂度比链表快，链表的查询时间复杂度是O(n)，二叉排序树平均是O(logn)。二叉排序树越平衡，越能模拟二分法，所以越能想二分法的查询的时间复杂度O(logn)。</p>
</blockquote>
<h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><blockquote>
<p>​	但是BST树有一个不足的地方，就是如果插入的结点的值的顺序，是越来越小或者越来越大的，那么BST就会退化为一条链表，那么其查询的时间复杂度就会降为O(n)。</p>
<p>如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111145211189fadsvasvadsz.png"></p>
</blockquote>
<h4 id="AVL树-—-平衡二叉树"><a href="#AVL树-—-平衡二叉树" class="headerlink" title="AVL树 — 平衡二叉树"></a>AVL树 — 平衡二叉树</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111yuntbrvcwverbytunrter145654356.png"></p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li><p>拥有BST树的特点：根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。</p>
</li>
<li><p>AVL树上任意结点的左、右子树的高度差最大为1。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>​	由于AVL树的第二个特点，使得，AVL树的形状肯定不会退化成一条链表的，而是“矮胖”型的树。所以能确保AVL的查找、添加、删除的时间复杂度都是O(logn)。</p>
</blockquote>
<h4 id="B树-—-平衡多路查找树"><a href="#B树-—-平衡多路查找树" class="headerlink" title="B树 — 平衡多路查找树"></a>B树 — 平衡多路查找树</h4><blockquote>
<p>​	B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。数据库索引技术里大量使用者B树和B+树的数据结构。一个结点存储多个值(索引)。</p>
</blockquote>
<blockquote>
<p>​	B树的阶数：M阶表示 一个B树的结最多有多少个查找路径(即这个结点有多少个子节点)。M&#x3D;M路，M&#x3D;2是二叉树，M&#x3D;3则是三叉树。</p>
</blockquote>
<h5 id="一棵M阶B树有以下特点"><a href="#一棵M阶B树有以下特点" class="headerlink" title="一棵M阶B树有以下特点"></a>一棵M阶B树有以下特点</h5><blockquote>
<ol>
<li><p>每个结点的值(索引) 都是按递增次序排列存放的，并遵循左小右大原则。</p>
</li>
<li><p>根结点 的 子节点 个数为 [2，M]。</p>
</li>
<li><p>除 根结点 以外 的 非叶子结点 的子节点个数 为[ Math.ceil(M&#x2F;2)，M]。 Math.ceil() 为向上取整。</p>
</li>
<li><p>每个 非叶子结点 的值(索引) 个数 &#x3D; 子节点个数 -1 。最小为 Math.ceil(M&#x2F;2)-1   最大为 M-1 个。</p>
</li>
<li><p>B树的所有叶子结点都位于同一层。</p>
</li>
</ol>
</blockquote>
<p>下图是一个 3阶B树：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101111747xrdcftvgbhjyvbuijnkmlnkml22874.png"></p>
<p>可以看到：</p>
<blockquote>
<ol>
<li><p>除 根结点 外，所有 非叶子结点 都至少有 M&#x2F;2 &#x3D; 1.5 取整 &#x3D; 2 个结点。</p>
</li>
<li><p>每个 结点中 的索引值 都是从小到大排序的。</p>
</li>
<li><p>所有叶子结点都在同一层中。</p>
</li>
</ol>
</blockquote>
<h5 id="B树的查找结点过程"><a href="#B树的查找结点过程" class="headerlink" title="B树的查找结点过程"></a>B树的查找结点过程</h5><p>从上述的 3阶B树 中，查找 结点5 的过程：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101111imyunthbgrvfcd74041912.png"></p>
<blockquote>
<p>（1）第一次读IO，把9的结点读到内存，再与目标数5比较，5是小于9的，因此往9的左边走。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011tybgrfvbrnthgdd1175002129.png"></p>
<blockquote>
<p>（2） 第二次读IO，还是把结点读到内存中，然后比较结点中的2和6与目标值5。发现5是大于2小于6的，因此往中间路径走。</p>
</blockquote>
<blockquote>
<p>（3）第三次读IO，还是把结点读到内存中，然后发现结点中有5，因此找到目标值。</p>
</blockquote>
<h6 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h6><blockquote>
<ol>
<li><p>在数据库查询中，以树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。（众所周知，读IO是一件费事的操作）当数据量大的时候，用AVL树存的话，就算AVL是平衡树，但是也扛不住数据量大，数据量大，AVL树的树高肯定很高，那么读取数据的IO次数也会多。那么有没有办法能压缩AVL树的树高呢？这时候B树就出来了。B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p>
</li>
<li><p>B树的每一个结点都包含key(索引值) 和 value(对应数据)，因此方位离根结点近的元素会更快速。（相对于B+树）</p>
</li>
</ol>
</blockquote>
<h5 id="B树的添加结点过程（和结点分裂过程）"><a href="#B树的添加结点过程（和结点分裂过程）" class="headerlink" title="B树的添加结点过程（和结点分裂过程）"></a>B树的添加结点过程（和结点分裂过程）</h5><p>下面以 5阶B树为例：</p>
<p>（a）在空树中插入39，此时根结点只有一个索引值。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011120211uyjtygbvfsvbntbgvfd2856.png"></p>
<p>（b）继续插入22，97和41，根结点此时有4个索引值。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011yuntbrtvecevgrbhtnb1202239618.png"></p>
<p>（c）继续插入53。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111%E5%85%8Biuynegtrvefc202358865.png"></p>
<p>此时已经超过了最大允许的索引个数4，即4个。所以以其中心（41）分裂。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101uiyntbgrfvd11202537763.png"></p>
<p>（d）然后在上图的基础上，再依次插入13，21，40，那么41所在结点的左子结点里的值就为13、21、22、39、40，一共五个，所以会以22为中心进行分裂。分裂的中心22会进位到上一层的结点中。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112042246(%E2%8A%99%EF%B9%8F%E2%8A%99)%E7%8E%87scefrsdc632.png"></p>
<p>（e）再在上图的基础上，插入30，27，33，那么其中有一个结点内的值为27、30、33、39、40，那么就会以33为中心引起一次分裂。然后再插入36，35，34，那么就又会有一个结点内的值为34、35、36、39、40，那么就会以36为中心分裂。然后再插入24、29。<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112050465164656518240.png"></p>
<p>（f）此时拥有24、27、29、30的结点只要再插入一个索引值，就又会发生分裂，插入26。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111785132649861205152145.png"></p>
<p>（g）27进位到父节点后，父节点里的索引值也超过了4个，因此也要分裂。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210drxcfgvhbjnkl111205424884.png"></p>
<p>根结点分裂后的B树：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112486512305548682.png"></p>
<h5 id="B树的删除结点过程"><a href="#B树的删除结点过程" class="headerlink" title="B树的删除结点过程"></a>B树的删除结点过程</h5><p>（a）原始状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011148652205748179.png"></p>
<p>（b）在上图的树中，删除21，由于删除21后的结点的索引值个数仍然大于2（Math.ceil( 5&#x2F;2 ) -1 &#x3D;2），因此删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111465154986155485210437440.png"></p>
<p>（c）接着删除27，从上图可知，由于27是非叶子结点，所以要删除27的话，需要用27的后继替代它。从上图可以看出，27的后继是28，因此我们用28来替代27，再删除原来的28，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210486515648651485111210759920.png"></p>
<p>删除后发现，当前结点(当前结点如上图所示)的索引值个数小于2个，而它的兄弟结点有3个索引值（当前结点还有一个右兄弟，选择右兄弟的话，会出现合并结点的情况，不论选哪一个都可以，只是最后的B树形态会不一样而已），那么就向左兄弟借一个索引值，注意这里的借并非直接从左兄弟结点处拿一个索引值过来，如果是这样的话，就破坏了B树父节点左子树比根结点小，右子树比根结点大的特性了。借是 把当前结点的父节点的28下移，然后把左兄弟结点的26上移到父节点，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112124865564865150254.png"></p>
<p>（d）在上述情况接着删除32</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/2021011124652354862312347403.png"></p>
<p>在删除32后，当前结点剩下31，即索引值数目小于2。这时候，它的兄弟结点，也仅仅有2个索引值，所以不能向兄弟结点借。</p>
<p>那只能够让父结点下移一个值(30)，并和兄弟结合合并成一个新的结点，如下图：当前结点的索引值个数不小于2 （Math.ceil( 5&#x2F;2 ) -1 &#x3D;2），满足条件，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/202101112%E5%8F%91v%E6%90%9E%E7%8E%AF%E4%BF%9D%E8%8A%82%E8%83%BD%E5%96%80%E9%BA%A6%E9%9A%86%EF%BC%8C%EF%BC%9B12640720.png"></p>
<p>（e）接着删除 40：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/xrectbujnmonhbuvctfvygu.png"></p>
<p>当前结点由于索引值小于2，因此需要像父结点借，父结点下移36到当前结点，然后和兄弟结点合并(选择左兄弟或右兄弟都可以，这里我选择了左兄弟)，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210114651321213700457.png"></p>
<p>但这时候发现，新的当前结点的索引值个数又小于2了，那么只能向其父结点借了，所以其父结点下移33，然后当前结点和其兄弟结点合并，如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/20210111213485249865825743.png"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote>
<p>关键字个数和孩子结点个数相同。即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。</p>
</blockquote>
<p>一颗阶数为4的B+树。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232854940-1019144331.png"></p>
<h5 id="一棵M阶B-树有以下特点"><a href="#一棵M阶B-树有以下特点" class="headerlink" title="一棵M阶B+树有以下特点"></a>一棵M阶B+树有以下特点</h5><blockquote>
<ol>
<li><p>B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</p>
</li>
<li><p>B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</p>
</li>
<li><p>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</p>
</li>
<li><p>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</p>
</li>
<li><p>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
</ol>
</blockquote>
<h5 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h5><blockquote>
<ol>
<li><p>若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p>
</li>
<li><p>针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m&#x2F;2个记录，右结点包含剩下的记录，将第m&#x2F;2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p>
</li>
<li><p>针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)&#x2F;2个key，右结点包含m-(m-1)&#x2F;2个key，将第m&#x2F;2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p>
</li>
</ol>
</blockquote>
<p>下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。</p>
<p>（a）空树中插入5</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018040sss6232858129-694616618.png"></p>
<p>（b）依次插入8，10，15</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018040623290139ss1-1401289774.png"></p>
<p>（c）插入16</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/xtcfybipoiouvyctfgbhjnlk.png"></p>
<p>​	插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232909712-1807724284.png"></p>
<p>当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。</p>
<p>（d）插入17</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232913379-576202883.png"></p>
<p>（e）插入18，插入后如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232917817-12405736a30.png"></p>
<p>​	当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-2018s0406232921679-618565224.png"></p>
<p>当前结点的关键字个数满足条件，插入结束。</p>
<p>（f）插入若干数据后</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232926305-8126505003.png"></p>
<p>（g）在上图中插入7，结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232935105-10019482143.png"></p>
<p>​	当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232940557-12047242223.png"></p>
<p>当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-201804306232945267-543224744.png"></p>
<p>当前结点的关键字个数满足条件，插入结束。</p>
<h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5><blockquote>
<p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p>
<ol>
<li><p>删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)&#x2F;2 – 1，删除操作结束,否则执行第2步。</p>
</li>
<li><p>若兄弟结点key有富余（大于Math.ceil(m-1)&#x2F;2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p>
</li>
<li><p>若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p>
</li>
<li><p>若索引结点的key的个数大于等于Math.ceil(m-1)&#x2F;2 – 1，则删除操作结束。否则执行第5步</p>
</li>
<li><p>若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p>
</li>
<li><p>当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p>
</li>
</ol>
<p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p>
</blockquote>
<p>下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。</p>
<p>（a）初始状态</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834468-20180406232951603-28451095664521.png"></p>
<p>（b）删除22,删除后结果如下图</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/83448452168-20180406232956857-909502342.png"></p>
<p>删除后叶子结点中key的个数大于等于2，删除结束</p>
<p>（c）删除15，删除后的结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/83446852sss8-20180406233002074-155906598.png"></p>
<p>​	删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834gdrvs468-20180406233008129-433585803.png"></p>
<p>（d）删除7，删除后的结果如下图所示</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834imyunhgfbd468-20180406233017339-92051658.png"></p>
<p>​	当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/8344yimutnybtdf68-20180406233022828-172757536.png"></p>
<p>此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/834imyuntytrb468-20180406233027773-1578264573.png"></p>
<h4 id="b树与b-树区别"><a href="#b树与b-树区别" class="headerlink" title="b树与b+树区别"></a>b树与b+树区别</h4><blockquote>
<ol>
<li>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li>
<li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历；</li>
<li>b+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低</li>
</ol>
</blockquote>
<h3 id="MyISAM存储引擎与InnoDB存储引擎对比"><a href="#MyISAM存储引擎与InnoDB存储引擎对比" class="headerlink" title="MyISAM存储引擎与InnoDB存储引擎对比"></a>MyISAM存储引擎与InnoDB存储引擎对比</h3><blockquote>
<ol>
<li><p><strong>事务支持：</strong>innodb支持事务，事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；而myisam强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p>
</li>
<li><p><strong>外键支持：</strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败。</p>
</li>
<li><p><strong>聚集索引</strong>：InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p>MyISAM是非<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020">聚集索引</a>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
<p>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p>
<p>InnoDB的结构：</p>
</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/urinofmkonubvjndklcsmnovdk.jpg"></p>
<p>MyISAM的结构：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/src=http___blog.zhuzi.net.cn_zb_users_upload_2020_02_20200229004600_11595.png&refer=http___blog.zhuzi.net.png"></p>
<ol start="4">
<li><p><strong>count(*)：</strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件，但是在加了wehre条件后，myisam和innodb处理的方式都一样。）；</p>
<p>那么为什么InnoDB没有了这个变量呢？</p>
<p> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。</p>
</li>
<li><p><strong>全文索引：</strong>MyISAM支持 FULLTEXT类型的全文索引；InnoDB的不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好，而且自从mysql5.6版本开始innodb就已经开始支持全文索引，mysql8.0则完全抛弃MyISAM存储引擎了，所以淡化MyISAM吧，已经逐渐成为历史产品，innoDB引擎对FULLTEXT索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持FULLTEXT索引。</p>
</li>
<li><p><strong>表锁差异：</strong>myisam只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁；innodb支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。<strong>但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</strong></p>
</li>
<li><p><strong>主键差异：</strong>MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址；而InnoDB如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
</li>
<li><p><strong>存储结构：</strong>每个MyISAM表在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。而innodb是由.frm文件、表空间（分为独立表空间或者共享表空间，如果在配置文件中配置了innodb_file_per_table&#x3D;true或者不配置就会使用独立表空间）和日志文件（redo log）组成。</p>
</li>
<li><p><strong>都是B+树索引：</strong>Innodb是索引组织表，myisam是堆表</p>
</li>
</ol>
</blockquote>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><h4 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h4><h5 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h5><blockquote>
<p>​	InnoDB 将数据划分为若干个页，InnoDB中页的大小默认为 16KB 。</p>
</blockquote>
<blockquote>
<p>​	以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库 I&#x2F;O 操作的最小单位是页。一个页中可以存储多个行记录。</p>
</blockquote>
<h5 id="页结构概述"><a href="#页结构概述" class="headerlink" title="页结构概述"></a>页结构概述</h5><blockquote>
<p>​	页a、页b、页c … 页n <strong>这些页可以不在物理结构上相连，只要通过双向链表相关联即可</strong>。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
</blockquote>
<h5 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h5><blockquote>
<p>​	另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/rtfyuijnibuvyctxrectuvybhjnmklmji.jpg"></p>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><blockquote>
<p>​	数据页的16KB 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum+supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>
</blockquote>
<p>页结构的示意图如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrectvbuhjnnhbgvfdxrszexrdfvbhnjk.jpg"></p>
<h5 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/dxrcfvgbhjnkmjnbufct.jpg"></h5><h5 id="File-Tailer"><a href="#File-Tailer" class="headerlink" title="File Tailer"></a>File Tailer</h5><blockquote>
<ul>
<li><p>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</p>
</li>
<li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p>
</li>
</ul>
</blockquote>
<h5 id="Free-Space"><a href="#Free-Space" class="headerlink" title="Free Space"></a>Free Space</h5><blockquote>
<p>​	我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjnhgbfvdcvbrytuymutny.png"></p>
<h5 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h5><blockquote>
<p>User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。</p>
</blockquote>
<h6 id="compact行格式"><a href="#compact行格式" class="headerlink" title="compact行格式"></a>compact行格式</h6><blockquote>
<p>​	在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-22_13-41-43.png"></p>
<p><strong>记录头信息：</strong></p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>这个表中记录的行格式示意图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctrybuinonyutycfgbhj.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/tybuhnjihbugvyfgbhjnk.png"></p>
<p>插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>), </span><br><span class="line">    (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>), </span><br><span class="line">    (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>), </span><br><span class="line">    (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>图示如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/trcyuboiomoiuiyty.png"></p>
<h5 id="Infimum-supremum"><a href="#Infimum-supremum" class="headerlink" title="Infimum + supremum"></a>Infimum + supremum</h5><blockquote>
<p>记录可以比较大小吗？<br>    是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p>
</blockquote>
<blockquote>
<p>​	InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nhtgbdsdvbdfx.png"></p>
</blockquote>
<blockquote>
<p>​	这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/unthgbdfvdsbtnmhnb.png"></p>
</blockquote>
<h5 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h5><blockquote>
<p>为什么需要页目录？<br>    在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</p>
</blockquote>
<blockquote>
<p>使用页目录，二分法查找</p>
<ol>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br> 最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br> 其余的组记录数量在 4-8 条之间。<br> 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
</blockquote>
<p>举例1：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/yujegwedxs.png"></p>
<p>举例2：</p>
<blockquote>
<p>​	现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctfuvygibjnmk,l;..png"></p>
</blockquote>
<blockquote>
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li>
<li>注意最小和最大记录的头信息中的n_owned属性<ul>
<li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li>
<li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li>
</ul>
</li>
</ul>
<p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/tfcvgbhjnmkjnibuvyct.png"></p>
<p>再换个角度看一下：（单纯从逻辑上看一下这些记录和页目录的关系）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fghjbklmjnibyuty.png"></p>
</blockquote>
<h5 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h5><blockquote>
<p>​	为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/utyetwercwwrvt.png"></p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><blockquote>
<p>​	B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I&#x2F;O 。再一次强调，磁盘的速度和内存的速度差了好几个数量级， 随机I&#x2F;O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I&#x2F;O 。</p>
<p>引入区的概念，一个区就是在物理位置上连续的64个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D; 1MB 。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O， 功大于过！</p>
</blockquote>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><blockquote>
<p>​	对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（ segment ），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>​	除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。<br>​	在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。<br>​	段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
</blockquote>
<h4 id="碎片区"><a href="#碎片区" class="headerlink" title="碎片区"></a>碎片区</h4><blockquote>
<p>​	默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64 * 16Kb &#x3D; 1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。<br>​	为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p>
</blockquote>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><blockquote>
<p>​	表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。<br>​	表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间（System tablespace）、独立表空间（File-per-table tablespace）、撤销表空间（Undo Tablespace）和临时表空间（Temporary Tablespace）等。</p>
</blockquote>
<h5 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h5><blockquote>
<p>​	独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即：单表）可以在不同的数据库之间进行迁移。<br>​	空间可以回收（DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收）。如果对于统计分析或是日志表，删除大量数据后可以通过： alter table TableName engine&#x3D;innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
</blockquote>
<h6 id="真实表空间对应的文件大小"><a href="#真实表空间对应的文件大小" class="headerlink" title="真实表空间对应的文件大小"></a>真实表空间对应的文件大小</h6><blockquote>
<p>​	我们到数据目录里看，会发现一个新建的表对应的.ibd 文件只占用了96K ，才6个页面大小（MySQL5.7中），这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些.ibd文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
</blockquote>
<h5 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h5><blockquote>
<p>​	系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
</blockquote>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><blockquote>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</li>
</ol>
</blockquote>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>索引（Index）：是帮助MySQL高效获取数据的数据结构。</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 </p>
<p>（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，<br>可以提高查询速度。 </p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 </p>
<p>（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p>
</blockquote>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><blockquote>
<p>从功能逻辑上说，索引主要有 4 种，分别是<strong>普通索引</strong>、<strong>唯一索引</strong>、<strong>主键索引</strong>、<strong>全文索引</strong>。</p>
</blockquote>
<blockquote>
<p>按照物理实现方式，索引可以分为 2 种：<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。</p>
</blockquote>
<blockquote>
<p>按照作用字段个数进行划分，分成<strong>单列索引</strong>和<strong>联合索引</strong>。</p>
</blockquote>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h5><p><font color = 'red'>说明：在创建表的被primary key、unique、foreign key 所修饰的属性，会自动创建索引。</font></p>
<h6 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h6><p>在book表中的year_publication字段上建立普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">    book_id   <span class="type">INT</span>,</span><br><span class="line">    book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    authors   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    info      <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    comment   <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">    INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line">    id   <span class="type">INT</span>         <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX uk_idx_id (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id           <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT,</span><br><span class="line">    student_no   <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h6 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(</span><br><span class="line">    id   <span class="type">INT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX single_idx_name (name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test3(</span><br><span class="line">    id   <span class="type">INT</span>(<span class="number">11</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age  <span class="type">INT</span>(<span class="number">11</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    INDEX multi_idx (id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `papers`(</span><br><span class="line">    `id`      <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `title`   <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` text,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    FULLTEXT KEY `title` (`title`, `content`)</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<p>不同于like方式的的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>

<h6 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h6><p>空间索引创建中，要求空间类型的字段必须为非空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test5(</span><br><span class="line">    geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    SPATIAL INDEX spa_idx_geo (geo)</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM;</span><br></pre></td></tr></table></figure>

<h5 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h5><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<h6 id="使用ALTER-TABLE语句创建索引"><a href="#使用ALTER-TABLE语句创建索引" class="headerlink" title="使用ALTER TABLE语句创建索引"></a>使用ALTER TABLE语句创建索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<h6 id="使用CREATE-INDEX创建索引"><a href="#使用CREATE-INDEX创建索引" class="headerlink" title="使用CREATE INDEX创建索引"></a>使用CREATE INDEX创建索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><h6 id="使用ALTER-TABLE删除索引"><a href="#使用ALTER-TABLE删除索引" class="headerlink" title="使用ALTER TABLE删除索引"></a>使用ALTER TABLE删除索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h6 id="使用DROP-INDEX语句删除索引"><a href="#使用DROP-INDEX语句删除索引" class="headerlink" title="使用DROP INDEX语句删除索引"></a>使用DROP INDEX语句删除索引</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a>MySQL8.0索引新特性</h4><h5 id="支持降序索引-默认索引排序是升序的"><a href="#支持降序索引-默认索引排序是升序的" class="headerlink" title="支持降序索引(默认索引排序是升序的)"></a>支持降序索引(默认索引排序是升序的)</h5><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));</span><br></pre></td></tr></table></figure>

<h5 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h5><blockquote>
<p>​	在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>​	从MySQL 8.x开始支持隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
</blockquote>
<blockquote>
<p><font color='red'>注意：</font>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<h6 id="创建表时直接创建"><a href="#创建表时直接创建" class="headerlink" title="创建表时直接创建"></a>创建表时直接创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">    propname1 type1[CONSTRAINT1],</span><br><span class="line">    propname2 type2[CONSTRAINT2],</span><br><span class="line">    ……</span><br><span class="line">    propnamen typen,</span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="在已经存在的表上创建"><a href="#在已经存在的表上创建" class="headerlink" title="在已经存在的表上创建"></a>在已经存在的表上创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<h6 id="通过ALTER-TABLE语句创建"><a href="#通过ALTER-TABLE语句创建" class="headerlink" title="通过ALTER TABLE语句创建"></a>通过ALTER TABLE语句创建</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<h6 id="切换索引可见状态"><a href="#切换索引可见状态" class="headerlink" title="切换索引可见状态"></a>切换索引可见状态</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><h5 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h5><h6 id="字段的数值有唯一性的限制"><a href="#字段的数值有唯一性的限制" class="headerlink" title="字段的数值有唯一性的限制"></a>字段的数值有唯一性的限制</h6><blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
</blockquote>
<h6 id="频繁作为-WHERE-查询条件的字段"><a href="#频繁作为-WHERE-查询条件的字段" class="headerlink" title="频繁作为 WHERE 查询条件的字段"></a>频繁作为 WHERE 查询条件的字段</h6><blockquote>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
</blockquote>
<h6 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h6><blockquote>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p>
</blockquote>
<h6 id="UPDATE、DELETE-的-WHERE-条件列"><a href="#UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="UPDATE、DELETE 的 WHERE 条件列"></a>UPDATE、DELETE 的 WHERE 条件列</h6><blockquote>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
</blockquote>
<h6 id="DISTINCT-字段需要创建索引"><a href="#DISTINCT-字段需要创建索引" class="headerlink" title="DISTINCT 字段需要创建索引"></a>DISTINCT 字段需要创建索引</h6><blockquote>
<p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
</blockquote>
<h6 id="多表-JOIN-连接操作时，创建索引注意事项"><a href="#多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="多表 JOIN 连接操作时，创建索引注意事项"></a>多表 JOIN 连接操作时，创建索引注意事项</h6><blockquote>
<ul>
<li>首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li>
<li>其次， 对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li>
<li>最后， 对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型，不然因为使用函数对类型转换时，会导致该索引失效。</li>
</ul>
</blockquote>
<h6 id="使用字符串前缀创建索引"><a href="#使用字符串前缀创建索引" class="headerlink" title="使用字符串前缀创建索引"></a>使用字符串前缀创建索引</h6><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？<br>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure>

<p>通过不同长度去计算，与全表的选择性对比：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p>
</blockquote>
<h6 id="使用最频繁的列放到联合索引的左侧"><a href="#使用最频繁的列放到联合索引的左侧" class="headerlink" title="使用最频繁的列放到联合索引的左侧"></a>使用最频繁的列放到联合索引的左侧</h6><h6 id="在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>在多个字段都要创建索引的情况下，联合索引优于单值索引</h6><h5 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h5><h6 id="在where中使用不到的字段，不要设置索引"><a href="#在where中使用不到的字段，不要设置索引" class="headerlink" title="在where中使用不到的字段，不要设置索引"></a>在where中使用不到的字段，不要设置索引</h6><h6 id="数据量小的表最好不要使用索引"><a href="#数据量小的表最好不要使用索引" class="headerlink" title="数据量小的表最好不要使用索引"></a>数据量小的表最好不要使用索引</h6><h6 id="有大量重复数据的列上不要建立索引"><a href="#有大量重复数据的列上不要建立索引" class="headerlink" title="有大量重复数据的列上不要建立索引"></a>有大量重复数据的列上不要建立索引</h6><blockquote>
<p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
</blockquote>
<blockquote>
<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
</blockquote>
<h6 id="避免对经常更新的表创建过多的索引"><a href="#避免对经常更新的表创建过多的索引" class="headerlink" title="避免对经常更新的表创建过多的索引"></a>避免对经常更新的表创建过多的索引</h6><h4 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h4><h5 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h5><p>在MySQL中，可以使用SHOW STATUS 语句查询一些MySQL数据库服务器的性能参数、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<blockquote>
<ul>
<li>connections：连接MySQL服务器的次数</li>
<li>uptime：MySQL服务器的上线时间</li>
<li>slow_queries：慢查询的次数</li>
<li>innodb_rows_read：Select查询返回的行数</li>
<li>innodb_rows_inserted：执行INSERT操作插入的行数</li>
<li>innodb_rows_updated：执行UPDATE操作更新的行数</li>
<li>innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>com_select：查询操作的次数</li>
<li>com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次</li>
<li>com_update：更新操作的次数</li>
<li>com_delete：删除操作的次数</li>
</ul>
</blockquote>
<h5 id="统计SQL的查询成本：last-query-cost"><a href="#统计SQL的查询成本：last-query-cost" class="headerlink" title="统计SQL的查询成本：last_query_cost"></a>统计SQL的查询成本：last_query_cost</h5><p>student_info 表为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info`(</span><br><span class="line">    `id`          <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `student_id`  <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`        <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `course_id`   <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `class_id`    <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` DATETIME    <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（1 条记录，运行时间为 0.042s ）</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（100 条记录，运行时间为 0.046s ）：</p>
<p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span>   <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了<strong>顺序读取</strong>的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
</blockquote>
<h4 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h4><blockquote>
<p><font color='red'>默认情况下，不开启慢查询日志</font></p>
</blockquote>
<h5 id="开启slow-query-log"><a href="#开启slow-query-log" class="headerlink" title="开启slow_query_log"></a>开启slow_query_log</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/trvhjmkojigbytdcrcgbhjkmhubtfyu.jpg"></p>
<blockquote>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu02-slow.log 文件中。</p>
</blockquote>
<h5 id="修改long-query-time阈值"><a href="#修改long-query-time阈值" class="headerlink" title="修改long_query_time阈值"></a>修改long_query_time阈值</h5><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fcygvhbjlnbhuvyctxrdtgvbhjkml.jpg"></p>
<p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="查看慢查询数目"><a href="#查看慢查询数目" class="headerlink" title="查看慢查询数目"></a>查看慢查询数目</h5><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h5><h4 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-24-28.png"></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1(</span><br><span class="line">    id           <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">INT</span>,</span><br><span class="line">    key3         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-28-28.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2(</span><br><span class="line">    id           <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">INT</span>,</span><br><span class="line">    key3         <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-23_11-30-43.png"></p>
<h5 id="explain各列作用"><a href="#explain各列作用" class="headerlink" title="explain各列作用"></a>explain各列作用</h5><h6 id="table"><a href="#table" class="headerlink" title="table"></a>table</h6><blockquote>
<p>​	不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p>
</blockquote>
<h6 id="id"><a href="#id" class="headerlink" title="id"></a>id</h6><blockquote>
<p>​	我们写的查询语句一般都以SELECT 关键字开头，比较简单的查询语句里只有一个SELECT 关键字，比如下边这个查询语句：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的连接查询中也只有一个SELECT 关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mutyhtbgvfcdfvb.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/gfbsdsvrabgddvs.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nhtgbdsdvbrtdfdsv.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field</span><br><span class="line"><span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/fcghvjblkbugycfgvhbj.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/dtcfygvubhjnklm;,.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/vyighbjnklm.jpg"></p>
<p><strong>小结：</strong></p>
<blockquote>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
</blockquote>
<h6 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h6><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>SIMPLE代表单表查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrdtcfuvgbhjnkml.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/xrdtcfygvuijnmk;,l.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmjnhbugvfctdr.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmljnbhuvycrt.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjnbhgvyfctd.jpg"></p>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><blockquote>
<p>​	结果值从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 其中比较重要的几个提取出来（见上图中的蓝<br>色）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴<br>开发手册要求）</p>
</blockquote>
<p><strong>const：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mklnjuibyuvtf.jpg"></p>
<p><strong>eq_ref：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmjnbhugvycrt.jpg"></p>
<blockquote>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref ，表明在访问s1表的时候可以通过主键的等值匹配来进行访问。</p>
</blockquote>
<p><strong>ref：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkjhnbugvyr.jpg"></p>
<p><strong>index_merge：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jkbhuvtyc.jpg"></p>
<p><strong>ALL：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnihbugvyf.jpg"></p>
<h6 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmojnihbugvyf.jpg"></p>
<h6 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjnibhuvyct.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/nibuvyfct.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbgvfctd.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbugvyftcdrx.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnhbugvyfctd.jpg"></p>
<p>练习：<br>key_len的长度计算公式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h6 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/hbgvfctdxr.jpg"></p>
<h4 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class`</span><br><span class="line">(</span><br><span class="line">    `id`        <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address`   <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `monitor`   <span class="type">INT</span>     <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`(</span><br><span class="line">    `id`      <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `stuno`   <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`    <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age`     <span class="type">INT</span>(<span class="number">3</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `classId` <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">#<span class="keyword">CONSTRAINT</span> `fk_class_id` <span class="keyword">FOREIGN</span> KEY (`classId`) <span class="keyword">REFERENCES</span> `t_class` (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<h5 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h5><h6 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h6><h6 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h6><h6 id="计算、函数、类型转换-自动或手动-导致索引失效"><a href="#计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="计算、函数、类型转换(自动或手动)导致索引失效"></a>计算、函数、类型转换(自动或手动)导致索引失效</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="类型转换导致索引失效"><a href="#类型转换导致索引失效" class="headerlink" title="类型转换导致索引失效"></a>类型转换导致索引失效</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）"><a href="#范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）" class="headerlink" title="范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）"></a>范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mojnihbugvyfctdr.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_age_name_classid <span class="keyword">on</span> student(age,name,classid);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjhjbgvyfctdrx.jpg"></p>
<h6 id="不等于-或者-索引失效-在覆盖索引可能会失效）"><a href="#不等于-或者-索引失效-在覆盖索引可能会失效）" class="headerlink" title="不等于(!&#x3D; 或者&lt;&gt;)索引失效(在覆盖索引可能会失效）"></a>不等于(!&#x3D; 或者&lt;&gt;)索引失效(在覆盖索引可能会失效）</h6><h6 id="is-null可以使用索引，is-not-null无法使用索引"><a href="#is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="is null可以使用索引，is not null无法使用索引"></a>is null可以使用索引，is not null无法使用索引</h6><h6 id="like以通配符-开头索引失效"><a href="#like以通配符-开头索引失效" class="headerlink" title="like以通配符%开头索引失效"></a>like以通配符%开头索引失效</h6><h6 id="OR-前后存在非索引的列，索引失效"><a href="#OR-前后存在非索引的列，索引失效" class="headerlink" title="OR 前后存在非索引的列，索引失效"></a>OR 前后存在非索引的列，索引失效</h6><blockquote>
<p> <font color='red'>建议把查询记录少的放在or的前面</font></p>
<p>用<strong>in来替换or</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">低效: </span><br><span class="line"><span class="keyword">select</span>…. <span class="keyword">from</span> location <span class="keyword">where</span> loc_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">30</span> </span><br><span class="line">高效 </span><br><span class="line"><span class="keyword">select</span>… <span class="keyword">from</span> location <span class="keyword">where</span> loc_in  <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>OR，就是从a1匹配，匹配失败，去匹配a2，直到匹配成功或者一个都匹配不上，时间复杂度O(n)</li>
<li>IN，先将a1, a2, …, an变成二叉树，通过二叉树查找，时间复杂度O(log n)</li>
</ul>
</blockquote>
<h6 id="数据库和表的字符集统一使用utf8mb4"><a href="#数据库和表的字符集统一使用utf8mb4" class="headerlink" title="数据库和表的字符集统一使用utf8mb4"></a>数据库和表的字符集统一使用utf8mb4</h6><h5 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h5><blockquote>
<ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将小结果集的表选为驱动表。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
</blockquote>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><blockquote>
<p>​	执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
</blockquote>
<blockquote>
<p>​	在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
</blockquote>
<blockquote>
<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote>
<p>​	非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> cover(</span><br><span class="line">    id      <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    age     <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">    name    <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    idcard  <span class="type">varchar</span>(<span class="number">18</span>),</span><br><span class="line">    address <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    gender  <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index `idx_age_name_idcard` <span class="keyword">on</span> cover (age, name, idcard);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 索引 有效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">4</span> ;</span><br><span class="line"># 索引 有效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cover <span class="keyword">where</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 失效</span><br><span class="line">explain <span class="keyword">select</span> gender <span class="keyword">from</span> cover <span class="keyword">where</span> idcard <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"># 索引 有效(这是属于优化器优化的结果，是要回表的)</span><br><span class="line">explain <span class="keyword">select</span> sql_no_cache gender <span class="keyword">from</span> cover <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5 id="好处-2"><a href="#好处-2" class="headerlink" title="好处"></a>好处</h5><blockquote>
<ol>
<li>避免Innodb表进行索引的二次查询（回表）</li>
<li>可以把随机IO变成顺序IO加快查询效率</li>
</ol>
</blockquote>
<h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><blockquote>
<p>​	索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p>
</blockquote>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="键和相关属性的概念"><a href="#键和相关属性的概念" class="headerlink" title="键和相关属性的概念"></a>键和相关属性的概念</h4><blockquote>
<p><strong>超键：</strong>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 </p>
<p><strong>候选键：</strong>是最小超键，即没有冗余元素的超键。 </p>
<p><strong>主键：</strong>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 </p>
<p><strong>外键：</strong>在一个表中存在的另一个表的主键称此表的外键。</p>
</blockquote>
<blockquote>
<p>这里有两个表：<br>    球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号<br>    球队表(team) ：  球队编号 | 主教练 | 球队所在地</p>
</blockquote>
<blockquote>
<p><strong>超键：</strong>对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）、（球员编号，姓名）、（身份证号，年龄）等。</p>
<p><strong>候选键：</strong>对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p><strong>主键：</strong>我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p><strong>外键：</strong>球员表中的球队编号。<br>主属性、非主属性：在球员表中，主属性是（球员编号）、（身份证号），其他的属性（姓名）、（年龄）、（球队编号）都是非主属性。</p>
</blockquote>
<h4 id="范式简介"><a href="#范式简介" class="headerlink" title="范式简介"></a>范式简介</h4><blockquote>
<p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</p>
</blockquote>
<blockquote>
<p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkjnibuytcrexzw.jpg"></p>
</blockquote>
<h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式(1st NF)"></a>第一范式(1st NF)</h4><blockquote>
<p>数据表的每一列都要保持它的原子特性，也就是列不能再被分割。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1487363-20190521195635864-1806009902.jpg"></p>
<blockquote>
<p>这张表就不符合第一范式规定的原子性，不符合关系型数据库的基本要求，在关系型数据库中创建这个表的操作就不能成功。不得不将数据表设计为如下形式。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1487363-20190521195649651-325732847.jpg"></p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><blockquote>
<p>非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p>
</blockquote>
<blockquote>
<p>比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p>
</blockquote>
<blockquote>
<ol>
<li>数据冗余：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</li>
</ol>
</blockquote>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><blockquote>
<p>任何非主<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7">属性</a>不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211311408-1364899740.png"></p>
<blockquote>
<p>上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，而不是主键“学号”，所以需做如下调整：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211539242-1391100354.png" alt="5"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/1218459-20180909211602202-1069383439.png"></p>
<h4 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h4><blockquote>
<p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。</p>
</blockquote>
<h4 id="BCFN-巴斯-科德范式"><a href="#BCFN-巴斯-科德范式" class="headerlink" title="BCFN(巴斯-科德范式)"></a>BCFN(巴斯-科德范式)</h4><blockquote>
<p>它在 3NF 的基础上消除了主属性对候选键的部分函数依赖或者传递依赖关系。</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><h5 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h5><blockquote>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
</blockquote>
<h5 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h5><blockquote>
<p>一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。</p>
<p>举例说明：张三向李四转100元，转账前和转账后的数据是正确的状态，这就叫一致性，如果出现张三转出100元，李四账号没有增加100元这就出现了数据错误，就没有达到一致性。</p>
</blockquote>
<h5 id="隔离型（isolation）"><a href="#隔离型（isolation）" class="headerlink" title="隔离型（isolation）"></a>隔离型（isolation）</h5><blockquote>
<p>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</blockquote>
<h5 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h5><blockquote>
<p>一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</blockquote>
<blockquote>
<p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
</blockquote>
<h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><h5 id="活动的（active）"><a href="#活动的（active）" class="headerlink" title="活动的（active）"></a>活动的（active）</h5><blockquote>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</p>
</blockquote>
<h5 id="部分提交的（partially-committed）"><a href="#部分提交的（partially-committed）" class="headerlink" title="部分提交的（partially committed）"></a>部分提交的（partially committed）</h5><blockquote>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
</blockquote>
<h5 id="失败的（failed）"><a href="#失败的（failed）" class="headerlink" title="失败的（failed）"></a>失败的（failed）</h5><blockquote>
<p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p>
</blockquote>
<h5 id="中止的（aborted）"><a href="#中止的（aborted）" class="headerlink" title="中止的（aborted）"></a>中止的（aborted）</h5><blockquote>
<p>如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
</blockquote>
<h5 id="提交的（committed）"><a href="#提交的（committed）" class="headerlink" title="提交的（committed）"></a>提交的（committed）</h5><blockquote>
<p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/lkmjnibyutv6rf5de4.jpg"></p>
<h4 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h4><blockquote>
<p>使用事务有两种方式，分别为显式事务和隐式事务。</p>
</blockquote>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h5><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"># 或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure>

<p>START TRANSACTION 语句相较于BEGIN 特别之处在于，后边能跟随几个修饰符：</p>
<blockquote>
<p>① READ ONLY ：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<p>② READ WRITE ：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
<p>③ WITH CONSISTENT SNAPSHOT ：启动一致性读。</p>
</blockquote>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL）</p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure>

<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><p>MySQL中有一个系统变量autocommit ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span>   <span class="keyword">ON</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p>
<ul>
<li>显式的的使用START TRANSACTION 或者BEGIN 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li>
<li>把系统变量autocommit 的值设置为OFF ，就像这样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h6><blockquote>
<ul>
<li>数据定义语言（Data definition language，缩写为：DDL）</li>
<li>隐式使用或修改mysql数据库中的表</li>
<li>事务控制或关于锁定的语句</li>
</ul>
<p>① 当我们在一个事务还没提交或者回滚时就又使用START TRANSACTION 或者BEGIN 语句开启了<br>另一个事务时，会隐式的提交上一个事务。</p>
<p>② 当前的autocommit 系统变量的值为OFF ，我们手动把它调为ON 时，也会隐式的提交前边语<br>句所属的事务。</p>
<p>③ 使用LOCK TABLES 、UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事<br>务。</p>
</blockquote>
<blockquote>
<ul>
<li>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</li>
<li>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</li>
</ul>
</blockquote>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    studentno <span class="type">INT</span>,</span><br><span class="line">    name      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    class     <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) Engine <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小谷&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> studentno <span class="operator">|</span>   name <span class="operator">|</span> class <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span>      <span class="operator">|</span>  小谷   <span class="operator">|</span>  <span class="number">1</span>班 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h5><h6 id="脏写（-Dirty-Write-）"><a href="#脏写（-Dirty-Write-）" class="headerlink" title="脏写（ Dirty Write ）"></a>脏写（ Dirty Write ）</h6><blockquote>
<p>对于两个事务 Session A、Session B，如果事务Session A 修改了另一个未提交事务Session B 修改过的数据，那就意味着发生了脏写。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/Snipaste_2022-01-24_19-40-26.png"></p>
<blockquote>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p>
</blockquote>
<h6 id="脏读（-Dirty-Read-）"><a href="#脏读（-Dirty-Read-）" class="headerlink" title="脏读（ Dirty Read ）"></a>脏读（ Dirty Read ）</h6><blockquote>
<p>对于两个事务 Session A、Session B，Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ctyubiomkjnitrctu.png"></p>
<blockquote>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
</blockquote>
<h6 id="不可重复读（-Non-Repeatable-Read-）"><a href="#不可重复读（-Non-Repeatable-Read-）" class="headerlink" title="不可重复读（ Non-Repeatable Read ）"></a>不可重复读（ Non-Repeatable Read ）</h6><blockquote>
<p>假设缓存页里一条数据原来的值是 A 值，此时事务 A 开启之后，第一次查询这条数据，读取到的就是 A 值。接着事务 B 更新了那行数据的值为 B 值，同时事务 B 立马提交了，然后事务 A 此时还没提交。大家注意，此时事务 A 是没提交的，它在事务执行期间第二次查询数据，此时查到的是事务 B 修改过的值，B 值，因为事务 B 已经提交了，所以事务 A 是可以读到的，紧接着事务 C 再次更新数据为 C 值，并且提交事务了，此时事务 A 在还没提交的情况下，第三次查询数据，查到的值为 C 值。</p>
</blockquote>
<h6 id="幻读（-Phantom-）"><a href="#幻读（-Phantom-）" class="headerlink" title="幻读（ Phantom ）"></a>幻读（ Phantom ）</h6><blockquote>
<p>对于两个事务Session A、Session B, Session A 从一个表中读取了一个字段, 然后 Session B 在该表中插入了一些新的行。 之后, 如果 Session A 再次读取同一个表, 就会多出几行。那就意味着发生了幻读。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mjniohbyutrc.png"></p>
<blockquote>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
</blockquote>
<h5 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h5><blockquote>
<p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：<strong>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</strong></p>
</blockquote>
<blockquote>
<p><strong>READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</p>
<p><strong>READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</p>
<p><strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnibuyctrxezwxrctbyu.jpg"></p>
<h5 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h5><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br></pre></td></tr></table></figure>

<p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响：</p>
<ul>
<li><p>使用GLOBAL 关键字（在全局范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用SESSION 关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事务之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<h5 id="不同隔离级别举例"><a href="#不同隔离级别举例" class="headerlink" title="不同隔离级别举例"></a>不同隔离级别举例</h5><h6 id="演示1-读未提交之脏读"><a href="#演示1-读未提交之脏读" class="headerlink" title="演示1. 读未提交之脏读"></a>演示1. 读未提交之脏读</h6><p>设置隔离级别为未提交读：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kmnjibuyvctrxezw.jpg"></p>
<p>事务1和事务2的执行流程如下：<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/mkljnihbuytcrxe.jpg"></p>
<h6 id="演示2：读已提交"><a href="#演示2：读已提交" class="headerlink" title="演示2：读已提交"></a>演示2：读已提交</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/kjnibhyvucrtxe.jpg"></p>
<h6 id="演示3：可重复读"><a href="#演示3：可重复读" class="headerlink" title="演示3：可重复读"></a>演示3：可重复读</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/jnbhgvyfctxerzewrx.jpg"></p>
<h6 id="演示4：幻读"><a href="#演示4：幻读" class="headerlink" title="演示4：幻读"></a>演示4：幻读</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img5/ojnibhuyvtcrex5rctyvubyino.jpg"></p>
<h4 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h4><blockquote>
<p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由锁机制实现。</li>
<li>事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul>
<li>REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>有的DBA或许会认为UNDO是REDo的逆过程，其实不然。REDO和UNDO都可以视为是一种恢复操作，但是:</p>
<ul>
<li>REDO LOG：是存储引擎层(innodb)生成的日志，记录的是”物理级别”上的页修改操作，比如页号xx、偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性;</li>
<li>UNDO LOG；是存储引擎层(innodb)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚(undo log记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)。</li>
</ul>
</blockquote>
<h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><h6 id="好处-3"><a href="#好处-3" class="headerlink" title="好处"></a>好处</h6><blockquote>
<ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
</blockquote>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><blockquote>
<ul>
<li>redo日志是顺序写入磁盘的</li>
<li>事务执行过程中，redo log不断记录</li>
</ul>
</blockquote>
<h6 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h6><p>Redo log可以简单分为以下两个部分：</p>
<ul>
<li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li>
</ul>
<p>参数设置：innodb_log_buffer_size：<br>redo log buffer 大小，<strong>默认16M</strong> ，最大值是4096M，最小值为1M。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</li>
</ul>
<h6 id="redo-log的整体流程"><a href="#redo-log的整体流程" class="headerlink" title="redo log的整体流程"></a>redo log的整体流程</h6><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njbhugvyctryvubijnokm.jpg"></p>
<blockquote>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
</blockquote>
<h6 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h6><blockquote>
<p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定的频率刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibyutyrtertcryubi.jpg"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>针对这种情况，InnoDB给出innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li>
<li>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值）</li>
<li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li>
</ul>
<h6 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h6><p><strong>补充概念：Mini-Transaction</strong></p>
<p>MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr 组成，每一个mtr 又可以包含若干条redo日志，画个图表示它们的关系就是这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/ouiygt7fr6de5rftyioipo.jpg"></p>
<p><strong>redo 日志写入log buffer</strong></p>
<p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block(512字节)中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示:</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibuvyctexrze.jpg"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。我们现在假设有两个名为T1、T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下:</p>
<ul>
<li><p>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</p>
</li>
<li><p>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2。</p>
</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkhbjgvyfcdtxrzea.jpg"></p>
<p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kmjnihbugvyfctdxrs.jpg"></p>
<p><strong>redo log block的结构图</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kjnhbugvyfctdxrjhbugvy.jpg"></p>
<h6 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h6><p>MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。</p>
<p>单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p>
<p><strong>日志文件组</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/khbjgvyfctdxrze.jpg"></p>
<p>总共的redo日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。<br>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p>
<p><strong>checkpoint</strong></p>
<p>在整个日志文件组中还有两个重要的属性，分别是write pos、checkplointo </p>
<ul>
<li>write pos是当前记录的位置，一边写一边后移</li>
<li>checkpoint是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MysQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把 checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbugvyfctdxrszerxdfgbhinj.jpg"></p>
<p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mkojnihbugvyfctdx.jpg"></p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><blockquote>
<p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log 。</p>
</blockquote>
<blockquote>
<p><strong>保存了事务发生之前的数据的一个版本</strong>，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
</blockquote>
<blockquote>
<p>​	事务发生异常需要回滚，这时就需要回滚日志。回滚日志不同于重做日志，它是<strong>逻辑日志</strong>，<strong>对数据库的修改都逻辑的取消</strong>了。<strong>当事务回滚时，它实际上做的是与先前相反的工作。对于每个INSERT，InnoDB存储引擎都会完成一个DELETE；对于每个UPDATE，InnoDB存储引擎都会执行一个相反的UPDATE。</strong></p>
<p>　　未提交的事务和回滚了的事务也会产生重做日志。InnoDB存储引擎会重做所有事务包括未提交的事务和回滚了的事务，然后通过回滚日志回滚那些未提交的事务。使用这种策略需要回滚日志在重做日志之前写入磁盘，使得持久化变得复杂起来。为了降低复杂度，InnoDB存储引擎将回滚日志作数据，记录回滚日志的操作也会记录到重做日志中。这样回滚日志就可以像数据一样缓存起来，而不用在重写日志之前写入磁盘了。</p>
</blockquote>
<h6 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h6><p><strong>回滚段与undo页</strong></p>
<blockquote>
<p>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment） 。每个回滚段记录了1024 个undo log segment ，而在每个undo log segment段中进行undo页的申请。</p>
<ul>
<li>在InnoDB1.1版本之前（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为1024 。虽然对绝大多数的应用来说都已经够用。</li>
<li>从1.1版本开始InnoDB支持最大128个rollback segment ，故其支持同时在线的事务限制提高到了128*1024 。</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong>回滚段与事务</strong></p>
<blockquote>
<ol>
<li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p>
</li>
<li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p>
</li>
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
</li>
<li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p>
</li>
<li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>​	<strong>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间</strong>。</p>
</blockquote>
<p><strong>undo log 可重用</strong></p>
<blockquote>
<p>​	当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。</p>
<p>​	为每一个事务分配一个页，是非常浪费的，于是undo页就被设计的可以重用了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3&#x2F;4，如果小于3&#x2F;4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。</p>
</blockquote>
<p><strong>undo log的类型</strong></p>
<blockquote>
<p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li><p><strong>insert undo log</strong>是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
</li>
<li><p><strong>update undo log</strong>记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
</li>
</ul>
</blockquote>
<p><strong>undo log的生命周期</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/nibyuvtcr6x5ctvyubio.jpg"></p>
<p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p>
<ul>
<li><p>DB_ROW_ID:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</p>
</li>
<li><p>DB_TRX_ID:每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。I</p>
</li>
<li><p>DB_ROLL_PTR:回滚指针，本质上就是指向undo log的指针。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbyutrcex4wexrctyuio.jpg"></p>
<p>当我们执行INSERT时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jonihbugvfydxrctfybhnjiom.jpg"></p>
<p>当我们执行UPDATE时：</p>
<p>对于更新的操作会产生update undo log，并且会分更新主键的和不更新主键的，假设现在执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span>&quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkbhugvfctdxrtcfygujnmk.jpg"></p>
<p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no&#x3D;0) 。<br>假设现在执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/kjnibhugtycrxetcybyuij.jpg"></p>
<p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增</p>
<p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p>
<p><strong>undo log是如何回滚的</strong></p>
<blockquote>
<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ol>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbvgyctxcryvuybimk.jpg"></p>
<h5 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h5><h6 id="锁所在的事务信息"><a href="#锁所在的事务信息" class="headerlink" title="锁所在的事务信息"></a>锁所在的事务信息</h6><blockquote>
<p>​	不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个事务的信息。此锁所在的事务信息在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
</blockquote>
<h6 id="索引信息"><a href="#索引信息" class="headerlink" title="索引信息"></a>索引信息</h6><blockquote>
<p>​	对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
</blockquote>
<h6 id="表锁／行锁信息"><a href="#表锁／行锁信息" class="headerlink" title="表锁／行锁信息"></a>表锁／行锁信息</h6><p>表锁结构和行锁结构在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li>Space ID ：记录所在表空间。</li>
<li>Page Number ：记录所在页号。</li>
<li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li>
</ul>
</li>
</ul>
<h6 id="type-mode"><a href="#type-mode" class="headerlink" title="type_mode"></a>type_mode</h6><p>​	这是一个32位的数，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkbhugvycrtxercytvuybinokl,';.jpg"></p>
<ul>
<li>锁的模式（ lock_mode ），占用低4位，可选的值如下：<ul>
<li>LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。</li>
<li>LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。</li>
<li>LOCK_S （十进制的2 ）：表示共享锁，也就是S锁。</li>
<li>LOCK_X （十进制的3 ）：表示独占锁，也就是X锁。</li>
<li>LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。</li>
</ul>
</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<ul>
<li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li>LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为</p>
<ul>
<li>LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li>
<li>LOCK_ORDINARY （十进制的0 ）：表示next-key锁。</li>
<li>LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示gap锁。</li>
<li>LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经记录锁。</li>
<li>LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting 属性呢？基于内存空间的节省，所以把is_waiting 属性放到了type_mode 这个32位的数字中：</p>
<ul>
<li>LOCK_WAIT （十进制的256 ） ：当第9个比特位置为1 时，表示is_waiting 为true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<h6 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h6><p>​	为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
<h6 id="一堆比特位"><a href="#一堆比特位" class="headerlink" title="一堆比特位"></a>一堆比特位</h6><p>​	如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no 属性，伪记录Infimum 的heap_no 值为0 ， Supremum 的heap_no 值为1 ，之后每插入一条记录， heap_no 值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no ，即一个比特位映射到页内的一条记录。</p>
<h4 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h4><h5 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h5><blockquote>
<p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
</blockquote>
<h5 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h5><p>写-写情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibugvexrctybyuiom.jpg"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jinhbugvyctrybyuinimp,l.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hjbgvyfctdxrszxdtcfgbhijn.jpg"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvyctrxetcyubiomk.jpg"></p>
<p>小结几种说法：</p>
<ul>
<li><p>不加锁</p>
<ul>
<li>意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。</li>
</ul>
</li>
<li><p>获取锁成功，或者加锁成功</p>
<ul>
<li>意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务可以继续执行操作。</li>
</ul>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p>
<ul>
<li>意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务需要等待，不可以继续执行操作。</li>
</ul>
</li>
</ul>
<h5 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h5><ul>
<li><p>读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p>
</li>
<li><p>各个数据库厂商对SQL标准的支持都可能不一样。比如MySQL在REPEATABLE READ 隔离级别上就已经解决了幻读问题。</p>
</li>
</ul>
<h4 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行加锁。</li>
</ul>
<p>所谓的WVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本〔历史版本由undo log构建)。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</li>
<li>在REPEATABLE READ 隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
<ul>
<li>方案二：读、写操作都采用加锁的方式。</li>
</ul>
<p>小结对比发现：</p>
<ul>
<li>采用MVCC 方式的话， 读-写操作彼此并不冲突， 性能更高。</li>
<li>采用加锁方式的话， 读-写操作彼此需要排队执行，影响性能。</li>
</ul>
<p>一般情况下我们当然愿意采用MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行</p>
<h4 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibhutv6c5excr6tvunomp.jpg"></p>
<h5 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h5><ul>
<li>读锁：也称为共享锁、英文用S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li>写锁：也称为排他锁、英文用X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li>
</ul>
<p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<h6 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h6><p>对读取的记录加 <code>S</code> 锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name lock <span class="keyword">in</span> share mode;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">for</span> share;</span><br></pre></td></tr></table></figure>

<p>对读取的记录加 <code>X</code> 锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL8.o新特性:</strong><br>在5.7及之前的版本，SELECT …FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout 超时。在8.o版本中，SELECT…FOR UPDATE，SELEC . FOR SHARE 添加NOWAIT、SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p>
<ul>
<li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:<ul>
<li>那么NOWAIT会立即报错返回</li>
<li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (i) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line">#初始化 <span class="number">3</span> 条数据就行了，多了数不过来。#session1</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"># Session <span class="number">2</span>:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> i<span class="operator">=</span><span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line"># 从上面可以看到 <span class="keyword">for</span> <span class="keyword">update</span> 执行需要等待锁超时才能退出。接下来我们看一下 <span class="keyword">for</span> <span class="keyword">update</span> nowait 执行：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> NOWAIT;</span><br><span class="line">ERROR <span class="number">3572</span> (HY000): Statement aborted because lock(s) could <span class="keyword">not</span> be acquired immediately <span class="keyword">and</span> NOWAIT <span class="keyword">is</span> set.</span><br><span class="line"># 从这里可以看到在 <span class="keyword">for</span> <span class="keyword">update</span> nowait 直接执行返回，从错误提示上可以出来因为设置了 nowait 因为获取不到锁直接退出了。# Session <span class="number">2</span>:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"># Query 直接执行返回，但从结果上可以看出来少了一条记录：<span class="number">2</span>， 原因是 <span class="number">2</span> 这条记录正处在锁 X 锁状态下，因为使用了 <span class="keyword">skip</span> locked,直接跳过该条记录。</span><br></pre></td></tr></table></figure>

<h6 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h6><p>平常所用到的写操作无非是 DELETE、UPDATE、INSERT这三种:</p>
<ul>
<li><p>DELETE：对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p>
</li>
<li><p>UPDATE：在对一条记录做UPDATE操作时分为三种情况:</p>
<ul>
<li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</li>
<li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。</li>
<li>情况3：修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。</li>
</ul>
</li>
<li><p>INSERT：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p>
</li>
</ul>
<h4 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h4><h5 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h5><blockquote>
<p>​	该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎（不管你是MysQL的什么存储引擎对于表锁的策略都是一样的)，并且表锁是开销最小的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p>
</blockquote>
<h6 id="表级别的S锁、X锁"><a href="#表级别的S锁、X锁" class="headerlink" title="表级别的S锁、X锁"></a>表级别的S锁、X锁</h6><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名： Metadata Locks ，简称MDL ）结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量autocommit&#x3D;0，innodb_table_locks &#x3D; 1 时，手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ ：  #InnoDB存储引擎会对表t 加表级别的S锁。</span><br><span class="line">LOCK TABLES t WRITE ： #InnoDB存储引擎会对表t 加表级别的X锁。</span><br><span class="line">UNLOCK TABLES;         #解锁</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/csfvrdbtrnytumyuntbyrtv.png"></p>
<h5 id="意向锁-（intention-lock）"><a href="#意向锁-（intention-lock）" class="headerlink" title="意向锁 （intention lock）"></a>意向锁 （intention lock）</h5><h6 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h6><blockquote>
<p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p>
</blockquote>
<p>需要强调一下，意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。意向锁分为两种：</p>
<ul>
<li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>即：<code>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁</code>，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p><strong>举例1：</strong></p>
<p>设想这样一张 <code>users</code> 表： <strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：users（id PK，name）</p>
<p>事务 A 获取了某一行的排他锁，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>事务 B 想要获取 <code>users</code> 表的表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<p>因为共享锁与排他锁<code>互斥</code>，所以事务 B 在视图对 <code>users</code> 表加共享锁的时候，必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁。</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁  。</li>
</ul>
<p>为了检测是否满足第二个条件，事务 B 必须在确保 <code>users</code>表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了<strong>意向锁</strong>之后，情况就不一样了：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvyfctdxrsdtcfyvgbhijno.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mknhjbugvyfdtxrtcfyubhiomk.png"></p>
<p><strong><font color='red'>注意：这里的排他 &#x2F; 共享锁指的都是表锁！！！意向锁不会与行级的共享 &#x2F; 排他锁互斥！！！</font></strong></p>
<p><strong>举例2：</strong></p>
<p><code>事务 A</code> 获取了某一行的排他锁，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>此时 <code>users</code> 表存在两把锁：<code>users</code> 表上的<strong>意向排他锁</strong>与 id 为 6 的数据行上的<strong>排他锁</strong>。</p>
<p>事务 B 想要获取 users 表的共享锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<p>此时<code>事务 B</code> 检测事务 A 持有 <code>users</code> 表的<strong>意向排他锁</strong>，就可以得知<code>事务 A</code> 必然持有该表中某些数据行的<strong>排他锁</strong>，那么<code>事务 B</code> 对 <code>users</code> 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p>
<p><strong>举例3：</strong></p>
<p><code>事务 A</code> 先获取了某一行的<strong>排他锁</strong>，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 A</code> 获取了 <code>users</code> 表上的<strong>意向排他锁</strong>。</li>
<li><code>事务 A</code> 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>之后<code>事务 B</code> 想要获取 <code>users</code> 表的<strong>共享锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 B</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 B</code> 对 <code>users</code> 表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后<code>事务 C</code> 也想获取 <code>users</code> 表中某一行的<strong>排他锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><code>事务 C</code> 申请 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p><code>事务 C</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p>因为意向锁之间并不互斥，所以<code>事务 C</code> 获取到了 <code>users</code> 表的<strong>意向排他锁</strong>。</p>
<p>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终<code>事务 C</code> 成功获取到了该数据行上的<strong>排他锁</strong>。</p>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><blockquote>
<ul>
<li><p>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</p>
</li>
<li><p>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</p>
</li>
<li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</p>
</li>
<li><p>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</p>
</li>
</ul>
</blockquote>
<h5 id="自增锁（AUTO-INC锁）"><a href="#自增锁（AUTO-INC锁）" class="headerlink" title="自增锁（AUTO-INC锁）"></a>自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT 属性。举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight plaintext"><figcaption><span>select * from teacher;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| id |   name   |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | zhangsan |</span><br><span class="line">| 2  |   lisi   |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。</p>
</blockquote>
<h6 id="Simple-inserts-（简单插入）"><a href="#Simple-inserts-（简单插入）" class="headerlink" title="Simple inserts （简单插入）"></a>Simple inserts （简单插入）</h6><blockquote>
<p>​	可以预先确定要插入的行数（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES() 和REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p>
</blockquote>
<h6 id="Bulk-inserts-（批量插入）"><a href="#Bulk-inserts-（批量插入）" class="headerlink" title="Bulk inserts （批量插入）"></a>Bulk inserts （批量插入）</h6><blockquote>
<p>​	事先不知道要插入的行数（和所需自动递增值的数量）的语句。比如INSERT … SELECT ， REPLACE… SELECT 和LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>
</blockquote>
<h6 id="Mixed-mode-inserts-（混合模式插入）"><a href="#Mixed-mode-inserts-（混合模式插入）" class="headerlink" title="Mixed-mode inserts （混合模式插入）"></a>Mixed-mode inserts （混合模式插入）</h6><blockquote>
<p>​	这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INTO teacher (id,name)VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</p>
</blockquote>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<blockquote>
<ol>
<li><p>innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p>
<p>​	在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会限制并发能力。</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)</p>
<p>​	在 MySQL 8.0 之前，连续锁定模式是默认的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECTREPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。对于“Simple inserts”（要插入的行数事先已知），则通过在mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple<br>inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
</li>
<li><p>innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)</p>
<p>从 MySQL 8.0 开始，交错锁模式是默认设置。在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。</p>
</li>
</ol>
</blockquote>
<h5 id="元数据锁-meta-data-lock"><a href="#元数据锁-meta-data-lock" class="headerlink" title="元数据锁(meta data lock)"></a>元数据锁(meta data lock)</h5><blockquote>
<p>​	MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>
</blockquote>
<p><strong><font color='red'>当对一张表进行增删改查的时候，加MDL读锁(共享);当对表结构进行变更操作的时候，加MDL写锁(排他)。</font></strong></p>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnihbugvyfctdfvybhnjomk,l.;.png"></p>
<h6 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h6><blockquote>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njbihugcfxdtcfygvubhim;l,';.jpg"></p>
<p>举例如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/onubyutr6cybuimp,l[.jpg"></p>
<h6 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h6><blockquote>
<p>​	MySQL 在REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC 方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为gap锁。比如，把id值为8的那条记录加一个gap锁的示意图如下。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/lkjhgvyfcdtfygbhijnom.jpg"></p>
<blockquote>
<p>​	图中id值为8的记录加了gap锁，意味着不允许别的事务在id值为8的记录前边的间隙插入新记录，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
</blockquote>
<blockquote>
<p>​	<strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁(不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</strong></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hubgvyfctexrctyui.png"></p>
<p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此session 1加的是间隙锁(3,8)。而session2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<p>注意，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是student表中id值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加 gap锁才能阻止其他事务插入id值在(20，+∞)这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了:</p>
<ul>
<li>Infimum记录，表示该页面中最小的记录。</li>
<li>Supremum记录，表示该页面中最大的记录。|</li>
</ul>
<p>为了实现阻止其他事务插入id值在(20, +co)这个区间的新记录，我们可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的Supremum记录加上一个gap锁，如图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnhbugvyfctfygubiomk.png"></p>
<h6 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h6><blockquote>
<p>​	有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为:LOCK_ORDINARY，我们也可以简称为next-key锁。Next-KeyLocks是在存储引擎innodb、事务级别在可重复读的情况下使用的数据库锁，<strong>innodb默认的锁就是Next-Key locks</strong>。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下:</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hbugvyfdxrdcfygbhnj.png"></p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p>
</li>
<li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p>
</li>
</ol>
<h6 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h6><blockquote>
<p>​	我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（ next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert<br>操作时产生。</p>
<p>​	插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。</p>
<p>​	事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
</blockquote>
<h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><blockquote>
<p>​	页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。<br>​	每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
</blockquote>
<h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><blockquote>
<p>​	全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句</p>
<p>​	全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本</p>
<p>但是让整个库都只读，可能出现以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</li>
</ul>
</blockquote>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><blockquote>
<p>​	MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</p>
</blockquote>
<h5 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h5><blockquote>
<p>​	MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁， 非阻塞并发读，而<strong>这个读指的就是快照读, 而非当前读</strong>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
</blockquote>
<h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h6><blockquote>
<p>​	快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读；比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>​	之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>​	既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>​	快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
</blockquote>
<h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h6><blockquote>
<p>​	当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE; # 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... # 排他锁</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... # 排他锁</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... # 排他锁</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/nibugvyfdxrtfgubhjnmk.jpg"></p>
<p>另图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/ljkhbgvfctyvgujnmkl;.jpg"></p>
<h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><blockquote>
<p>对于使用InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</li>
<li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhufctdxcfygbhjk.jpg"></p>
<blockquote>
<p>​	insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<h5 id="Undo-Log版本链"><a href="#Undo-Log版本链" class="headerlink" title="Undo Log版本链"></a>Undo Log版本链</h5><p>假设之后两个事务id分别为10 、20 的事务对这条记录进行UPDATE 操作，操作流程如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/dcfvgebtrntuiuyntb.png"></p>
<blockquote>
<p>​	每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表：</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhugvfdxrtvgunjomk.jpg"></p>
<blockquote>
<p>​	对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。每个版本中还包含生成该版本时对应的事务id 。</p>
</blockquote>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><blockquote>
<ul>
<li>使用READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</li>
<li>使用SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</li>
<li>使用READ COMMITTED 和REPEATABLE READ 隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</li>
</ul>
</blockquote>
<blockquote>
<p>ReadView中主要包含4个比较重要的内容，分别如下：</p>
<ol>
<li>creator_trx_id ，创建这个 Read View 的事务 ID。<br>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</li>
<li>trx_ids ，表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>up_limit_id ，活跃的事务中最小的事务 ID。</li>
<li>low_limit_id ，表示生成ReadView时系统中应该分配给下一个事务的id 值。low_limit_id 是系<br>统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。<br>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</li>
</ol>
</blockquote>
<h6 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h6><blockquote>
<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的up_limit_id 和low_limit_id 之间，那就需要判断一下trx_id属性值是不是在trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h5><ul>
<li><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p>
</li>
<li><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View</p>
</li>
</ul>
<h6 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h6><p><strong>READ COMMITTED隔离级别下</strong></p>
<p>现在有两个事务id 分别为10 、20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录得到的版本链表如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jhbugvycttcrvubhnjmk.jpg"></p>
<p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下:</p>
<blockquote>
<p><strong>步骤1∶</strong>在执行SELECT语句时会先生成一个ReadView ，ReadView的trx_ids列表的内容就是 {10, 20} ,up_limit_id为10, low_limit_id为21, creator_trx_id为0。</p>
<p><strong>步骤2：</strong>从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p><strong>步骤3：</strong>下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p><strong>步骤4：</strong>下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p>
</blockquote>
<p>之后，我们把事务id 为10 的事务提交一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中id 为1 的记录的版本链就长这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jihbuvctdfvbhnjmk.jpg"></p>
<p>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个id 为1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下:</p>
<blockquote>
<p><strong>步骤1：</strong>在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的trx_ids列表的内容就是{20}，up_limit_id为20,low_limit_id为21, creator_trx_id为日。</p>
<p><strong>步骤2：</strong>从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’宋八’，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p><strong>步骤3：</strong>下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p><strong>步骤4：</strong>下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</p>
</blockquote>
<p><strong>REPEATABLE READ隔离级别下</strong></p>
<p>比如，系统里有两个事务id 分别为10 、20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录得到的版本链表如下所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jkhgfdsxrdcfvbyuno,l..jpg"></p>
<p>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之后，我们把事务id 为10 的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id 为1 的记录的版本链长这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibuvctcrubhjmk,l.jpg"></p>
<p>然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个id 为1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibufrtedtrfybhnjmk,l.jpg"></p>
<p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。</p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids&#x3D;[20,30] ， up_limit_id&#x3D;20 ， low_limit_id&#x3D;31 ， creator_trx_id&#x3D;20 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibugvfcdxrsdvgubhjo,l;.jpg"></p>
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<ol>
<li>id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</li>
<li>然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</li>
<li>同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbutrcexrectybuiomp,[.;'.jpg"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h3 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h3><h4 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h4><blockquote>
<p>​	MySQL有不同类型的日志文件，用来存储不同类型的日志，分为二进制日志、错误日志、通用查询日志和慢查询日志，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志和数据定义语句日志。使用这些日志文件，可以查看MySQL内部发生的事情。</p>
</blockquote>
<p>这6类日志分别为：</p>
<ul>
<li><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li>
<li><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li>
<li><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li>
<li><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li>
<li><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</li>
</ul>
<p>除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。</p>
<h4 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h4><blockquote>
<p>​	查询日志分为一般查询日志和慢查询日志，它们是通过查询是否超出变量 long_query_time 指定时间的值来判定的。在超时时间内完成的查询是一般查询，可以将其记录到一般查询日志中，<strong>但是建议关闭这种日志（默认是关闭的）</strong>，超出时间的查询是慢查询，可以将其记录到慢查询日志中。</p>
</blockquote>
<blockquote>
<p>​	通用查询日志用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。<strong>默认关闭</strong></p>
</blockquote>
<blockquote>
<p><strong>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</strong></p>
</blockquote>
<h5 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span>            <span class="keyword">Value</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span>            OFF               <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01.log <span class="operator">|</span> #通用查询日志文件的名称是atguigu01.log</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h4><blockquote>
<p>在MySQL数据库中，错误日志功能是默认开启的。而且，错误日志无法被禁止。</p>
</blockquote>
<blockquote>
<p>​	默认情况，错误日志存储在mysql数据库的数据文件中。错误日志文件通常的名称为hostname.err（hostname表示服务器的主机名）。</p>
<p>​	错误日志可以自己配置，错误日志可以通过log-error和log-warnings来定义，其中log-error：配置是否启用错误日志功能和错误日志的存储位置？log-warning：配置是否将警告信息也定义至错误日志中？</p>
<p>​	错误日志记录信息：服务器启动关闭信息、运行错误信息、时间调度器运行一个事件时产生的信息、在服务器上启动进程产生的信息。</p>
</blockquote>
<h4 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h4><blockquote>
<p>​	binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL 和DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p>
</blockquote>
<blockquote>
<p>binlog主要应用场景：</p>
<ul>
<li>一是用于<strong>数据恢复</strong>，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作,对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li>
<li>二是用于<strong>数据复制</strong>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/tmtnrbvcwevtrbyujikol.jpg"></p>
<h5 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h5><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><blockquote>
<p>​	当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>​	MySQL服务重新启动一次，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。</p>
</blockquote>
<p>查看当前的二进制日志文件列表及大小。指令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span>       <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure>

<h5 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h5><p>格式1： <strong><code>STATEMENT</code>模式</strong>（基于SQL语句的复制(statement-based replication, SBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span>STATEMENT</span><br></pre></td></tr></table></figure>

<p>每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。</p>
<ul>
<li><p>SBR 的优点：</p>
<ul>
<li>历史悠久，技术成熟</li>
<li><strong>不需要记录每一行的变化，减少了binlog日志量，文件较小</strong></li>
<li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li>
<li><strong>binlog可以用于实时的还原，而不仅仅用于复制</strong></li>
<li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
</ul>
</li>
<li><p>SBR 的缺点：</p>
<ul>
<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li>
<li><strong>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()</strong></li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li>
</ul>
</li>
</ul>
<p>格式2： <strong><code>ROW</code>模式</strong>（基于行的复制(row-based replication, RBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span><span class="type">ROW</span></span><br></pre></td></tr></table></figure>

<p>不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了。</p>
<ul>
<li><p>RBR 的优点：</p>
<ul>
<li>任何情况都可以被复制，这对复制来说是最安全可靠的。（比如：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li>
<li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li>
</ul>
</li>
<li><p>RBR 的缺点：</p>
<ul>
<li><strong>binlog 大了很多</strong></li>
<li><strong>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</strong></li>
<li><strong>无法从 binlog 中看到都复制了些什么语句</strong></li>
</ul>
</li>
</ul>
<p>格式2： <strong><code>MIXED</code>模式</strong>（混合模式复制(mixed-based replication, MBR)）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format<span class="operator">=</span>MIXED</span><br></pre></td></tr></table></figure>

<p>实际上就是Statement与Row的结合。</p>
<p>​	在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。<br>​	MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>
<h5 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h5><p>​	binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kojibuvycrtxercytvubinoipo[.jpg"></p>
<p>​	write和fsync的时机，可以由参数sync_binlog 控制，默认是0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/uhigutfrdeswasertgyhuoi.jpg"></p>
<p>​	为了安全起见，可以设置为1 ，表示每次提交事务都会执行fsync，就如同redo log 刷盘流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnkbugtfrde5sdrfguyijiop.jpg"></p>
<p>​	在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h5 id="redo-log-与-binlog-的不同"><a href="#redo-log-与-binlog-的不同" class="headerlink" title="redo log 与 binlog 的不同"></a>redo log 与 binlog 的不同</h5><blockquote>
<p>1）<strong>适用对象不同</strong>：</p>
<ul>
<li>bin log 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li>
<li>而 redo log 是 InnoDB 引擎特有的</li>
</ul>
<p>2）<strong>写入内容不同</strong>：</p>
<ul>
<li>bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 id &#x3D; 1 这一行的 age 字段加 1”</li>
<li>redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”</li>
</ul>
<p>3）<strong>写入方式不同</strong>：</p>
<ul>
<li>bin log 是可以追加写入的。“追加写” 是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</li>
<li>redo log 是循环写的，空间固定会被用完</li>
</ul>
</blockquote>
<h5 id="redo-log-两阶段提交"><a href="#redo-log-两阶段提交" class="headerlink" title="redo log 两阶段提交"></a>redo log 两阶段提交</h5><p>以下面这条简单的 SQL 语句为例，我们来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行器：找存储引擎取到 id &#x3D; 1 这一行记录</p>
</li>
<li><p>存储引擎：根据主键索引树找到这一行，如果 id &#x3D; 1 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入内存池，然后再返回</p>
</li>
<li><p>执行器：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</p>
</li>
<li><p>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务</p>
<blockquote>
<p>注意不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，commit 命令就执行成功了。</p>
</blockquote>
</li>
<li><p>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</p>
</li>
<li><p>执行器：调用存储引擎的提交事务接口</p>
</li>
<li><p>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</p>
</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kjnbhugvyfdtxrsdtcfy.png"></p>
<p>可以看到，<strong>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit</strong>。</p>
<p>所以，为什么要这样设计呢？这样设计怎么就能够实现崩溃恢复呢？</p>
<p>根据两阶段提交，<strong>崩溃恢复时的判断规则</strong>是这样的：</p>
<ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</li>
<li>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整</li>
</ol>
<ul>
<li>a. 如果 binlog 存在并完整，则提交事务；</li>
<li>b. 否则，回滚事务。</li>
</ul>
<p>当然，这样说小伙伴们肯定没法理解，下面来看几个实际的例子：</p>
<p>如下图所示，假设数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃，此时 redo log 里面的事务处于 prepare 状态，binlog 还没写（对应 2b），所以崩溃的时候，这个事务会回滚。</p>
<blockquote>
<p>Why？</p>
<p>因为 binlog 还没有写入，之后从库进行同步的时候，无法执行这个操作，那如果我们主库上继续执行这个操作的话显然就会导致主备不一致，所以在主库上需要回滚这个事务</p>
</blockquote>
<p>并且，由于 binlog 还没写，所以也就不会传到备库，从而避免主备不一致的情况。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnhbugvyfctdxrtcfygub.png"></p>
<p>​	而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整（对应 2a），所以即使在这个时刻数据库崩溃了，事务仍然会被正常提交。</p>
<blockquote>
<p>Why？</p>
<p>​	因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，在主库上需要提交这个事务。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnihbuvyctrxerctfbyhijnomk.png"></p>
<p>所以，其实可以看出来，<strong>处于 prepare 阶段的 redo log 加上完整的 bin log，就能保证数据库的崩溃恢复了</strong>。</p>
<p>可能有同学就会问了，MySQL 咋知道 bin log 是不是完整的？</p>
<p>简单来说，一个事务的 binlog 是有完整格式的（这个我们在后面的文章中会详细解释）：</p>
<ul>
<li>statement 格式的 bin log，最后会有 COMMIT</li>
<li>row 格式的 bin log，最后会有 XID event</li>
</ul>
<p>而对于 bin log 可能会在中间出错的情况，MySQL 5.6.2 版本以后引入了 <code>binlog-checksum</code> 参数，用来验证 bin log 内容的正确性。</p>
<p>思考一个问题，<strong>两阶段提交是必要的吗？可不可以先 redo log 写完，再写 bin log 或者反过来？</strong></p>
<p>1）对于先写完 redo log 后写 bin log 的情况：</p>
<p>​	假设在 redo log 写完，bin log 还没有写完的时候，MySQL 崩溃。主库中的数据确实已经被修改了，但是这时候 bin log 里面并没有记录这个语句。因此，从库同步的时候，就会丢失这个更新，和主库不一致。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibhugvyfcdtxrsdtcfygbhij.png"></p>
<p>2）对于先写完 binlog 后写 redo log 的情况：</p>
<p>​	如果在 bin log 写完，redo log 还没写的时候，MySQL 崩溃。因为 binlog 已经写入成功了，这样之后就会被从库同步过去，但是实际上 redo log 还没写，主库并没有完成这个操作，所以从库相比主库就会多执行一个事务，导致主备不一致</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnibyutctrxecrtuiomp,l;.png"></p>
<h5 id="中继日志-relay-log"><a href="#中继日志-relay-log" class="headerlink" title="中继日志(relay log)"></a>中继日志(relay log)</h5><blockquote>
<p>​	中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhgcftdxrtgbhijn.jpg"></p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote>
<p>​	如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<strong>优化SQL和索引</strong>，这种方式简单有效；其次才是<strong>采用缓存的策略</strong>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<strong>主从架构</strong>，进行读写分离。</p>
</blockquote>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/mjnbhgvyfdxrszrxdtvgbhjlk.jpg"></p>
<blockquote>
<p>其中一个是Master主库，负责写入数据，我们称之为：<strong>写库</strong>。</p>
<p>其它都是Slave从库，负责读取数据，我们称之为：<strong>读库</strong>。</p>
<p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。</p>
<p>面对“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器.上,让读取更加顺畅。读取顺畅的另-一个原因,就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p>
</blockquote>
<h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><blockquote>
<p>​	我们通过主从复制将主库上的数据复制到了从库上,相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份,不会影响到服务。</p>
</blockquote>
<h5 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h5><blockquote>
<p>​	数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p>
</blockquote>
<h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><h5 id="三个线程"><a href="#三个线程" class="headerlink" title="三个线程"></a>三个线程</h5><blockquote>
<p>​	实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程来操作，一个主库线程，两个从库线程。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/ohygutfrdfyguinio.jpg"></p>
<blockquote>
<p><strong>二进制日志转储线程（Binlog dump thread）</strong>：是一个主库线程。当从库线程连接的时候，主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。 负责将主服务器上的数据更改写入二进制日志中。</p>
<p><strong>从库 I&#x2F;O 线程</strong>：会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p>
<p><strong>从库 SQL 线程</strong>：会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jhghfcdxrzeasrdcfgbhij.jpg"></p>
<h5 id="复制三步骤"><a href="#复制三步骤" class="headerlink" title="复制三步骤"></a>复制三步骤</h5><blockquote>
<p>步骤1： Master 将写操作记录到二进制日志（ binlog ）。</p>
<p>步骤2： Slave 将Master 的binary log events拷贝到它的中继日志（ relay log ）。</p>
<p>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化<br>的，而且重启后从接入点开始复制。</p>
</blockquote>
<h5 id="复制的问题"><a href="#复制的问题" class="headerlink" title="复制的问题"></a>复制的问题</h5><blockquote>
<p><strong>延时</strong></p>
</blockquote>
<h4 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h4><blockquote>
<ul>
<li><p>每个Slave 只有一个Master</p>
</li>
<li><p>每个Slave 只能有一个唯一的服务器ID</p>
</li>
<li><p>每个Master 可以有多个Slave</p>
</li>
</ul>
</blockquote>
<h4 id="同步数据一致性问题"><a href="#同步数据一致性问题" class="headerlink" title="同步数据一致性问题"></a>同步数据一致性问题</h4><h5 id="主从同步的要求"><a href="#主从同步的要求" class="headerlink" title="主从同步的要求"></a>主从同步的要求</h5><blockquote>
<ul>
<li>读库和写库的数据一致(最终一致)；</li>
<li>写数据必须写到写库；</li>
<li>读数据必须到读库(不一定)；</li>
</ul>
</blockquote>
<h5 id="主从延迟问题原因"><a href="#主从延迟问题原因" class="headerlink" title="主从延迟问题原因"></a>主从延迟问题原因</h5><blockquote>
<p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</p>
<p>造成原因：</p>
<ul>
<li>从库的机器性能比主库要差</li>
<li>从库的压力大</li>
<li>大事务的执行</li>
</ul>
</blockquote>
<h5 id="如何减少主从延迟"><a href="#如何减少主从延迟" class="headerlink" title="如何减少主从延迟"></a>如何减少主从延迟</h5><blockquote>
<p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<ol>
<li>降低多线程大事务并发的概率，优化业务逻辑</li>
<li>优化SQL，避免慢SQL， 减少批量操作，建议写脚本以update-sleep这样的形式完成。</li>
<li><strong>提高从库机器的配置，减少主库写binlog和从库读binlog的效率差。</strong></li>
<li>尽量采用短的链路，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输<br>的网络延时。</li>
<li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li>
</ol>
</blockquote>
<h5 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h5><blockquote>
<p>​	如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份，并没有起到读写分离，分担主库读压力的作用。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kmjnibyutvyrterytyuiomp.jpg"></p>
<p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间数据复制方式的问题，如果按照数据一致性从弱到强来进行划分，有以下 3 种复制方式。</p>
<h6 id="方法-1：异步复制"><a href="#方法-1：异步复制" class="headerlink" title="方法 1：异步复制"></a>方法 1：异步复制</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jkhbjgvfyctdxcfyvgujnlk;.jpg"></p>
<blockquote>
<p>​	异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主， 那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。|</p>
</blockquote>
<h6 id="方法-2：半同步复制"><a href="#方法-2：半同步复制" class="headerlink" title="方法 2：半同步复制"></a>方法 2：半同步复制</h6><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kjhbjgvcfdxrzsxdtybhijnm;l.jpg"></p>
<blockquote>
<p>​	MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一一个从库接收到了Binlog,并且写入到中继日志中，再返回给客户端。<br>​	这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。<br>​	在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大,可以提升数据一致性的强度,但也会增加主库等待从库响应的时间。</p>
</blockquote>
<h6 id="方法-3：组复制"><a href="#方法-3：组复制" class="headerlink" title="方法 3：组复制"></a>方法 3：组复制</h6><blockquote>
<p>​	异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。<br>​	组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p>
</blockquote>
<p><strong>MGR 是如何工作</strong></p>
<blockquote>
<p>​	首先我们将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接 COMMIT 即可。<br>​	在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
</blockquote>
<h3 id="MySQL组成部分"><a href="#MySQL组成部分" class="headerlink" title="MySQL组成部分"></a>MySQL组成部分</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jiyutyrctexrtcybujomkl.png"></p>
<p>可以大致把 MySQL 的逻辑架构分成 Server 层和存储引擎层：</p>
<p>​	1）大多数 MySQL 的核心服务功能都在 Server 层，包括连接，查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
<p>​	值得一提的是，Server 最上面的服务也就是连接器，拥有管理 MySQL 连接、权限验证的功能。显然这并非 MySQL 所独有，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。</p>
<p>​	2）第二层就是存储引擎（支持 InnoDB、MyISAM、Memory 等多个存储引擎）。存储引擎负责 MySQL 中数据的存储和提取，响应上层服务器的请求。每个存储引擎自然是有它的优势和劣势，不同的存储引擎之间无法相互通信，所以我们需要根据不同的场景来选择合适的存储引擎。</p>
<p>​	服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎 API 包含几十个底层函数，用于执行诸如 “开始一个事务” 或者 “根据主键提取一行记录” 等操作。</p>
<p>​	需要注意的是，在 MySQL 5.1 及之前的版本，MyISAM 是默认的存储引擎，而在 MySQL 5.5.5 后，InnoDB 成为了默认的存储引擎。</p>
<h4 id="连接器（Connector）"><a href="#连接器（Connector）" class="headerlink" title="连接器（Connector）"></a>连接器（Connector）</h4><p>MySQL 5.7 的官方文档中，是这样描述连接器的：</p>
<blockquote>
<p>MySQL Connectors provide connectivity to the MySQL server for client programs.</p>
</blockquote>
<p>​	<strong>MySQL 连接器为客户端程序提供到 MySQL 服务器的连接</strong>。 说得更细节一点的话，连接器其实会做两个事情，一个是管理 MySQL 连接，一个是权限验证。我们依次来解释下。</p>
<p>​	首先，要连接到 MySQL 服务器，我们通常需要提供 MySQL 用户名和密码，并且如果服务器运行在我们登录的机器以外的机器上，还需要指定一个主机名比如 host。 所以连接命令一般是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell<span class="operator">&gt;</span> mysql <span class="operator">-</span>h host <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p</span><br><span class="line">Enter password: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>当然了，如果在运行 MySQL 的同一台机器上登录，就可以省略主机名，只需使用以下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell<span class="operator">&gt;</span> mysql <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>

<p>上面这个命令各位应该都很熟悉。</p>
<p>OK，通过上述命令完成经典的 TCP 三次握手建立连接后，连接器就会根据你输入的用户名和密码来认证你的身份：</p>
<p>1）如果用户名或密码不对，你就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。</p>
<p>2）如果用户名密码认证通过，你会看到下面这一串内容：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibyutrfdetrcyvubinio.png"></p>
<p><code>mysql&gt;</code> 就是在提示你 MySQL 已准备好了，你可以开始输入 SQL 语句了！</p>
<p>​	当然，连接器做的事情不仅仅是比对一下用户名和密码，它还会验证该用户是否具有执行某个特定查询的权限（例如，是否允许该用户对 world 数据库的 Country 表执行 SELECT 语句）。之后，这个连接里面的所有权限判断逻辑，都将依赖于此时读到的权限。</p>
<p>​	这意味着，当一个用户成功建立连接后，即使你在另一个终端用管理员账号对这个用户的权限做了修改，对当前已经存在连接的权限不会造成任何影响。</p>
<p>​	也就是说，当修改了用户权限后，只有再新建的连接才会使用新的权限设置。</p>
<p>​	当一个连接建立起来后，如果你没有后续的动作，那么这个连接就处于空闲状态（Sleep）。</p>
<p>​	事实上，对于一个 MySQL 连接来说（或者说一个线程），任何时刻都有一个状态，<strong>该状态表示了 MySQL 当前正在做什么</strong>。有很多种方式能查看当前的状态，最简单的是使用 <code>SHOW FULL PROCESSLIST</code> 命令（该命令返回结果中的 Command 列就表示当前的状态）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhiugvctrxercytvbuikml.png"></p>
<p>​	在一个查询的生命周期中，状态会变化很多次。这里就不详细列出来了，上图中的 <code>Sleep</code> 状态就是说当前连接正在等待客户端发送新的请求，<code>Query</code> 状态表示当前连接正在执行查询或者正在将结果发送给客户端。</p>
<p>​	在 MyQL 的默认设置中，如果一个连接处在 Sleep 状态 8 小时（就是超过 8 小时没有使用），服务器将断开这条连接，后续在该连接上进行的所有操作都将失败。这个时间是由参数 <code>wait_timeout</code> 控制的：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/jnbhugfcdxrsdtcfybhj.png"></p>
<h4 id="查询缓存（Query-Cache）"><a href="#查询缓存（Query-Cache）" class="headerlink" title="查询缓存（Query Cache）"></a>查询缓存（Query Cache）</h4><p>OK，连接建立完成后，我们就可以输入 select 语句进行查询了。执行逻辑就来到了第二步：查询缓存。</p>
<p>官方文档是这样解释 Query Cache 的：</p>
<blockquote>
<p>The query cache stores the text of a SELECT statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client.</p>
</blockquote>
<p>​	就是说查询缓存存储了 SELECT 语句的文本以及响应给客户端的相应结果。这样，如果服务器稍后接收到相同的 SELECT 语句，服务器会先从查询缓存中检索结果，而不是再次解析和执行该语句。查询缓存在 session 之间共享，因此可以发送一个客户端生成的结果集以响应另一个客户端发出的相同查询。</p>
<p>​	如果当前的查询恰好命中了查询缓存，那么<strong>在返回查询结果之前 MySQL 会检查一次用户权限</strong>。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。</p>
<p>​	那么既然涉及到缓存，就必然绕不开缓存一致性问题了。值得庆幸的是，不需要我们进行额外操作，查询缓存并不会返回陈旧数据！</p>
<blockquote>
<p>The query cache does not return stale data. When tables are modified, any relevant entries in the query cache are flushed.</p>
</blockquote>
<p>当表被修改时，查询缓存中的任何相关条目都会被 flushed，注意，这里的 flushed 翻译为<strong>清空</strong>而不是刷新。</p>
<p>看起来好像还不错？不用我们手动操作，失效缓存就能够被自动清空。</p>
<p>然而，很不幸的是，正是由于这个特性，<strong>从 MySQL 5.7.20 开始，官方不再推荐使用查询缓存，并在 MySQL 8.0 中直接删除了查询缓存！</strong></p>
<blockquote>
<p>The query cache is deprecated as of MySQL 5.7.20, and is removed in MySQL 8.0.</p>
</blockquote>
<p>​	其实不难理解，举个例子，对于一个流量很大的论坛项目来说，查询帖子表的需求每时每刻都存在，帖子也几乎每时每刻都在增加，那只要这个表一更新，这个表上所有的查询缓存都会被清空，这对于 MySQL 数据库的压力之大，可想而知了吧。费个劲把查询结果存起来，还没来得及使用呢，就被一个更新全清空了。</p>
<p>​	对于 MySQL 8.0 之前的版本来说，你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样所有的 SQL 语句都不会再使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from t1 where id = 1;</span><br></pre></td></tr></table></figure>

<h4 id="解析器（Parser）"><a href="#解析器（Parser）" class="headerlink" title="解析器（Parser）"></a>解析器（Parser）</h4><p>​	如果没有命中或者没有开启查询缓存，MySQL 服务器接下来要做的就是将一条 SQL 语句转换成一个执行计划，再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析 SQL、预处理、优化 SQL 执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。</p>
<p>其中<strong>解析 SQL 和预处理</strong>就是解析器做的事情，优化 SQL 执行计划就是优化器做的事情。这里我们先说解析器。</p>
<p>​	所谓解析 SQL 就是说，MySQL 通过关键字对 SQL 语句进行解析，并生成一棵对应的 “<strong>解析树</strong>”，用于根据语法规则来验证语句是否正确。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。</p>
<p>​	而预处理则会进一步检查解析树是否合法，例如，检查数据表和数据列是否存在，检查表名和字段名是否正确等。</p>
<h4 id="优化器（Optimizer）"><a href="#优化器（Optimizer）" class="headerlink" title="优化器（Optimizer）"></a>优化器（Optimizer）</h4><p>​	现在，解析树是合法的了，MySQL 已经知道你要做什么了。不过，一条查询可以有很多种执行计划，最后都返回相同的结果，那到底该选择哪种执行计划呢？</p>
<p>举个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id = 10 and name = &quot;good&quot;;</span><br></pre></td></tr></table></figure>

<p>​	对于上面这个语句，可以先查找 name &#x3D; good 再查找 id &#x3D; 10，也可以先查找  id &#x3D; 10 再查找 name &#x3D; good，这两种不同的执行计划可能耗费的时间成本是不一样的。</p>
<p>​	那么<strong>优化器的作用就是找到这其中最好的执行计划</strong>。需要注意的是，这里的执行计划是一个数据结构，而不是和很多其他的关系型数据库那样会生成对应的字节码。</p>
<p>​	另外，优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。</p>
<p>​	当优化器阶段完成后，这个语句的执行计划就确定下来了，就可以进入执行器阶段了。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>​	和命中查询缓存一样，在开始执行 SQL 语句之前，执行器会先判断一下当前用户对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p>
<p>​	权限认证完成后，MySQL 就会根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是我们称为 “handler API” 的接口。</p>
<p>​	查询中的每一个表由一个 handler 的实例表示。实际上，MySQL 在优化阶段就为每个表创建了一个 handler 实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名、索引统计信息，等等。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id = 10;</span><br></pre></td></tr></table></figure>

<p>假设我们使用默认的 InnoDB 引擎，则执行器的执行流程大概是这样的（注意，如果 id 不是索引则会进行全表扫描，一行一行的查找，如果是索引则会在索引组织表中查询，比较负责。这里以非索引举例）：</p>
<p>1）调用 InnoDB 引擎接口获取这个表的第一行记录，判断 id 值是不是 10，如果是则将这行记录存在一个集合中；如果不是则进入下一行的判断，直到取到这个表的最后一行</p>
<p>2）执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果返回给客户端</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhugvycdxrszxdtvguij.png"></p>
<ol>
<li>MySQL 客户端与服务器间建立连接，客户端发送一条查询给服务器；</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果；否则进入下一阶段；</li>
<li>服务器端进行 SQL 解析、预处理，生成合法的解析树；</li>
<li>再由优化器生成对应的执行计划；</li>
<li>MySQL 根据优化器生成的执行计划，调用相应的存储引擎的 API 来执行，并将执行结果返回给客户端。</li>
</ol>
<h3 id="一条-SQL-的执行过程"><a href="#一条-SQL-的执行过程" class="headerlink" title="一条 SQL 的执行过程"></a>一条 SQL 的执行过程</h3><p>这个需要分成两种，查询（select）和修改（delete、update、insert）</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>连接器 —-&gt; 查询缓存（命中直接返回，未命中进行后面操作） —-&gt; 解析器 —-&gt; 优化器 —-&gt; 执行器与存储引擎配合操作</p>
<h4 id="delete、update、insert"><a href="#delete、update、insert" class="headerlink" title="delete、update、insert"></a>delete、update、insert</h4><p>连接器 —-&gt; 解析器 —-&gt; 优化器 —-&gt; 执行器与存储引擎配合操作（这里有对binlog、与redo log的写入操作）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/">http://example.com/2021/07/26/SQL%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SQL/">SQL</a></div><div class="post_share"><div class="social-share" data-image="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/fthcgjjgfcjgft.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/12/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98/" title="LeetCode算法题"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/xsrdctfvybhnij.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">LeetCode算法题</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/23/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="SpringBoot项目部署到阿里云服务器"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/fgjhvhkbhj.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">SpringBoot项目部署到阿里云服务器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/10/30/MongoDB/" title="MongoDB"><img class="cover" src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/buvycrtybyuibyutcrtyubi.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-30</div><div class="title">MongoDB</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80%E5%8C%85%E5%90%AB6%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">结构化查询语言包含6个部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%9C%89%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">提交数据有三种类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">SQL基础教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%EF%BC%9A%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.</span> <span class="toc-text">select：查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#distinct%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%94%AF%E4%B8%80%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">distinct：返回唯一不同的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#where%EF%BC%9A%E8%A7%84%E5%AE%9A%E9%80%89%E6%8B%A9%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">3.3.</span> <span class="toc-text">where：规定选择的标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">特殊条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#and-or%EF%BC%9A%E4%BD%9C%E4%B8%BA%E8%BF%87%E6%BB%A4%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.2.</span> <span class="toc-text">and &amp; or：作为过滤的运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Order-by%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%AF%B9%E7%BB%93%E6%9E%9C%E9%9B%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">Order by：用于对结果集进行排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert%EF%BC%9A%E6%8F%92%E5%85%A5"><span class="toc-number">3.5.</span> <span class="toc-text">insert：插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update%EF%BC%9A%E4%BF%AE%E6%94%B9"><span class="toc-number">3.6.</span> <span class="toc-text">update：修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%EF%BC%9A%E5%88%A0%E9%99%A4"><span class="toc-number">3.7.</span> <span class="toc-text">delete：删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">3.8.</span> <span class="toc-text">top：返回指定的记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alias%EF%BC%9A%E5%88%AB%E5%90%8D"><span class="toc-number">3.9.</span> <span class="toc-text">Alias：别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%EF%BC%9A%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.10.</span> <span class="toc-text">join：连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union%EF%BC%9A%E5%90%88%E5%B9%B6"><span class="toc-number">3.11.</span> <span class="toc-text">union：合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-into%EF%BC%9A%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%96%B0%E8%A1%A8%E4%B8%AD"><span class="toc-number">3.12.</span> <span class="toc-text">select into：从一个表复制数据，然后把数据插入到另一个新表中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-into-select%EF%BC%9A%E6%8F%92%E5%85%A5"><span class="toc-number">3.13.</span> <span class="toc-text">insert into select：插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-datbase%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.14.</span> <span class="toc-text">create datbase：创建数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-table%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="toc-number">3.15.</span> <span class="toc-text">create table：创建表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constraints%EF%BC%9A%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.16.</span> <span class="toc-text">constraints：约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#not-null%EF%BC%9A%E4%B8%8D%E4%B8%BA%E7%A9%BA%E5%80%BC"><span class="toc-number">3.16.1.</span> <span class="toc-text">not null：不为空值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique%EF%BC%9A%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">3.16.2.</span> <span class="toc-text">unique：唯一标识数据库表中的每条记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#primary-key%EF%BC%9A%E4%B8%BB%E9%94%AE"><span class="toc-number">3.16.3.</span> <span class="toc-text">primary key：主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#foreign-key%EF%BC%9A%E5%A4%96%E9%94%AE"><span class="toc-number">3.16.4.</span> <span class="toc-text">foreign key：外键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#check%EF%BC%9A%E9%99%90%E5%88%B6%E5%88%97%E4%B8%AD%E7%9A%84%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">3.16.5.</span> <span class="toc-text">check：限制列中的值的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">3.16.6.</span> <span class="toc-text">default：默认值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">MySQL高级教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BST%E6%A0%91-%E2%80%94-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">4.1.1.</span> <span class="toc-text">BST树 — 二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">不足</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91-%E2%80%94-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">AVL树 — 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91-%E2%80%94-%E5%B9%B3%E8%A1%A1%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.1.3.</span> <span class="toc-text">B树 — 平衡多路查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%A3%B5M%E9%98%B6B%E6%A0%91%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">一棵M阶B树有以下特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">B树的查找结点过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-1"><span class="toc-number">4.1.3.2.1.</span> <span class="toc-text">好处</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E6%B7%BB%E5%8A%A0%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B%EF%BC%88%E5%92%8C%E7%BB%93%E7%82%B9%E5%88%86%E8%A3%82%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">B树的添加结点过程（和结点分裂过程）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">B树的删除结点过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">4.1.4.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%A3%B5M%E9%98%B6B-%E6%A0%91%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">一棵M阶B+树有以下特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">B+树的插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">B+树的删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E4%B8%8Eb-%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.5.</span> <span class="toc-text">b树与b+树区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8EInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.</span> <span class="toc-text">MyISAM存储引擎与InnoDB存储引擎对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">InnoDB数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">页结构概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#File-Header"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">File Header</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">4.3.2.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#File-Tailer"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">File Tailer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Free-Space"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">Free Space</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#User-Records"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">User Records</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#compact%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.2.5.1.</span> <span class="toc-text">compact行格式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Infimum-supremum"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">Infimum + supremum</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-Directory"><span class="toc-number">4.3.2.7.</span> <span class="toc-text">Page Directory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-Header"><span class="toc-number">4.3.2.8.</span> <span class="toc-text">Page Header</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA"><span class="toc-number">4.3.3.</span> <span class="toc-text">区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-number">4.3.4.</span> <span class="toc-text">段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-number">4.3.5.</span> <span class="toc-text">碎片区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.6.</span> <span class="toc-text">表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">独立表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.6.1.1.</span> <span class="toc-text">真实表空间对应的文件大小</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">系统表空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9"><span class="toc-number">4.4.</span> <span class="toc-text">存储引擎选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">创建表的时候创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.1.</span> <span class="toc-text">创建普通索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.2.</span> <span class="toc-text">创建唯一索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.3.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.4.</span> <span class="toc-text">单列索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.5.</span> <span class="toc-text">组合索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.6.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.1.7.</span> <span class="toc-text">空间索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">在已经存在的表上创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ALTER-TABLE%E8%AF%AD%E5%8F%A5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.2.1.</span> <span class="toc-text">使用ALTER TABLE语句创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CREATE-INDEX%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.2.2.</span> <span class="toc-text">使用CREATE INDEX创建索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">删除索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ALTER-TABLE%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.3.1.</span> <span class="toc-text">使用ALTER TABLE删除索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DROP-INDEX%E8%AF%AD%E5%8F%A5%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.4.3.2.</span> <span class="toc-text">使用DROP INDEX语句删除索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.5.5.</span> <span class="toc-text">MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95-%E9%BB%98%E8%AE%A4%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E6%98%AF%E5%8D%87%E5%BA%8F%E7%9A%84"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">支持降序索引(默认索引排序是升序的)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">隐藏索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="toc-number">4.5.5.2.1.</span> <span class="toc-text">创建表时直接创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA"><span class="toc-number">4.5.5.2.2.</span> <span class="toc-text">在已经存在的表上创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ALTER-TABLE%E8%AF%AD%E5%8F%A5%E5%88%9B%E5%BB%BA"><span class="toc-number">4.5.5.2.3.</span> <span class="toc-text">通过ALTER TABLE语句创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%B4%A2%E5%BC%95%E5%8F%AF%E8%A7%81%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.5.2.4.</span> <span class="toc-text">切换索引可见状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.5.6.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">哪些情况适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">4.5.6.1.1.</span> <span class="toc-text">字段的数值有唯一性的限制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BA-WHERE-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">4.5.6.1.2.</span> <span class="toc-text">频繁作为 WHERE 查询条件的字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%8F%E5%B8%B8-GROUP-BY-%E5%92%8C-ORDER-BY-%E7%9A%84%E5%88%97"><span class="toc-number">4.5.6.1.3.</span> <span class="toc-text">经常 GROUP BY 和 ORDER BY 的列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#UPDATE%E3%80%81DELETE-%E7%9A%84-WHERE-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="toc-number">4.5.6.1.4.</span> <span class="toc-text">UPDATE、DELETE 的 WHERE 条件列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DISTINCT-%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.1.5.</span> <span class="toc-text">DISTINCT 字段需要创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8-JOIN-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.5.6.1.6.</span> <span class="toc-text">多表 JOIN 连接操作时，创建索引注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.1.7.</span> <span class="toc-text">使用字符串前缀创建索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7"><span class="toc-number">4.5.6.1.8.</span> <span class="toc-text">使用最频繁的列放到联合索引的左侧</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.1.9.</span> <span class="toc-text">在多个字段都要创建索引的情况下，联合索引优于单值索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">哪些情况不适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.2.1.</span> <span class="toc-text">在where中使用不到的字段，不要设置索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.2.2.</span> <span class="toc-text">数据量小的表最好不要使用索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.2.3.</span> <span class="toc-text">有大量重复数据的列上不要建立索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.6.2.4.</span> <span class="toc-text">避免对经常更新的表创建过多的索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.5.7.</span> <span class="toc-text">性能分析工具的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.7.1.</span> <span class="toc-text">查看系统性能参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1SQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC%EF%BC%9Alast-query-cost"><span class="toc-number">4.5.7.2.</span> <span class="toc-text">统计SQL的查询成本：last_query_cost</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">4.5.8.</span> <span class="toc-text">定位执行慢的 SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AFslow-query-log"><span class="toc-number">4.5.8.1.</span> <span class="toc-text">开启slow_query_log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9long-query-time%E9%98%88%E5%80%BC"><span class="toc-number">4.5.8.2.</span> <span class="toc-text">修改long_query_time阈值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%9B%AE"><span class="toc-number">4.5.8.3.</span> <span class="toc-text">查看慢查询数目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-number">4.5.8.4.</span> <span class="toc-text">慢查询日志分析工具：mysqldumpslow</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="toc-number">4.5.9.</span> <span class="toc-text">分析查询语句：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.5.9.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explain%E5%90%84%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">4.5.9.2.</span> <span class="toc-text">explain各列作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#table"><span class="toc-number">4.5.9.2.1.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#id"><span class="toc-number">4.5.9.2.2.</span> <span class="toc-text">id</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#select-type"><span class="toc-number">4.5.9.2.3.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#type"><span class="toc-number">4.5.9.2.4.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#possible-keys%E5%92%8Ckey"><span class="toc-number">4.5.9.2.5.</span> <span class="toc-text">possible_keys和key</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#key-len"><span class="toc-number">4.5.9.2.6.</span> <span class="toc-text">key_len</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rows"><span class="toc-number">4.5.9.2.7.</span> <span class="toc-text">rows</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.10.</span> <span class="toc-text">索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">4.5.10.1.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B"><span class="toc-number">4.5.10.2.</span> <span class="toc-text">索引失效案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">4.5.10.2.1.</span> <span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">4.5.10.2.2.</span> <span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%8A%A8%E6%88%96%E6%89%8B%E5%8A%A8-%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">4.5.10.2.3.</span> <span class="toc-text">计算、函数、类型转换(自动或手动)导致索引失效</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">4.5.10.2.4.</span> <span class="toc-text">类型转换导致索引失效</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%88%E8%BF%99%E4%B8%AA%E5%8F%B3%E8%BE%B9%E6%98%AF%E5%80%BC%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B8%8D%E6%98%AFwhere%E5%8F%B3%E8%BE%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">4.5.10.2.5.</span> <span class="toc-text">范围条件右边的列索引失效（这个右边是值索引的位置，不是where右边的位置）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E-%E6%88%96%E8%80%85-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E5%9C%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">4.5.10.2.6.</span> <span class="toc-text">不等于(!&#x3D; 或者&lt;&gt;)索引失效(在覆盖索引可能会失效）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#is-null%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8Cis-not-null%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.10.2.7.</span> <span class="toc-text">is null可以使用索引，is not null无法使用索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#like%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">4.5.10.2.8.</span> <span class="toc-text">like以通配符%开头索引失效</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#OR-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">4.5.10.2.9.</span> <span class="toc-text">OR 前后存在非索引的列，索引失效</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8utf8mb4"><span class="toc-number">4.5.10.2.10.</span> <span class="toc-text">数据库和表的字符集统一使用utf8mb4</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.10.3.</span> <span class="toc-text">关联查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.10.4.</span> <span class="toc-text">子查询优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.11.</span> <span class="toc-text">覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-2"><span class="toc-number">4.5.11.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%8A%E7%AB%AF"><span class="toc-number">4.5.11.2.</span> <span class="toc-text">弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%92%8C%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.6.1.</span> <span class="toc-text">键和相关属性的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">4.6.2.</span> <span class="toc-text">范式简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1st-NF"><span class="toc-number">4.6.3.</span> <span class="toc-text">第一范式(1st NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">4.6.4.</span> <span class="toc-text">第二范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">4.6.5.</span> <span class="toc-text">第三范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-number">4.6.6.</span> <span class="toc-text">反范式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCFN-%E5%B7%B4%E6%96%AF-%E7%A7%91%E5%BE%B7%E8%8C%83%E5%BC%8F"><span class="toc-number">4.6.7.</span> <span class="toc-text">BCFN(巴斯-科德范式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.7.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="toc-number">4.7.1.</span> <span class="toc-text">事务的ACID特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88atomicity%EF%BC%89"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">原子性（atomicity）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88consistency%EF%BC%89"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">一致性（consistency）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%9E%8B%EF%BC%88isolation%EF%BC%89"><span class="toc-number">4.7.1.3.</span> <span class="toc-text">隔离型（isolation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88durability%EF%BC%89"><span class="toc-number">4.7.1.4.</span> <span class="toc-text">持久性（durability）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.7.2.</span> <span class="toc-text">事务的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%9A%84%EF%BC%88active%EF%BC%89"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">活动的（active）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%8F%90%E4%BA%A4%E7%9A%84%EF%BC%88partially-committed%EF%BC%89"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">部分提交的（partially committed）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%EF%BC%88failed%EF%BC%89"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">失败的（failed）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%AD%A2%E7%9A%84%EF%BC%88aborted%EF%BC%89"><span class="toc-number">4.7.2.4.</span> <span class="toc-text">中止的（aborted）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E7%9A%84%EF%BC%88committed%EF%BC%89"><span class="toc-number">4.7.2.5.</span> <span class="toc-text">提交的（committed）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.7.3.</span> <span class="toc-text">如何使用事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">显式事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">隐式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.7.3.2.1.</span> <span class="toc-text">隐式提交数据的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.7.4.</span> <span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-1"><span class="toc-number">4.7.4.1.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.4.2.</span> <span class="toc-text">数据并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%84%8F%E5%86%99%EF%BC%88-Dirty-Write-%EF%BC%89"><span class="toc-number">4.7.4.2.1.</span> <span class="toc-text">脏写（ Dirty Write ）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB%EF%BC%88-Dirty-Read-%EF%BC%89"><span class="toc-number">4.7.4.2.2.</span> <span class="toc-text">脏读（ Dirty Read ）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88-Non-Repeatable-Read-%EF%BC%89"><span class="toc-number">4.7.4.2.3.</span> <span class="toc-text">不可重复读（ Non-Repeatable Read ）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%EF%BC%88-Phantom-%EF%BC%89"><span class="toc-number">4.7.4.2.4.</span> <span class="toc-text">幻读（ Phantom ）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.7.4.3.</span> <span class="toc-text">SQL中的四种隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.7.4.4.</span> <span class="toc-text">MySQL支持的四种隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.7.4.5.</span> <span class="toc-text">不同隔离级别举例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA1-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%E4%B9%8B%E8%84%8F%E8%AF%BB"><span class="toc-number">4.7.4.5.1.</span> <span class="toc-text">演示1. 读未提交之脏读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA2%EF%BC%9A%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-number">4.7.4.5.2.</span> <span class="toc-text">演示2：读已提交</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA3%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">4.7.4.5.3.</span> <span class="toc-text">演示3：可重复读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA4%EF%BC%9A%E5%B9%BB%E8%AF%BB"><span class="toc-number">4.7.4.5.4.</span> <span class="toc-text">演示4：幻读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">4.7.5.</span> <span class="toc-text">MySQL事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log"><span class="toc-number">4.7.5.1.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-3"><span class="toc-number">4.7.5.1.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">4.7.5.1.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redo%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">4.7.5.1.3.</span> <span class="toc-text">redo的组成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redo-log%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.7.5.1.4.</span> <span class="toc-text">redo log的整体流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redo-log%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">4.7.5.1.5.</span> <span class="toc-text">redo log的刷盘策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%85%A5redo-log-buffer-%E8%BF%87%E7%A8%8B"><span class="toc-number">4.7.5.1.6.</span> <span class="toc-text">写入redo log buffer 过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redo-log-file"><span class="toc-number">4.7.5.1.7.</span> <span class="toc-text">redo log file</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo-log"><span class="toc-number">4.7.5.2.</span> <span class="toc-text">undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#undo%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.7.5.2.1.</span> <span class="toc-text">undo的存储结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.8.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.1.</span> <span class="toc-text">锁结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">结构解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E6%89%80%E5%9C%A8%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">4.8.1.1.1.</span> <span class="toc-text">锁所在的事务信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BF%A1%E6%81%AF"><span class="toc-number">4.8.1.1.2.</span> <span class="toc-text">索引信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%EF%BC%8F%E8%A1%8C%E9%94%81%E4%BF%A1%E6%81%AF"><span class="toc-number">4.8.1.1.3.</span> <span class="toc-text">表锁／行锁信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#type-mode"><span class="toc-number">4.8.1.1.4.</span> <span class="toc-text">type_mode</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%A1%E6%81%AF"><span class="toc-number">4.8.1.1.5.</span> <span class="toc-text">其他信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E5%A0%86%E6%AF%94%E7%89%B9%E4%BD%8D"><span class="toc-number">4.8.1.1.6.</span> <span class="toc-text">一堆比特位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="toc-number">4.8.2.</span> <span class="toc-text">MySQL并发事务访问相同记录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">读-读情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">写-写情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">4.8.2.3.</span> <span class="toc-text">读-写或写-读情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.8.3.</span> <span class="toc-text">并发问题的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-number">4.8.4.</span> <span class="toc-text">锁的不同角度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-number">4.8.4.1.</span> <span class="toc-text">从数据操作的类型划分：读锁、写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">4.8.4.1.1.</span> <span class="toc-text">锁定读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.8.4.1.2.</span> <span class="toc-text">写操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-number">4.8.5.</span> <span class="toc-text">从数据操作的粒度划分：表级锁、页级锁、行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%EF%BC%88Table-Lock%EF%BC%89"><span class="toc-number">4.8.5.1.</span> <span class="toc-text">表锁（Table Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84S%E9%94%81%E3%80%81X%E9%94%81"><span class="toc-number">4.8.5.1.1.</span> <span class="toc-text">表级别的S锁、X锁</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81-%EF%BC%88intention-lock%EF%BC%89"><span class="toc-number">4.8.5.2.</span> <span class="toc-text">意向锁 （intention lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">4.8.5.2.1.</span> <span class="toc-text">意义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.8.5.2.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88AUTO-INC%E9%94%81%EF%BC%89"><span class="toc-number">4.8.5.3.</span> <span class="toc-text">自增锁（AUTO-INC锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Simple-inserts-%EF%BC%88%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%EF%BC%89"><span class="toc-number">4.8.5.3.1.</span> <span class="toc-text">Simple inserts （简单插入）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Bulk-inserts-%EF%BC%88%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%EF%BC%89"><span class="toc-number">4.8.5.3.2.</span> <span class="toc-text">Bulk inserts （批量插入）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Mixed-mode-inserts-%EF%BC%88%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%8F%92%E5%85%A5%EF%BC%89"><span class="toc-number">4.8.5.3.3.</span> <span class="toc-text">Mixed-mode inserts （混合模式插入）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81-meta-data-lock"><span class="toc-number">4.8.5.4.</span> <span class="toc-text">元数据锁(meta data lock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">4.8.5.5.</span> <span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-number">4.8.5.5.1.</span> <span class="toc-text">记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-number">4.8.5.5.2.</span> <span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-number">4.8.5.5.3.</span> <span class="toc-text">临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-number">4.8.5.5.4.</span> <span class="toc-text">插入意向锁（Insert Intention Locks）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%94%81"><span class="toc-number">4.8.5.6.</span> <span class="toc-text">页锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">4.8.5.7.</span> <span class="toc-text">全局锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-number">4.8.6.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">4.8.6.1.</span> <span class="toc-text">快照读与当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">4.8.6.1.1.</span> <span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">4.8.6.1.2.</span> <span class="toc-text">当前读</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.8.6.2.</span> <span class="toc-text">再谈隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">4.8.6.3.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Undo-Log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">4.8.6.4.</span> <span class="toc-text">Undo Log版本链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReadView"><span class="toc-number">4.8.6.5.</span> <span class="toc-text">ReadView</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">4.8.6.5.1.</span> <span class="toc-text">ReadView的规则</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVCC%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.8.6.6.</span> <span class="toc-text">MVCC整体操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">4.8.6.6.1.</span> <span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">4.8.6.7.</span> <span class="toc-text">如何解决幻读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97"><span class="toc-number">4.9.</span> <span class="toc-text">其他数据库日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.9.1.</span> <span class="toc-text">日志类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">4.9.2.</span> <span class="toc-text">通用查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">查看当前状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97-error-log"><span class="toc-number">4.9.3.</span> <span class="toc-text">错误日志(error log)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97-bin-log"><span class="toc-number">4.9.4.</span> <span class="toc-text">二进制日志(bin log)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="toc-number">4.9.4.1.</span> <span class="toc-text">查看默认情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">4.9.4.2.</span> <span class="toc-text">查看日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binlog%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.9.4.3.</span> <span class="toc-text">binlog格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.9.4.4.</span> <span class="toc-text">写入机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-%E4%B8%8E-binlog-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">4.9.4.5.</span> <span class="toc-text">redo log 与 binlog 的不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.9.4.6.</span> <span class="toc-text">redo log 两阶段提交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97-relay-log"><span class="toc-number">4.9.4.7.</span> <span class="toc-text">中继日志(relay log)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">4.10.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.10.1.</span> <span class="toc-text">主从复制的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">4.10.1.1.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="toc-number">4.10.1.2.</span> <span class="toc-text">数据备份</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">4.10.1.3.</span> <span class="toc-text">高可用性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.10.2.</span> <span class="toc-text">主从复制的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.10.2.1.</span> <span class="toc-text">三个线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%89%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.10.2.2.</span> <span class="toc-text">复制三步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.10.2.3.</span> <span class="toc-text">复制的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">4.10.3.</span> <span class="toc-text">复制的基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.10.4.</span> <span class="toc-text">同步数据一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">4.10.4.1.</span> <span class="toc-text">主从同步的要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.10.4.2.</span> <span class="toc-text">主从延迟问题原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">4.10.4.3.</span> <span class="toc-text">如何减少主从延迟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.10.4.4.</span> <span class="toc-text">如何解决一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">4.10.4.4.1.</span> <span class="toc-text">方法 1：异步复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%EF%BC%9A%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">4.10.4.4.2.</span> <span class="toc-text">方法 2：半同步复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E7%BB%84%E5%A4%8D%E5%88%B6"><span class="toc-number">4.10.4.4.3.</span> <span class="toc-text">方法 3：组复制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">4.11.</span> <span class="toc-text">MySQL组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%EF%BC%88Connector%EF%BC%89"><span class="toc-number">4.11.1.</span> <span class="toc-text">连接器（Connector）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%EF%BC%88Query-Cache%EF%BC%89"><span class="toc-number">4.11.2.</span> <span class="toc-text">查询缓存（Query Cache）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88Parser%EF%BC%89"><span class="toc-number">4.11.3.</span> <span class="toc-text">解析器（Parser）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%88Optimizer%EF%BC%89"><span class="toc-number">4.11.4.</span> <span class="toc-text">优化器（Optimizer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">4.11.5.</span> <span class="toc-text">执行器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">一条 SQL 的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">4.12.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E3%80%81update%E3%80%81insert"><span class="toc-number">4.12.2.</span> <span class="toc-text">delete、update、insert</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Spring-Framework/" title="Spring Framework"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/ABT290204B8179D36368B6D90EA94F3EB0F9300A14B8F4E47C252F30A75B7E1441A.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Framework"/></a><div class="content"><a class="title" href="/2022/03/22/Spring-Framework/" title="Spring Framework">Spring Framework</a><time datetime="2022-03-22T08:08:19.000Z" title="Created 2022-03-22 16:08:19">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/SpringBoot/" title="SpringBoot"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bcdsjbcdjlsbcdsbvdsfvbdsvdsbjk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2022/01/13/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-01-13T12:18:07.000Z" title="Created 2022-01-13 20:18:07">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/MyBatis/" title="MyBatis"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/bdljasbsbvjdfvbdsvbhjdsbfvhdsh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2022/01/13/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2022-01-13T12:15:31.000Z" title="Created 2022-01-13 20:15:31">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/axcsavrstrheyt2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2022-01-04T09:01:41.000Z" title="Created 2022-01-04 17:01:41">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img2/mvcgnxfdgareth96150 (1).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-01-02T11:57:45.000Z" title="Created 2022-01-02 19:57:45">2022-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>