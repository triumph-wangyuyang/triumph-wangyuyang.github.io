<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-智力题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/22/%E6%99%BA%E5%8A%9B%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-12-22T12:44:41.000Z" itemprop="datePublished">2021-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/">智力题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/22/%E6%99%BA%E5%8A%9B%E9%A2%98/">智力题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="问题：Swap函数不使用额外空间交换变量"><a href="#问题：Swap函数不使用额外空间交换变量" class="headerlink" title="问题：Swap函数不使用额外空间交换变量"></a>问题：Swap函数不使用额外空间交换变量</h3><p>通过 异或 运算符进行得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">    A = A ^ B;</span><br><span class="line">    B = A ^ B;</span><br><span class="line">    A = A ^ B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弊端：</strong>当对数组进行交换时，需要交换的索引值为同一个，那么这两个元素都会变成 <code>0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        array[left] = array[left] ^ array[right];</span><br><span class="line">        array[right] = array[left] ^ array[right];</span><br><span class="line">        array[left] = array[left] ^ array[right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        swap(array, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;left: &quot;</span> + array[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;right:  &quot;</span> + array[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    left: <span class="number">0</span></span><br><span class="line">    right:  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（扩展：算法题 “<strong>数组中数字出现的次数</strong>”）</p>
<h3 id="问题：如何不用比较将小写字符串转换为大写字符串"><a href="#问题：如何不用比较将小写字符串转换为大写字符串" class="headerlink" title="问题：如何不用比较将小写字符串转换为大写字符串"></a>问题：如何不用比较将小写字符串转换为大写字符串</h3><blockquote>
<p><code>a~z</code> 的 <code>ASCII</code> 码：<code>97~122</code> 也就是：1  <strong>1</strong>  00001 ~ 1  <strong>1</strong>  11010</p>
<p><code>A~Z</code> 的 <code>ASCII</code> 码：<code>65~90</code> 也就是： 1  <strong>0</strong>  00001 ~ 1  <strong>0</strong>  11010</p>
<p>通过判断从低位数第六位是否是 <code>0</code>、<code>1</code> ，而得到是小写字母还是大写字母，只要右移 <code>5</code> 位就可以</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> chars[i] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> ((tmp &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            chars[i] -= <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题：1000瓶药水找毒药"><a href="#问题：1000瓶药水找毒药" class="headerlink" title="问题：1000瓶药水找毒药"></a>问题：1000瓶药水找毒药</h3><p>问题描述：一共 <code>1000</code> 瓶药水，其中 <code>1</code> 瓶有毒药。已知小白鼠喝毒药一天内死，想在一天内找到毒药，最少需要几只小白鼠？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li><p><code>0 000 000 001</code>表示 1 号老鼠，喝了药水 1 。</p>
</li>
<li><p><code>0 000 000 010</code>表示 2 号老鼠，喝了药水 2 。</p>
</li>
<li><p><code>0 000 000 011</code>表示 1 号、 2 号老鼠，喝了药水 3 。</p>
</li>
<li><p>… …</p>
</li>
<li><p><code>1 111 101 000</code>表示 4、6、7、8、9、10号老鼠，喝了药水 1000。</p>
</li>
</ul>
<p><strong>按照上述的方法依次喝:</strong></p>
<ul>
<li><p>第一回合，1 号老鼠喝药水 1</p>
</li>
<li><p>第二回合，2 号老鼠喝药水 2</p>
</li>
<li><p>… …</p>
</li>
<li><p>第一千回合，4、6、7、8、9、10号老鼠喝药水 1000</p>
</li>
</ul>
<p>喝完一天时，看 10 只老鼠的状态，根据老鼠状态就知道哪瓶药水有毒了。</p>
<p><strong>比如最后只是 2 号老鼠死了，那就说明第2瓶药水有毒；如果4、6、7、8、9、10死了，那就说明第1000瓶药水有毒！</strong></p>
</blockquote>
<h3 id="问题：分金块问题"><a href="#问题：分金块问题" class="headerlink" title="问题：分金块问题"></a>问题：分金块问题</h3><p>问题描述：工人为老板打工，工作七天可以获得一块金子，工人每天可以分得一点金子，老板必须每天发金子，不能多给，也不能少给，把这个金子切两刀，就可以每天给工人发工资，请问怎么切？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>切两刀将金子分成三份，<code>1/7</code>、<code>2/7</code>、<code>4/7</code>；</p>
<ul>
<li>工作第一天 把<code>1/7</code>分给工人；</li>
<li>工作第二天 把<code>2/7</code>分给工人，并要回<code>1/7</code>那块金子，工人有<code>2/7</code>的金子；</li>
<li>工作第三天 把<code>1/7</code>给工人 工人有<code>3/7</code>金子；</li>
<li>工作第四天 把前两块金子要回，给工人<code>4/7</code>的金子 工人有<code>4/7</code>的金子；</li>
<li>工作第五天 把<code>1/7</code>分给工人 工人有<code>5/7</code>的金子；</li>
<li>工作第六天 把<code>2/7</code>分给工人，并要回<code>1/7</code>那块金子，工人有<code>6/7</code>的金子；</li>
<li>工作第七天 把<code>1/7</code>给工人 工人有完整的金子；</li>
</ul>
<p><strong>扩展：如何给工人发15天的工资？把金块分成<code>1/15</code>、<code>2/15</code>、<code>4/15</code>、<code>8/15</code>。</strong></p>
</blockquote>
<h3 id="问题：抢-30的必胜策略"><a href="#问题：抢-30的必胜策略" class="headerlink" title="问题：抢 30的必胜策略"></a>问题：抢 30的必胜策略</h3><p>问题描述：抢 30 是双人游戏，游戏规则是：第一个人喊“ 1 ”或“ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。两人轮流进行下去，最后喊 30 的人获胜，问喊数字的最佳策略。</p>
<p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li><strong>尽量喊3的倍数</strong>；</li>
</ul>
<p>解析： </p>
<ul>
<li>倒着看，其实，喊 27 时，就决定胜负了。</li>
<li>假设 A 喊了 27，B只能喊 28 或 29 ， 下个回合，A 一定可以喊30。也就是说，喊 27 者必胜。</li>
<li>再倒着看，其实喊 24 时，就定胜负了。假设 A 喊了 24 ，B 只能喊 25 或 26 ， 下个回合 A 一定能喊 27 。</li>
<li>由于喊 27 者必胜，因此喊 24 者也必胜。</li>
<li>同理可以推出：喊 3 的倍数者必胜。</li>
<li>然后就会发现，这个游戏，谁先喊，谁一定输</li>
</ul>
</blockquote>
<h3 id="问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？"><a href="#问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？" class="headerlink" title="问题：100本书，每次能够拿1~5本，怎么拿能保证最后一次是你拿？"></a>问题：100本书，每次能够拿1~5本，怎么拿能保证最后一次是你拿？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>如果最后一次是我拿，那么上回合最少剩下6本；</p>
<p>只要保持每个回合结束后都剩下6的倍数，且在这个回合中我拿的书和对方拿的书加起来为6本；</p>
<p>第一次我必须先手拿4本(100 % 6 &#x3D; 4)，这不算在第一回合内。</p>
</blockquote>
<h3 id="问题：轮流拿石子Ⅰ"><a href="#问题：轮流拿石子Ⅰ" class="headerlink" title="问题：轮流拿石子Ⅰ"></a>问题：轮流拿石子Ⅰ</h3><p>问题描述：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，谁最后会获胜？（假设他们每次都取最优解）。</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>简单的巴什博奕：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/StrayWolf/p/5396427.html">https://www.cnblogs.com/StrayWolf/p/5396427.html</a></p>
</blockquote>
<h3 id="问题：轮流拿石子Ⅱ"><a href="#问题：轮流拿石子Ⅱ" class="headerlink" title="问题：轮流拿石子Ⅱ"></a>问题：轮流拿石子Ⅱ</h3><p>问题描述：有若干堆石子，每堆石子的数量是有限的，二个人依次从这些石子堆中拿取任意的石子，至少一个（不能不取），最后一个拿光石子的人胜利。</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>答案：较复杂的尼姆博弈：<a target="_blank" rel="noopener" href="https://blog.csdn.net/BBHHTT/article/details/80199541">https://blog.csdn.net/BBHHTT/article/details/80199541</a></p>
</blockquote>
<h3 id="问题：掰巧克力问题"><a href="#问题：掰巧克力问题" class="headerlink" title="问题：掰巧克力问题"></a>问题：掰巧克力问题</h3><p>问题描述：一块N * M大小的巧克力，每次掰一块的一行或一列，全部掰成 1 * 1 大小的巧克力需要掰多少次？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li><strong>N * M - 1次；</strong></li>
</ul>
<p>不管怎么掰，每次只能把一个大块掰成两个小块，即每次掰只能增加1块巧克力； 那么将1块巧克力掰成N * M块小巧克力就需要掰N * M - 1次。</p>
</blockquote>
<h3 id="问题：辩论赛问题"><a href="#问题：辩论赛问题" class="headerlink" title="问题：辩论赛问题"></a>问题：辩论赛问题</h3><p>问题描述：1000个人参加辩论赛，1对1进行辩论，淘汰输掉的一方，问需要安排多少场比赛才能角出冠军？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>每场辩论赛只能淘汰一个人，要淘汰999个人则需要安排999场比赛。</p>
</blockquote>
<h3 id="3-3-在24小时里面时针分针秒针可以重合几次"><a href="#3-3-在24小时里面时针分针秒针可以重合几次" class="headerlink" title="3.3 在24小时里面时针分针秒针可以重合几次"></a>3.3 在24小时里面时针分针秒针可以重合几次</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2&#x3D;22次， 而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p>
</blockquote>
<h3 id="3-4-N只蚂蚁走树枝，问总距离或者总时间"><a href="#3-4-N只蚂蚁走树枝，问总距离或者总时间" class="headerlink" title="3.4 N只蚂蚁走树枝，问总距离或者总时间"></a>3.4 N只蚂蚁走树枝，问总距离或者总时间</h3><blockquote>
<p>问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间为多少？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p>参考回答：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的，A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p>
</blockquote>
<h3 id="3-5-旅馆的1元钱问题"><a href="#3-5-旅馆的1元钱问题" class="headerlink" title="3.5 旅馆的1元钱问题"></a>3.5 旅馆的1元钱问题</h3><blockquote>
<p>问题：有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了于是叫小弟退回5给三位客人，谁知小弟贪心,只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了不2，总共是29。可是当初他们三个人一共付出30那么还有$1呢？</p>
</blockquote>
<blockquote>
<p>他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元&#x3D;30元； 这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好！</p>
</blockquote>
<h2 id="4-概率问题"><a href="#4-概率问题" class="headerlink" title="4. 概率问题"></a>4. 概率问题</h2><h3 id="4-1-家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？"><a href="#4-1-家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？" class="headerlink" title="4.1 家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？"></a>4.1 家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p><strong>1&#x2F;3</strong></p>
<p>样本空间为（男男）（女女）（男女）（女男）</p>
<p>A＝（已知其中一个是女孩）＝（女女）（男女）（女男）</p>
<p>B＝（另一个也是女孩）＝（女女）</p>
<p>于是P（B／A）＝P（AB）／P（A）＝（1／4）／（3／4）＝1／3</p>
</blockquote>
<h3 id="4-2-一条绳子砍两刀，能构成一个三角形的概率？"><a href="#4-2-一条绳子砍两刀，能构成一个三角形的概率？" class="headerlink" title="4.2 一条绳子砍两刀，能构成一个三角形的概率？"></a>4.2 一条绳子砍两刀，能构成一个三角形的概率？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>设绳子总长为L，分成三段为：x，y，L - x - y； 其中x &gt; 0，y &gt; 0， L - x - y &gt; 0，取值范围如图中蓝***域所示；</p>
<p>又因为任意两边之和要大于第三边，故有如下条件： x + y &gt; L - x - y &#x3D;&gt; y &gt; -x + L &#x2F; 2； x + (L - x - y) &gt; y &#x3D;&gt; y &lt; L &#x2F; 2; y + (L - x - y) &gt; x &#x3D;&gt; x &lt; L &#x2F; 2;</p>
<p>该区域为图中绿<em><strong>域，占蓝</strong></em>域的<strong>四分之一</strong>；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636442481985/A28873D4FC88FDD3458AE21133B84288" alt="img"></p>
</blockquote>
<h3 id="4-3-一个圆上随机画两条弦，求相交的概率？"><a href="#4-3-一个圆上随机画两条弦，求相交的概率？" class="headerlink" title="4.3 一个圆上随机画两条弦，求相交的概率？"></a>4.3 一个圆上随机画两条弦，求相交的概率？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>四个点确定两条线，在一个圆上取四个点； 四个点画两条线有三种情况，其中只有一种情况是相交的，故相交概率为<strong>三分之一；</strong></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636442532943/AE64BFD9D3FC9C76CDE013E9EDE4B4F1" alt="img"></p>
</blockquote>
<h3 id="4-4-犯人猜颜色"><a href="#4-4-犯人猜颜色" class="headerlink" title="4.4 犯人猜颜色"></a>4.4 犯人猜颜色</h3><blockquote>
<p>问题：一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色．然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字：”黑”或”白”，如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的答案所有犯人都能听见，是否说对，其他犯人不知道，在这之前，所有犯人可以聚在一起商量策略，问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p>1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死</p>
<p>2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一</p>
<p>3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑”</p>
<p><strong>99人能100%存活，1人50%能活</strong></p>
</blockquote>
<h3 id="问题：火枪手决斗，谁活下来的概率大？"><a href="#问题：火枪手决斗，谁活下来的概率大？" class="headerlink" title="问题：火枪手决斗，谁活下来的概率大？"></a>问题：火枪手决斗，谁活下来的概率大？</h3><p>问题描述：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时开枪，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>参考回答：一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，<strong>枪法最糟糕的丙活下来的几率最大；</strong></p>
<p>那么我们先来分析一下各个枪手的策略：</p>
<p>如同田忌赛马一般，枪手甲一定要对枪手乙先。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。</p>
<p>同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。</p>
<p>枪手丙的最佳策略也是先对甲。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。</p>
<p>我们根据分析来计算一下三个枪手在上述情况下的存活几率：</p>
<p>第一轮：甲射乙，乙射甲，丙射甲。</p>
<ul>
<li>甲的活率为24%（40% X 60%）</li>
<li>乙的活率为20%(100% - 80%)</li>
<li>丙的活率为100%（无人射丙）</li>
</ul>
<p>由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率：</p>
<p>情况1：甲活乙死（24% X 80% &#x3D; 19.2%） 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。</p>
<p>情况2：乙活甲死（20% X 76% &#x3D; 15.2%） 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。</p>
<p>情况3：甲乙同活（24% X 20% &#x3D; 4.8%） 重复第一轮。</p>
<p>情况4：甲乙同死（76% X 80% &#x3D; 60.8%） 枪战结束。</p>
<p>据此来计算三人活率：</p>
<ul>
<li>甲的活率为(19.2% X 60%) + (4.8% X 24%) &#x3D; 12.672%</li>
<li>乙的活率为(15.2% X 60%) + (4.8% X 20%) &#x3D; 10.08%</li>
<li>丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) &#x3D; 75.52%</li>
</ul>
<p><strong>通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</strong></p>
</blockquote>
<h3 id="问题：100个奴隶猜帽子颜色"><a href="#问题：100个奴隶猜帽子颜色" class="headerlink" title="问题：100个奴隶猜帽子颜色"></a>问题：100个奴隶猜帽子颜色</h3><p>问题描述：一百个奴隶站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色． 然后从最后一个奴隶开始，每人只能用同一种声调和音量说一个字：”黑”或”白”， 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的参考回答所有奴隶都能听见。 是否说对，其他奴隶不知道。 在这之前，所有奴隶可以聚在一起商量策略，问如果奴隶都足够聪明而且反应足够快，100个人最大存活率是多少？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死</p>
<p>2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一</p>
<p>3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑” 99人能100%存活，1人50%能活</p>
<p>另外，此题还有变种：每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？ 参考回答：增加限制条件后，上面的方法就失效了， 此时只能约定偶数位奴隶说他前一个人的帽子颜色， 奇数奴隶获取信息100%存活，偶数奴隶50几率存活。</p>
</blockquote>
<h3 id="问题：水资源无限，3L和5L水桶各一个，怎样取4L的水？"><a href="#问题：水资源无限，3L和5L水桶各一个，怎样取4L的水？" class="headerlink" title="问题：水资源无限，3L和5L水桶各一个，怎样取4L的水？"></a>问题：水资源无限，3L和5L水桶各一个，怎样取4L的水？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>初始时0，5</li>
<li>然后3，2</li>
<li>然后0，2</li>
<li>然后2，0</li>
<li>然后2，5</li>
<li>然后1，4</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636442752038/07B08EAB4B32A3B904B8B869FC0F9A4A" alt="img"></p>
</blockquote>
<h3 id="问题：水资源无限，5L和6L水桶各一个，怎样取3L的水？"><a href="#问题：水资源无限，5L和6L水桶各一个，怎样取3L的水？" class="headerlink" title="问题：水资源无限，5L和6L水桶各一个，怎样取3L的水？"></a>问题：水资源无限，5L和6L水桶各一个，怎样取3L的水？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>step 1 , 6L水桶装满水倒入5L水桶，余下1L水</li>
<li>step 2 , 5L水桶倒空，将6L水桶中剩余的1L水倒入5L水桶</li>
<li>step 3 , 6L水桶再次装满水倒入5L水桶，余下2L水</li>
<li>step 4 , 5L水桶倒空， 将6L水桶中剩余2L水倒入5L水桶</li>
<li>step 5 , 6L水桶再次装满水倒入5L水桶，余下3L水</li>
</ul>
</blockquote>
<h3 id="问题：一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L？"><a href="#问题：一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L？" class="headerlink" title="问题：一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L？"></a>问题：一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>初始时为10，0，0；</li>
<li>第二步7，0，3；</li>
<li>然后7，3，0；</li>
<li>然后4，3，3；</li>
<li>然后4，6，0；</li>
<li>然后1，6，3；</li>
<li>然后1，7，2；</li>
<li>然后8，0，2；</li>
<li>然后8，2，0；</li>
<li>然后5，2，3；</li>
<li>然后5，5，0；</li>
</ul>
</blockquote>
<h3 id="问题：舀酒问题：只有两个舀酒的勺子，分别能舀7两和11两酒，如何舀出2两酒？"><a href="#问题：舀酒问题：只有两个舀酒的勺子，分别能舀7两和11两酒，如何舀出2两酒？" class="headerlink" title="问题：舀酒问题：只有两个舀酒的勺子，分别能舀7两和11两酒，如何舀出2两酒？"></a>问题：舀酒问题：只有两个舀酒的勺子，分别能舀7两和11两酒，如何舀出2两酒？</h3><p>问题描述：据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>思路：大勺子装满酒,再倒满小勺,于是大勺子还有4两,倒出小勺的酒,把大勺的4两倒入小勺中,再次在大勺中装满酒,大小勺加起来就是15两,把大勺中的酒倒入小勺中,使小勺装满,于是大勺中还有8两,倒掉小勺中的酒,再次把大勺中的酒倒入小勺中,使小勺装满,于是大勺中还有1两.重复以上动作一次,就可以得到2两酒</p>
<ul>
<li>初始0，11</li>
<li>然后7，4</li>
<li>然后0，4</li>
<li>然后4，0</li>
<li>然后4，11</li>
<li>然后7，8</li>
<li>然后0，8</li>
<li>然后7，1</li>
<li>然后0，1</li>
<li>然后1，11</li>
<li>然后7，5</li>
<li>然后0，5</li>
<li>然后5，0</li>
<li>然后5，11</li>
<li>然后7，9</li>
<li>然后0，9</li>
<li>然后7，2</li>
</ul>
</blockquote>
<h3 id="问题：有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？"><a href="#问题：有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？" class="headerlink" title="问题：有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？"></a>问题：有一个能计时6分钟的小沙漏和一个能计时8分钟的大沙漏，如何计时10分钟？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>两个沙漏同时倒置开始计时，等小沙漏漏完，大沙漏还剩2分钟，这时倒置小沙漏继续计时；</li>
<li>大沙漏漏完小沙漏还剩4分钟，再把大沙漏倒置继续计时；</li>
<li>小沙漏漏完大沙漏还剩4分钟，这时准备工作已经完毕；</li>
<li>等待大沙漏漏完（4分钟）+ 小沙漏（6分钟） &#x3D; 10分钟。</li>
</ul>
</blockquote>
<h3 id="问题：烧一根绳子需要一个小时，现有若干条相同的绳子，问如何计时15分钟？"><a href="#问题：烧一根绳子需要一个小时，现有若干条相同的绳子，问如何计时15分钟？" class="headerlink" title="问题：烧一根绳子需要一个小时，现有若干条相同的绳子，问如何计时15分钟？"></a>问题：烧一根绳子需要一个小时，现有若干条相同的绳子，问如何计时15分钟？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>点燃绳子A的一头，同时点燃绳子B的两头； 绳子B烧完的时候绳子A还剩一半，此时点燃绳子A的另一头开始计时；</li>
<li>15分钟绳子A烧完。</li>
</ul>
</blockquote>
<h3 id="问题：蜡烛燃烧问题：两根蜡烛，燃烧完都需要1小时，怎么确定15分钟是多久？"><a href="#问题：蜡烛燃烧问题：两根蜡烛，燃烧完都需要1小时，怎么确定15分钟是多久？" class="headerlink" title="问题：蜡烛燃烧问题：两根蜡烛，燃烧完都需要1小时，怎么确定15分钟是多久？"></a>问题：蜡烛燃烧问题：两根蜡烛，燃烧完都需要1小时，怎么确定15分钟是多久？</h3><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>点燃第一根的一端，第二根的两端。</li>
<li>第二根烧完代表半小时后，点燃第一根另一端，烧完代表15分钟。</li>
</ul>
</blockquote>
<h3 id="问题：25匹马5条跑道找最快的3匹马，需要跑几次？"><a href="#问题：25匹马5条跑道找最快的3匹马，需要跑几次？" class="headerlink" title="问题：25匹马5条跑道找最快的3匹马，需要跑几次？"></a>问题：25匹马5条跑道找最快的3匹马，需要跑几次？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>参考回答：7</p>
<ul>
<li>将25匹马分成ABCDE5组，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5,用边相连，这里比赛5次</li>
<li>第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1 D1，E1肯定进不了前3，直接排除掉</li>
<li>第7次，B1 C1 A2 B2 A3比赛，可以找出第二，第三名</li>
</ul>
<p>所以最少比赛需要7次；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636443105987/AA35340A35DF0D8669A5D04EB14BE07A" alt="img"></p>
</blockquote>
<h3 id="问题：64匹马，8条跑道找最快的4匹马，需要跑几次？"><a href="#问题：64匹马，8条跑道找最快的4匹马，需要跑几次？" class="headerlink" title="问题：64匹马，8条跑道找最快的4匹马，需要跑几次？"></a>问题：64匹马，8条跑道找最快的4匹马，需要跑几次？</h3><p>问题描述：有 <strong><code>64</code> 匹马</strong> 赛跑，没有任何秒表之类的计时工具，跑道每次只允许 <strong><code>8</code> 匹马</strong> 同时比，问 <strong>最少</strong> 需要比赛几场才能够选出跑的最快的 <strong>前 <code>4</code> 名</strong>？</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>这道题目坑点很多，题目中任何一个数字的改动都会影响到最终结果，因此一定要明确题目上的关键数字。</p>
<p>网上也有很多题目的变种，比如 <code>36</code> 匹马 <code>6</code> 个跑道找前三名，但思路都是一致的，下面我们模拟一下比赛全程。</p>
<p><strong>第一轮</strong></p>
<p>首先，跑道最多允许 <code>8</code> 匹马同时比，那我们一定要最大程度地利用资源，每场比赛都要上满 <code>8</code> 匹马。</p>
<p>所以第一轮最简单，无脑 <strong>将 <code>64</code> 匹马分为 <code>8</code> 组，每组 <code>8</code> 匹马比一场</strong> 就好了，共计 <code>8</code> 场比赛。</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手</th>
</tr>
</thead>
<tbody><tr>
<td>组 <code>1</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>2</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>3</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>4</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>5</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>6</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>7</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>8</code></td>
<td><code>🐴 🐴 🐴 🐴 🐴 🐴 🐴 🐴</code></td>
</tr>
</tbody></table>
<p>本轮比赛之后，由于题目要求选出前 <code>4</code> 名，因此，每组比赛第 <code>4</code> 名之后的马可以直接淘汰，还剩 <code>32</code> 匹马。</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手（<code>🐎</code> &#x3D; 组内冠军）</th>
</tr>
</thead>
<tbody><tr>
<td>组 <code>1</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>2</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>3</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>4</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>5</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>6</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>7</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>8</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
</tbody></table>
<p><strong>第二轮</strong></p>
<p>第二轮开始，我们必须精打细算了。</p>
<p>最简单的方式是将剩下的 <code>32</code> 匹马直接分为 4 组去比赛，但其实利用上一轮的信息，我们可以有更好的方法。</p>
<p><strong>让上轮比赛中，每组第 <code>1</code> 名一起比赛 <code>1</code> 场，然后按照本轮比赛结果，选出前 <code>4</code> 组。</strong></p>
<p>赛场：🐎 🐎 🐎 🐎 🐎 🐎 🐎 🐎</p>
<p>比赛结果：</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手（<code>🐎</code> &#x3D; 组内冠军）</th>
</tr>
</thead>
<tbody><tr>
<td>组 <code>1</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>2</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>3</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>4</code></td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td><del>组 5</del></td>
<td><code>~~🐎 🐴 🐴 🐴</code>~~</td>
</tr>
</tbody></table>
<p>这么操作的原因是：如果某个组的第一名都进不了前 <code>4</code>，那这个组剩下的马肯定也进不了前 <code>4</code>，直接整组淘汰即可。</p>
<p>截止到目前，还剩下 <code>16</code> 匹马，那这一轮淘汰到这里就结束了么？</p>
<p>其实并没有，以这轮比赛排名第四的马所在的组为例，这个组的冠军最高也才第四名，那么这个组其他的马也是可以被淘汰的。同理，可以淘汰更多的马，剩余 <code>10</code> 匹。</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手（<code>🐎</code> &#x3D; 组内冠军）</th>
</tr>
</thead>
<tbody><tr>
<td>组 1</td>
<td><code>🐎 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 2</td>
<td><code>🐎 🐴 🐴 ~~🐴</code>~~</td>
</tr>
<tr>
<td>组 3</td>
<td><code>🐎 🐴 ~~🐴 🐴</code>~~</td>
</tr>
<tr>
<td>组 4</td>
<td><code>🐎 ~~🐴 🐴 🐴</code>~~</td>
</tr>
</tbody></table>
<p>现在场上还有 <code>10</code> 匹马，看似胜利近在咫尺，但其实，接下来才是关键！</p>
<p><strong>第三轮</strong></p>
<p>接下来我们的目标是从 <code>10</code> 匹马中选出前 <code>4</code> 名，但一场比赛只能容纳 <code>8</code> 匹马，那好像至少还得比两场。</p>
<p>一步步来吧，先选 <code>8</code> 匹马比一场呗，问题是选哪 <code>8</code> 匹马呢？</p>
<p>不知道大家有没有发现，在无意中，冠军已经产生了，那就是组内组外都未尝败绩的那匹 中之强！</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手（🐎 &#x3D; 组内冠军）</th>
</tr>
</thead>
<tbody><tr>
<td>组 <code>1</code></td>
<td><code>🏆 🐴 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>2</code></td>
<td><code>🐎 🐴 🐴</code></td>
</tr>
<tr>
<td>组 <code>3</code></td>
<td><code>🐎 🐴</code></td>
</tr>
<tr>
<td>组 <code>4</code></td>
<td><code>🐎</code></td>
</tr>
</tbody></table>
<p>因此，它不用再比了，目标变成，从剩余 <code>9</code> 匹马中选出第 <code>2 - 4</code> 名。</p>
<p>让我们任意选 <code>8</code> 匹马先比一场吧，选出前 <code>3</code> 名。</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>参赛选手（<code>🐎</code> &#x3D; 组内冠军）</th>
</tr>
</thead>
<tbody><tr>
<td>组 <code>1</code></td>
<td><code>🏆 [ 🐴 🐴 🐴 ]</code> 出战</td>
</tr>
<tr>
<td>组 <code>2</code></td>
<td><code>[ 🐎 🐴 🐴 ]</code> 出战</td>
</tr>
<tr>
<td>组 <code>3</code></td>
<td><code>[ 🐎 🐴 ]</code> 出战</td>
</tr>
<tr>
<td>组 <code>4</code></td>
<td><code>🦓</code>（未参与比赛的马）</td>
</tr>
</tbody></table>
<p>那么最后一轮，还需要让上轮没比的马与前 <code>3</code> 名比 <code>1</code> 场，万一人家是黑马呢？</p>
<p>赛场：<code>🐎 🐴 🐴 🦓</code></p>
<p><strong>至此，答案出来了，最少需要 <code>8 + 1 + 1 + 1 = 11</code> 场。</strong></p>
<p><strong><font color="red">然而，这是一个错误答案！</font></strong></p>
<p>其实，还有更优解！</p>
<p>在还剩 9 匹马的时候，如果不任选 8 匹马比赛，而是先移除组 2 的冠军，让剩下 8 匹马赛一场。</p>
<p>如果这场比赛中，组 3 的冠军拿了第一，那么由于之前已经证明了组 2 的冠军强于组 3 的冠军，则前 4 名已经确定，只需要比 10 场。如果它不是第一，那么还是要多比一场了。</p>
<p><strong>因此正确答案是，最少需要 10 场，你做对了么？</strong></p>
</blockquote>
<h3 id="问题：25匹马5条跑道找最快的5匹马，需要跑几次？"><a href="#问题：25匹马5条跑道找最快的5匹马，需要跑几次？" class="headerlink" title="问题：25匹马5条跑道找最快的5匹马，需要跑几次？"></a>问题：25匹马5条跑道找最快的5匹马，需要跑几次？</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>参考回答：最少8次最多9次</p>
</blockquote>
<blockquote>
<p>(1) 首先将25匹马分成5组，并分别进行5场比赛之后得到的名次排列如下：</p>
<p>A组： [A1 A2 A3 A4 A5]</p>
<p>B组： [B1 B2 B3 B4 B5]</p>
<p>C组： [C1 C2 C3 C4 C5]</p>
<p>D组： [D1 D2 D3 D4 D5]</p>
<p>E组： [E1 E2 E3 E4 E5]</p>
<p>其中，每个小组最快的马为[A1、B1、C1、D1、E1]。</p>
<p>(2) 将[A1、B1、C1、D1、E1]进行第6场，选出第1名的马，不妨设 A1&gt;B1&gt;C1&gt;D1&gt;E1. 此时第1名的马为A1。</p>
<p>(3) 将[A2、B1、C1、D1、E1]进行第7场，此时选择出来的必定是第2名的马，不妨假设为B1。因为这5匹马是除去A1之外每个小组当前最快的马。</p>
<p>(3) 进行第8场，选择[A2、B2、C1、D1、E1]角逐出第3名的马。</p>
<p>(4) 依次类推，第9，10场可以分别决出第4，5名的吗。</p>
<p>因此，依照这种竞标赛排序思想，需要10场比赛是一定可以取出前5名的。</p>
<p>仔细想一下，如果需要减少比赛场次，就一定需要在某一次比赛中同时决出2个名次，而且每一场比赛之后，有一些不可能进入前5名的马可以提前出局。</p>
<p>当然要做到这一点，就必须小心选择每一场比赛的马匹。我们在上面的方法基础上进一步思考这个问题，希望能够得到解决。</p>
<p>(1) 首先利用5场比赛角逐出每个小组的排名次序是绝对必要的。</p>
<p>(2) 第6场比赛选出第1名的马也是必不可少的。假如仍然是A1马(A1&gt;B1&gt;C1&gt;D1&gt;E1)。那么此时我们可以得到一个重要的结论：有一些马在前6场比赛之后就决定出局的命运了(下面粉色字体标志出局)。</p>
<p>A组： [A1 A2 A3 A4 A5]</p>
<p>B组： [B1 B2 B3 B4 B5 ]</p>
<p>C组： [C1 C2 C3 C4 C5 ]</p>
<p>D组： [D1 D2 D3 D4 D5 ]</p>
<p>E组： [E1 E2 E3 E4 E5 ]</p>
<p>(3) 第7场比赛是关键，能否同时决出第2，3名的马呢？我们首先做下分析：</p>
<p>在上面的方法中，第7场比赛[A2、B1、C1、D1、E1]是为了决定第2名的马。但是在第6场比赛中我们已经得到(B1&gt;C1&gt;D1&gt;E1)，试问？有B1在的比赛，C1、D1、E1还有可能争夺第2名吗？ 当然不可能，也就是说第2名只能在A2、B1中出现。实际上只需要2条跑道就可以决出第2名，剩下C1、D1、E1的3条跑道都只能用来凑热闹的吗？</p>
<p>能够优化的关键出来了，我们是否能够通过剩下的3个跑道来决出第3名呢？当然可以，我们来进一步分析第3名的情况？</p>
<p>● 如果A2&gt;B1(即第2名为A2)，那么根据第6场比赛中的(B1&gt;C1&gt;D1&gt;E1)。 可以断定第3名只能在A3和B1中产生。</p>
<p>● 如果B1&gt;A2(即第2名为B1)，那么可以断定的第3名只能在A2, B2,C1 中产生。</p>
<p>好了，结论也出来了，只要我们把[A2、B1、A3、B2、C1]作为第7场比赛的马，那么这场比赛的第2，3名一定是整个25匹马中的第2，3名。</p>
<p>我们在这里列举出第7场的2，3名次的所有可能情况：</p>
<p>① 第2名&#x3D;A2，第3名&#x3D;A3</p>
<p>② 第2名&#x3D;A2，第3名&#x3D;B1</p>
<p>③ 第2名&#x3D;B1，第3名&#x3D;A2</p>
<p>④ 第2名&#x3D;B1，第3名&#x3D;B2</p>
<p>⑤ 第2名&#x3D;B1，第3名&#x3D;C1</p>
<p>(4) 第8场比赛很复杂，我们要根据第7场的所有可能的比赛情况进行分析。</p>
<p>① 第2名&#x3D;A2，第3名&#x3D;A3。那么此种情况下第4名只能在A4和B1中产生。</p>
<p>● 如果第4名&#x3D;A4，那么第5名只能在A5、B1中产生。</p>
<p>● 如果第4名&#x3D;B1，那么第5名只能在A4、B2、C1中产生。</p>
<p>不管结果如何，此种情况下，第4、5名都可以在第8场比赛中决出。其中比赛马匹为[A4、A5、B1、B2、C1]</p>
<p>② 第2名&#x3D;A2，第3名&#x3D;B1。那么此种情况下第4名只能在A3、B2、C1中产生。</p>
<p>● 如果第4名&#x3D;A3，那么第5名只能在A4、B2、C1中产生。</p>
<p>● 如果第4名&#x3D;B2，那么第5名只能在A3、B3、C1中产生。</p>
<p>● 如果第4名&#x3D;C1，那么第5名只能在A3、B2、C2、D1中产生。</p>
<p>那么，第4、5名需要在马匹[A3、B2、B3、C1、A4、C2、D1]七匹马中产生，则必须比赛两场才行，也就是到第9场角逐出全部的前5名。</p>
<p>③ 第2名&#x3D;B1，第3名&#x3D;A2。那么此种情况下第4名只能在A3、B2、C1中产生。</p>
<p>情况和②一样，必须角逐第9场</p>
<p>④ 第2名&#x3D;B1，第3名&#x3D;B2。 那么此种情况下第4名只能在A2、B3、C1中产生。</p>
<p>● 如果第4名&#x3D;A2，那么第5名只能在A3、B3、C1中产生。</p>
<p>● 如果第4名&#x3D;B3，那么第5名只能在A2、B4、C1中产生。</p>
<p>● 如果第4名&#x3D;C1，那么第5名只能在A2、B3、C2、D1中产生。</p>
<p>那么，第4、5名需要在马匹[A2、B3、B4、C1、A3、C2、D1]七匹马中产 生，则必须比赛两场才行，也就是到第9场角逐出全部的前5名。</p>
<p>⑤ 第2名&#x3D;B1，第3名&#x3D;C1。那么此种情况下第4名只能在A2、B2、C2、D1中产生。</p>
<p>● 如果第4名&#x3D;A2，那么第5名只能在A3、B2、C2、D1中产生。</p>
<p>● 如果第4名&#x3D;B2，那么第5名只能在A2、B3、C2、D1中产生。</p>
<p>● 如果第4名&#x3D;C2，那么第5名只能在A2、B2、C3、D1中产生。</p>
<p>● 如果第4名&#x3D;D1，那么第5名只能在A2、B2、C2、D2、E2中产生。</p>
<p>那么，第4、5名需要在马匹[A2、B2、C2、D1、A3、B3、C3、D2、E1]九匹马中 产 生，因此也必须比赛两场，也就是到第9长决出胜负。</p>
<p><strong>总结：最好情况可以在第8场角逐出前5名，最差也可以在第9场搞定。</strong></p>
</blockquote>
<h3 id="问题：过河-过桥问题"><a href="#问题：过河-过桥问题" class="headerlink" title="问题：过河&#x2F;过桥问题"></a>问题：过河&#x2F;过桥问题</h3><h4 id="问题：三人三鬼过桥"><a href="#问题：三人三鬼过桥" class="headerlink" title="问题：三人三鬼过桥"></a>问题：三人三鬼过桥</h4><blockquote>
<p>问题：有三个人跟三个鬼要过河,河上没桥只有条小船,然后船一次只能渡一个人和一个鬼,或者两个鬼或者两个人,无论在哪边岸上,只有是人比鬼少的情况下(如两鬼一人,三鬼两人,三鬼一人)人会被鬼吃,然而船又一定需要人或鬼操作才能航行(要有人或鬼划船),问,如何安全的把三人三鬼渡过河对岸?</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>先两鬼过去。在一鬼回来。对面有一鬼。这边有三人两鬼。</li>
<li>再两鬼过去。在一鬼回来。对面有两鬼。这边有三人一鬼。</li>
<li>再两人过去。一人一鬼回来。对面一人一鬼。这边两人两鬼。</li>
<li>最后两人过去。一鬼回来。对面三人。这边三鬼。</li>
<li>剩下的就三个鬼二个过去一个回来在接另外个就OK了。</li>
</ul>
</blockquote>
<h4 id="问题：限时过桥问题"><a href="#问题：限时过桥问题" class="headerlink" title="问题：限时过桥问题"></a>问题：限时过桥问题</h4><blockquote>
<p>问题：在一个夜晚，同时有4人需要过一桥，一次最多只能通过两个人，且只有一只手电筒，而且每人的速度不同。A，B，C，D需要时间分别为：1，2，5，10分钟。问：在17分钟内这四个人怎么过桥？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p>总共是17分钟</p>
<ul>
<li>第一步：A、B过花时间2分钟。</li>
<li>第二步：B回花时间2分钟。</li>
<li>第三步：C、D过花时间10分钟。</li>
<li>第四步：A回花时间1分钟。</li>
<li>第五步：A、B再过花时间2分钟。</li>
</ul>
</blockquote>
<h3 id="问题：猴子搬香蕉"><a href="#问题：猴子搬香蕉" class="headerlink" title="问题：猴子搬香蕉"></a>问题：猴子搬香蕉</h3><p>问题描述：一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。</p>
<p>（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。）</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p>​	这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？</p>
<p>​	其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数《&#x3D;50，直接搬回去。每走一米吃掉1根。</p>
<p>我们分析第一阶段：假如把100根香蕉分为两箱。一箱50根。</p>
<ul>
<li>第一步，把A箱搬一米，吃一根。</li>
<li>第二步，往回走一米，吃一根。</li>
<li>第三步，把B箱搬一米，吃一根。</li>
</ul>
<p>这样，把所有香蕉搬走一米需要吃掉三根香蕉。</p>
<p>这样走到第几米的时候，香蕉数刚好小于50呢？ 100-(n*3)&lt;50 &amp;&amp; 100-(n-1*3)&gt;50</p>
<p>走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦。直接背着走就行。</p>
<p>第二阶段：走一米吃一根。</p>
<p>把剩下的50-17&#x3D;33米走完。还剩49-33&#x3D;16根香蕉。</p>
</blockquote>
<h3 id="问题：高楼扔鸡蛋"><a href="#问题：高楼扔鸡蛋" class="headerlink" title="问题：高楼扔鸡蛋"></a>问题：高楼扔鸡蛋</h3><p>问题描述：有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层。如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？</p>
<p>首先要说明的是这道题你要是一上来就说出正确答案，那说明你的智商不是超过160就是你做过这题。所以建议你循序渐进的回答，一上来就说最优解可能结果不会让你和面试官满意。</p>
<p><strong>解题思路</strong></p>
<blockquote>
<p><strong>1.暴力法</strong></p>
<p>举个栗子，最笨的测试方法，是什么样的呢？把其中一个鸡蛋，从第1层开始往下扔。如果在第1层没碎，换到第2层扔；如果在第2层没碎，换到第3层扔…….如果第59层没碎，换到第60层扔；如果第60层碎了，说明不会摔碎的临界点是第59层。</p>
<p>在最坏情况下，这个方法需要扔100次。</p>
<p><strong>2. 二分法</strong></p>
<p>采用类似于二分查找的方法，把鸡蛋从一半楼层（50层）往下扔。</p>
<p>如果第一枚鸡蛋，在50层碎了，第二枚鸡蛋，就从第1层开始扔，一层一层增长，一直扔到第49层。</p>
<p>如果第一枚鸡蛋在50层没碎了，则继续使用二分法，在剩余楼层的一半（75层）往下扔……</p>
<p>这个方法在最坏情况下，需要尝试50次。</p>
<p><strong>3.均匀法</strong></p>
<p>如何让第一枚鸡蛋和第二枚鸡蛋的尝试次数，尽可能均衡呢？</p>
<p>很简单，做一个平方根运算，100的平方根是10。</p>
<p>因此，我们尝试每10层扔一次：第1次从10层扔，第2次从20层扔，第3次从30层…一直扔到100层。</p>
<p>这样的最好情况是在第10层碎掉，尝试次数为 1 + 9 &#x3D; 10次。</p>
<p>最坏的情况是在第100层碎掉，尝试次数为 10 + 9 &#x3D; 19次。</p>
<p>不过，这里有一个小小的优化点，我们可以从15层开始扔，接下来从25层、35层扔……一直到95层。</p>
<p>这样最坏情况是在第95层碎掉，尝试次数为 9 + 9 &#x3D; 18次。</p>
<p>4.最优解法</p>
<p>最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔X次，那第一次在第几层扔最好呢？</p>
<p>答案是：从X层扔</p>
<p>假设最优的尝试次数的x次，为什么第一次扔就要选择第x层呢？</p>
<p>这里的解释会有些烧脑，请小伙伴们坐稳扶好：</p>
<p><strong>假设第一次扔在第x+1层：</strong></p>
<p>如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。</p>
<p>这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。</p>
<p><strong>假设第一次扔在第x-1层：</strong></p>
<p>如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。</p>
<p>这样一来，我们总共尝试了x-2+1 &#x3D; x-1次，虽然没有超出假设次数，但似乎有些过于保守。</p>
<p><strong>假设第一次扔在第x层：</strong></p>
<p>如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。</p>
<p>这样一来，我们总共尝试了x-1+1 &#x3D; x次，刚刚好没有超出假设次数。</p>
<p>因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。</p>
<p>那么算最坏情况，第二次你只剩下x-1次机会，按照上面的说法，你第二次尝试的位置必然是X+（X-1）；</p>
<p>以此类推我们可得：</p>
<p>x + (x-1) + (x-2) + … + 1 &#x3D; 100</p>
<p>这个方程式不难理解：</p>
<p>左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。</p>
<p>右边是总的楼层数100。</p>
<p>下面我们来解这个方程：</p>
<p>x + (x-1) + (x-2) + … + 1 &#x3D; 100 转化为 (x+1)*x&#x2F;2 &#x3D; 100</p>
<p>最终x向上取整，得到 x &#x3D; 14</p>
<p>因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。</p>
<p>最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来：</p>
<p>14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100</p>
<p>举个栗子验证下：</p>
<p>假如鸡蛋不会碎的临界点是65层， 那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。 第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。 因此得到不会碎的临界点65层，总尝试次数是 6 + 6 &#x3D; 12 &lt; 14 。</p>
</blockquote>
<h3 id="问题：11223344问题"><a href="#问题：11223344问题" class="headerlink" title="问题：11223344问题"></a>问题：11223344问题</h3><blockquote>
<p>问题：有8个数，11223344，将其排列，要求结果满足：两个1之间有一个数，两个2之间有两个数，两个3之间有三个数，两个4之间有四个数。问这个结果是多少？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p>答案：41312432 或 23421314</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636443891896/0FD3B74390D4EB8E6F7F3B75233960AC" alt="img"><br><img src="https://uploadfiles.nowcoder.com/images/20211109/973419228_1636443771688/D2D46D6B2172EC2E808D105EF9808342" alt="img"></p>
</blockquote>
<h3 id="问题：重量问题"><a href="#问题：重量问题" class="headerlink" title="问题：重量问题"></a>问题：重量问题</h3><h4 id="问题：乒乓球重量问题：8个乒乓球，其中一个重，有一个秤，问至少几次能够找出重的那个乒乓球"><a href="#问题：乒乓球重量问题：8个乒乓球，其中一个重，有一个秤，问至少几次能够找出重的那个乒乓球" class="headerlink" title="问题：乒乓球重量问题：8个乒乓球，其中一个重，有一个秤，问至少几次能够找出重的那个乒乓球"></a>问题：乒乓球重量问题：8个乒乓球，其中一个重，有一个秤，问至少几次能够找出重的那个乒乓球</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>2次，分成3堆，3，3，2。</p>
</blockquote>
<blockquote>
<ul>
<li>①称3和3，如果一样重，代表重的在2。</li>
<li>②称2个那一堆的。</li>
</ul>
<p>或</p>
<ul>
<li>①称3和3，不一样重，重的在3里面重的那堆。</li>
<li>②3个里面随便取2个，一样重，第三个重，不一样重，重的那个就是。</li>
</ul>
</blockquote>
<h4 id="问题：盐重量问题：有7克、2克砝码各一个，天平一只，如何只用这些物品五次内将140克的盐分成50、90克各一份？"><a href="#问题：盐重量问题：有7克、2克砝码各一个，天平一只，如何只用这些物品五次内将140克的盐分成50、90克各一份？" class="headerlink" title="问题：盐重量问题：有7克、2克砝码各一个，天平一只，如何只用这些物品五次内将140克的盐分成50、90克各一份？"></a>问题：盐重量问题：有7克、2克砝码各一个，天平一只，如何只用这些物品五次内将140克的盐分成50、90克各一份？</h4><p><strong>解题思路</strong></p>
<blockquote>
<ul>
<li>第一次：先分成70和70</li>
<li>第二次：通过7和2砝码将70分成9和61</li>
<li>第三次：通过9克盐和2砝码将61分成50和11</li>
</ul>
</blockquote>
<h4 id="问题：有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？"><a href="#问题：有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？" class="headerlink" title="问题：有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？"></a>问题：有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>需要称2次；</p>
</blockquote>
<blockquote>
<p>天平一边放三个砝码，哪边轻就在哪边，一样重就在剩下的三个砝码中；</p>
<p>现在已经锁定了三个砝码，天平一边放一个，哪边轻是哪个，一样重就是剩下的那个；</p>
</blockquote>
<h4 id="问题：十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？"><a href="#问题：十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？" class="headerlink" title="问题：十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？"></a>问题：十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>称一次即可；</p>
</blockquote>
<blockquote>
<p>将砝码分组编号1~10， 第1组拿1个砝码、第2组拿2个…第10组拿10个，全部放到秤上计算总克数X； Y &#x3D; (1*10 + 2 * 10 + … + 10 * 10) - X &#x3D; 550 - X，Y即为轻的那组的编号。</p>
</blockquote>
<h4 id="问题：药丸问题：有20瓶药丸，其中19瓶装有1克-粒的药丸，余下一瓶装有1-1克-粒的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次；"><a href="#问题：药丸问题：有20瓶药丸，其中19瓶装有1克-粒的药丸，余下一瓶装有1-1克-粒的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次；" class="headerlink" title="问题：药丸问题：有20瓶药丸，其中19瓶装有1克&#x2F;粒的药丸，余下一瓶装有1.1克&#x2F;粒的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次；"></a>问题：药丸问题：有20瓶药丸，其中19瓶装有1克&#x2F;粒的药丸，余下一瓶装有1.1克&#x2F;粒的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次；</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，依此类推。</p>
<p>如果每粒药丸均重1克，则称得总重量为210克（1 + 2 + … + 20 &#x3D; 20 * 21 &#x2F; 2 &#x3D; 210），“多出来的”重量必定来自每粒多0.1克的药丸。</p>
<p>药瓶的编号可由算式(weight - 210) &#x2F; 0.1 得出。因此，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。</p>
</blockquote>
<h4 id="问题：药丸问题：你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量-1-只称量一次，如何判断哪个罐子的药被污染了？"><a href="#问题：药丸问题：你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量-1-只称量一次，如何判断哪个罐子的药被污染了？" class="headerlink" title="问题：药丸问题：你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量+1.只称量一次，如何判断哪个罐子的药被污染了？"></a>问题：药丸问题：你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量+1.只称量一次，如何判断哪个罐子的药被污染了？</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>从第一盒中取出一颗，第二盒中取出2 颗，第三盒中取出三颗。</p>
<p>依次类推，称其总量。减去10，多的数字就是药丸罐子序号。</p>
</blockquote>
<h3 id="问题：灯泡开关问题"><a href="#问题：灯泡开关问题" class="headerlink" title="问题：灯泡开关问题"></a>问题：灯泡开关问题</h3><h4 id="问题：在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#问题：在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="问题：在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>问题：在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4><p><strong>解题思路</strong></p>
<blockquote>
<p>打开一个开关，过10分钟后关掉开关，并打开另一个开关。进屋确认可知：</p>
<ul>
<li>亮的灯是由第二次打开的开关控制；</li>
<li>摸上去发热的不发亮的灯是由第一次打开的开关控制</li>
<li>剩下的第三盏灯是由未操作过的开关控制。</li>
</ul>
<h4 id="问题：一个圆环上有-100-个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。设计一种算法，对于任意初始状态，使所有灯泡全亮。"><a href="#问题：一个圆环上有-100-个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。设计一种算法，对于任意初始状态，使所有灯泡全亮。" class="headerlink" title="问题：一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。设计一种算法，对于任意初始状态，使所有灯泡全亮。"></a>问题：一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。设计一种算法，对于任意初始状态，使所有灯泡全亮。</h4><p>将灯泡编号 1 ~ 100</p>
<p>步骤一：将灯泡变为全亮或只剩一个为暗</p>
<p>从 1 循环到 98 ，遇到暗的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。</p>
<ul>
<li>若为亮亮，皆大欢喜，满足题目要求</li>
<li>暗亮、亮暗，达到只剩一个为暗的状态；</li>
<li>若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。</li>
</ul>
<p>步骤二：将灯泡变为全暗</p>
<p>由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。</p>
<p>步骤三：将灯泡变为全亮</p>
<p>将所有灯泡按一下，灯泡变为全亮;</p>
<p><strong>扩展:</strong></p>
<p>对于 N 个灯泡的任意初始状态 ( N &gt; 3 ) ，能否经过若干次操作使得所有灯泡全亮？</p>
<p>答案：N 个灯泡做分类讨论。</p>
<ol>
<li>N &#x3D; 3*k+1一定可以。方法与上述步骤相同，在步骤二中可以将3k个亮的灯泡分为k组。</li>
<li>N &#x3D; 3*k+2一定可以。将上述步骤一目标状态的只剩一个为暗改成<strong>剩两个相邻为暗</strong>，其余 3 * k 个灯泡分组按即可。因为，对于任意只剩一个为暗的状态，按下该灯泡左右任意一个就可以变成剩两个相邻为暗的状态！</li>
<li>N &#x3D; 3*k不一定。如果经过上述步骤一可以将灯泡变成全亮的状态则有解；否则，无解。（该结论有待证明）</li>
</ol>
<p><strong>附:</strong></p>
<p>对于这道题，以下两个状态可以相互转化</p>
<p>大家可以琢磨下，对理解这道题会有帮助。</p>
<ol>
<li>全暗 &lt;&#x3D;&gt; 全亮。全暗和全亮状态可以相互转化，方法就是将每个灯泡按一次。这样每个灯泡都被改变了 3 次状态，使得全暗变为全亮，全亮也可变为全暗。</li>
<li>剩一个为暗 &lt;&#x3D;&gt; 剩两个相邻为暗。剩一个为暗时，按下该灯泡左右任意一个，就变成了剩两个相邻为暗的状态；剩两个相邻为暗时，按下第二个暗，便可变成了剩一个为暗的状态。</li>
</ol>
</blockquote>
<h4 id="问题：一个圆环上有-100-个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。-设计一种算法，对于任意初始状态，使所有灯泡全亮。"><a href="#问题：一个圆环上有-100-个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。-设计一种算法，对于任意初始状态，使所有灯泡全亮。" class="headerlink" title="问题：一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。"></a>问题：一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。</h4><blockquote>
<p>将灯泡编号 1 ~ 100</p>
<p><strong>步骤一：将灯泡变为全亮或只剩一个为暗</strong></p>
<p>从 1 循环到 98 ，遇到暗的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。</p>
<ul>
<li>若为亮亮，皆大欢喜，满足题目要求</li>
<li>暗亮、亮暗，达到只剩一个为暗的状态；</li>
<li>若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。</li>
</ul>
<p><strong>步骤二：将灯泡变为全暗</strong></p>
<p>由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。</p>
<p><strong>步骤三：将灯泡变为全亮</strong></p>
<p>将所有灯泡按一下，灯泡变为全亮。</p>
</blockquote>
<h3 id="问题：蓝眼-疯狗-耳光问题"><a href="#问题：蓝眼-疯狗-耳光问题" class="headerlink" title="问题：蓝眼&#x2F;疯狗&#x2F;耳光问题"></a>问题：蓝眼&#x2F;疯狗&#x2F;耳光问题</h3><h4 id="问题：蓝眼睛问题"><a href="#问题：蓝眼睛问题" class="headerlink" title="问题：蓝眼睛问题"></a>问题：蓝眼睛问题</h4><blockquote>
<p>问题：有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p><strong>有多少个蓝眼睛的人就会花多少天。</strong></p>
<ul>
<li>c&#x3D;1</li>
</ul>
<p>假设岛上所有人都是聪明的，蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。</p>
<ul>
<li>c&#x3D;2</li>
</ul>
<p>两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c &#x3D; 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c &#x3D; 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。</p>
<ul>
<li>c&gt;2</li>
</ul>
<p>逐步提高c时，我们可以看出上述逻辑仍旧适用。如果c &#x3D; 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c &#x3D; 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。</p>
<p>不论c为什么值，都可以套用这个模式。所以，如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。</p>
</blockquote>
<h4 id="问题：疯狗问题"><a href="#问题：疯狗问题" class="headerlink" title="问题：疯狗问题"></a>问题：疯狗问题</h4><blockquote>
<p>问题：有50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪响，第二天没有枪响，第三天开始一阵枪响，问：一共死了几条狗？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p><strong>死了3条（第几天枪响就有几条）。</strong></p>
<p>从有一条不正常的狗开始，显然第一天将会听到一声枪响。这里的要点是你只需站在那条不正常狗的主人的角度考虑。有两条的话思路继续，只考虑有两条不正常狗的人，其余人无需考虑。通过第一天他们了解了对方的信息。第二天杀死自己的狗。换句话说每个人需要一天的时间证明自己的狗是正常的。有三条的话，同样只考虑那三个人，其中每一个人需要两天的时间证明自己的狗是正常的狗。</p>
</blockquote>
<h4 id="问题：耳光问题"><a href="#问题：耳光问题" class="headerlink" title="问题：耳光问题"></a>问题：耳光问题</h4><blockquote>
<p>问题：一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</p>
</blockquote>
<p><strong>解题思路</strong></p>
<blockquote>
<p><strong>有三个人戴黑帽。</strong></p>
<p>假设有N个人戴黑帽，当N＝1时，戴黑帽的人看见别人都为白则能肯定自己为黑。于是第一次关灯就应该有声。可以断定N＞1。对于每个戴黑帽的人来说，他能看见N-1顶黑帽，并由此假定自己为白。但等待N-1次还没有人打自己以后，每个戴黑人都能知道自己也是黑的了。所以第N次关灯就有N个人打自己。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/22/%E6%99%BA%E5%8A%9B%E9%A2%98/" data-id="clpsh979e001jxgvs4fzu9x1g" data-title="智力题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" rel="tag">智力题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2021-12-13T12:13:22.000Z" itemprop="datePublished">2021-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><blockquote>
<p>OSI：是<code>Open System Interconnect</code>的缩写，意为开放式系统互联。其各个层次的划分遵循下列原则：</p>
<ul>
<li>同一层中的各网络节点都有相同的层次结构，具有同样的功能。</li>
<li>同一节点内相邻层之间通过接口进行通信。</li>
<li>七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。</li>
<li>不同节点的同等层按照协议实现对等层之间的通信。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img12/20210104093sdfaghdjfhdnsgbdfvdg70574.png"></p>
<p><strong><font color = 'red'>为什么要分层？</font></strong></p>
<blockquote>
<p>通信协议：通信双方都必须要遵守的通信规则。</p>
<p>答：两个系统中实体间的通信是一个十分复杂的过程，为了减少协议设计和调试过程的复杂性，网络协议通常都按结构化的层次方式来进行组织，每一层完成一定功能，每一层又都建立在它的下层之上。</p>
<p>​		每一层都是在下一层的基础上，通过层间接口向上一层提供一定的服务。</p>
</blockquote>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><blockquote>
<p>物理层：<strong>解决在各种传输媒体上传输比特 <code>0 </code>和 <code>1</code> 的问题</strong>，进而给数据链路层提供透明传输比特流的服务。</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote>
<ul>
<li><strong>机械特性</strong>：指明接口所用的接线器的<code>形状</code>和<code>尺寸</code>，<code>引脚数目</code>和<code>排列</code>，<code>固定</code>和<code>锁定装置</code>。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的<code>电压的范围</code>。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的<code>电压表示何种意义</code>。</li>
<li><strong>过程特征</strong>：指明对于不同功能的各种可能<code>事件的出现顺序</code>。</li>
</ul>
</blockquote>
<h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><blockquote>
<p>传输媒体一共分为两大类：<code>引导型传输媒体</code>和<code>非引导性传输媒体</code>。</p>
<ul>
<li>引导性传输媒体有：<code>同轴电缆</code>，<code>双绞线</code>，<code>光纤</code>，<code>电力线</code>。</li>
<li>非引导性传输媒体有：<code>无线电波</code>，<code>微波</code>，<code>红外线</code>，<code>可见光</code>。</li>
</ul>
</blockquote>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><blockquote>
<p><strong>数据传输方式</strong>（data transmission mode）：<code>是数据在信道上传送所采取的方式</code>。若按<strong>数据传输的顺序</strong>可以分为<code>并行传输</code>和<code>串行传输</code>；若按<strong>数据传输的同步方式</strong>可分为<code>同步传输</code>和<code>异步传输</code>；若按<strong>数据传输的流向和时间关系</strong>可以分为<code>单工</code>、<code>半双工</code>和<code>全双工数据传输</code>。</p>
<ul>
<li><strong>并行传输</strong>：是将数据以成组的方式在两条以上的并行信道上同时传输。</li>
<li><strong>串行传输</strong>：是数据流以串行方式在一条信道上传输。</li>
<li><strong>同步传输</strong>：是以<code>固定时钟节拍</code>来发送数据信号的。</li>
<li><strong>异步传输</strong>：<code>每次传送一个字符代码</code>（5～8bit），在发送每一个字符代码的前面均加上一个“起”信号，后面均加一个止信号。</li>
<li><strong>单工数据传输</strong>：是两数据站之间<code>只能沿一个指定的方向</code>进行数据传输。</li>
<li><strong>半双工数据传输</strong>：是两数据站之间可以在两个方向上进行数据传输，但不能同时进行。</li>
<li><strong>全双工数据传输</strong>：是在两数据站之间，可以在两个方向上同时进行传输。</li>
</ul>
</blockquote>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><blockquote>
<p><strong>编码</strong>：<code>用数字信号</code>承载数字或模拟数据<br><strong>调制</strong>：<code>用模拟信号</code>承载数字或模拟数据</p>
</blockquote>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote>
<p>数据链路层：用于两个设备(同一种数据链路节点)之间进行信息传递，数据链路层以<strong>帧</strong>为单位传输和处理数据。</p>
</blockquote>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><blockquote>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ul>
</blockquote>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><blockquote>
<p><strong>封装成帧</strong>：是指数据链路层给上层交付的协议数据单元<code>添加帧头和帧尾</code>使之成为帧。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/gsahsgsnagrgsnhfdgndghnhgdmhmfh.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/vfsgbfvfsbfvdsfbgfnggdfndghnhdgndg.png"></p>
<h4 id="常见的两种帧的格式"><a href="#常见的两种帧的格式" class="headerlink" title="常见的两种帧的格式"></a>常见的两种帧的格式</h4><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/a4accb18056645ba98a9a627c1ee5392.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/c6dc3a086f314bdc96e31f048805da70.png"></p>
<blockquote>
<p>ASCII控制字符<code>SOH</code>表示<strong>帧首部</strong>开始，<code>EOT</code>表示<strong>帧的结束</strong>。</p>
</blockquote>
<blockquote>
<p><strong>接收方的数据链路层如何从物理层交付的比特流中提取出一个一个的帧呢？</strong></p>
<p>帧头和帧尾的作用之一就是<strong>帧定界</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/gbhnjmnjmujytyhtggvffdvftrgrhytujtnyb.png"></p>
</blockquote>
<blockquote>
<p>不是所有的帧都有帧定界符的，比如以太网V2的MAC帧就没有帧定界符，它是通过前导码和帧间间隔来识别一个一个的帧的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/cvbgvfcvfgbdffvdsvsbgsfvdbgfbfgbfgbdbgb.png"></p>
</blockquote>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><blockquote>
<p>透明传输：是指数据链路层对上层交付的传输数据<code>没有任何限制</code>，就好像数据链路层不存在一样。</p>
</blockquote>
<blockquote>
<p>没有透明传输，会出下面的问题：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/28774c42cfgbhnjmkmjnhbb62d4ca8b55513c.png"></p>
</blockquote>
<blockquote>
<ul>
<li><p>字节填充或字符填充——发送端的数据链路层在数据中出现控制字符<code>“SOH”</code>或<code>“EOT”</code>的前面插入一个转义字符<code>“ESC”</code>。</p>
</li>
<li><p>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</p>
</li>
<li><p>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2116e7dbdfa3frgtyhdfsgsb189c4ab3.png"></p>
</blockquote>
<blockquote>
<p>为了<strong>提高帧的传输效率</strong>，我们应当<code>使帧的数据部分的长度尽可能大些</code>。</p>
<p>每一种数据链路层协议都规定了<strong>帧的数据部分的上限长度</strong>，即：<code>最大传输单位MTU</code>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2244db1b7b314bb49edsfs5aefb5fe.png"></p>
</blockquote>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><blockquote>
<p>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：<code>1可能会变成0，而0也可能会变成1。这称为比特差错。</code></p>
<p>误码率BER(BitErrorRate)：在一段时间内，传输错误的比特占所传输比特总数的<code>比率</code>。误码率与<code>信噪比有很大的关系</code>。</p>
<p>使用<code>差错检测码</code>来检测数据在传输过程中是否产生了比特差错，是数据链路层索要解决的重要问题之一。</p>
</blockquote>
<h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><blockquote>
<p><strong>奇偶校验</strong>：在待发送的<code>数据后面添加1位奇偶校验位</code>，使得整个数据（<code>包括所添加的校验码</code>位在内）中的“1”的个数为奇数（奇校验）或偶数（偶校验）。</p>
<p><code>如果有奇数个位发生误码</code>，则奇偶性发生变化，<code>可以检查出误码</code>；</p>
<p><code>如果有偶数个位发生误码</code>，则奇偶性不发生变化，<code>不能检查出误码（漏检）</code>；</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/01b56f21795c432e8dcfsgdha543d707.png"></p>
<p><strong>漏检率比较高所以一般不使用这种检测方法。</strong></p>
</blockquote>
<h5 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h5><blockquote>
<p>（1）收发双方约定好一个<code>生成多项式G(x)</code>.<br>（2）发送方基于待发送的数据生成多项式计算出<code>差错检测码（冗余码）</code>，将其添加到带传输数据的后面<code>一起传输</code>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/f0e9af094d864f0jnbhgfhj3ceda2e23.png"></p>
<p>（3）接收方<code>通过生成多项式来计算</code>收到的数据<code>是否产生了误码</code>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2e483c9cd9784c8fgbhn36efd3c26db0c.png"></p>
</blockquote>
<h3 id="三种可靠传输的实现机制"><a href="#三种可靠传输的实现机制" class="headerlink" title="三种可靠传输的实现机制"></a>三种可靠传输的实现机制</h3><blockquote>
<p>三种可靠传输的实现机制分别是：<code>停止-等待协议SW</code>，<code>回退N帧协议GBN</code>，<code>选择重传协议SR</code></p>
</blockquote>
<h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><blockquote>
<p><strong>停止等待协议的信道利用率比较低</strong></p>
</blockquote>
<blockquote>
<ol>
<li>首先，每次<strong>发送方</strong>都<code>只发一个数据分组</code>，<strong>接收方</strong>对数据分组进行差错检测，<code>检验是否有误码</code>。</li>
</ol>
<ul>
<li>如果<strong>没有误码</strong>，那么给发送方<code>发送ACK确认分组</code>；</li>
<li>如果<strong>有误码</strong>，则丢弃分组，并给发送方<code>发送NAK否认分组</code>；</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/ffa071d868ea464e8e7fd27bb8cxzvf8172b.png"></p>
<ol start="2">
<li>但其实，数据分组在传输过程中并不会那么一帆风顺，数据分组有可能在半路上遇到一个已经满了的路由器等情况，此时路由器会毫不犹豫地丢失该分组，如此便会产生数据分组被丢失，发送方等不到接收方的ACK或者NAK。<br> 所以，我们需要给每次的数据分组的传输提供一个超时计时器，若到了超时计时器所设置的重传时间，而发送方仍收不到接收方的ACK或NAK，则重传原来的数据分组。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/80c8a91f0dsfadfb168d8085681a315.png"></p>
<ol start="3">
<li>在传输的过程中接收方的确认可能会丢失或者迟到。这样就会导致发送方误判重新传一个重复的数据，而接受方也无法判断这个数据是不是接受过。或者来了一个重复的确认不能判断这个ACK是哪个消息的。<br> 所以我们需要给发送方发送的消息和接受方发送的ACK进行编号使他们相互对应来避免这些问题的发生。</li>
</ol>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/3bd6cdsvdf4b76928bd58d55ab1b73.png"></p>
</blockquote>
<h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><blockquote>
<p>停止等待协议在传输中都是单个信息进行传输的，其实我们可以一次传输多条信息，这样就可以解决信道利用率低的问题了。</p>
</blockquote>
<blockquote>
<p>我们在发送方和接收方分别定义设置一个发送窗口与接收窗口。</p>
<p><strong>对于发送方：</strong></p>
<p>（1）发送窗口尺寸<code>T</code>的取值范围是：<code>1 &lt; T&lt;= 2^n − 1</code></p>
<p>接收方无法辨析新旧数据分组。<br>（2）发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去；</p>
<p>（3）发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；</p>
<p>（4）发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定。</p>
<p>（5）发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内的分且已发送的数据分组也必须重传，这就是回退N帧协议。</p>
<p><strong>对于接收方：</strong></p>
<p>（1）接收方的的接收窗口取值R为1，因此接收方只能按序接收分组。</p>
<p>（2）接收方只接受序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，为此同时给发送方发回相应的确认分组，为了减少开销接收方不一定要对收到的数据分组逐个发送确认。</p>
<ul>
<li>而是可以在连续收到好几个按序到达且无误码的数据分组后，在针对最后一个数据分组发回确认分组，这也称为累计确认。</li>
<li>或者可以在自己有数据分组发送时才对之前按序接收且无误码的数据分组进行捎带确认。</li>
</ul>
<p>（3）接收方收到未按需到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认。</p>
</blockquote>
<h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><blockquote>
<p>回退N帧协议的接收窗口尺寸R<code>只能等于1</code>，因此<code>接收方只能按序接收正确到达的数据分组</code>。</p>
<p>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管他们无乱序和误码）。这势必会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</p>
<p>为了进一步提高性能，可以设法只重传出现误码的数据分组。因此，接收窗口的尺寸R不应再等于1（应该大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收起在一并送交上层，这就是选择重传协议。<br><strong>注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再使用累计确认，而需要对每一个正确接收到的数据分组进行逐一确认。</strong></p>
<p><strong>对于发送方：</strong></p>
<p>（1）发送窗口尺寸<code>T</code>的取值范围是：<code>1 &lt; T&lt;= 2^n − 1</code></p>
<p>接收方无法辨析新旧数据分组。<br>（2）发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去；</p>
<p>（3）发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动；</p>
<p><strong>对于接收方：</strong></p>
<p>（1）接收窗口尺寸R的取值范围是：<code>1 &lt; R &lt; = T</code></p>
<p>（2）接收方<code>可接受未按序到达但没有误码并且序号落在接收窗口内的数据分组</code>。</p>
<ul>
<li>为了使发送方仅重传出现差错的分组，接收方不能在采用累计确认，而需要<code>对正确接收到的分组逐一确认!</code></li>
</ul>
<p>（3）接收方只有在<code>按序接收到数据分组之后</code>，接收窗口<code>才能向前相应滑动</code>。</p>
</blockquote>
<h3 id="点对点PPP协议"><a href="#点对点PPP协议" class="headerlink" title="点对点PPP协议"></a>点对点PPP协议</h3><blockquote>
<p><strong>点对点协议PPP</strong>是目前<code>使用最广泛的</code>点对点数据链路层协议。</p>
</blockquote>
<blockquote>
<p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p>
<p>（1）对各种协议数据报的<code>封装方法</code>（封装成帧）；<br>（2）<code>链路控制协议LCP</code>：用于建立，配置以及测试数据链路的连接；<br>（3）<code>一层网络控制协议NCPs</code>：其中每一个协议支持不同的网络层协议；</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2020cdfddfsgrdthyjdfdf522631.png"></p>
<ul>
<li><p>PPP帧的首部和尾部分别为4个和2个字段</p>
</li>
<li><p>首部和尾部都有标志字段F（flag），规定为0x7E，表示一帧的开始或结束，也就是帧定界符，连续两帧之间，只需要一个标志字段（帧定界符），如果连续出现两个标志字段，认为是空帧，直接丢弃</p>
</li>
<li><p>首部的地址字段<code>A</code>规定为<code>0xFF</code>，控制字段<code>C</code>规定为<code>0x03</code>，这两个字段目前就是固定的，不会有其它值</p>
</li>
<li><p>首部的协议字段是<code>2</code>字节</p>
<ul>
<li><code>0x0021</code>：信息字段是<code>IP</code>数据报</li>
<li><code>0xC021</code>：信息字段是<code>PPP</code>链路控制协议<code>LCP</code>的数据</li>
<li><code>0x8021</code>：信息字段是网络层的控制数据</li>
</ul>
</li>
<li><p>信息字段的长度可变，但是不超过<code>1500</code>字节，<code>MTU</code>规定了最大长度</p>
</li>
<li><p>尾部的第一个字段为<code>2</code>个字节，是使用<code>CRC</code>的帧检验序列<code>FCS</code></p>
</li>
</ul>
<p><strong>字节填充</strong></p>
<ul>
<li>当信息字段出现了和标志字段一样的值时，就需要采取措施，使接收端正确接收信息，而不是当错误帧丢弃</li>
<li>当<code>PPP</code>使用异步传输时，转义符定义为<code>0x7D</code>，并使用字节填充，<code>RFC1662</code>规定了如下填充方法<ul>
<li>把信息字段中的<code>0x7E</code>转换成2字节序列（<code>0x7D</code>，<code>0x5E</code>）</li>
<li>把信息字段中的<code>0x7D</code>转换成2字节序列（<code>0x7D</code>，<code>0x5D</code>）</li>
<li>若信息字段中出现<code>ASCII</code>码控制字符，则在该字符前加<code>0x7D</code>，同时改变该字符的编码，例如出现<code>0x03</code>，则转换成（<code>0x7D</code>，<code>0x23</code>），改变编码就是在本身基础上加<code>0x20</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h3><h4 id="MAC层的硬件地址"><a href="#MAC层的硬件地址" class="headerlink" title="MAC层的硬件地址"></a>MAC层的硬件地址</h4><blockquote>
<p>在局域网中，硬件地址又称为物理地址或MAC地址，地址就是识别某个系统的重要标识符</p>
<p>（1）<code>MAC</code>地址<strong>是以太网的MAC子层所使用的地址（<code>数据链路层</code>）；<br>（2）</strong><code>IP</code>地址<strong>是TCP&#x2F;IP体系结构<code>网际层</code>所使用的地址；<br>（3）</strong><code>ARP</code>协议属于TCP&#x2F;IP体系结构的<code>网际层</code>，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；</p>
</blockquote>
<h5 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202009dfgbfjfgjfhdg14172.png"></p>
<h3 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h3><blockquote>
<p><code>ARP</code> 地址解析协议：<strong>实现由<code> IP</code> 地址得到 <code>MAC</code> 地址</strong></p>
</blockquote>
<p><strong>示例：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2cec8dbf0cdsafdabe65bf947.png"></p>
<blockquote>
<p>​		主机<code>B</code>要向主机<code>C</code>发送数据包，但是主机<code>B</code>只知道主机<code>C</code>的<code>IP</code>地址，不知道<code>C</code>的<code>MAC</code>地址，所以主机<code>B</code>在数据链路层封装<code>MAC</code>帧时，无法填写目的<code>MAC</code>地址。</p>
<p>​		每台主机都有<code>arp</code>缓存表，<code>arp</code>缓存表中记录有<code>ip</code>地址和<code>mac</code>地址的对应关系，<code>arp</code>缓存表里面记录着之前和该主机通信的主机信息，例如，<code>ip</code>地址，<code>mac</code>地址。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/c24eaa37c02b4a1b98sdfasg1c754f860.png"></p>
<p>​		主机<code>B</code>和主机<code>C</code>通信时会首先查看<code>arp</code>缓存表，在表里查找主机<code>C</code>的<code>ip</code>地址和所对应的<code>mac</code>地址。但是主机<code>B</code>的<code>arp</code>缓存表里面并没有主机<code>C</code>的<code>ip</code>地址和<code>mac</code>地址，因此，主机<code>B</code>需要发送<code>arp</code>请求报文来获取主机<code>C</code>的<code>mac</code>地址。它会发送如下<code>arp</code>请求报文（因为不知道目的<code>mac</code>地址，所以会进行广播）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/94b827c51034427b911d72sss0e1301496a.png"></p>
<p>​		<code>arp</code>请求报文被封装在帧中发送，目的地址为广播地址，主机<code>B</code>发送封装有<code>arp</code>请求报文的广播帧，总线上的所有设备都能收到广播，</p>
<p>​		当主机<code>A</code>收到广播以后，网卡将帧交付上层处理，上层的<code>arp</code>进程解析<code>arp</code>请求报文，发现所询问的<code>ip</code>地址不是自己的<code>ip</code>地址，主机<code>A</code>就会将该帧丢弃不会响应。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/f604188d10c24c3983weeb8a98a2e78dbea.png"></p>
<p>​		当主机<code>C</code>收到广播以后，网卡将帧交付上层处理，上层的<code>arp</code>进程解析<code>arp</code>请求报文，发现所询问的<code>ip</code>地址是自己的<code>ip</code>地址，需要进行响应，于是主机<code>C</code>会首先将<code>B</code>的<code>ip</code>地址和<code>mac</code>地址记录到自己的<code>arp</code>缓存表里面，然后给<code>B</code>发送<code>arp</code>响应，告诉主机<code>B</code>自己的<code>mac</code>地址</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/sss7934296f49868107bc322720a76f.png"></p>
<p>​		主机<code>C</code>给主机<code>B</code>发送<code>arp</code>响应报文（因为此时主机<code>C</code>知道主机<code>B</code>的<code>mac</code>地址，所以<code>arp</code>响应报文会进行单播）主机<code>A</code>收到单播以后发现<code>mac</code>地址与自己不匹配，网卡会直接丢弃该帧，主机<code>B</code>发现<code>mac</code>地址匹配，网卡将帧交付上层处理，上层的<code>arp</code>进程会解析<code>arp</code>报文，然后将主机<code>C</code>的<code>ip</code>地址与<code>mac</code>地址记录到自己的<code>arp</code>缓存表中</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/6967598ad8b44asss9b8780196fbcbf69a9.png"></p>
<p>​		然后主机<code>B</code>就可以给主机<code>C</code>发送数据包了。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/ce6ac466649b4395bdsssa7583540d.png"></p>
</blockquote>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><blockquote>
<p>网络层：负责在不同的网络之间(基于数据包的IP地址)<code>尽力转发数据包，不负责丢包重传和接收顺序</code>。</p>
</blockquote>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><blockquote>
<p>IP 协议是一个无连接的服务，负责在源地址和目的地址之间传送数据报，其主要功能就是把数据报在互连的网络上传送，将数据报在一个个模块间通过路由处理网络地址传送到目的地址。</p>
<p>（1）寻址<br>在不同网络中必须通过三层地址进行寻址。常用的IP网络中运行的三层协议就是 IP 协议，对应的三层地址就是 IP 地址。</p>
<p>（2） 数据报的封装<br>从传输层过来的数据段需要经过IP协议的重封装，而从数据链路层过来的数据帧就需要进行解封装。在IP网络中封装后形成的是IP数据报，IP封装的目的就是标识此IP数据报发送节点和接受节点的IP地址和控制信息。</p>
<p>（3）分段与重组<br>不同网络上的链路可以传输的最大报文大小是不同的，这就是我们通常说的MTU（最大传输单元）。尺寸较大的数据报在MTU值较小的网络链路传输需要将数据报分段依次传输，对应的接收方就需要把这些接收到的拆分的分段组合起来，还原成原来的数据报。</p>
</blockquote>
<h4 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202107071948cdfsgdhfhmk46480.png"></p>
<ul>
<li>版本：指定IP数据报中使用的IP协议版本，占4位。IPv4对应值为4（0100）</li>
<li>首部长度：指示IP数据报头部的总长度，占4位。IP数据报头部的总长度以4字节为单位（即4字节的整数倍）</li>
<li>区分服务：用于表示数据报的优先级和服务类型，占8位。包括一个3位长度的优先级，4位长度的标志位，最高位未用</li>
<li>总长度：标识整个IP数据报的总长度，包括报头和数据部分，占16位，由此可知IPv4的最大长度为65535（64KB）</li>
<li>标识：用于表示IP数据报的标识符，占16位，每个IP数据报有一个唯一的标识（不是序号）。当数据报分段时，这个标识的值就被复制到所有分段的标识字段中，相同的标识字段值使分段后的数据报分段最后能正确地重组成为原来的数据报。</li>
<li>标志：指出该IP数据报后面是否还有分段，为分段标志，占3位，仅最低位有意义</li>
<li>片偏移：指出该分段在数据报中的相对位置。相对于用户数据字段的起点，该字段从何处开始，占13位</li>
<li>生存时间：标识IP数据报在网络中传输的有效期，以秒来计数，占8位。现在通常认为这个数值是指数据报允许经过的路由器数，当值为0时，就丢弃这个数据报。设定生存时间是为了防止数据报在网络中无限制地循环转发。</li>
<li>协议：用来标识此IP数据报在传输层所采用的协议类型（如TCP、UDP或ICMP等），以便使目的主机的IP层知道应将数据部分上交给哪个处理过程，占8位</li>
<li>首部校验和：用来检验IP数据报的包头部分（不含“数据”部分）在传输到接收端后是否发生了变化，占16位。因为数据报每经过一个路由器，路由器都要重新计算一下报头校验和</li>
<li>源地址&#x2F;目的地址：分别表示该IP数据报发送者和接收者的IP地址，各站32位</li>
<li>可变部分：用来支持各种选项，提供扩展余地，可用来支持排错、测量以及安全等措施。后面的填充字段就是为了保证IP数据报的报头是32位的整数倍。</li>
</ul>
</blockquote>
<h4 id="IPv4数据报的封装与解封转"><a href="#IPv4数据报的封装与解封转" class="headerlink" title="IPv4数据报的封装与解封转"></a>IPv4数据报的封装与解封转</h4><blockquote>
<ul>
<li>发送端网络层生成的IP数据报还要继续向下传输，到达数据链路层就要封装成数据帧了。IP数据报的“帧封装”只需把来自网络层的整个 IP 数据报（报头和数据部分）当做数据链路层帧的数据部分，然后在前面加上与数据链路层对应的协议头即可。</li>
<li>在以太局域网中，由于数据链路层分成了LLC子层和MAC子层这两层，所以来自网络层的IP数据报在到达数据链路层后先要经过LLC子层和MAC子层的协议头封装，最终形成数据链路层的以太网MAC帧。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202107041dfgbfhgjmhgf53147334.png"></p>
<p>​		<code>IP 数据报无论经过了多少个网络，整个数据报内容都不会变，包括报头部分的源和目的地址信息。变化的只是在不同网络数据链路上传输的帧头信息</code>。</p>
</blockquote>
<h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><h5 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h5><blockquote>
<p>​		每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号，host-id，它标志该主机（或路由器）。</p>
<ul>
<li>网络号：保证相互连接的两个网段具有不同的标识, 简单来说就是标识网络 (网段:一段范围内的IP, 具体是网络号相同的所有IP)</li>
<li>主机号：同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号, 简单来说就是标识同一网段下的不同主机.</li>
<li>子网：IP 地址是以网络号和主机号来表示网络上的主机的, 只有在一个网络号下的计算机之间才能“直接”互通, 不同网络号的计算机要通过网关（Gateway）才能互通. 但这样的划分在大多数情况下显得并不十分灵活. 为此IP网络还允许划分成更小的网络, 称为子网（Subnet）.</li>
</ul>
</blockquote>
<p>通过合理的设置网络号和主机号，就可以保证在相互连接的网络中，每台主机的IP地址都不同。那么如何自动管理子网内的IP：</p>
<blockquote>
<p><code>DHCP 动态主机配置协议</code> ：首先,这是一个应用层协议，<code>可以自动给子网内新增的主机节点分配IP地址</code>. 。一般的路由器都带有DHCP功能， 因此路由器也可以看做是一个DHCP服务器。</p>
</blockquote>
<h5 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h5><blockquote>
<p> IP 地址分为三类：A类、B类、C类、D类、E类</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210704154FDSGFHGJGFJFKFH234313.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/FDGSHGNHDGNGNGBCVBVBDGNDGHNDGHN.png"></p>
</blockquote>
<h5 id="特殊的几个地址"><a href="#特殊的几个地址" class="headerlink" title="特殊的几个地址"></a>特殊的几个地址</h5><blockquote>
<ul>
<li>IP地址中的主机号全为0，就成了网络号，代表这个局域网</li>
<li>将IP地址中的主机号的二进制全部设为1，就成为了广播地址，用于给同一个链路中相互连接的所有主机发送数据包(此时目的地址当然就被设为了广播地址)</li>
<li>127.0.0.1. 它代表设备的本地虚拟接口， 所以默认被看作是永远不会宕掉的接口。所以通常在安装物理网卡前就可以ping通这个本地回环地址。 一般都会用来检查本地网络协议、基本数据接口等是否正常的。</li>
<li>0.0.0.0 标识本机上的所有网卡。用与TCP服务端程序的绑定地址，相当于监听本机的所有网卡。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202107sdfggefghgfhggh06170238713.png"></p>
</blockquote>
<h5 id="IP-地址的特点"><a href="#IP-地址的特点" class="headerlink" title="IP 地址的特点"></a>IP 地址的特点</h5><blockquote>
<p>① IP 地址是一种分等级的地址结构。分两个等级的好处是：</p>
<blockquote>
<p>● IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。<br>● 路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</p>
</blockquote>
<p>② 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。</p>
<blockquote>
<p>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多接口主机(multihomed host)。<br>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。</p>
</blockquote>
<p>③ 用转发器或网桥连接起来的若干个局域网仍为一个网络</p>
<blockquote>
<p>因此这些局域网都具有同样的网络号 net-id。</p>
</blockquote>
<p>④ 所有网络都是平等的。</p>
<blockquote>
<p>所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</p>
</blockquote>
<p>⑤ 路由器总是具有两个或两个以上的 IP 地址。</p>
<blockquote>
<p>路由器的每一个接口都有一个不同网络号的 IP 地址。</p>
</blockquote>
<p>⑥ 两个路由器直接相连的接口处，可指明也可不指明 IP 地址。</p>
<blockquote>
<p> 如指明 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。现在常不指明 IP 地址。</p>
</blockquote>
</blockquote>
<h5 id="私有IP地址和公网IP地址"><a href="#私有IP地址和公网IP地址" class="headerlink" title="私有IP地址和公网IP地址"></a>私有IP地址和公网IP地址</h5><blockquote>
<p>私有IP地址 ：在局域网中使用的IP；<br>公网IP地址 ：在互联网中使用的地址。</p>
</blockquote>
<h5 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h5><h6 id="IP-地址与硬件地址的区别"><a href="#IP-地址与硬件地址的区别" class="headerlink" title="IP 地址与硬件地址的区别"></a>IP 地址与硬件地址的区别</h6><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210707101fsgdhnfhngfbvbdgnhm75936.png"></p>
<p>① IP 地址</p>
<blockquote>
<p>● IP 地址是一种<code>逻辑地址</code>。<br>● IP 地址称为逻辑地址，是因为IP地址是用软件实现的。<br>● IP 地址是<code>网络层及其以上各层(包括运输层、应用层等)使用的地址</code>。<br>● IP 地址<code>放在 IP 数据报的首部</code>。</p>
</blockquote>
<p>② 硬件地址</p>
<blockquote>
<p>● 硬件地址是一种<code>物理地址</code>。<br>● 硬件地址称为物理地址，是因为硬件地址是用硬件实现的。<br>● 硬件地址是<code>数据链路层和物理层使用的地址</code>。<br>● 硬件地址<code>放在 MAC 帧的首部</code>。</p>
</blockquote>
</blockquote>
<h6 id="数据发送中的-IP-地址与硬件地址"><a href="#数据发送中的-IP-地址与硬件地址" class="headerlink" title="数据发送中的 IP 地址与硬件地址"></a>数据发送中的 IP 地址与硬件地址</h6><blockquote>
<p>① 发送数据</p>
<blockquote>
<p>● 在发送数据时，数据从高层下到低层，然后才到通信链路上传输。<br>● 使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。<br>● MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部。<br>● 当 IP 数据报放入到数据链路层的 MAC 帧中以后，整个 IP 数据报就成了 MAC 帧的数据部分，因而在数据链路层看不见 IP 数据报的 IP 地址。</p>
</blockquote>
<p>② 接收数据</p>
<blockquote>
<p>● 在接收数据时，数据从低层上到高层。<br>● 连接在通信链路上的设备(主机或路由器)在接收 MAC 帧时，其根据是 MAC 帧首部的硬件地址。<br>● 在数据链路层看不见隐藏在 MAC 帧的数据中的 IP 地址。<br>● 只有在剥去 MAC 帧的首部和尾部后，把 MAC 帧的数据部分上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。</p>
</blockquote>
</blockquote>
<h6 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h6><blockquote>
<p>三个局域网用两个路由器 R1 和 R2 互连起来，现在主机 H1 要和主机 H2 通信。<br>主机 H1 的IP地址是 IP1，硬件地址是 HA1；主机 H2 的 IP 地址是 IP2，硬件地址是 HA2。路由器 R1 由于同时连接到两个局域网上，因此它有两个硬件地址 HA3 和 HA4。路由器 R2 由于同时连接到两个局域网上，因此它有两个硬件地址 HA5 和 HA6。<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021070710sdfgfcdsvsgbdhgn3603765.png"></p>
<p>通信的路径是：H1 —&gt; 经过 R1 转发 —&gt; 再经过 R2 转发 —&gt; H2</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021070710362svfgfdhndsfgsdfg4.png"></p>
</blockquote>
<h3 id="路由转发分组"><a href="#路由转发分组" class="headerlink" title="路由转发分组"></a>路由转发分组</h3><blockquote>
<p><code>分组转发是指在互联网络中路由器转发IP分组的物理传输过程与数据报转发机制</code>。根据分组的目的IP地址与源IP地址是否属于同一个子网可分为直接转发和间接转发。</p>
</blockquote>
<blockquote>
<p><code>路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点</code>。</p>
<p><code>在路由表中，对每一条路由最主要的是以下两个信息：(目的网络地址，下一跳地址)</code>。</p>
</blockquote>
<blockquote>
<p>假设：有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于庞大。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目（每一行对应于一个网络），这样就可使路由表大大简化。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210707dsfgfhdsfdsgdhg0523843.png"></p>
<p>根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p>
<p>● IP 数据报<code>最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）</code>。<br>● <code>只有到达最后一个路由器时，才试图向目的主机进行直接交付</code>。</p>
</blockquote>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><blockquote>
<p>①　当 IP数据包到达路由器,，路由器会先查看目的地址 ；<br>②　通过判断目的IP，判定目的主机的所在网络是否与自己相连 ；<br>③　若相连， 则直接发送给目标主机；<br>④　若不相连，则发送给下一个路由器(这个过程中源IP地址会被替换为路由器的WAN口地址)；<br>⑤　重复这个过程, 一直到达目的IP(或者TTL为0时被丢弃)；</p>
</blockquote>
<h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><blockquote>
<p>从两级 IP 地址到三级 IP 地。</p>
<p>① 划分子网纯属一个单位内部的事情，对外部网络透明，单位<code>对外仍然表现为没有划分子网的网络</code></p>
<p>② <code>从主机号借用若干个位作为子网号 subnet-id</code>，而主机号 host-id 也就相应减少了若干个位。于是两级 IP 地址变成了三级 IP 地址：网络号、子网号和主机号。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210706181cdvbgfnhgmjgnfbdg713948.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210706181cdsfdgthydtdsgfbhg724463.png"></p>
<p>③ 凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。</p>
<p>④ 最后就将 IP 数据报直接交付目的主机。</p>
</blockquote>
<h4 id="划分子网后变成三级结构的优点"><a href="#划分子网后变成三级结构的优点" class="headerlink" title="划分子网后变成三级结构的优点"></a>划分子网后变成三级结构的优点</h4><blockquote>
<p>● 减少了 IP 地址的浪费<br>● 使网络的组织更加灵活<br>● 更便于维护和管理</p>
</blockquote>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><h5 id="子网掩码-1"><a href="#子网掩码-1" class="headerlink" title="子网掩码"></a>子网掩码</h5><blockquote>
<p>● 子网掩码是一个应用于 TCP&#x2F;IP 网络的32位二进制值，每节 8 位，必须结合IP地址对应使用。 （常见的 255.255.255.0 等）</p>
<p>● 子网掩码 32 位都与 IP 地址 32 位对应，如果某位是网络地址（网络号部分和子网号部分）则对应的位全为“1”，如果是主机号部分则对应的位全为“0”。(11111111.11111111.11111111.0)</p>
<p>● 子网掩码(subnet masking)的功能是告知主机或路由设备，地址的哪一部分是网络号，包括子网的网络号部分，哪一部分是主机号部分。</p>
<p>● 子网掩码可以分离出 IP 地址中的网络地址和主机地址，用于判断该 IP 地址是在局域网上，还是在广域网上。</p>
<p>● 子网掩码一般用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而 IP 浪费。</p>
</blockquote>
<h5 id="子网掩码使用原因"><a href="#子网掩码使用原因" class="headerlink" title="子网掩码使用原因"></a>子网掩码使用原因</h5><blockquote>
<p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分，因为 IP 地址本身及数据报的首部没有包含任何关于有关子网划分的信息。<code>使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分</code>。</p>
</blockquote>
<h5 id="子网掩码是一个重要属性"><a href="#子网掩码是一个重要属性" class="headerlink" title="子网掩码是一个重要属性"></a>子网掩码是一个重要属性</h5><blockquote>
<p>● 子网掩码是一个网络或一个子网的重要属性。</p>
<p>● 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</p>
<p>● 路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</p>
<p>● 若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p>
</blockquote>
<h5 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h5><blockquote>
<p><code>子网掩码可以分离出 IP 地址中的网络地址和主机地址。当两台计算机要通讯，首先要判断是否处于同一个广播域（局域网）内，即网络地址（网络号）是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地</code>。</p>
</blockquote>
<h5 id="默认子网掩码"><a href="#默认子网掩码" class="headerlink" title="默认子网掩码"></a>默认子网掩码</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210706191dsfghdjyhtgrvfbgnhgfbdsv006470.png"></p>
<h5 id="子网掩码的使用"><a href="#子网掩码的使用" class="headerlink" title="子网掩码的使用"></a>子网掩码的使用</h5><blockquote>
<p>● 网络号：IP地址和子网掩码进行与运算得到网络号。</p>
<p>● 子网号：子网掩码 32 位都与 IP 地址 32 位对应，如果某位是网络地址（网络号部分和子网号部分）则对应的位全为“1”，如果是主机号部分则对应的位全为“0”。将子网掩码中“1”的位数减去该类的默认子网掩码的“1”的位数即为子网号位数。</p>
<p>● 主机号：子网掩码取反再和 IP 地址做与运算得到主机号。</p>
</blockquote>
<h3 id="国际控制报文协议-ICMP"><a href="#国际控制报文协议-ICMP" class="headerlink" title="国际控制报文协议 ICMP"></a>国际控制报文协议 ICMP</h3><blockquote>
<p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p>
<ul>
<li>ICMP 是互联网的标准协议。</li>
<li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</li>
<li>ICMP 报文作为 IP 数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。</li>
<li>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</li>
<li>ICMP只能搭配IPv4工作，如果是IPv6，需要使用ICMPv6</li>
</ul>
</blockquote>
<h4 id="ICMP协议的功能"><a href="#ICMP协议的功能" class="headerlink" title="ICMP协议的功能"></a>ICMP协议的功能</h4><blockquote>
<p>● <code>确认IP包是否成功到达目标地址</code><br>● <code>通知在发送过程中 IP 包被丢弃的原因</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210707190dfbgnhmjhdnbdgnfhm726822.png"></p>
<p>​		接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。一般来说，主机只能接收ICMP重定向报文，路由器只能发送ICMP重定向报文。</p>
</blockquote>
<h4 id="ICMP-的报文格式"><a href="#ICMP-的报文格式" class="headerlink" title="ICMP 的报文格式"></a>ICMP 的报文格式</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021070718dfdgfhgjhkfjg5324681.png"></p>
<p>（1）8 位类型字段用于区分报文类型。它将ICMP报文分为两大类：<br>        ● 差错报文：主要用于回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）<br>        ● 查询报文：用于查询网络信息，比如ping命令就是使用ICMP报文查看目标是否可到达（类型值为8）的</p>
<p>（2）有的类型通过8位代码字段来进一步细分不同的条件：<br>        比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向</p>
<p>（3）ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行CRC校验（循环冗余校验），以校验报文是否损坏</p>
</blockquote>
<h4 id="ICMP-报文的种类"><a href="#ICMP-报文的种类" class="headerlink" title="ICMP 报文的种类"></a>ICMP 报文的种类</h4><blockquote>
<p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p>
<p>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。</p>
</blockquote>
<blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021070719cdsvdbffgfndhfjnfgb0335971.png"></p>
<p>​		把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段，再加上相应的 ICMP差错报告的前8个字节，就构成了ICMP差错报告报文。</p>
<p>​		ICMP报文包含在IP数据报中，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。</p>
</blockquote>
<h4 id="ICMP-差错报告报文种类"><a href="#ICMP-差错报告报文种类" class="headerlink" title="ICMP 差错报告报文种类"></a>ICMP 差错报告报文种类</h4><blockquote>
<p>① 终点不可达</p>
<blockquote>
<p>当路由器发送的数据报不能发送到指定目的地时，或者说当路由器不能够给数据报找到路由或主机不能够交付数据报时，就丢弃这个数据报，然后向发送数据报的源主机设备发回一个终点不可达数据报文。</p>
</blockquote>
<p>② 端口不可达</p>
<blockquote>
<p>当目标系统收到一个ip数据报的某个服务请求时，如果本地没有此服务，那么会向源头返回ICMP端口不可达信息。   <br>常见的端口不可达有，R1向R3发起一个ftp的传输请求，从R3传输一个文件到R1，由于R3设备没有开启ftp服务的69端口，因此R1在请求R3时会收到R3回复的一个ICMP端口不可达的差错报文。</p>
</blockquote>
<p>③ 超时</p>
<blockquote>
<p>ICMP差错报告报文主要在以下几种情况中，会发送ICMP超时报文：<br> ●  当路由器接收到的数据报的生命周期字段值为0时，路由器会把该数据报丢弃掉，并向源主机发回一个 ICMP 超时报文。<br> ●  当目标主机在规定时间内没有收到所有的数据分片时，会把已经收到的所有数据分片丢弃，并向源主机发回一个 ICMP 超时报文。在超时报文中，代码 0 只能给路由器使用，表示生存周期字段值为 0，代码 1 只能给目的主机使用，它表示在规定的时间内，目的主机没有收到所有的数据分片。</p>
</blockquote>
<p>④ 参数问题</p>
<blockquote>
<p> 当路由器或目的主机收到的数据报的首部字段中有的字段的值不正确时，就会丢弃该数据报，并向源点回送参数问题报文。</p>
</blockquote>
<p>⑤ 改变路由（重定向）</p>
<blockquote>
<p>路由器吧改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p>
</blockquote>
</blockquote>
<h4 id="ICMP-询问报文有两种"><a href="#ICMP-询问报文有两种" class="headerlink" title="ICMP 询问报文有两种"></a>ICMP 询问报文有两种</h4><blockquote>
<p>● 回送请求和回答报文<br>● 时间戳请求和回答报文</p>
</blockquote>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><blockquote>
<p>作用：运输层为它上面的应用层提供通信服务。</p>
<p>传输层两大重要的功能：<strong>复用</strong> 和 <strong>分用</strong></p>
<ul>
<li>复用：在发送端，多个应用进程公用一个传输层；</li>
<li>分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。</li>
</ul>
<p>传输层和网络层的区别：</p>
<ul>
<li>网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ul>
</blockquote>
<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><blockquote>
<ul>
<li><strong>面向无连接</strong>（目的是减少开销和发送时延）：通信前不需要建立连接，通信结束也无需释放连接，即 UDP 客户与服务器不必存在长期的关系。不需要像 TCP 一样在发送数据前进行三次握手，想发就直接发了，<code>它只是数据的搬运工，不会对数据进行任何拆分和拼接操作</code>。具体来说，就是在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头，标识一下是 UDP 协议，然后就传递给网络层了；在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</li>
<li><strong>尽最大努力交付</strong>：它是尽力而为交付，不能确保每一个数据报都送达</li>
<li><strong>不可靠性</strong>：由于 “尽最大努力交付” 的，所以不保证每个数据报都到达目的地，也不保证各个数据报的先后顺序跨网络保持不变，也不保证每个数据报只到达一次</li>
<li><strong>面向报文</strong>：所谓面向报文就是指UDP数据传输的单位是报文，且不会对数据作任何拆分和拼接操作。</li>
<li><strong>没有拥塞控制</strong>：当网络出现堵塞不会使源主机的发送速率降低，这对实时视频会议比较重要，即允许在网络发生堵塞时丢失一些数据，但不允许数据有太大时延</li>
<li><strong>支持一对一，一对多，多对一，多对多的交互通信</strong>（单播、多播、广播），而TCP只支持一对一通信</li>
<li><strong>首部开销小</strong>（只有 8 个字节），而TCP头部至少20字节</li>
</ul>
</blockquote>
<h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><blockquote>
<p>用户数据报 UDP 有两个部分组成：首部 + 数据部分。首部部分很简单，只有 8 个字节（如图 5-5），由四个字段组成，每个字段的长度都是两个字节。各字段含义如下：</p>
<ul>
<li>源端口：源端口号。在需要对方回信时选用。不需要使用时可用 0 填充。</li>
<li>目的端口：目的端口号。这在终点交付报文时必须使用。</li>
<li>长度：UDP 用户数据报的长度，其最小值是 8（即仅有首部部分），单位：字节。</li>
<li>校验和：检测 UDP 用户数据报在传输过程中是否出错。有错就丢弃。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202108311fegtrhdyrfuhht02952222.png"></p>
</blockquote>
<h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h3><blockquote>
<p> TCP（Transmission Control Protocol）是 面向连接 的，提供可靠交付，有 流量控制，拥塞控制，提供 全双工通信，面向 字节流，每一条 TCP 连接只能是 点对点 的（一对一）的传输层通信协议。TCP将用户数据打包成报文段，它发送后会启动一个定时器。TCP 既可以使用 IPv4 也可以使用 IPv6。</p>
<ul>
<li><strong>面向连接的</strong>：通信前需要建立连接（三次握手），通信结束也需要释放连接（四次挥手）</li>
<li><strong>提供可靠交付</strong>：保证数据无重复、无丢失、无错误、与发送端顺序一致。当使用 TCP 向另一端发送数据时，它要求对端返回一个确认，如果没有收到确认，TCP 会自动重传数据并等待更长时间，数次重传失败后，TCP 才放弃</li>
<li><strong>面向字节流</strong>：把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块</li>
<li><strong>提供流量控制</strong>： TCP 会告诉对端它能接收多少字节的数据，称作“通知窗口”，该窗口任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区</li>
<li><strong>提供拥塞控制</strong>：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）。</li>
<li><strong>点对点通信（单播）</strong>：TCP 只能提供点到点的通信，而 UDP 可以任意方式的通信</li>
<li><strong>提供全双工通信</strong>：全双工通信指的是 TCP 的两端既可以作为发送端，也可以作为接收端，且两个方向可以同时进行发送和接收，就好比双行道（UDP 其实也可以是全双工的）</li>
</ul>
</blockquote>
<h4 id="TCP的首部格式"><a href="#TCP的首部格式" class="headerlink" title="TCP的首部格式"></a>TCP的首部格式</h4><blockquote>
<ul>
<li><p><strong>源端口</strong>：源端口和IP地址的作用是标识报文的返回地址。</p>
</li>
<li><p><strong>目的端口</strong>：端口指明接收方计算机上的应用程序接口。</p>
</li>
<li><p><strong>序号</strong>：序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。例如一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。</p>
</li>
<li><p><strong>确认号</strong>：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</p>
</li>
<li><p><strong>数据偏移</strong>：由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p>
</li>
<li><p><strong>保留</strong>：为将来定义新的用途保留，现在一般置0。</p>
</li>
<li><p>控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</p>
<ul>
<li><code>URG</code>：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</li>
<li><code>ACK</code>：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</li>
<li><code>PSH</code>：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li>
<li><code>RST</code>：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</li>
<li><code>SYN</code>：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。</li>
<li><code>FIN</code>：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
</li>
<li><p><strong>窗口</strong>：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</p>
</li>
<li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
</li>
<li><p><strong>紧急指针</strong>：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
</li>
<li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
</li>
<li><p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2019053110dvfdbfndygmbfbfgbf5135488.png"></p>
</blockquote>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021011019371vfbgfnhgjmhngbf3551.png"></p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。<strong>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</strong></p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。<strong>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</strong></p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。<strong>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</strong></p>
</li>
</ul>
</blockquote>
<p><strong>为什么要三次握手，而不是两次握手&#x2F;四次握手?</strong></p>
<blockquote>
<ol>
<li>三次握手才可以<code>阻止历史重复连接</code>（主要原因）</li>
<li>三次握手才可以<code>同步双方的初始序列号</code></li>
<li>三次握手才可以<code>避免重复建立连接</code></li>
</ol>
<p><strong>原因一：避免历史连接</strong></p>
<blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210110204923cvfsgbfvvdbbvnbn968.png"></p>
</blockquote>
<p><strong>原因二：同步双方初始序列号</strong></p>
<blockquote>
<p>两次握手只保证了客户端的初始序列号被服务端成功接收，没办法保证服务端的初始序列号被客户端确认接收。</p>
<p>四次握手当然能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」，即四次握手没有必要，优化成了三次握手。</p>
</blockquote>
<p><strong>原因三：避免重复建立连接</strong></p>
<blockquote>
<p>​		如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就会建立一个新的连接，服务器就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021011021fgdhdgjdfdagd0404746.png"></p>
</blockquote>
</blockquote>
<h5 id="最大TCP连接数量问题总结"><a href="#最大TCP连接数量问题总结" class="headerlink" title="最大TCP连接数量问题总结"></a>最大TCP连接数量问题总结</h5><blockquote>
<p><strong>最大TCP连接数量限制有：可用端口号数量、文件描述符数量、线程、内存、CPU</strong></p>
<ul>
<li>可用端口号限制：</li>
</ul>
<blockquote>
<p><strong>Q：一台主机可以有多少端口号？端口号与TCP连接？是否能修改？端口号限制因素？</strong></p>
<p>第一：端口号是<strong>16位</strong>的，所以总共有65535个，即<strong>可创建65535个TCP连接</strong></p>
<p>第二：端口分为<code>知名端口(0~1023)</code>、<code>注册端口(1024~49511)</code>、<code>动态/私有端口(49152~65535)</code></p>
</blockquote>
<ul>
<li>文件描述符限制</li>
</ul>
<blockquote>
<p>每建立一个TCP连接，操作系统就得分配一个文件描述符，linux 对可打开的文件描述符的数量分别作了三个方面的限制。</p>
<p>系统级：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看</p>
<p>用户级：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf查看</p>
<p>进程级：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open查看</p>
</blockquote>
<ul>
<li>线程的限制</li>
</ul>
<blockquote>
<p><strong>传统的多线程并发模型</strong>：<strong>一个TCP连接</strong>就需要<strong>创建一个线程</strong></p>
<p>I&#x2F;O多路复用：一个线程可以管理多个 TCP 连接的资源</p>
</blockquote>
<ul>
<li>内存的限制</li>
</ul>
<blockquote>
<p>TCP连接数过大可能会出现: <code>ERROR: out of memory</code> ,即内存溢出。</p>
<p><strong>原因</strong>：每个TCP连接本身，以及这个连接所用到的缓冲区，<strong>都是需要占用一定内存的</strong>，现在内存已经被占满了，不够用了就会报这个错。</p>
</blockquote>
<ul>
<li>CPU的限制</li>
</ul>
<blockquote>
<p>每个TCP连接都是需要占用CPU资源的，若占用CPU资源过多，则会导致死机，用户啥也干不了，然后就重启了，TCP连接也就全没了。</p>
</blockquote>
</blockquote>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/vdfvvsfdvfvgfberdfvasdvfvfdU0MjdfOTMxLnBuZw.png"></p>
<p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
</blockquote>
<p><strong>挥手为什么需要四次？</strong></p>
<blockquote>
<p>​		因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
</blockquote>
<p><strong>四次挥手释放连接时，等待2MSL的意义?</strong></p>
<blockquote>
<p><strong>保证客户端发送的最后一个ACK报文段能够到达服务端</strong>。</p>
<blockquote>
<p>​		这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
</blockquote>
<p><strong>防止“已失效的连接请求报文段”出现在本连接中</strong>。</p>
<blockquote>
<p>​		客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</blockquote>
</blockquote>
<h4 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h4><blockquote>
<p>流量控制：如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>
</blockquote>
<blockquote>
<p>假设主机A发送的每个TCP 报文段可携带100字节数据，因此，图中每个小格子表示100个字节数据的序号。</p>
<p>在主机A和B建立TCP 连接时，B 告诉A 我的接收窗口为400，因此，主机A 将自己的发送窗口也设置为400。</p>
<p>这意味着主机A 在未收到主机B 发来的确认时，可将序号落入发送窗口中的全部数据发送出去。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/a57e96esssss3ssssd4636dd4f.png"></p>
<blockquote>
<p>这里的seq是TCP报文段首部中的序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号是1。这里的DATA 表示这是TCP 数据报文段。</p>
<p>这里的大写ACK 是TCP 报文段首部中的标志位，取值1表示这是一个TCP 确认报文段，小写ack 是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接收。现在希望收到序号201及其后续数据。</p>
<p>rwnd 是TCP 报文段首部中的窗口字段取值300，表示自己的接收窗口大小为300。</p>
</blockquote>
<p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/24bab5fgsdfgfhvfvfxvxcvxc711373d.png"></p>
<p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/24bab53c091edcfdgfdsgfdsgfdsgs72711373d.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2fbf7883925ed8dda53de1bcccabf6e618f.png"></p>
<p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/754550612861f5e8a0c9ddddfbe32e1dde7.png"></p>
<blockquote>
<p>​		为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方，收到对方的零窗口通知，就启动持续计时器。若持续计时计超时，就发送一个零窗口探测报文，仅携带一字节的数据。而对方在确认这个探测报文段时，给出自己现在的接收窗口值。如果接收窗口仍然是零，那么收到这个报文段的一方就重新启动持续计时器。如果接收窗口不是零，那么死锁的局面就可以被打破了。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/9d42d50c3507sss0b580435df1bbff25c6a.png"></p>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p>
<p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p>
</blockquote>
<h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><blockquote>
<p>拥塞控制：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。</p>
<p>算法：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）。</p>
</blockquote>
<blockquote>
<ul>
<li>MSS:报文段</li>
<li>RTT：往返时间 (表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间,总共经历的时间)。</li>
<li>SWND:发送窗口 (发送端向网络一次连续写入的数据量，窗口大小就是无需等待确认应答而可以继续发送数据的最大值）</li>
<li>CWND:拥塞窗口 指某一源端数据流在一个RTT内可以最多发送的数据包数</li>
<li>RWND：接收窗口</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031609ffffffffffffssssssssssss4015847.png"></p>
<h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><blockquote>
<p>纵坐标：拥塞窗口cwnd会随着网络拥塞程度以及所使用的拥塞控制算法动态变化</p>
<p>横坐标：传输轮次：发送方给接收方发送数据报文段后，接收方给发送方返回相应的确认报文段，一个传输轮次所经历的时间就是往返时间RTT(RTT并非是恒定的数值），使用传输轮次是为了强调，把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210316swwwwwwwwwwwwwwwww094505743.png"></p>
<p>设置初始值：cwnd &#x3D; 1，ssthresh &#x3D; 16，swnd &#x3D; cwnd，即发送方当前只能发送一个数据报文段</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031609sssssssss4813779.png"></p>
<p>接收方收到报文段后，给发送方返回一个确认报文段</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031609sssssssssswwwwwwww4840809.png"></p>
<p>发送方收到确认报文段后，cwnd 加一，并在图中标注</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202103160949fdfsfaddfsdg5033.png"></p>
<p>此时发送方可以依此发送2个数据报文段</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031609ssssssssaaaa5105734.png"></p>
<p>接收方收到后，依此返回发送方2个确认报文段</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202103160ssssszzzzzz95152109.png"></p>
<p>此时cwnd + 2 &#x3D; 4</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210316095dgdsfgdfbdvxcfv324144.png"></p>
<p>此时发送方可以依此发送4个数据报文段，cwnd + 4 &#x3D; 8</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202103160953gfbfnbfnbdhbd5943.png"></p>
<p>此时发送方可以依此发送8个数据报文段，cwnd + 8 &#x3D; 16，cwnd &#x3D; ssthresh</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202103160956fdfdafgfsdbsf19339.png"></p>
</blockquote>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><blockquote>
<p>此时发送方可以依此发送16个数据报文段，但cwnd只能加一，cwnd + 1 &#x3D; 17</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031609591vdfvbfsbsg1448.png"></p>
<p>直至cwnd &#x3D; 24时，发送方理应接受到24个确认报文段，但只接受到20个，被认为出现拥塞状态。将ssthresh更新为12 &#x3D; 24&#x2F; 2，cwnd减少为1，并重新执行慢开始算法。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031610044vsdbfbsfbsfrgsdf3633.png"></p>
<p><strong>存在的问题：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031610vsfbgfbdgb115445.png"></p>
</blockquote>
<h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><blockquote>
<ul>
<li>在之前的拥塞控制网络中，收到全部的数据报文段后才会发送确认报文段。</li>
<li>现在只要收到一个数据报文段，就立即确认。比如M3丢失，M4发送后，由于接收方没有收到按序的M3，会继续返回M2的确认报文段。同理，发送M5、M6时，也会收到对M2的重复确认。</li>
<li>连续收到3个重复确认，立即重传M3。</li>
<li>此时接收方会返回M6的确认报文段，表示到M6的所有报文都收到了</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021031610100ghnmndhfgg1747.png"></p>
</blockquote>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><blockquote>
<p>在连续收到3个重复确认后，知道丢失个别的报文段，开始执行快恢复算法</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202103161020fsdgfgsbgsss39162.png"></p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210316fgfbfdbsds102010560.png"></p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><blockquote>
<p>会话层：主要功能是用来管理网络设备的会话连接，细分为三大功能：</p>
<ul>
<li><strong>建立会话</strong>：A、B两台网络设备之间要通信，要建立一条会话供他们使用，在建立会话的过程中也会有身份验证，权限鉴定等环节；</li>
<li><strong>保持会话</strong>：通信会话建立后，通信双方开始传递数据，当数据传递完成后，OSI会话层不一定会立刻将两者这条通信会话断开，它会根据应用程序和应用层的设置对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；</li>
<li><strong>断开会话</strong>：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。或者A、B重启、关机、手动执行断开连接的操作时，OSI会话层也会将A、B之间的会话断开。</li>
</ul>
</blockquote>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><blockquote>
<p>表示层：负责数据格式的转换，如加密解密、压缩解压缩等。</p>
</blockquote>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><blockquote>
<p><strong>应用层</strong>：位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。 </p>
</blockquote>
<h3 id="DNS域名解析协议"><a href="#DNS域名解析协议" class="headerlink" title="DNS域名解析协议"></a>DNS域名解析协议</h3><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h4><blockquote>
<p>​		为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202101sssswwwwwwwwwwwwwqqq20124147.png"></p>
</blockquote>
<h4 id="1-什么是-DNS-协议"><a href="#1-什么是-DNS-协议" class="headerlink" title="1. 什么是 DNS 协议"></a>1. 什么是 DNS 协议</h4><blockquote>
<p>​		在学习 DNS 协议之前，我们先区分一下域名和 IP 地址这个两个概念：</p>
<ul>
<li><strong>IP 地址</strong>：一长串能够唯一地标记网络上的计算机的数字</li>
<li><strong>域名</strong>：又称网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）比如 <code>www.baidu.com</code></li>
</ul>
<blockquote>
<p>​		不知道有没有同学会混淆域名和网址的概念，可以这样理解，网址里面含有域名。举个例子：<a target="_blank" rel="noopener" href="http://www.gitee.com/veal98">www.gitee.com/veal98</a> 就是一个网址，而 <a target="_blank" rel="noopener" href="http://www.gitee.com/">www.gitee.com</a> 就是域名</p>
</blockquote>
<p>​		由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并<strong>通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</strong>，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。</p>
</blockquote>
<blockquote>
<p>​		DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但大多数情况下 DNS 都使用 UDP 进行传输。</p>
</blockquote>
<h4 id="2-域名详解"><a href="#2-域名详解" class="headerlink" title="2. 域名详解"></a>2. 域名详解</h4><blockquote>
<p>​		那么域名由谁来规定和管理呢？不能是随便写吧？</p>
<p>​		全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。<strong>ICANN 负责管理全世界域名系统的运作</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210119205gbdbdgbdgbdgbd250.png"></p>
<p>​		域名其实是具有一定的层次结构的，从上到下依次为：<strong>根域名</strong>、<strong>顶级域名</strong>（top level domain，TLD）、<strong>二级域名</strong>、（三级域名）</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021011bgdbgdbdbfgbdgbgd9205159.png"></p>
</blockquote>
<h5 id="①-顶级域名"><a href="#①-顶级域名" class="headerlink" title="① 顶级域名"></a>① 顶级域名</h5><blockquote>
<p>​		先来讲讲<strong>顶级域名</strong>（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<code>www.baidu.com</code> 的顶级域名就是 <code>.com</code>。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个，它们大致可以分成两类：</p>
<ul>
<li><p>一类是<strong>通用顶级域名</strong>（gTLD），比如<code>.com</code>、<code>.net</code>、<code>.edu</code>、<code>.org</code>、<code>.xxx</code>等等，共有 700 多个。</p>
</li>
<li><p>另一类是<strong>国家顶级域名</strong>（ccTLD），代表不同的国家和地区，比如<code>.cn</code>（中国）、<code>.io</code>（英属印度洋领地）、<code>.cc</code>（ 科科斯群岛）、<code>.tv</code>（图瓦卢）等，共有 300 多个。</p>
<p>​	当然，ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个<strong>托管商</strong>，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，<code>.cn</code> 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 <code>.cn</code> 域名的各种政策。</p>
</li>
</ul>
</blockquote>
<h5 id="②-二级域名"><a href="#②-二级域名" class="headerlink" title="② 二级域名"></a>② 二级域名</h5><blockquote>
<p>​		而<strong>二级域名</strong>(Second Level Domain,SLD) 在通用顶级域名或国家顶级域名之下具有不同的意义：</p>
<ul>
<li><p>通用顶级域名下的二级域名：一般是指域名注册人选择使用的网上名称，如 <code>yahoo.com</code>（商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如 <code>baidu.com</code>）</p>
</li>
<li><p>国家顶级域名下的二级域名：一般是指类似于通用顶级域名的表示注册人类别和功能的标志。例如，在 <code>.com.cn</code> 域名结构中，<code>.com</code> 此时是置于国家顶级域名 <code>.cn</code> 下的二级域名，表示中国的商业性组织，以此类推。</p>
<p>​	<strong>三级域名</strong>是形如 <code>www.baidu.com</code> 的域名，可以当做是二级域名的子域名，特征为域名包含两个 <code>.</code>。对于域名所有者&#x2F;使用者而言，三级域名都是二级域名的附属物而无需单独费用。<strong>三级域名甚至不能称为域名，一般称之为域名下的 “二级目录”</strong>。</p>
</li>
</ul>
</blockquote>
<h5 id="③-根域名"><a href="#③-根域名" class="headerlink" title="③ 根域名"></a>③ 根域名</h5><blockquote>
<p>​		 那么<strong>根域名</strong>在哪里呢？在层次结构中根域名不是最顶级的吗？域名中怎么没有看见它？</p>
<p>​		由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<code>www.xxx.com</code> 被写成 <code>www.xxx.com.</code>，即最后还会多出一个点。这个点就是根域名。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210120105gbgsbsbsndgndgnd950.png"></p>
<p>​		理论上，<strong>所有域名的查询都必须先查询根域名</strong>，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，<strong>ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210119bsfgbfvsfvfbfsbsgsb214844.png"></p>
<p>​		比如，我要访问<code>abc.xyz</code>，也必须先去询问根域名列表，它会告诉我 <code>.xyz</code> 域名由 CentralNic 公司托管。根域名列表还记载，<code>.google</code>由谷歌公司托管，<code>.apple</code>由苹果公司托管等等。</p>
<p>​		由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p>
</blockquote>
<h4 id="3-域名服务器详解"><a href="#3-域名服务器详解" class="headerlink" title="3. 域名服务器详解"></a>3. 域名服务器详解</h4><blockquote>
<p>​		域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作 区 (ZONE)。域名的每层都设有一个域名服务器：</p>
<ul>
<li><p>根域名服务器</p>
</li>
<li><p>顶级域名服务器</p>
</li>
<li><p>权限域名服务器</p>
<p>​	下面这幅图就很直观了：</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021012011vfsbgfbsnfnsfnfns1157.png"></p>
<p>​		除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，即<strong>本地域名服务器</strong>。下面我们分别讲解这四种服务器都是用来干什么的 👇</p>
</blockquote>
<h5 id="①-根域名服务器"><a href="#①-根域名服务器" class="headerlink" title="① 根域名服务器"></a>① 根域名服务器</h5><blockquote>
<p>​		上面我们提到，ICANN 维护着一张根域名列表，里面记载着顶级域名和对应的托管商，其实根域名列表的正式名称是 <strong>DNS 根区</strong>（DNS root zone），保存 DNS 根区文件的服务器，就叫做 <strong>DNS 根域名服务器</strong>（root name server）。根域名服务器<strong>保存所有的顶级域名服务器的地址</strong></p>
<p>​		由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从 <code>a.root-servers.net</code> 一直到 <code>m.root-servers.net</code>。其中 10 台设置在美国，另外各有一台设置于荷兰、瑞典和日本。</p>
<p>​		前面我们说过，理论上<strong>所有域名的查询都必须先查询根域名</strong>，所以一般来说所有的域名服务器都会注册一份根域名服务器的 IP 地址的缓存，用于在必要的时候向其发送请求。</p>
</blockquote>
<h5 id="②-顶级域名服务器"><a href="#②-顶级域名服务器" class="headerlink" title="② 顶级域名服务器"></a>② 顶级域名服务器</h5><blockquote>
<p>​		按照根域名服务器管理顶级域名的逻辑，顶级域名服务器显然就是用来<strong>管理注册在该顶级域名下的所有二级域名</strong>的，<strong>记录这些二级域名的 IP 地址</strong>。</p>
</blockquote>
<h5 id="③-权限域名服务器"><a href="#③-权限域名服务器" class="headerlink" title="③ 权限域名服务器"></a>③ 权限域名服务器</h5><blockquote>
<p>​		按照上面的逻辑，权限域名服务器应该是管理注册在二级域名下的所有三&#x2F;四级域名的，但其实不是这样，如果一个二级域名或者一个三&#x2F;四级域名对应一个域名服务器，则域名服务器数量会很多，我们需要使用<strong>划分区</strong>的办法来解决这个问题。那么权限域名服务器就是负责管理一个“<strong>区</strong>”的域名服务器。</p>
<p>​		什么是区？怎样划分区呢？</p>
<p>​		区和域其实是不同的，区可以有多种不同的划分方法。以百度为例，我们假设有 <code>fanyi.baidu.com</code>、<code>ai.baidu.com</code>、<code>tieba.baidu.com</code> 这三个三级域名。我们可以这样分区，<code>fanyi.baidu.com</code> 和 <code>tieba.baidu.com</code> 放在 <code>baidu.com</code> 权限域名服务器，<code>ai.baidu.com</code> 放在 <code>ai.baidu.com</code> 权限域名服务器中。并且 <code>baidu.com</code> 权限域名服务器和 <code>ai.baidu.com</code> 权限域名服务器是<strong>同等地位</strong>的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。</p>
<p>​		画个图直观理解一下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202101201bsgbngndndghnhdg14419.png"></p>
</blockquote>
<h5 id="④-本地域名服务器"><a href="#④-本地域名服务器" class="headerlink" title="④ 本地域名服务器"></a>④ 本地域名服务器</h5><blockquote>
<p>​		除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，就是<strong>本地域名服务器</strong>（也被称为<strong>权威域名服务器</strong>）。本地域名服务器是电脑解析时的<strong>默认</strong>域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202101fvfsdbfgbsbfbs20121349.png"></p>
<p>​		每个因特网服务提供者或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。<strong>当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</strong>。<strong>本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询</strong>。</p>
<p>​		那么具体本地域名服务器是如何向上级域名服务器转发查询请求的呢？</p>
</blockquote>
<h4 id="4-DNS-查询方式"><a href="#4-DNS-查询方式" class="headerlink" title="4. DNS 查询方式"></a>4. DNS 查询方式</h4><blockquote>
<p>​		具体 DNS 查询的方式有两种：</p>
<ul>
<li><p>递归查询</p>
</li>
<li><p>迭代查询</p>
<p>​	所谓递归就是，如果请求的接收者不知道所请求的内容，那么<strong>接收者将扮演请求者</strong>，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。</p>
<p>​	通俗点来说，在递归查询中，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案；而迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</p>
<p>​	一般来说，<strong>域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大</strong>。通过下面这两个图就能很好的理解了 👇</p>
</li>
</ul>
<p>1）递归查询：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021011923vfsdbsgbsbss2409.png"></p>
<p>2）迭代查询：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210119fbfgbsbsgbsbsbs232744.png"></p>
</blockquote>
<h4 id="5-域名缓存"><a href="#5-域名缓存" class="headerlink" title="5. 域名缓存"></a>5. 域名缓存</h4><blockquote>
<p>​		上面讲解的是域名服务器之间的 DNS 查询请求过程，但实际上，每个时刻都有无数网民要上网，那每次都去访问本地域名服务器去获取 IP 地址显然是不实际的。解决方法就是<strong>使用缓存保存域名和 IP 地址的映射</strong>。</p>
<p>​		计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p>
<p>​		1）<strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</p>
<p>​		2）<strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210120dvdaffsbsgbsgbsbsfbsf115853.png"></p>
<p>​		Windows 系统默认开启 DNS 缓存服务，服务名是 <code>DNSClient</code>，可以缓存一些常用的域名。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/202101201200bsbgfnbdfgbdbfd35.png"></p>
<p>​		使用命令 <code>ipconfig/displaydns</code> 可以查看电脑中缓存的域名。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210120120bfsbbsfgbdfbsbd212.png"></p>
<p>​		在浏览器中进行访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，最后再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，最后返回结果。<strong>主机和本地域名服务器之间的查询方式是递归查询</strong>，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。</p>
</blockquote>
<h4 id="6-完整域名解析过程"><a href="#6-完整域名解析过程" class="headerlink" title="6. 完整域名解析过程"></a>6. 完整域名解析过程</h4><blockquote>
<p>​		1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p>
<p>​		2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>
<p>​		3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>
<p>​		4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>
<ul>
<li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>
<li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
<p>​		5）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>​		6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
<p>​		7）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>
<p>配合下图直观理解：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021012012vfsgbfbdfgbdbdfbd3619.png"></p>
</blockquote>
<h3 id="DNS用的是TCP协议还是UDP协议"><a href="#DNS用的是TCP协议还是UDP协议" class="headerlink" title="DNS用的是TCP协议还是UDP协议"></a>DNS用的是TCP协议还是UDP协议</h3><blockquote>
<p>DNS占用53号端口，同时使用TCP和UDP协议。</p>
</blockquote>
<blockquote>
<p>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。</p>
</blockquote>
<blockquote>
<p>DNS区域传输的时候使用TCP协议：</p>
<ul>
<li><p>1、辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p>
</li>
<li><p>2、TCP是一种可靠连接，保证了数据的准确性。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>域名解析时使用UDP协议：</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
</blockquote>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote>
<p>HTTP ： <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/fbsfvfgbsvsfdvdszEzMy0xMzAwNDA2NjE4LnBuZw.png"></p>
</blockquote>
<h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><blockquote>
<ul>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP&#x2F;1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ul>
</blockquote>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><blockquote>
<ul>
<li><code>起始行（start line）</code>：描述请求或响应的基本信息；</li>
<li><code>头部字段（header）</code>：使用 key-value 形式更详细地说明报文；</li>
<li><code>消息正文（entity）</code>：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210126cvbnhrjmtumyubrtercrvtbyntu145429.png"></p>
<p>1）<strong>Referer</strong>：表示这个请求是从哪个 URI 跳过来的。比如说通过百度来搜索淘宝网，那么在进入淘宝网的请求报文中，Referer 的值就是：<a href="notion://www.notion.so/flying-veal/www.baidu.com">www.baidu.com</a>。如果是直接访问就不会有这个头。这个字段通常用于防盗链。</p>
<p>2）<strong>Accept</strong>：告诉服务端，该请求所能支持的响应数据类型。（对应的，HTTP 响应报文中也有这样一个类似的字段 Content-Type，用于表示服务端发送的数据类型，如果 Accept 指定的类型和服务端返回的类型不一致，就会报错）</p>
<p>3）<strong>Host</strong>：告知服务器请求的资源所处的互联网主机名和端口号。该字段是 HTTP&#x2F;1.1 规范中唯一一个必须被	包含在请求头中的字段。</p>
<p>4）<strong>Cookie</strong>：客户端的 Cookie 就是通过这个报文头属性传给服务端的！</p>
<p>5）<strong>Connection</strong>：表示客户端与服务连接类型；Keep-Alive 表示持久连接，close 已关闭</p>
<p>6）<strong>Content-Length</strong>：请求体的长度</p>
<p>7）<strong>Accept-Language</strong>：浏览器通知服务器，浏览器支持的语言</p>
<p>8）<strong>Range</strong>：对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围</p>
</blockquote>
<h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><blockquote>
<ul>
<li><code>响应行</code>（必须在 HTTP 响应报文的第一行）</li>
<li><code>响应头</code>（从第二行开始，到第一个空行结束。响应头和响应体之间存在一个空行）</li>
<li><code>响应体</code></li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/20210126nytngbgfbfgbsfbdsbs154224.png"></p>
</blockquote>
<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><blockquote>
<p>Cookie实际上是一<strong>小段的文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。</p>
<p>Session是另一种记<strong>录客户状态的机制</strong>，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p><strong>Session和Cookie的区别？</strong></p>
<ul>
<li><strong>数据存储位置</strong>：cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li><strong>安全性</strong>：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li>
<li><strong>服务器性能</strong>：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</li>
<li><strong>数据大小</strong>：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li><strong>信息重要程度</strong>：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</li>
</ul>
</blockquote>
<h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><blockquote>
<p>HTTP 请求方法：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>HEAD</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>CONNECT</code>、<code>TRACE</code></p>
</blockquote>
<h5 id="GET获取资源"><a href="#GET获取资源" class="headerlink" title="GET获取资源"></a>GET获取资源</h5><blockquote>
<p>​		GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021012vdsgbndhyjmyjmtngbfv6153110.png"></p>
</blockquote>
<blockquote>
<p>使用 GET 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101dvndakjvbadfjvbjdbfv26154500.png"></p>
</blockquote>
<h5 id="POST传输实体主体"><a href="#POST传输实体主体" class="headerlink" title="POST传输实体主体"></a>POST传输实体主体</h5><blockquote>
<p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021hfvhkfsvbkbvvs0126153402.png"></p>
</blockquote>
<blockquote>
<p>使用 POST 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210126fvjbsdfjvbdkcsdvca4526.png"></p>
</blockquote>
<h5 id="PUT-传输文件"><a href="#PUT-传输文件" class="headerlink" title="PUT 传输文件"></a>PUT 传输文件</h5><blockquote>
<p> PUT 方法用来传输文件，由于自身<strong>不带验证机制，任何人都可以上传文件</strong>，因此存在安全性问题，一般不使用该方法。向指定资源位置上传其最新内容</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101261dbajkbvjakdvj54626.png"></p>
</blockquote>
<blockquote>
<p>使用 PUT 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021cdnvj;bvjsdjfvbs0126154655.png"></p>
</blockquote>
<h5 id="HEAD-获取报文首部"><a href="#HEAD-获取报文首部" class="headerlink" title="HEAD 获取报文首部"></a>HEAD 获取报文首部</h5><blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URI 的有效性以及资源更新的日期时间等。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101cyvubhjbhugycftxcfgv26154727.png"></p>
</blockquote>
<blockquote>
<p>使用 HEAD 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101ckdjbjdkjacdavadf26154752.png"></p>
</blockquote>
<h5 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE 删除文件"></a>DELETE 删除文件</h5><blockquote>
<p>与 PUT 功能相反，用来删除文件，并且同样不带验证机制，按照请求 URI 删除指定的资源。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101261dgsfdfdbdfcdsca55025.png"></p>
</blockquote>
<blockquote>
<p>使用 DEELTE 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021012kfdvbjkbafadvb6155100.png"></p>
</blockquote>
<h5 id="OPTIONS-查询支持的方法"><a href="#OPTIONS-查询支持的方法" class="headerlink" title="OPTIONS 查询支持的方法"></a>OPTIONS 查询支持的方法</h5><blockquote>
<p>用于<strong>获取当前 URI 所支持的方法</strong>。若请求成功，会在 HTTP 响应头中包含一个名为 “<code>Allow</code>” 的字段，值是所支持的方法，如 “GET, POST”。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210126vuybunoinoubiyvubj155245.png"></p>
</blockquote>
<blockquote>
<p>使用 OPTIONS 方法请求-响应的例子：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210cjdbcjkbladjvkda126155317.png"></p>
</blockquote>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><blockquote>
<ul>
<li>GET参数通过URL传递，POST放在Request body中。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
</ul>
<ul>
<li><strong>GET产生一个TCP数据包，POST产生两个TCP数据包</strong>：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
</blockquote>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><h5 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h5><table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h5 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a>1XX 信息性状态码</h5><blockquote>
<ul>
<li>100 （部分接受） 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。</li>
<li>101 （已了解） 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。</li>
</ul>
</blockquote>
<h5 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h5><blockquote>
<ul>
<li>200  （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </li>
<li>204  （无内容） 服务器成功处理了请求，但没有返回任何内容。 </li>
<li>205  （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li>
<li>206  （部分内容） 服务器成功处理了部分 GET 请求。</li>
</ul>
</blockquote>
<h5 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h5><blockquote>
<ul>
<li>300  （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </li>
<li>301  （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>304（浏览器缓存未修改）所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
</ul>
</blockquote>
<h5 id="4XX客户端错误状态码"><a href="#4XX客户端错误状态码" class="headerlink" title="4XX客户端错误状态码"></a>4XX客户端错误状态码</h5><blockquote>
<ul>
<li>400  （错误请求） 服务器不理解请求的语法。 </li>
<li>401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </li>
<li>403  （禁止） 服务器拒绝请求。</li>
<li>404  （未找到） 服务器找不到请求的网页。</li>
<li>405  （方法禁用） 禁用请求中指定的方法。 </li>
<li>406  （不接受） 无法使用请求的内容特性响应请求的网页。</li>
</ul>
</blockquote>
<h5 id="5XX服务器错误状态码"><a href="#5XX服务器错误状态码" class="headerlink" title="5XX服务器错误状态码"></a>5XX服务器错误状态码</h5><blockquote>
<ul>
<li>500  （服务器内部错误） 服务器遇到错误，无法完成请求。 </li>
<li>501  （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </li>
<li>502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 </li>
<li>503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。</li>
</ul>
</blockquote>
<h4 id="请求方法中幂等性"><a href="#请求方法中幂等性" class="headerlink" title="请求方法中幂等性"></a>请求方法中幂等性</h4><blockquote>
<p>对于单个输入或者无输入的运算方法，如果每次都是同样的结果，则称其是幂等的；</p>
<p>GET，PUT，DELETE都是<strong>幂等操作</strong>，而POST不是，以下进行分析：</p>
<ul>
<li>GET对资源做查询多次，此实现的结果都是一样的，是幂等操作；</li>
<li>PUT将A修改为B，它第一次请求时值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作；</li>
<li>DELETE第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了；</li>
<li>POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作；</li>
</ul>
</blockquote>
<h4 id="HTTP-请求的过程"><a href="#HTTP-请求的过程" class="headerlink" title="HTTP 请求的过程"></a>HTTP 请求的过程</h4><h5 id="0-前言-1"><a href="#0-前言-1" class="headerlink" title="0. 前言"></a>0. 前言</h5><blockquote>
<p>​		在浏览中输入 URL 并且获取响应的过程，其实就是浏览器和该 URL 对应的服务器的网络通信过程。比如我们输入 <code>www.baidu.com</code>，那么会返回一个百度搜索的界面，这其实就是浏览器和百度服务器之间的网络通信过程。浏览器就是客户端，用于发出请求，而百度的服务器就是服务端，用于接收并响应请求。</p>
</blockquote>
<h5 id="1-解析-URL"><a href="#1-解析-URL" class="headerlink" title="1. 解析 URL"></a>1. 解析 URL</h5><blockquote>
<p>​		不知道有没有同学会混淆域名和 URL 的概念，可以这样理解，URL 就是我们输入的网址，而网址里面含有域名。举个例子：<code>www.baidu.com/veal98</code> 是一个网址，而 <code>www.baidu.com</code> 就是服务器的域名。</p>
<p>​		URL 各元素的组成如下（当然，下述请求文件的路径名可以省略）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102072fdjkvbsdfjvbjsdfbv10245.png"></p>
<p>​		这个 URL 请求的目标服务器上的文件路径就是：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021020721dbjkadbvjbfjlbajdf0750.png"></p>
<p>​		那么首先，浏览器做的第一步就是解析 URL 得到里面的参数，将域名和需要请求的资源分离开来，从而了解需要请求的是哪个服务器，请求的是服务器上什么资源等等。</p>
</blockquote>
<h5 id="2-浏览器封装-HTTP-请求报文"><a href="#2-浏览器封装-HTTP-请求报文" class="headerlink" title="2. 浏览器封装 HTTP 请求报文"></a>2. 浏览器封装 HTTP 请求报文</h5><blockquote>
<p>​		对 <code>URL</code> 进行解析之后，浏览器确定了目标服务器和文件名，接下来就需要根据这些消息<strong>封装</strong>成一个 HTTP 请求报文发送出去。举个 HTTP 请求报文的例子：</p>
<blockquote>
<p>​		关于 HTTP 协议详细可见 HTTP 协议的前世今生 这篇文章，这里不再赘述</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021020cjbfvjbfvbjvbsjvsdvfdsvds7212035.png"></p>
<p>​		解释一下<strong>封装</strong>，这是一个贯穿整个计算机网络的概念。就是说发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层就会把该层对应的首部信息消去。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102072vnsdfjvnbvdsjkcndsfnsjkd30329.png"></p>
</blockquote>
<h5 id="3-DNS-域名解析获取-IP-地址"><a href="#3-DNS-域名解析获取-IP-地址" class="headerlink" title="3. DNS 域名解析获取 IP 地址"></a>3. DNS 域名解析获取 IP 地址</h5><blockquote>
<p>​		封装好 HTTP 请求报文后，在正式还有一项准备工作没有做，那就是获取目标服务器的 IP 地址。</p>
<p>​		虽然解析得到了域名，理论浏览器已经知道目标服务器是谁了。但是实际上，域名并不是目标服务器真正意义上的地址，互联网上每一台计算机都被全世界唯一 IP 地址标识着，但是 IP 地址并不方便记忆，所以才设计出了域名。</p>
<p>​		那么就需要解析域名获取目标服务器的 IP 地址。不然空有一个方便记忆的域名咋知道这个请求到底发送到哪里去呢。由域名转换得到 IP 地址就是 DNS 协议做的事情，如下：</p>
<blockquote>
<p>​		关于 DNS 详细的内容各位可以回顾 超详细 DNS 协议解析 这篇文章，比如什么是域名，域名服务器，递归查询和迭代查询等等，写的已经足够详细，此处只列出 DNS 的解析过程。</p>
</blockquote>
<p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护着一张域名与 IP 地址的对应表；</p>
<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>
<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>
<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>
<ul>
<li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>
<li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>
<p>配合下图直观理解：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101201ndvfjvbdsjvbdsjjdsjv23619.png"></p>
<p>​		需要注意的是，DNS 使用的是 UDP 协议，也就是说上面各种请求的转发，都是基于 UDP 这个无连接协议的。</p>
</blockquote>
<h5 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h5><blockquote>
<p>​		获取到了目标服务器的 IP 地址之后，浏览器就知道我等下请求要发给谁了，这个时候就可以开始发送封装好了的 HTTP 请求报文了，那么既然需要发送请求，必然就需要 TCP 通过三次握手为浏览器和服务器之间建立可靠的连接，<strong>保证双方都具有可靠的接收和发送能力</strong>。</p>
<blockquote>
<p>这里又是一道经典的面试题：TCP 三次握手和四次挥手，详细可见 关于 TCP 三次握手和四次挥手，满分回答在此 这篇文章。</p>
</blockquote>
<p>​		三次握手过程如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/2021011019371vfbgfnhgjmhngbf3551.png"></p>
</blockquote>
<h5 id="5-浏览器发送请求"><a href="#5-浏览器发送请求" class="headerlink" title="5. 浏览器发送请求"></a>5. 浏览器发送请求</h5><blockquote>
<p>​		TCP 三次握手完成后，浏览器与目标服务器之间就建立了一个可靠的虚拟通道，于是浏览器就可以发送自己的 HTTP 请求了。</p>
<p>​		需要注意的是，HTTP 请求报文或者响应报文在 TCP 连接通道上进行传输的时候，由于这些报文比较大，为了更容易和准确可靠的传输，<strong>TCP 会将 HTTP 报文按序号分割成若干报文段并加上 TCP 首部，分别进行传输。接收方在收到这些报文段后，按照序号以原来的顺序重组 HTTP 报文</strong>。</p>
</blockquote>
<h5 id="6-负责传输的-IP-协议"><a href="#6-负责传输的-IP-协议" class="headerlink" title="6. 负责传输的 IP 协议"></a>6. 负责传输的 IP 协议</h5><blockquote>
<p>​		实际上，TCP 在三次握手建立连接、四次握手断开连接、以及连接建立过程中的收发数据（TCP 报文段）等各阶段操作时，都是通过 IP 协议进行传输的，IP 协议将这些阶段的数据添加 IP 首部封装成 IP 数据报再进行传输。</p>
<p>​		IP 数据报的首部存有<strong>源 IP 地址</strong>和 <strong>目标 IP 地址</strong>。所谓源 IP 地址 就是发送方的 IP 地址；目标 IP 地址就是通过 DNS 域名解析得到的目标服务器的 IP 地址。</p>
<p>​		事实上，<strong>IP 协议身处的网络层规定的是：数据报要通过怎样的路径（传输路线）才能到达对方计算机，并传送给对方</strong>。不理解这句话的详细解释马上就来，继续往下读。</p>
</blockquote>
<h5 id="7-使用-ARP-协议凭借-MAC-地址通信"><a href="#7-使用-ARP-协议凭借-MAC-地址通信" class="headerlink" title="7. 使用 ARP 协议凭借 MAC 地址通信"></a>7. 使用 ARP 协议凭借 MAC 地址通信</h5><blockquote>
<p>​		上面说了，IP 协议的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中必要的两个就是 IP 地址 和 MAC 地址。</p>
<p>​		MAC 地址也是用来唯一标识一个接入互联网的设备的，可能不禁有小伙伴要问，既然网络层已经有了唯一标识的 IP 地址，为啥还需要 MAC 地址？</p>
<p>​		看下面这幅图，在网络上，<strong>通信的双方在同一局域网内的情况是很少见的，通常是需要多台计算机和网络设备的中转才能连接到对方。而在进行中转时，就需要利用下一站中转设备的 MAC 地址来搜索下一个中转目标</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021011dhcdkfjbcjdfdjv4143919.png"></p>
<ul>
<li><p>网络层指定了从哪个主机（「源 IP 地址」）发送到哪个主机（「目的 IP 地址」）。<strong>源 IP 地址和目标 IP 地址在传输过程中是不会变化的</strong></p>
</li>
<li><p>而数据链路层则是根据 MAC 地址在一个接一个的区间中进行传输的，每个区间内的出发地址即「源 MAC 地址」，每个区间内的目的地址即「目的 MAC 地址」。显然，随着数据的传输，<strong>源 MAC 地址和目的 MAC 地址会不断的发生变化</strong></p>
<p>比如上图，<strong>网络层告知了 1-2-3 路线，也就是说指明了这几个路由器的 IP 地址。那么数据链路层就会根据这几个 IP 地址对应的 MAC 地址依次找到 1、2、3，并在他们之间传输数据</strong>。</p>
</li>
</ul>
<p>🍉 这么说吧，举个形象点的例子：我们把数据链路层当成乘坐高铁从苏州到南京，再在南京转乘到北京，再在北京转乘到西藏的旅客，那么网络层就相当于每个车站的工作人员，<strong>在数据链路层每次转乘时，网络层为其购买了一张标有下一个 MAC 地址的车票</strong>。因此，即使旅客（数据链路层）不知道其最终目的地也没有关系，工作人员（网络层）会给你做出指引。</p>
<p>​		实际上，网络层做出指引的过程，我们将其称为<strong>路由控制</strong>，其中又涉及到了路由协议比如 OSPF 等</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101151djcbnjadfvbds51809.png"></p>
<p>​	那么，<strong>将 IP 地址转化为 MAC 地址</strong>，从而在数据链路层精确的传输数据的协议就是 <strong>ARP 协议</strong>。</p>
<p>​	ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。并且每个主机都有一个 <strong>ARP 高速缓存</strong>，里面有本局域网上的各主机和路由器的 <strong>IP 地址到 MAC 地址的映射表</strong>。</p>
<p>​	如下图所示，假定主机 A 向同一链路上的主机 B 发送 IP 数据报，已知主机 A 和主机 B 的 IP 地址，它们互不知道对方的 MAC 地址：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202101232vbdsfsvbsdfjkvbdsjk13052.png"></p>
<p>​		1）首先，主机 A 为了获得主机 B 的 MAC 地址，它会先去查询自己的 ARP 高速缓存中有没有主机 B 的相关记录；</p>
<p>​		2）如果主机 A 的 ARP 高速缓存中没有主机 B 的 IP 地址到 MAC 地址的映射，主机 A 就会通过<strong>广播</strong>的方式发送 <strong>ARP 请求包</strong>（该包携带自己的 IP 地址 和 MAC 地址 以及 目标主机的 IP 地址），表明自己想要获得主机 B 的 MAC 地址；</p>
<p>​		3） 由于广播请求可以被同一个链路上的所有主机或路由器接收，因此如果这条链路上某个主机或路由的 IP 地址与这个 ARP 请求包中包含的目标主机的 IP 地址相同，那么这个节点就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>中返回给主机 A；</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021012322vbjdfvbsdjvbsj0759.png"></p>
<blockquote>
<p>当然，ARP 响应包是以单播的形式进行发送的，毕竟 ARP 请求包中已经包含了主机 A 的 IP 地址，所以主机 B 非常清楚这个响应包应该发送给谁。</p>
<p>大部分网络协议在设计的时候，都是保持极度克制的，不需要的交互就砍掉，能合并的信息就合并，能不用广播就用单播，以此让带宽变得更多让网络变得更快。</p>
</blockquote>
<p>​		4）主机 A 在收到主机 B 发过来的 ARP 响应包后，向其 ARP 高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20200427jkdbcksdfjvbjk210248.png"></p>
<p>​		当然，缓存是有一定期限的，超过这个期限，缓存的内容将被清空。这也使得即使 MAC 地址和 IP 地址的映射关系发生了变化，也依然能够正确的将数据包发送给目标地址。</p>
</blockquote>
<h5 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8. 服务器响应请求"></a>8. 服务器响应请求</h5><blockquote>
<p>​		浏览器的 HTTP 请求报文通过 TCP 三次握手建立的连接通道被切分成若干报文段分别发送给服务器，服务器在收到这些报文段后，按照序号以原来的顺序重组 HTTP 请求报文。然后处理并返回一个 HTTP 响应。当然，HTTP 响应报文也要经过和 HTTP 请求报文一样的过程。</p>
<p>​		看下方这个图回顾一下（图片来源《图解 HTTP》）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021020cdbvbdgfbsdfvbdsvb7224444.png"></p>
</blockquote>
<h5 id="9-断开-TCP-连接"><a href="#9-断开-TCP-连接" class="headerlink" title="9. 断开 TCP 连接"></a>9. 断开 TCP 连接</h5><blockquote>
<p>​		浏览器和服务器都不再需要发送数据后，四次挥手断开 TCP 连接。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img14/sdafgsthvcdsvdbsgndtsbgfvbgsvfbsg.png"></p>
</blockquote>
<h5 id="10-浏览器显示界面"><a href="#10-浏览器显示界面" class="headerlink" title="10. 浏览器显示界面"></a>10. 浏览器显示界面</h5><blockquote>
<p>​		浏览器接收到服务器返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染</p>
</blockquote>
<h4 id="HTTP1-0、HTTP1-1、HTTP2-0"><a href="#HTTP1-0、HTTP1-1、HTTP2-0" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0"></a>HTTP1.0、HTTP1.1、HTTP2.0</h4><h5 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h5><h6 id="长连接-Persistent-Connection"><a href="#长连接-Persistent-Connection" class="headerlink" title="长连接(Persistent Connection)"></a>长连接(Persistent Connection)</h6><blockquote>
<p>​		长连接在无数据传输后不会立即断开，而是会等待一定的时间再断开。</p>
<p>​		HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</p>
<p>​		<strong>注意：但是这种方式是阻塞式的，即多个请求是顺序执行的。</strong></p>
</blockquote>
<h6 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h6><blockquote>
<p>​		HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p>
</blockquote>
<h6 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h6><blockquote>
<p>​		在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p>
</blockquote>
<h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h6><blockquote>
<p>​		在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
</blockquote>
<h6 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h6><blockquote>
<p>​		在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</blockquote>
<h5 id="HTTP1-x和HTTP2-0的区别"><a href="#HTTP1-x和HTTP2-0的区别" class="headerlink" title="HTTP1.x和HTTP2.0的区别"></a>HTTP1.x和HTTP2.0的区别</h5><blockquote>
<ul>
<li>HTTP&#x2F;2采用二进制格式而非文本格式</li>
<li>HTTP&#x2F;2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li>
<li>使用报头压缩，HTTP&#x2F;2降低了开销</li>
<li>HTTP&#x2F;2让服务器可以将响应主动“推送”到客户端缓存中</li>
</ul>
</blockquote>
<h6 id="二进制解析"><a href="#二进制解析" class="headerlink" title="二进制解析"></a>二进制解析</h6><blockquote>
<p>​		HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
</blockquote>
<h6 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h6><blockquote>
<p>​		在HTTP1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
</blockquote>
<blockquote>
<p>​		HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
</blockquote>
<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h6><blockquote>
<ul>
<li>HTTP&#x2F;1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。</li>
<li>HTTP&#x2F;1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。</li>
<li>多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</li>
</ul>
</blockquote>
<h6 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h6><blockquote>
<p>​		服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p>
</blockquote>
<blockquote>
<p>​		为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
</blockquote>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote>
<p>HTTPS &#x3D; HTTP + 加密 + 认证 + 完整性保护</p>
</blockquote>
<h4 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h4><blockquote>
<ul>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；</li>
<li>HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/tgsfbsfbdgbdgbdfca0860d344f94dfvdsv.jpg"></p>
<p><strong>步骤一</strong>：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。<strong>注意</strong>：客户端还会附加一个随机数，这里记为A。</p>
<p><strong>步骤二</strong>：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。<strong>注意</strong>：这里服务器同样会附加一个随机数，发给客户端，这里记为B。</p>
<p><strong>步骤三</strong>：之后服务器发送Certificate报文。报文中包含公开密钥证书。（具体的数字签名请看证书一节）</p>
<p><strong>步骤四</strong>：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</p>
<p><strong>步骤五</strong>：SSL第一次握手结束后，客户端会对服务器发过来的证书进行验证，如果验证成功，解密取出证书中的公钥。（具体查看证书一节）<br>接着，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为<strong>Pre-master secret</strong>的随机密码串。该报文使用从证书中解密获得的公钥进行加密（其实就是服务器的公钥）。</p>
<p><strong>步骤六</strong>：客户端继续发送Change Cipher Spec报文。用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
<p><strong>步骤七</strong>：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值（也就是HASH值），用来供服务器校验。</p>
<p><strong>步骤八</strong>：服务器接收到客户端的请求之后，使用私钥解密报文，把Pre-master secret取出来。接着，服务器同样发送Change Cipher Spec报文。</p>
<p><strong>步骤九</strong>：服务器同样发送Finished报文，用来供客户端校验。</p>
<p><strong>步骤十</strong>：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</p>
<p><strong>步骤十一</strong>：应用层协议通信，即发送HTTP响应。</p>
<p><strong>步骤十二</strong>：最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</p>
<p><strong><code>通俗理解：</code></strong></p>
<p><strong>步骤一</strong>：客户端发起一个HTTPS请求，请求服务器公钥，连接服务器443端口，还包含此时客户端生成的随机数（Client Random）。</p>
<p><strong>步骤二</strong>：服务端接到请求后生成一个公私钥和一个随机数（Server Random），把公钥以数字证书的形式加上刚才生成的随机数（Server Random）返回给客户端。证书中有一个公钥（此公钥是机构的公钥）来加密信息，私钥由服务器持有（数字证书除了服务器的公钥外，还有网站地址，证书颁发机构，失效日期等）。</p>
<p><strong>步骤三</strong>：客户端收到服务器的数字证书后，先验证证书的合法性（是否被篡改，是否过期）。</p>
<p><strong>步骤四</strong>：如果验证通过，客户端则生成一个随机数 (pre-master)，并用刚拿到的服务器公钥加密，发给服务器。</p>
<p><strong>步骤五</strong>：服务器收到这个随机数后，使用私钥进行解密，此时双方就都拥有3个随机数，分别是Client Random、Server Random、pre-master，通过这三个随机数生成会话秘钥（对称秘钥）。以后双方就使用这个对称秘钥进行传输数据，提高效率。</p>
<p><strong>步骤六</strong>：最后，客户端和服务端相互发送一个摘要信息，包含之前发送的所有数据的摘要，叫做「Encrypted Handshake Message（Finishd） 」，用会话加密加密后发送，以验证之前交互的消息是否被篡改过。服务器做个验证，验证加密通信是否可⽤和之前握⼿信息是否有被中途篡改过。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="clpsh979m002txgvs1jvb3yj0" data-title="计算机网络" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-12-13T12:13:16.000Z" itemprop="datePublished">2021-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p><strong>说明：</strong>本篇博客主要借鉴王道操作系统内容。</p>
<h1 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h1><blockquote>
<ul>
<li>是系统最基本最核心的软件，属于系统软件</li>
<li>控制和管理整个计算机的硬件和软件资源</li>
<li>合理的组织、调度计算机的工作与资源的分配</li>
<li>为用户和其它软件提供方便的接口和环境</li>
</ul>
</blockquote>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p><strong>进程</strong>：是一个具有一定独立功能的程序，在一个数据集上的一次动态执行的过程，是表示资源分配的基本单位，又是调度运行的基本单位，是应用程序运行的载体。进程一般由<strong>程序，数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志。</p>
</blockquote>
<h4 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h4><blockquote>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进行一起并发执行；</li>
<li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序，数据和进程控制块三部分组成</li>
</ul>
</blockquote>
<h4 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h4><blockquote>
<p><strong>进程</strong>：由程序段、数据段、PCB三部分组成。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/cdvdsfvdsfvfdsvdsvds1143755.png"></p>
</blockquote>
<h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><blockquote>
<ul>
<li>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</li>
<li>PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</li>
<li>进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；</li>
<li>当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在PCB中。</li>
<li>可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</li>
<li>PCB是进程存在的唯一标志。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2020030cdscdscsdcdscscs191134423.png"></p>
</blockquote>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><h5 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h5><p>按进程在执行过程中的不同情况至少要定义三种状态：</p>
<ul>
<li><p><strong>运行（<code>running</code>）态：</strong>进程占有处理器正在运行的状态。</p>
<blockquote>
<p>​	进程已获得<code>CPU</code>，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</p>
</blockquote>
</li>
<li><p><strong>就绪（<code>ready</code>）态：</strong>进程具备运行条件，等待系统分配处理器以便运行的状态。</p>
<blockquote>
<p>​	当进程已分配到除<code>CPU</code>以外的所有必要资源后，只要再获得<code>CPU</code>，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
</blockquote>
</li>
<li><p><strong>阻塞（<code>Blocked</code>）态：</strong>指进程不具备运行条件，正在等待某个时间完成的状态。</p>
<blockquote>
<p>​	也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/AryWDI.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>就绪态—→运行态：<code>CPU</code> 空闲时选择一个就绪进程。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h5><p>五态模型在三态模型的基础上增加了新建态（<code>new</code>）和终止态（<code>exit</code>）。</p>
<ul>
<li><p><strong>新建态：</strong>对应于进程被创建时的状态，尚未进入就绪队列。</p>
<blockquote>
<p>创建一个进程需要通过两个步骤：</p>
<p>​	1.为新进程分配所需要资源和建立必要的管理信息。</p>
<p>​	2.设置该进程为就绪态，并等待被调度执行。</p>
</blockquote>
</li>
<li><p><strong>终止态：</strong>指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。</p>
<blockquote>
<p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。</p>
<p>终止一个进程需要两个步骤：</p>
<p>​	1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。</p>
<p>​	2.然后回收占用的资源并被系统删除。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Aryfbt.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下：</p>
<blockquote>
<p>NULL→新建态：执行一个程序，创建一个子进程。</p>
<p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
<p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
<p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
<p>终止态→NULL：完成善后操作。</p>
</blockquote>
</li>
</ul>
<h5 id="进程的七态模型"><a href="#进程的七态模型" class="headerlink" title="进程的七态模型"></a>进程的七态模型</h5><blockquote>
<p>​	三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（<code>suspend</code>），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。</p>
</blockquote>
<blockquote>
<p>引起进程挂起的原因是多样的，主要有：</p>
<ul>
<li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。 </li>
<li>父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 </li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 </li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 </li>
<li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</li>
</ul>
</blockquote>
<blockquote>
<p>七态模型在五态模型的基础上增加了挂起就绪态（<code>ready suspend</code>）和挂起等待态（<code>blocked suspend</code>）。</p>
<ul>
<li>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。</li>
<li>挂起等待态：表明进程正在等待某一个事件发生且在外存中。</li>
</ul>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Ary4VP.png"></p>
<ul>
<li><p>引起进程状态转换的具体原因如下:</p>
<blockquote>
<p>等待态→挂起等待态：操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</p>
<p>挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态</p>
<p>挂起就绪态→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</p>
<p>就绪态→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</p>
<p>挂起等待态→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>运行态→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 <code>CPU</code>，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</p>
<p>新建态→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>​	挂起进程等同于不在内存中的进程，因此挂起进程将不参与低级调度直到它们被调换进内存。</p>
<p>挂起进程具有如下特征：</p>
<ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。 （等待事件结束后进程变为挂起就绪态）</li>
<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>
</ul>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p><strong>线程</strong>：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p>
</blockquote>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><blockquote>
<p>从操作系统角度：线程的状态一共可以描述为五种：初始态，可运行，运行态，阻塞态，终止态。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1583507073055.png"></p>
<ol>
<li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联；</li>
<li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待<code>CPU</code>给它分配时间片就可运行；</li>
<li>运行状态，指线程获取了<code>CPU</code>时间片，正在运行<ol>
<li>当<code>CPU</code>时间片用完，线程会转换至【可运行状态】，等待<code>CPU</code>再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ol>
</li>
<li>阻塞状态<ol>
<li>如果调用了阻塞<code>API</code>，如<code>BIO</code>读写文件，那么线程实际上不会用到<code>CPU</code>，不会分配<code>CPU</code>时间片，会导致上下文切换，进入【阻塞状态】</li>
<li>等待<code>BIO</code>操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，<code>CPU</code>就一直不会分配时间片</li>
</ol>
</li>
<li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ol>
</blockquote>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote>
<p><strong>协程</strong>：是一种用户态的轻量级线程，协程的调度完全由用户（程序执行）控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210324200sdafvdsvdcsdvdsfvsdf6167.png"></p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><blockquote>
<ul>
<li><strong>调度</strong>：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li><strong>并发性</strong>：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
<li><strong>拥有资源</strong>：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.</li>
<li><strong>系统开销</strong>：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li>
<li>多进程是指操作系统能同时运行多个任务（程序）。</li>
<li>多线程是指在同一程序中有多个顺序流在执行。</li>
</ul>
</blockquote>
<h3 id="协程与线程的区别"><a href="#协程与线程的区别" class="headerlink" title="协程与线程的区别"></a>协程与线程的区别</h3><blockquote>
<ul>
<li>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</li>
<li>线程进程都是同步机制，而协程则是异步。</li>
<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li>
<li>线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li>
<li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</li>
<li>线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</li>
<li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
</blockquote>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><blockquote>
<p><strong>内核态</strong>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</p>
</blockquote>
<blockquote>
<p><strong>用户态</strong>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。 </p>
</blockquote>
<h3 id="为什么划分内核态、用户态？"><a href="#为什么划分内核态、用户态？" class="headerlink" title="为什么划分内核态、用户态？"></a>为什么划分内核态、用户态？</h3><blockquote>
<ul>
<li>为了保证系统的稳定性、安全性，需要在系统中划分内核态、用户态。</li>
<li>所有涉及IO操作、内存操作等，均在内核态中完成，因为当这些操作出现差错时，可能会导致整个计算机系统的崩溃。用户写的程序可能是含有导致这些操作出现差错的bug的，所以，用户编写的不涉及IO、内存等操作的程序在用户态中完成，而涉及这些操作时，则需要进行用户态到内核态的切换。将实际操作交付给内核态，内核态完成操作后，将结果传递至用户态。</li>
<li>注意，用户态、内核态之间的切换是十分耗费性能资源的。</li>
</ul>
</blockquote>
<h3 id="用户态切换到内核态"><a href="#用户态切换到内核态" class="headerlink" title="用户态切换到内核态"></a>用户态切换到内核态</h3><h4 id="外围设备的中断"><a href="#外围设备的中断" class="headerlink" title="外围设备的中断"></a>外围设备的中断</h4><blockquote>
<p>​		当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote>
<p>​		当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
<blockquote>
<p>按照中断信号来源于CPU 的外部还是内部，将中断类型分为外中断和内中断：</p>
<ul>
<li><p><strong>外中断</strong> （也称中断，狭义上的中断）</p>
<p>外中断与当前执行的指令无关， 中断信号来源于 CPU 外部。如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，CPU 能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
</li>
<li><p><strong>内中断</strong>（也称 异常、例外）</p>
<p>内中断与当前执行的指令有关， 中断信号来源于 CPU 内部。如非法操作码、地址越界、算术溢出，除数为 0 等。</p>
</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/cdcdscdscdscdscsdfcfsdcfdscsdcs.png"></p>
</blockquote>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><blockquote>
<p>系统调用是通过陷入指令完成的，该指令会引发内中断。</p>
</blockquote>
<blockquote>
<p><strong>系统调用的过程</strong>简略版大致如下：</p>
<p>​	1）在用户态，应用程序传递系统调用参数</p>
<p>​	2）执行陷入指令，引发一个内中断，使 CPU 进入内核态</p>
<p>​	3）在内核态，执行相应的请求，内核程序处理系统调用</p>
<p>​	4）返回应用程序</p>
<p>思考一下<strong>为什么系统调用是必须的</strong>？</p>
<p>​		举个例子：我们去学校打印店打印论文，你按下了 WPS 的 “打印” 选项，于是打印机开始工作。 你的论文打印到一半时，另一位同学按下了 Word 的 “打印” 按钮，开始打印他自己的论文。想象一下如果两个进程可以随意的、并发的共享打印机资源，会发生什么情况？</p>
<p>​		显然，两个进程并发运行，导致打印机设备交替的收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了</p>
<p>​		如何解决这个问题？这就需要操作系统内核对共享资源进行统一的管理，并向上层提供 “系统调用” ，运行在用户态的应用程序或者进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，然后内核会对各个请求进行协调处理（进程调度）。</p>
<p>​		通过上面这个例子，我们就可以总结出什么功能会用到系统调用：<strong>凡是与共享资源有关的操作（比如内存分配、I&#x2F;O 操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出请求，由操作系统内核代为完成</strong>。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
</blockquote>
<h2 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h2><h3 id="0-什么是进程通信"><a href="#0-什么是进程通信" class="headerlink" title="0. 什么是进程通信"></a>0. 什么是进程通信</h3><blockquote>
<p><strong>进程通信</strong>：（ InterProcess Communication，IPC）就是指<strong>进程之间的信息交换</strong>。实际上，<strong>进程的同步与互斥本质上也是一种进程通信</strong>（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它<strong>缺乏传递数据的能力</strong>。</p>
<p>​		虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，<strong>进程之间需要交换大批数据</strong>，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。</p>
<p>​		再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以<strong>进程之间想要进行信息交换就必须通过内核</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102231vfdsvsdvdsvsdvsd12114.png"></p>
</blockquote>
<blockquote>
<p>下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：</p>
<ul>
<li>管道（也称作共享文件）</li>
<li>消息队列（也称作消息传递）</li>
<li>共享内存（也称作共享存储）</li>
<li>信号量和 PV 操作</li>
<li>信号</li>
<li>套接字（Socket）</li>
</ul>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><blockquote>
<p>​		各位如果学过 Linux 命令，那对管道肯定不陌生，Linux 管道使用竖线 <code>|</code> 连接多个命令，这被称为管道符。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">command1 | command2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		以上这行代码就组成了一个管道，它的功能是将前一个命令（<code>command1</code>）的输出，作为后一个命令（<code>command2</code>）的输入，从这个功能描述中，我们可以看出<strong>管道中的数据只能单向流动</strong>，也就是半双工通信，如果想实现相互通信（全双工通信），我们需要创建两个管道才行。</p>
</blockquote>
<blockquote>
<p>​		通过管道符 <code>|</code> 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，<strong>匿名管道只能用于父子进程之间的通信</strong>。</p>
</blockquote>
<blockquote>
<p>​		在 Linux 的实际编码中，是通过 <code>pipe</code> 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe (int fd[2]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数拥有一个存储空间为 2 的文件描述符数组：</p>
<ul>
<li><code>fd[0]</code> 指向管道的读端，<code>fd[1]</code> 指向管道的写端</li>
<li><code>fd[1]</code> 的输出是 <code>fd[0]</code> 的输入</li>
</ul>
</blockquote>
<blockquote>
<p>粗略的解释一下通过匿名管道实现进程间通信的步骤：</p>
<p>​		1）父进程创建两个匿名管道，管道 1（<code>fd1[0]</code>和 <code>fd1[1]</code>）和管道 2（<code>fd2[0]</code> 和 <code>fd2[1]</code>）；</p>
<blockquote>
<p>因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个。</p>
</blockquote>
<p>​		2）父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</p>
<p>​		3）父进程关闭管道 1 的读端 <code>fd1[0]</code> 和 管道 2 的写端 <code>fd2[1]</code>，子进程关闭管道 1 的写端 <code>fd1[1]</code> 和 管道 2 的读端 <code>fd2[0]</code>，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用<strong>环形队列</strong>实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314vdsfvdfsvdsfvds2402.png"></p>
<p>​		看完上面这些讲述，我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了），但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>​		简单来说，<strong>管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作</strong>。</p>
</blockquote>
<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><blockquote>
<p> ​	   匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
</blockquote>
<blockquote>
<p>​		所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。</p>
</blockquote>
<blockquote>
<p>​		使用 Linux 命令 <code>mkfifo</code> 来创建有名管道：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> myPipe</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		<code>myPipe</code> 就是这个管道的名称，接下来，我们往 myPipe 这个有名管道中写入数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		执行这行命令后，你会发现它就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个有名管道里的数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; myPipe</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><blockquote>
<p>​		可以看出，<strong>管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流</strong>。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314dvsdfvsdfvdsvdsf2747.png"></p>
<p>​		<strong>消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong>。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：</p>
<ul>
<li><p>消息队列允许一个或多个进程向它写入或读取消息。</p>
</li>
<li><p>消息队列可以实现消息的<strong>随机查询</strong>，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。</p>
</li>
<li><p>对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。</p>
</li>
<li><p>消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</p>
<p>​	需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
</li>
</ul>
</blockquote>
<h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><blockquote>
<p>​		为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。</p>
<p>​		顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将<strong>立即</strong>影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​		集合内存管理的内容，我们来深入理解下共享内存的原理。首先，每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。<strong>两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022314vfdvsdvsfdvsdfvsd4949.png"></p>
<p>​		不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210223dfsvsfvsdfvsdfvsdfv142910.png"></p>
</blockquote>
<h3 id="4-信号量和-PV-操作"><a href="#4-信号量和-PV-操作" class="headerlink" title="4. 信号量和 PV 操作"></a>4. 信号量和 PV 操作</h3><blockquote>
<p>​		实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为<strong>消息队列无需避免冲突，而共享内存机制可能会发生冲突</strong>。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。</p>
<p>​		并且，在多道批处理系统中，多个进程是可以并发执行的，但由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进（异步性）。但有时候我们又希望多个进程能密切合作，按照某个特定的顺序依次执行，以实现一个共同的任务。</p>
</blockquote>
<blockquote>
<p>​		举个例子，如果有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202102221vfsvfsvdsvdfvsdvfds82849.png"></p>
<p>​		因此，为了解决上述这两个问题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。</p>
</blockquote>
<blockquote>
<p>​		<strong>进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信</strong>。</p>
</blockquote>
<blockquote>
<p>​		信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
</blockquote>
<blockquote>
<p>​		用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：</p>
<p>​		1）<strong>P 操作</strong>：将信号量值减 1，表示<strong>申请占用一个资源</strong>。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。</p>
<p>​		可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。</p>
<p>​		2）<strong>V 操作</strong>：将信号量值加 1，表示<strong>释放一个资源</strong>，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。</p>
<p>​		我觉得已经讲的足够通俗了，不过对于 V 操作大家可能仍然有困惑，下面再来看两个关于 V 操作的问答：</p>
<p>​		问：<strong>信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程</strong>？</p>
<p>​		答：所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。</p>
<p>​		问：<strong>信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程</strong>？</p>
<p>​		答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。</p>
</blockquote>
<blockquote>
<p>信号量和 PV 操作具体的定义如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022cfdsvsbsvsdvfdsvsd2182011.png"></p>
</blockquote>
<h4 id="互斥访问共享内存"><a href="#互斥访问共享内存" class="headerlink" title="互斥访问共享内存"></a>互斥访问共享内存</h4><blockquote>
<p>两步走即可实现不同进程对共享内存的互斥访问：</p>
<ul>
<li>定义一个互斥信号量，并初始化为 1</li>
<li>把对共享内存的访问置于 P 操作和 V 操作之间</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022315vfdvsvdsfvsdfvds3221.png"></p>
<p>​		<strong>P 操作和 V 操作必须成对出现</strong>。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021cdfvdsvsfvsvsdfv0223153236.png"></p>
</blockquote>
<h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><blockquote>
<p>回顾一下进程同步，就是要各并发进程按要求有序地运行。</p>
<p>​		举个例子，以下两个进程 P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。假设 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022218cfdsvdsvsvsfvsfd1857.png"></p>
<p>​		如果 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
</blockquote>
<blockquote>
<p>使用信号量和 PV 操作实现进程的同步也非常方便，三步走：</p>
<ul>
<li>定义一个同步信号量，并初始化为当前可用资源的数量</li>
<li>在优先级较<strong>高</strong>的操作的<strong>后</strong>面执行 V 操作，释放资源</li>
<li>在优先级较<strong>低</strong>的操作的<strong>前</strong>面执行 P 操作，申请占用资源</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdsvsvsdfvdsvds2181925.png"></p>
<p>配合下面这张图直观理解下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdvsfdvcdsfvfdsv2171312.png"></p>
</blockquote>
<h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote>
<p>​		注意！<strong>信号和信号量是完全不同的两个概念</strong>！</p>
<p>​		信号是进程通信机制中唯一的<strong>异步</strong>通信机制，它可以在任何时候发送信号给某个进程。<strong>通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行</strong>。用户、内核和进程都能生成和发送信号。</p>
<p>​		信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；而软件来源就是通过 <code>kill</code> 系列的命令给进程发送信号，比如 <code>kill -9 1111</code> ，表示给 PID 为 1111 的进程发送 <code>SIGKILL</code> 信号，让其立即结束。我们来查看一下 Linux 中有哪些信号：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210223fdvdsvsvsvsvsvs154622.png"></p>
</blockquote>
<h3 id="6-Socket"><a href="#6-Socket" class="headerlink" title="6. Socket"></a>6. Socket</h3><blockquote>
<p>​		至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要<strong>跨网络与不同主机上的进程进行通信</strong>，那该怎么做呢？这就是 Socket 通信做的事情了（<strong>当然，Socket 也能完成同主机上的进程通信</strong>）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20201205vfdvdvdsvsdfvsdvs112439.png"></p>
<p>​		Socket 起源于 Unix，原意是<strong>插座</strong>，在计算机通信领域，Socket 被翻译为<strong>套接字</strong>，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>​		从计算机网络层面来说，<strong>Socket 套接字是网络通信的基石</strong>，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。</p>
<p>​		Socket 的本质其实是一个编程接口（API），是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它对 TCP&#x2F;IP 进行了封装。它<strong>把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面</strong>。对用户来说，只要通过一组简单的 API 就可以实现网络的连接。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022316ddvdfdvsdfvdfvfdvsdvs3258.png"></p>
</blockquote>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><blockquote>
<p>简单总结一下上面六种 Linux 内核提供的进程通信机制：</p>
<p>​		1）首先，最简单的方式就是<strong>管道</strong>，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。</p>
<p>​		2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此<strong>消息队列</strong>应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。</p>
<p>​		3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，<strong>共享内存</strong>可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​		对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p>​		4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。</p>
<p>​		5）<strong>信号</strong>和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。</p>
<p>​		6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 <strong>Socket</strong> 通信。另外，Socket 也能完成同主机上的进程通信。</p>
</blockquote>
<h2 id="作业-进程调度策略"><a href="#作业-进程调度策略" class="headerlink" title="作业&#x2F;进程调度策略"></a>作业&#x2F;进程调度策略</h2><h3 id="0-调度的概念"><a href="#0-调度的概念" class="headerlink" title="0. 调度的概念"></a>0. 调度的概念</h3><blockquote>
<p>​		当 CPU 有一堆任务要处理时，由于其资源有限，这些事情就没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是 “调度” 研究的问题。除了接下来将要说的进程调度，还有作业调度、内存调度等。</p>
<p>回顾一下进程的三态模型：</p>
<ul>
<li><strong>运行态</strong>（running）：进程占有 CPU 正在运行。</li>
<li><strong>就绪态</strong>（ready）：进程具备运行条件，等待系统分配 CPU 以便运行。</li>
<li><strong>阻塞态</strong> &#x2F; 等待态（wait）：进程不具备运行条件，正在等待某个事件的完成。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20210219bgfbgdbdgbfdgbdfb154606.png"></p>
<p>​		所谓进程调度，就是<strong>从进程的就绪队列（阻塞）中按照一定的算法选择一个进程并将 CPU 分配给它运行</strong>，以实现进程的并发执行。这是操作系统中最基本（最低级）的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。</p>
</blockquote>
<h3 id="1-非抢占式进程调度算法"><a href="#1-非抢占式进程调度算法" class="headerlink" title="1. 非抢占式进程调度算法"></a>1. 非抢占式进程调度算法</h3><blockquote>
<p>所谓非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件发生而被阻塞时，才会把 CPU 让给其他进程。</p>
<p>对应的，抢占式的意思就是，当进程正在运行的时，可以被打断，把 CPU 让给其他进程。</p>
</blockquote>
<h4 id="①-先到先服务-FCFS"><a href="#①-先到先服务-FCFS" class="headerlink" title="① 先到先服务 FCFS"></a>① 先到先服务 FCFS</h4><blockquote>
<p><strong>先来先服务调度算法（First Come First Serve，FCFS）</strong>：按照进程到达的先后顺序进行调度，<strong>先到的进程就先被调度</strong>，也就是说，等待时间越久的越优先得到服务。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2020040vfvfvsdfvdsvfdsvds5165950995.png"></p>
<p>优点：公平、算法实现简单</p>
<p>缺点：对短进程不利。排在长进程后面的短进程需要等待很长时间，短进程的响应时间太长了，用户交互体验会变差。</p>
</blockquote>
<h4 id="②-最短作业优先-SJF"><a href="#②-最短作业优先-SJF" class="headerlink" title="② 最短作业优先 SJF"></a>② 最短作业优先 SJF</h4><blockquote>
<p><strong>最短作业&#x2F;进程优先调度算法（Shortest Job First，SJF）</strong>：<strong>每次调度时选择当前已到达的、且运行时间最短 的进程</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/202004051710cdcsdadcsdcsd3262.png"></p>
<p>​		最短作业优先算法和先到先服务恰好相反，先到先服务对短进程不利，而最短作业优先算法对长程不利。因为如果一直有短进程到来，那么长进程永远得不到调度，长进程有可能会饿死，处于一直等待短作业执行完毕的状态。</p>
</blockquote>
<h4 id="③-高响应比优先-HRRN"><a href="#③-高响应比优先-HRRN" class="headerlink" title="③ 高响应比优先 HRRN"></a>③ 高响应比优先 HRRN</h4><blockquote>
<p><strong>高响应比优先算法（Highest Response Ratio Next，HRRN）</strong>：只有当前运行的进程主动放弃 CPU 时（正常&#x2F;异常完成，或主动阻塞），才需要进行调度，<strong>调度时计算所有就绪进程的响应比，为响应比最高的进程分配 CPU</strong>。响应比 &#x3D; (进程的等待时间 + 进程需要的运行时间) &#x2F; 进程需要的运行时间</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20200405cdcdcsdcsdcs210349993.png"></p>
</blockquote>
<h3 id="2-抢占式进程调度算法"><a href="#2-抢占式进程调度算法" class="headerlink" title="2. 抢占式进程调度算法"></a>2. 抢占式进程调度算法</h3><blockquote>
<p>​		抢占就是指当进程正在运行的时，可以被打断，把 CPU 让给其他进程。抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p>
</blockquote>
<h4 id="①-最短剩余时间优先-SRTN"><a href="#①-最短剩余时间优先-SRTN" class="headerlink" title="① 最短剩余时间优先 SRTN"></a>① 最短剩余时间优先 SRTN</h4><blockquote>
<p>最短剩余时间优先（Shortest Remaining Time Next，SRTN）算法是<strong>最短作业优先的抢占式版本</strong>。</p>
<p>​		<strong>当一个新的进程到达时，把它所需要的整个运行时间与当前进程的剩余运行时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/20200405cdcdcsdcsdcs171532909.png"></p>
</blockquote>
<h4 id="②-轮转调度算法-RR"><a href="#②-轮转调度算法-RR" class="headerlink" title="② 轮转调度算法 RR"></a>② 轮转调度算法 RR</h4><blockquote>
<p><strong>轮转调度算法（Round Robin，RR）也称时间片调度算法</strong>：调度程序每次把 CPU 分配给就绪队列首进程使用规定的时间间隔，称为时间片，通常为 10ms ~ 200ms，<strong>就绪队列中的每个进程轮流地运行一个时间片，当时间片耗尽时就强迫当前运行进程让出 CPU 资源，转而排到就绪队列尾部，等待下一轮调度</strong>。所以，一个进程一般都需要多次轮转才能完成。</p>
<p>​		轮转调度算法对每个进程都一视同仁，就好比大家都排好队，一个一个来，每个人都运行一会儿再接着重新排队等待运行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img15/2021022vfdsvdfvdscscsdcs1145415.png"></p>
<p>需要注意的是：时间片的长度是一个很关键的因素：</p>
<ul>
<li>如果时间片设置得太短，就会导致频繁的进程上下文切换，降低了 CPU 效率；</li>
<li>如果时间片设置得太长，那么随着就绪队列中进程数目的增加，轮转一次消耗的总时间加长，即每隔进程的相应速度放慢。甚至时间片大到让进程足以完成其所有任务，RR 调度算法便退化成 FCFS 算法。</li>
</ul>
</blockquote>
<h3 id="3-最高优先级调度算法-HPF"><a href="#3-最高优先级调度算法-HPF" class="headerlink" title="3. 最高优先级调度算法 HPF"></a>3. 最高优先级调度算法 HPF</h3><blockquote>
<p>​		RR 调度算法对所有的进程都是相同的策略，如果用户进程太多，可能会导致内核的服务进程响应跟不上。而在操作系统中，内核进程是比用户进程重要的多的，毕竟它关乎整个系统的稳定性。</p>
</blockquote>
<blockquote>
<p>最高优先级调度算法（Highest Priority First，HPF）就是<strong>从就绪队列中选择最高优先级的进程进行运行</strong>。进程的优先级是怎么规定的呢？分为静态优先级或动态优先级：</p>
<ul>
<li><strong>静态优先级</strong>：创建进程时候，就预先规定优先级，并且整个运行过程中该进程的优先级都不会发生变化。一般来说，内核进程的优先级都是高于用户进程的。</li>
<li><strong>动态优先级</strong>：根据进程的动态变化调整优先级。比如随着进程的运行时间增加，适当的降低其优先级；随着就绪队列中进程的等待时间增加，适当的升高其优先级。</li>
</ul>
</blockquote>
<blockquote>
<p>另外，需要注意的是，最高优先级算法并非是固定的抢占式策略或非抢占式，<strong>系统可预先规定使用哪种策略</strong>：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，则运行完当前进程后，再选择该优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，则立即强制剥夺当前运行进程的 CPU 资源，分配给优先级更高的进程运行。</li>
</ul>
</blockquote>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p><strong>死锁</strong>：指的是多个进程在运行过程中因为争夺资源而造成的种僵局，当进程处于这种僵局状态时，若无外力作用，他们都将无法再向前推进的状态。</p>
</blockquote>
<h3 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h3><blockquote>
<ul>
<li><strong>互斥使用</strong>：即当资源被一个线程使用(占有)时，别的线程不能使用</li>
<li><strong>不可抢占</strong>：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li>
<li><strong>请求和保持</strong>：即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li>
<li><strong>循环等待</strong>：即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</li>
</ul>
</blockquote>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><blockquote>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请求和保持）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><blockquote>
<p><strong>银行家算法</strong>：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
</blockquote>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h5 id="银行家算法数据结构"><a href="#银行家算法数据结构" class="headerlink" title="银行家算法数据结构"></a>银行家算法数据结构</h5><blockquote>
<ul>
<li>Avaliable—可利用资源向量。这是一个含有m个元素的数组，每个元素代表一类可利用资源数目，其初值是系统中所配置的该类全部可用资源数目，其数值随该类资源的分配和回收而动态地改变。</li>
<li>Max—最大需求矩阵。这是一个m*n的矩阵，它定义了系统中n个进程中的每一个进程对n类资源的最大需求。</li>
<li>Allocation—分配矩阵。这是一个m*n的矩阵，它定义了当前系统的n个进程得到每一类资源的数目。</li>
<li>Request—请求向量。这是一个含有m个元素的向量，它表示进程i对各类资源的需求情况。</li>
<li>Need—需求矩阵。这是一个n*m的矩阵，它定义了当前系统的n个进程要想完成工作，还需要各类资源的数目。因此有以下关系：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Need[i,j] = Max[i,j]-Allocation[i,j]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="安全性算法数据结构"><a href="#安全性算法数据结构" class="headerlink" title="安全性算法数据结构"></a>安全性算法数据结构</h5><blockquote>
<ul>
<li>Work—工作向量。这是-一个含有m个元素的向量，表示系统可以提供给进程继续运行所需的各类资源数目，其初值Work&#x3D;Avaliable。</li>
<li>Finish—结束向量。表示系统是否有足够的资源分配给进程，使之运行完成。开始时Finish[i]&#x3D;false，当有足够资源分配给进Finish[j]&#x3D;ture。</li>
</ul>
</blockquote>
<h5 id="银行家算法-1"><a href="#银行家算法-1" class="headerlink" title="银行家算法"></a>银行家算法</h5><blockquote>
<p>假设进程Pi提出资源请求Request[i] &#x3D; k</p>
<ul>
<li>(1)若Request[i]&lt;&#x3D; Need[i,j]便转向执行步骤 (2)；否则认为出错。</li>
<li>(2)若Request[i]&lt;&#x3D; Available[i,j]便转 向执行步骤(3)；否则表示系统尚无足够的资源分配，让Pi等待。</li>
<li>(3)系统假设将Pi所要求的资源分配给Pi，并对数据结构做如下修改：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Avaliable[j] =Available[j] - Request[j]  </span><br><span class="line">Allocation[i,j] = Allocation[i,j] - Request[j]  </span><br><span class="line">Need[i,j] = Need[i,j]- Request[j]</span><br></pre></td></tr></table></figure>

<ul>
<li>(4)系统执行安全性算法，检测此次资源分配后，系统是否处于安全状态。若安全才正式将资源分配给进程Pi,以完成本次分配：否则，本次试探分配废，恢复原来的资源分配状态，让Pi等待。</li>
</ul>
</blockquote>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><blockquote>
<ul>
<li>(1)从进程集合中找到一个能满足一下条件的进程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Finish[i] = <span class="literal">false</span>;</span><br><span class="line">Need[i,j] &lt;= Work[j]; </span><br></pre></td></tr></table></figure>

<p>若找到执行步骤(2)否则执行步骤(3)。</p>
<ul>
<li>(2)进程Pi获得资源后，可以顺利执行，直至完成，并释放分配给它们的资源，故应执行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work[i] = Work[i] +Allocation[i,j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>; </span><br></pre></td></tr></table></figure>

<p>转向执行步骤(2);</p>
<ul>
<li>(3)若所有的进程的<code>Finish[i]=true</code>都满足，则表示系统处于安全状态：否 则系统处于不安全状态。</li>
</ul>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><blockquote>
<p><strong>内存管理</strong>：操作系统对内存的划分和动态分配。</p>
</blockquote>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><blockquote>
<ul>
<li>内存空间的分配和回收：由操作系统完成对主存的分配和回收，对编程人员透明</li>
<li>地址转换：使逻辑地址转换为真实的物理地址</li>
<li>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li>
<li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li>
</ul>
</blockquote>
<h3 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h3><blockquote>
<p>源程序 -&gt; 可执行程序：</p>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421dadscdcdscdscdscdscd180308143.png"></p>
</blockquote>
<h4 id="程序链接的方式"><a href="#程序链接的方式" class="headerlink" title="程序链接的方式"></a>程序链接的方式</h4><blockquote>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及他们所需的库函数链接成一个可执行程序，此后不再拆开</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421203dsfsdfsdcsdac135471.png"></p>
<ul>
<li>装入时动态链接：编译后所得的一组目标模块在装入时，边装入边链接</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120cdscsdcdcsccs3248608.png"></p>
<ul>
<li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。便于修改和更新以及实现对目标模块的共享</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212034dscascsadcsadc35485.png"></p>
</blockquote>
<h4 id="装入内存的方式"><a href="#装入内存的方式" class="headerlink" title="装入内存的方式"></a>装入内存的方式</h4><blockquote>
<ul>
<li>绝对装入：在编译时即知道程序将装入的内存具体地址，则编译程序将产生绝对地址的目标代码。而后将程序和数据装入内存，只适用于单道程序环境</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120202sfevdsvdsvsd5892.png"></p>
<ul>
<li>可重定位装入：在多道程序环境中，多个目标模块的起始地址均为0开始。装入内存时，通过所分配的内存起始地址加上程序内的相对地址进行地址的动态变换，一次完成，又称为静态重定位。【必须一次性全部装入，运行期间不能动态扩充和移动】</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212dfvdvdfvdfvdvdfvd02117615.png"></p>
<ul>
<li>动态运行时装入：装入模块装入内存后并不立即进行地址转换，而是等到程序执行时才进行。需要重定位寄存器的支持【可以将程序分哦到不连续的存储区中，程序运行前只需要装入部分代码，运行期间根据需要动态分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间】</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042120dcdscsdcsdcsdcs2516120.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212csdcscscsdcsdcs02728962.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421202csdcdscsdcsdcsdcsdcs859982.png"></p>
</blockquote>
<h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><blockquote>
<ul>
<li>逻辑地址空间：程序编译后的每个模块都是以0开始编址，称为目标模块的逻辑地址。当链接为一个完整的可执行目标程序时，链接程序将按顺序以0开始编址，构造统一的逻辑地址空间。</li>
<li>物理地址空间：内存中物理单元的集合，是地址转换的最终地址，当装入程序将可执行代码装入内存中时，必须将逻辑地址转化为物理地址。</li>
</ul>
</blockquote>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><blockquote>
<p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p>
</blockquote>
<h4 id="内存保护的两种方式"><a href="#内存保护的两种方式" class="headerlink" title="内存保护的两种方式"></a>内存保护的两种方式</h4><blockquote>
<ul>
<li>在CPU中设立一对上、下限寄存器，存放用户作业在主存中的上下限地址，每当CPU要访问一个地址时，先根据这对上下限判断是否越界访问。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004212053vfdvdsfvfdsvfvdsf54626.png"></p>
<ul>
<li>采用重定位寄存器和限长寄存器来实现这种保护。重定位寄存器保存最小的物理地址，限长寄存器保存逻辑地址的最大值。进行内存访问时，先判断逻辑地址是否大于限长寄存器值，若未越界，则加上重定位寄存器的值映射成物理地址，再进行内存访问。</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200421cdscdscdscsdcsd205641907.png"></p>
</blockquote>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><blockquote>
<p>覆盖与交换技术是在多道程序环境下扩充内存的两种方法。</p>
</blockquote>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004dscascscsacsacscsd025985.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231csdcdscsacscsdc80820382.png"></p>
</blockquote>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020cdcsacsacsdcsdcsd0423181112552.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042318cdscsdcscsdcsd1400473.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423182csdcsdcsdcs501764.png"></p>
</blockquote>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><blockquote>
<p>连续分配:指为用户进程分配的必须是一个连续的内存空间。</p>
</blockquote>
<blockquote>
<p>包括单一连续分配、固定分区分配和动态分区分配。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231bfbfgbfgbfgbfg83108555.png"></p>
</blockquote>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231838ddfvfddfgfdgdfg33877.png"></p>
</blockquote>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423dffdgfhvsfdbfsbsdf184230246.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231846vfdvfdsvdfvdfvfd27961.png"></p>
</blockquote>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231bfgbgfbvdfvfsdvsdf8520337.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004231853vfdbvfsdvsdfvvfdvdf21400.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042fbsfbfsdfvsdfvds3185404256.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423185vfdvfsvdsfvds425770.png"></p>
<p>（1）系统要用怎样的数据结构记录内存的使用情况呢？</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321042cdvfdsvdsfvfvsfvfs395.png"></p>
<p>（2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232fvfsbgfbdfvdsfvdsfvsd10641126.png"></p>
<p>（3）如何进行分区的分配和回收操作？</p>
<p><strong>如何分配？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232vdsfvfdvfvdfvdvfdsv10951871.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423211fvfdsvfsvdfvdfvdfvd031656.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423cfdvfdsbvfgbfsbfgbdf211234282.png"></p>
<p><strong>如何回收？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423211vfdvbfbgfbgdbfgbfg626193.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423vfdbfsbdgbgdbdg211751743.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2vdfvfdsvfdsbdgbfgbfgbf1954749.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042vfdvsvdfvfdvfdsvdsfv3212108969.png"></p>
</blockquote>
<h3 id="内部碎片与外部碎片"><a href="#内部碎片与外部碎片" class="headerlink" title="内部碎片与外部碎片"></a>内部碎片与外部碎片</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232vfdvfdsvfdsvfdsv12544902.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321cdfvfdvfdvfsvdfvdfvd2650781.png"></p>
</blockquote>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><blockquote>
<ul>
<li>首次适应算法：按地址升序查找</li>
<li>最佳适应算法：按容量升序查找</li>
<li>最坏适应算法：按容量降序查找</li>
<li>邻近适应算法：在按地址升序查找的前提下，查找的起点是上一次查找结束的位置</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321391cdcdacasdcdscdscs8738.png"></p>
</blockquote>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcadscdscscsadcas1452336.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321dvsdfvfdvfsdvsdf4600818.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042321cdfvddscsdcsd465411.png"></p>
</blockquote>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232156cdscssasdcsdcdscd41164.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423cdcdscdscdcdscdscsd215758679.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcdcdscsdcdscdscsd1590110.png"></p>
</blockquote>
<h4 id="最坏（大）适应算法"><a href="#最坏（大）适应算法" class="headerlink" title="最坏（大）适应算法"></a>最坏（大）适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423frefrefvsfvsfdvfdsvsdf220300386.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232204vfvfdsvsdvdsfvsfvs32246.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232205cdcdscscsdcsdcds49394.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232206vfdvdsvfdsvdsfvs33433.png"></p>
</blockquote>
<h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200423220cdscdscdscdascads900503.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232209cadscdsacdsacsad37204.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcdscdscdscdscds21300749.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020042322cdcdscdscdscdsc1401765.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232cdcscsadcsdcsdcs21603115.png"></p>
</blockquote>
<h4 id="四种算法归纳比较"><a href="#四种算法归纳比较" class="headerlink" title="四种算法归纳比较"></a>四种算法归纳比较</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202004232219cdcdascdscdsacadsc37764.png"></p>
</blockquote>
<h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><h4 id="为什么学习分页存储"><a href="#为什么学习分页存储" class="headerlink" title="为什么学习分页存储"></a>为什么学习分页存储</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050319cdcsdccsdcsdcsdcdsc1058819.png"></p>
</blockquote>
<h4 id="基本分页存储管理的思想"><a href="#基本分页存储管理的思想" class="headerlink" title="基本分页存储管理的思想"></a>基本分页存储管理的思想</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020efefwefwefwefwefwef03191933864.png"></p>
</blockquote>
<h4 id="分页存储管理的重要概念"><a href="#分页存储管理的重要概念" class="headerlink" title="分页存储管理的重要概念"></a>分页存储管理的重要概念</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503sdfsfsdfsdfsfsfdsf192356252.png"></p>
</blockquote>
<h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503192fvfdvfdvfdvfdvds553130.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050319474vdfvdfvdfvfdvfdv3868.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005fvfdvfdvfdvdfvdsf03215055931.png"></p>
</blockquote>
<h4 id="如何计算页号和页偏移量"><a href="#如何计算页号和页偏移量" class="headerlink" title="如何计算页号和页偏移量"></a>如何计算页号和页偏移量</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032cadascsadcsadcdsacadsc15344637.png"></p>
<p><strong>为什么页面大小一般设为2的整数次幂？</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005vgfvfvdfvdfdfvfdvdfvdfv03215910111.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20csdcdscdscdscsdcsdcsdc200503220214800.png"></p>
</blockquote>
<h4 id="分页存储的逻辑结构"><a href="#分页存储的逻辑结构" class="headerlink" title="分页存储的逻辑结构"></a>分页存储的逻辑结构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503220cdscdscdscdscsdcsdcsd607170.png"></p>
</blockquote>
<h4 id="如何知道页面在内存中的起始地址"><a href="#如何知道页面在内存中的起始地址" class="headerlink" title="如何知道页面在内存中的起始地址"></a>如何知道页面在内存中的起始地址</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322cdscsccdscdscdscsdc0952295.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503cdcdscdscdscdscdscsd221250554.png"></p>
</blockquote>
<h4 id="分页存储管理的基本地址变换结构"><a href="#分页存储管理的基本地址变换结构" class="headerlink" title="分页存储管理的基本地址变换结构"></a>分页存储管理的基本地址变换结构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032cscscscscscscsscsc21903305.png"></p>
</blockquote>
<h5 id="页表寄存器"><a href="#页表寄存器" class="headerlink" title="页表寄存器"></a>页表寄存器</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322csdcdscdscdscdscdsc2207602.png"></p>
</blockquote>
<h5 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200503223sdcdcdscdscdscdscds729773.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200csdcsdscdcsdcsdcsc503223548369.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050322cdscdscsdcsdcdscds4323607.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005032csacascsacascssscscs25214679.png"></p>
</blockquote>
<h5 id="对页表项大小的进一步讨论"><a href="#对页表项大小的进一步讨论" class="headerlink" title="对页表项大小的进一步讨论"></a>对页表项大小的进一步讨论</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050csdcsdcsdcdscsdcdscs3230227132.png"></p>
</blockquote>
<h4 id="快表的地址变换结构"><a href="#快表的地址变换结构" class="headerlink" title="快表的地址变换结构"></a>快表的地址变换结构</h4><h5 id="局部性原理引入快表机制"><a href="#局部性原理引入快表机制" class="headerlink" title="局部性原理引入快表机制"></a>局部性原理引入快表机制</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/2020050cdcdscdscdcascsdcsdc5111434415.png"></p>
</blockquote>
<h5 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005051114cdsdscsdcdscsdcsdcd55765.png"></p>
</blockquote>
<h5 id="一个例图了解基于快表的地址变换结构"><a href="#一个例图了解基于快表的地址变换结构" class="headerlink" title="一个例图了解基于快表的地址变换结构"></a>一个例图了解基于快表的地址变换结构</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005051vdfvfdvfdvfdvfdv12605873.png"></p>
<p><strong>引入快表后，地址变换的过程的文字描述：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/202005csdcsccsdcdscsdc05114142450.png"></p>
</blockquote>
<h4 id="基本地址变换与快表地址变换的比较"><a href="#基本地址变换与快表地址变换的比较" class="headerlink" title="基本地址变换与快表地址变换的比较"></a>基本地址变换与快表地址变换的比较</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img16/20200505scsdcdscdscsdcdsc11441885.png"></p>
</blockquote>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><h5 id="为什么引入二级页表"><a href="#为什么引入二级页表" class="headerlink" title="为什么引入二级页表"></a>为什么引入二级页表</h5><blockquote>
<p><strong>因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051252cdscdscdscdscsdcdsc43303.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202csdcdscdscdscdscds00505125432184.png"></p>
<p><strong>上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202csdccsdcdscdscdscdscsd00505125857508.png"></p>
</blockquote>
<h5 id="二级页表的原理和地址结构"><a href="#二级页表的原理和地址结构" class="headerlink" title="二级页表的原理和地址结构"></a>二级页表的原理和地址结构</h5><blockquote>
<ul>
<li>对页表再次分组</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051csdcdscdscscsdcds31124485.png"></p>
<ul>
<li>二级页表的地址结构及对应关系</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020scdcsdcsdcdscdscdscdsc0505131519939.png"></p>
</blockquote>
<h5 id="如何实现二级页表的地址变换"><a href="#如何实现二级页表的地址变换" class="headerlink" title="如何实现二级页表的地址变换"></a>如何实现二级页表的地址变换</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdscsdcdscdscdscsdcs05133306791.png"></p>
<p><strong>上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005051csdcsdcsdcsdcdscdscdsc34203409.png"></p>
</blockquote>
<h5 id="几个小细节"><a href="#几个小细节" class="headerlink" title="几个小细节"></a>几个小细节</h5><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200505csdcdscdscdscsdcds144046207.png"></p>
</blockquote>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071333531csdcsdcsdcsdcdscsdcds33.png"></p>
</blockquote>
<h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071425cssdcdscdscdscdscdsc04777.png"></p>
<p><strong>分段的逻辑地址结构</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcdscdscdscds43112191.png"></p>
</blockquote>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050714cdscdscdscsdcdscsdcds3835462.png"></p>
</blockquote>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507144csdcsdcdscsdcsdcds037443.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscsdcdscd07144834316.png"></p>
</blockquote>
<h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050sacscascsacasc7145814456.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcdscdscdsc51524501.png"></p>
</blockquote>
<h4 id="分段实现信息共享共享"><a href="#分段实现信息共享共享" class="headerlink" title="分段实现信息共享共享"></a>分段实现信息共享共享</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507150csdcsdcdscdscdscdsc216415.png"></p>
</blockquote>
<h4 id="为什么分页不方便实现信息共享和保护"><a href="#为什么分页不方便实现信息共享和保护" class="headerlink" title="为什么分页不方便实现信息共享和保护"></a>为什么分页不方便实现信息共享和保护</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050715125fbfbfbfgbgfbfgbgf4763.png"></p>
</blockquote>
<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507scdcdscdscdscdscdsc154258573.png"></p>
</blockquote>
<h4 id="分页、分段的优缺点分析"><a href="#分页、分段的优缺点分析" class="headerlink" title="分页、分段的优缺点分析"></a>分页、分段的优缺点分析</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050715cdcsdcsdcsdcsdcdscds3829103.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005scdfvfdvfdvfdvfdvdv07153921773.png"></p>
</blockquote>
<h4 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段+分页&#x3D;段页式管理"></a>分段+分页&#x3D;段页式管理</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200cddscdscdscsdcdscsdc507154133960.png"></p>
<p><strong>段页式管理的逻辑地址结构</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071547cdcsdcdscdscsdcdscsdcsd55703.png"></p>
<p><strong>段页式存储的段表、页表</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071fdvfdvfdvfdvdfvfdv60703773.png"></p>
</blockquote>
<h4 id="段页式管理的地址转换过程"><a href="#段页式管理的地址转换过程" class="headerlink" title="段页式管理的地址转换过程"></a>段页式管理的地址转换过程</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071612cdscddscsdcdscdscdsc08162.png"></p>
</blockquote>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><h4 id="传统存储管理的特征、缺点"><a href="#传统存储管理的特征、缺点" class="headerlink" title="传统存储管理的特征、缺点"></a>传统存储管理的特征、缺点</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071cdcscdscdscsdcdsc75726392.png"></p>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507cdscscscsdcsdcsdcds180621142.png"></p>
</blockquote>
<h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcsdcsdcdscdscsdcdsc07180934242.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200csdcdscdscsdcsdc507181109721.png"></p>
</blockquote>
<h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507cdscdcdscsdcds181418228.png"></p>
</blockquote>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><h4 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507182cdscsdcsdcdscdscds75041.png"></p>
</blockquote>
<h4 id="页表机制—请求页表与基本页表的区别"><a href="#页表机制—请求页表与基本页表的区别" class="headerlink" title="页表机制—请求页表与基本页表的区别"></a>页表机制—请求页表与基本页表的区别</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscdscsdcdscsdcdsc07183231700.png"></p>
</blockquote>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050718csdcscscsdcdscsdc5201230.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscdscdscdscdscds7184941487.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcsdcsdcdscsdcsdc85905607.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005071csdcdscdscsdcdscdscd9010754.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005cdscdscdscdscdscds07220913997.png"></p>
</blockquote>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200507csdcssdcdscsdcsdcs221140511.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005vdvdfvfdvfdvfdvfdvd0722145316.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005072cdscdscdscsdcdscsdcsdcds22657919.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcscsdcdscsdcsdc7222739960.png"></p>
</blockquote>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508154300ascsdcdscdscsdcdsc75.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020dscscdscdscsdcsdcdscds0508164532762.png"></p>
</blockquote>
<h4 id="最佳置换算法—OPT"><a href="#最佳置换算法—OPT" class="headerlink" title="最佳置换算法—OPT"></a>最佳置换算法—OPT</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200cdscdscsdcdscsdcdsc508154738464.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005sdcdscdscdscdscdscsdc08155059159.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508155cdscdscdscdscdscsdcds134553.png"></p>
</blockquote>
<h4 id="先进先出置换算法—FIFO"><a href="#先进先出置换算法—FIFO" class="headerlink" title="先进先出置换算法—FIFO"></a>先进先出置换算法—FIFO</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081csdcdscdscdscds55429175.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005csdcdscsdcsdcdscds08155751826.png"></p>
</blockquote>
<h4 id="最近最久未使用置换算法—LRU"><a href="#最近最久未使用置换算法—LRU" class="headerlink" title="最近最久未使用置换算法—LRU"></a>最近最久未使用置换算法—LRU</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508160sdcdscdscsdcsdcdscds546901.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcdscdscdscsdcds8160702605.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcdscsdcdscsdcsdc160751452.png"></p>
</blockquote>
<h4 id="时钟置换算法—CLOCK"><a href="#时钟置换算法—CLOCK" class="headerlink" title="时钟置换算法—CLOCK"></a>时钟置换算法—CLOCK</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcsdcsdcsdacdssdc161527270.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081csdcscsdcsdcdscdsc61856209.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcdscdscdscsdc8162122576.png"></p>
</blockquote>
<h4 id="改造型时钟置换算法"><a href="#改造型时钟置换算法" class="headerlink" title="改造型时钟置换算法"></a>改造型时钟置换算法</h4><blockquote>
<p><strong>只需一轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200csdcsdcdscsdcsd508163111666.png"></p>
<p><strong>需要两轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508sdcsdcsdcdscsdcds163620613.png"></p>
<p><strong>需要三轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005cascsdcdasvcdfsvvfdsvsdcds08163834664.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508csdcsdcsdcsdcds164014937.png"></p>
<p><strong>需要四轮：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdcsdcsdsdcsdcdsc8164118342.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050csdscdscscsdcdscsdcsd8164207831.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050816cdscssdcdscdscdsc4330498.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508164sdcdscsdcdscsdcsdc453588.png"></p>
</blockquote>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cdscsdcdscdscsdcds0109170.png"></p>
</blockquote>
<h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20200508xdscsdcsdcdscsdcdscsdcs171207873.png"></p>
</blockquote>
<h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817csdcdscdscdscsdcsd1838609.png"></p>
<p><strong>固定分配局部置换、可变分配局部置换、可变分配全局置换</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817285dcdscdcdscsdcdscds5194.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscdscdscsdcdscsdcs8172936378.png"></p>
</blockquote>
<h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817csdcscsdcdscdscdsc3243782.png"></p>
</blockquote>
<h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cdscdscdscdscds3648546.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050cdscscscdscdscdscsdcd8173856601.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081739424bfgbfgbgfvdfvfdvsdf34.png"></p>
</blockquote>
<h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2020050817cascscavdfsvfdsbgbfbfd4328925.png"></p>
</blockquote>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/202005081746csdbnhfbgdvfbnbfvdfbgnbfvfbg21232.png"></p>
</blockquote>
<h2 id="进程切换为什么比线程切换慢"><a href="#进程切换为什么比线程切换慢" class="headerlink" title="进程切换为什么比线程切换慢"></a>进程切换为什么比线程切换慢</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><blockquote>
<p>​		在进入文题之前，我想有必要解释下虚拟地址（逻辑地址）和物理地址的区别</p>
<p>​		下面这段 C 代码摘录自《操作系统导论 -  [美] 雷姆兹·H.阿帕希杜塞尔》，依次打印出 main 函数的地址，由 malloc（类似于 Java 中的 new 操作）返回的堆空间分配的值，以及栈上一个整数的地址：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051cascsdcscsdcdscdscvfdvfdv3130338.png"></p>
<p>得到以下输出：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051313cdscscsdcdscdscdsc0523.png"></p>
<p>​		我们需要知道的是，<strong>所有这些打印出来的地址都是虚拟的</strong>，在物理内存中这些地址并不真实存在，它们最终都将由操作系统和 CPU 硬件翻译成真正的物理地址，然后才能从真实的物理位置获取该地址的值。</p>
</blockquote>
<h3 id="物理寻址-Physical-Addressing"><a href="#物理寻址-Physical-Addressing" class="headerlink" title="物理寻址 Physical Addressing"></a>物理寻址 Physical Addressing</h3><blockquote>
<p>​		计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。比如说，第一个字节的物理地址是 0，接下来的字节地址是 1，再下一个是 2，以此类推，给定这种简单的结构，CPU 访问内存的最自然的方式就是使用这样的物理地址。我们把这种方式称为<strong>物理寻址</strong>（physical  addressing）。</p>
<p>​		举个例子，比如说当程序执行了一条加载指令，指令内容是从物理地址 4 中读取 4 字节字传送到某个寄存器中。</p>
<p>​		物理寻址过程如下：当 CPU 执行到这条指令时，会生成物理地址 4，然后通过内存主线，把它传递给内存，内存取出从物理地址 4 处开始的 4 字节字，并将它返回给 CPU，CPU 会将它存放到指定的寄存器中。看下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051dcdscdscdscdscds2224824.png"></p>
<p>​		其实不难发现，物理寻址这种方式，<strong>每一个程序都直接访问物理内存</strong>，其实是存在重大缺陷的：</p>
<p>1）首先，用户程序可以寻址内存的任意一个字节，它们就可以<strong>很容易地破坏操作系统</strong>，从而使系统慢慢地停止运行。</p>
<p>2）再次，<strong>这种寻址方式使得操作系统中同时运行两个或以上的程序几乎是不可能的</strong>。</p>
<p>​		举个例子，我们打开了三个相同的程序（计算器），都执行到某一步。比方说，用户在这三个计算器程序的界面上分别输入了 10、100、1000，其对应的指令就是把用户输入的数字保存在内存中的某个地址中。如果这个位置只能保存一个数，那应该保存哪个呢？这不就冲突了吗？</p>
<p>​		简单来说，第一个计算器程序给物理内存地址赋值 10，第二个计算器程序也同样给这个地址赋值为 100，那么第二个程序的赋值会覆盖掉第一个程序所赋的值，这会造成两个程序同时崩溃。</p>
<p>​		最简单的方法就是：首先，<strong>将空闲的进程存储在磁盘上，这样当它们不运行时就不会占用内存</strong>，然后，让一个程序（或者说进程）单独占用全部内存运行一小段时间，当发生上下文切换的时候，就停止这个进程，并将它所有的状态信息保存在磁盘上，再加载其他进程的状态信息，然后运行一段时间…… 只要在某一个时间内存中只有一个程序，那么就不会发生上述所说的地址冲突。这就实现了一种<strong>比较粗糙的并发</strong>。</p>
<p>​		为什么说他是粗糙的呢，因为这种方法有一个问题：<strong>将全部的内存信息保存到磁盘太慢了</strong>！特别是当内存增长的时候。</p>
<p>​		因此，我们考虑<strong>把进程对应的内存一直留在物理内存中，给每个进程分别划分各自的区域，在发生上下文切换的时候就切换到特定的区域</strong>。</p>
<p>​		如下图所示，有 3 个进程（A、B、C），每个进程拥有从 512KB 物理内存中切出来给它们的一小部分内存，可以理解为这 3 个进程共享物理内存：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/2021051cdsvdbnhgfbdfvbgnhjmghfgbdfv3110350.png"></p>
<p>​		那么如何对每个进程使用的地址进行<strong>保护</strong>（protection）呢？继续使用物理内存模型肯定是不行了，因此操作系统创造了一个新的内存抽象，引入了一个新的内存模型，那就是<strong>虚拟地址空间</strong>，很多书中都会直接称呼为 “地址空间（Address Space）”。</p>
</blockquote>
<h3 id="虚拟寻址-Virtual-Addressing"><a href="#虚拟寻址-Virtual-Addressing" class="headerlink" title="虚拟寻址 Virtual Addressing"></a>虚拟寻址 Virtual Addressing</h3><blockquote>
<p>​		操作系统会给每个进程分配一个<strong>虚拟地址空间</strong>（vitural address），每个进程包含的栈、堆、代码段这些都会从这个地址空间中被分配一个地址，这个地址就被称为<strong>虚拟地址</strong>。底层指令写入的地址也是虚拟地址。</p>
<p>​		<strong>每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间</strong>。（注意这句话非常重要！！！兄弟姐妹们背起来）也就是说一个进程中的虚拟地址 28 所对应的物理地址与另一个进程中的虚拟地址 28 所对应的物理地址是不同的，这样就不会发生冲突了。</p>
<p>​		有了虚拟地址空间后，CPU 就可以通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前会先被转换成合适的物理地址，这个虚拟地址到物理地址的转换过程称为 <strong>地址翻译&#x2F;地址转换</strong>（address translation）。</p>
<p>​		地址翻译需要 CPU 硬件和操作系统的密切合作：CPU 上的<strong>内存管理单元</strong>（Memory Management Unit，<strong>MMU</strong>）就是专门用来进行虚拟地址到物理地址的转换的，不过 MMU 需要借助存放在内存中的<strong>页表</strong>，而这张表的内容正是由操作系统进行管理的。</p>
<p>​		页表是一个十分重要的数据结构！</p>
<p>​		操作系统为每个进程建立了一张页表。一个进程对应一张页表，进程的每个页面对应一个页表项，每个页表项由页号和块号（页框号）组成，记录着进程页面和实际存放的内存块之间的映射关系。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20210521csdcdscdcscdscdsc213621.png"></p>
<p>​		从数学角度来说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p>
<p>​		至此，上述这一套 CPU 生成虚拟地址并进行地址翻译的流程就是<strong>虚拟寻址</strong>（virtual addressing）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/20210cascascdsdcsdccsdcsdcsd513124736.png"></p>
</blockquote>
<h3 id="进程切换为什么比线程切换慢-1"><a href="#进程切换为什么比线程切换慢-1" class="headerlink" title="进程切换为什么比线程切换慢"></a>进程切换为什么比线程切换慢</h3><blockquote>
<p>​		每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间，<strong>进程切换会涉及到虚拟地址空间的切换，而这正是导致进程切换比线程切换慢的原因所在</strong>！</p>
<p>​		每次访问内存，都需要进行虚拟地址到物理地址的转换，对吧，因此，每条指令进行一两次或更多地去访问页表是必要的，而页表又是存在于内存中的。</p>
<p>​		显然，访问页表（内存）次数太多导致其成为了操作系统地一个性能瓶颈，我们得想个法子解决它，于是，转换检测缓冲区（Translation Lookaside Buffer，<strong>TLB</strong>）应运而生，也称为<strong>快表</strong></p>
<p>​		为啥说他快呢？因为 TLB 通常内置在 CPU 的 MMU 中，这访问速度跟内存不是一个档次的。内存中的页表一般被称为<strong>慢表</strong>。</p>
<p>​		事实上，TLB 的出现是基于这样一种现象的：大多数程序总是对少量的页面进行多次的访问。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。TLB 中存放的就是那些会被反复读取的页表项。换句话说，TLB 中存放的就是页表中的一部分副本。<strong>若 TLB 命中，就不需要再访问内存了</strong>；若 TLB 中没有目标页表项，则还需要去查询内存中的页表（慢表），从页表中得到物理页框地址，同时将页表中的该表项添加到 TLB 中。</p>
<blockquote>
<p>简单理解，TLB 就相当于一个缓存</p>
</blockquote>
<p>​		由于进程切换会涉及到虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。</p>
<p>​		而线程切换呢，由于不涉及虚拟地址空间的切换，也就不存在这个问题了。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="clpsh979f001mxgvscu79d4i2" data-title="操作系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/11/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-12-11T14:58:18.000Z" itemprop="datePublished">2021-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/11/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h2><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now        立刻关机</span><br><span class="line">shutdown -h 5          5分钟后关机</span><br><span class="line">poweroff               立刻关机</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now       立刻重启</span><br><span class="line">shutdown -r 5         5分钟后重启</span><br><span class="line">reboot                立刻重启</span><br></pre></td></tr></table></figure>

<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--help命令</span><br><span class="line">  shutdown --help：</span><br><span class="line">  ifconfig  --help：查看网卡信息</span><br><span class="line"> </span><br><span class="line">--man命令（命令说明书） </span><br><span class="line">  man shutdown</span><br><span class="line">  注意：man shutdown打开命令说明书之后，使用按键q退出</span><br></pre></td></tr></table></figure>

<h2 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--cd命令</span><br><span class="line">  cd /           切换到根目录</span><br><span class="line">  cd /usr        切换到根目录下的usr目录</span><br><span class="line">  cd ../         切换到上一级目录 或者  cd ..</span><br><span class="line">  cd ~           切换到home目录</span><br><span class="line">  cd -           切换到上次访问的目录</span><br></pre></td></tr></table></figure>

<h2 id="目录查看"><a href="#目录查看" class="headerlink" title="目录查看"></a>目录查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--ls [-al]命令</span><br><span class="line">  ls               查看当前目录下的所有目录和文件</span><br><span class="line">  ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">  ls -l 或 ll      列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class="line">  ls /dir          查看指定目录下的所有目录和文件   如：ls /usr</span><br></pre></td></tr></table></figure>

<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--mkdir命令</span><br><span class="line">  mkdir aaa          在当前目录下创建一个名为aaa的目录</span><br><span class="line">  mkdir /usr/aaa     在指定目录下创建一个名为aaa的目录</span><br></pre></td></tr></table></figure>

<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--rm命令</span><br><span class="line">	touch testFile  在当前目录下创建一个名为testFile的文件</span><br></pre></td></tr></table></figure>

<h3 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--rm命令</span><br><span class="line"></span><br><span class="line">删除文件：</span><br><span class="line">    rm 文件        删除当前目录下的文件</span><br><span class="line">    rm -f 文件     删除当前目录的的文件（不询问）</span><br><span class="line"></span><br><span class="line">删除目录：</span><br><span class="line">    rm -r aaa      递归删除当前目录下的aaa目录</span><br><span class="line">    rm -rf aaa     递归删除当前目录下的aaa目录（不询问）</span><br><span class="line"></span><br><span class="line">全部删除：</span><br><span class="line">    rm -rf *      将当前目录下的所有目录和文件全部删除</span><br><span class="line">    rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class="line"></span><br><span class="line">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</span><br></pre></td></tr></table></figure>

<h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--cat命令</span><br><span class="line">    cat a.java		查看a.java文件的最后一页内容；</span><br><span class="line"></span><br><span class="line">--more命令    </span><br><span class="line">    more a.java		从第一页开始查看a.java文件内容，按回车键一行一行进行查看，</span><br><span class="line">                        按空格键一页一页进行查看，q退出；             </span><br><span class="line"></span><br><span class="line">--less命令</span><br><span class="line">    less a.java		从第一页开始查看a.java文件内容，按回车键一行一行的看，</span><br><span class="line">                        按空格键一页一页的看，支持使用PageDown和PageUp翻页，q退出；</span><br><span class="line">                        </span><br><span class="line">总结下more和less的区别:</span><br><span class="line">    1、less可以按键盘上下方向键显示上下内容，more不能通过上下方向键控制显示</span><br><span class="line">    2、less不必读整个文件，加载速度会比more更快</span><br><span class="line">    3、less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容.</span><br></pre></td></tr></table></figure>

<h2 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--tail命令</span><br><span class="line">  -n  是显示行号；相当于nl命令；例子如下：</span><br><span class="line">    tail -100f test.log      实时监控100行日志</span><br><span class="line">    tail  -n  10  test.log   查询日志尾部最后10行的日志;</span><br><span class="line">	tail -n +10 test.log    查询10行之后的所有日志;</span><br><span class="line"></span><br><span class="line">--head命令 </span><br><span class="line">    跟tail是相反的，tail是看后多少行日志；例子如下：</span><br><span class="line">    head -n 10  test.log   查询日志文件中的头10行日志;</span><br><span class="line">    head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;</span><br><span class="line"></span><br><span class="line">--cat命令 </span><br><span class="line">    tac是倒序查看，是cat单词反写；例子如下：</span><br><span class="line">	cat -n test.log |grep &quot;debug&quot;   查询关键字的日志</span><br></pre></td></tr></table></figure>

<h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--grep命令</span><br><span class="line">    grep under 123.txt			在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">    grep -n under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br><span class="line">    grep -v under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示没搜索到的行；</span><br><span class="line">    grep -i under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">    grep -ni under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br></pre></td></tr></table></figure>

<h2 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--chomd命令</span><br><span class="line">    chmod u+x web.xml （---x------）		为文件拥有者（user）添加执行权限；</span><br><span class="line">    chmod g+x web.xml （------x---）		为文件拥有者所在组（group）添加执行权限；</span><br><span class="line">    chmod 111 web.xml  （---x--x--x）	为所有用户分类，添加可执行权限；</span><br><span class="line">    chmod 222 web.xml （--w--w--w-）		为所有用户分类，添加可写入权限；	</span><br><span class="line">    chmod 444 web.xml （-r--r--r--）		为所有用户分类，添加可读取权限；</span><br></pre></td></tr></table></figure>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="静态查看进程"><a href="#静态查看进程" class="headerlink" title="静态查看进程"></a>静态查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps aux #查看进程使用情况</span><br><span class="line">ps aux | less # 查看进程使用情况，考虑到显示过多，使用分管符和less命令查看</span><br><span class="line">ps aux --sort CPU #查看进程使用情况，并按照CPU的使用率升序排列</span><br><span class="line">ps aux --sort -CPU #查看进程使用情况，并按照CPU的使用率降序排列</span><br><span class="line">ps aux --sort rss #查看进程使用情况，并按照内存的使用升序排列</span><br><span class="line">ps aux --sort -rss  #查看进程使用情况，并按照内存的使用降序排列</span><br><span class="line">ps -ef | grep XXX #查看指定的进程是否开启</span><br><span class="line">ps axo user,pid,ppid……  #查看进程，并且只查看后面列举出的信息</span><br></pre></td></tr></table></figure>

<h3 id="动态查看进程"><a href="#动态查看进程" class="headerlink" title="动态查看进程"></a>动态查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top -d 1       # -d 表示刷新的时间间隔，单位为s</span><br><span class="line">top -p 100     # -p 表示查看指定PID的进程</span><br><span class="line">top -n 3 &gt;123.txt   # -n 表示top刷新指定次数后退出</span><br><span class="line">top -u nginx   # -u 表示查看指定用户的进程</span><br></pre></td></tr></table></figure>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/11/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="clpsh97960008xgvsebpkbuld" data-title="Linux操作系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-牛客网编程遇到的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-12-08T08:23:10.000Z" itemprop="datePublished">2021-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">牛客网编程遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h6 id="问题：数据处理"><a href="#问题：数据处理" class="headerlink" title="问题：数据处理"></a>问题：数据处理</h6><p>问题描述：小明周末在家闲得没事，统计出了自己朋友的名字、性别、年龄、爱好。然后，他将数据交给你，想请你帮忙算个数。</p>
<p><strong>输入描述：</strong>该数据的第 <code>1</code> 行表示性别限制，第 <code>2</code> 行表示年龄下限（包含），第 <code>3</code> 行表示年龄上限（包含），第 <code>4</code> 行表示爱好限制。之后的每行数据是每个人的名字、性别、年龄、爱好，用逗号隔开。注意某些行的前面可能加上了&#x2F;&#x2F;字符，表示该行数据被注释掉了，需要忽略。你需要算出「是第 1 行性别的人数」、「处于第 <code>2</code>, <code>3</code> 行年龄范围的人数」、「拥有第 <code>4</code> 行爱好的人数」，再将三个人数相加，算出结果。</p>
<p><strong>输出描述：</strong>上面的数据样例表示，他想请你帮忙数出第 <code>5</code> 行到第 <code>8</code> 行数据中：<br>有多少男性（<code>male</code>）。（结果是 <code>2</code> 。）有多少年龄在 <code>16-19</code> 岁（包含）。（结果是 <code>2</code> 。）有多少喜欢游泳（<code>swimming</code>）。（结果是 <code>1</code> 。）将三个数据相加，算出结果，是 <code>2 + 2 + 1 = 5</code>。答案是 <code>5</code> 。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/AC_S0TL%7BQIPETV4[R%7BYN]49.png"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> in.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> in.next();</span><br><span class="line">        in.nextLine(); <span class="comment">//读掉hobby后面的换行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">infos</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (!infos.startsWith(<span class="string">&quot;//&quot;</span>)) &#123;<span class="comment">//如果不是 // 开头则进行处理</span></span><br><span class="line">                String[] info = infos.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (gender.equals(info[<span class="number">1</span>])) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(info[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (age &gt;= min &amp;&amp; age &lt;= max) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hobby.equals(info[<span class="number">3</span>])) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在本地编译器时，是永远都不会停下里的，结果如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/7Q2%60EW9QDEP3VO]Q45G1[4P.png"></p>
<p>首先先说明为什么这个 <code>in.hasNextLine()</code> 会结束，本人在考试期间测试过一个代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> in.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> in.next();</span><br><span class="line">        in.nextLine(); <span class="comment">//读掉hobby后面的换行</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">infos</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            System.out.println(infos);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思就是把输入的内容读取出来，再打印出来，看一下 <code>while </code>循环是否能退出，输入内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">female</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">dancing</span><br><span class="line">Anthony,male,49,swimming</span><br><span class="line">// Tonny,male,23,dancing</span><br><span class="line">Mike,male,19,swimming</span><br><span class="line">Amy,female,23,chatting</span><br><span class="line">Patrick,male,15,dancing</span><br><span class="line">// Erik,male,14,nothing</span><br><span class="line">Taylor,female,20,singing</span><br></pre></td></tr></table></figure>

<p>输出内容我在考试期间未设定，控制台中打印了如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Anthony,male,49,swimming</span><br><span class="line">// Tonny,male,23,dancing</span><br><span class="line">Mike,male,19,swimming</span><br><span class="line">Amy,female,23,chatting</span><br><span class="line">Patrick,male,15,dancing</span><br><span class="line">// Erik,male,14,nothing</span><br><span class="line">Taylor,female,20,singing</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这最后一个 <code>0</code> 可能代表的就是输入完毕 ，随后我又测试了一下在 <code>while</code> 循环后面能否打印输出内容 ，测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> in.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> in.next();</span><br><span class="line">        in.nextLine(); <span class="comment">//读掉hobby后面的换行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">infos</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            System.out.println(infos);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试控制台输出如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Anthony,male,49,swimming</span><br><span class="line">// Tonny,male,23,dancing</span><br><span class="line">Mike,male,19,swimming</span><br><span class="line">Amy,female,23,chatting</span><br><span class="line">Patrick,male,15,dancing</span><br><span class="line">// Erik,male,14,nothing</span><br><span class="line">Taylor,female,20,singing</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这个 <code>2</code> 的输出表明牛客 的 <code>ide</code> ，在输入结束时 <code>Scanner</code> 的 <code>hasNextLine()</code> 可以正常退出，而我们不需要做其他特殊操作，故采用之前的代码便能通过全部 样例</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/08/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="clpsh979l002rxgvsd381389g" data-title="牛客网编程遇到的问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常见的设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-12-03T14:18:15.000Z" itemprop="datePublished">2021-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">常见的设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>说明：本篇博客主要借鉴传智播客的设计模式课程资料与菜鸟编程网站资料 <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-intro.html%E3%80%82">https://www.runoob.com/design-pattern/design-pattern-intro.html。</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="软件设计模式的概念"><a href="#软件设计模式的概念" class="headerlink" title="软件设计模式的概念"></a>软件设计模式的概念</h3><blockquote>
<p>​	软件设计模式（<code>Software Design Pattern</code>），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</blockquote>
<h3 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 <code>GOF</code>（四人帮，全拼 <code>Gang of Four</code>）？</h3><blockquote>
<p>​	在 <code>1994</code> 年，由 <code>Erich Gamma、Richard Helm、Ralph Johnson</code> 和 <code>John Vlissides</code> 四人合著出版了一本名为 <strong><code>Design Patterns - Elements of Reusable Object-Oriented Software</code>（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>​	四位作者合称 <strong><code>GOF</code>（四人帮，全拼 <code>Gang of Four</code>）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
</blockquote>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><blockquote>
<table>
<thead>
<tr>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式</strong>（<code>Factory Pattern</code>）<strong>抽象工厂模式</strong>（<code>Abstract Factory Pattern</code>）<strong>单例模式</strong>（<code>Singleton Pattern</code>）建造者模式（<code>Builder Pattern</code>）原型模式（<code>Prototype Pattern</code>）</td>
</tr>
<tr>
<td align="left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left">适配器模式（<code>Adapter Pattern</code>）桥接模式（<code>Bridge Pattern</code>）过滤器模式（<code>Filter、Criteria Pattern</code>）组合模式（<code>Composite Pattern</code>）<strong>装饰器模式</strong>（<code>Decorator Pattern</code>）外观模式（<code>Facade Pattern</code>）享元模式（<code>Flyweight Pattern</code>）代理模式（<code>Proxy Pattern</code>）</td>
</tr>
<tr>
<td align="left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td>
<td align="left">责任链模式（<code>Chain of Responsibility Pattern</code>）命令模式（<code>Command Pattern</code>）解释器模式（<code>Interpreter Pattern</code>）迭代器模式（<code>Iterator Pattern</code>）中介者模式（<code>Mediator Pattern</code>）备忘录模式（<code>Memento Pattern</code>）<strong>观察者模式</strong>（<code>Observer Pattern</code>）状态模式（<code>State Pattern</code>）空对象模式（<code>Null Object Pattern</code>）<strong>策略模式</strong>（<code>Strategy Pattern</code>）模板模式（<code>Template Pattern</code>）访问者模式（<code>Visitor Pattern</code>）</td>
</tr>
</tbody></table>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/the-relationship-between-design-patterns.jpg"></p>
</blockquote>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><blockquote>
<p>统一建模语言（<code>Unified Modeling Language，UML</code>）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p><code>UML</code> 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 <code>9</code> 种图。</p>
</blockquote>
<h3 id="类图概述"><a href="#类图概述" class="headerlink" title="类图概述"></a>类图概述</h3><blockquote>
<p>类图(<code>Class diagram</code>)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
</blockquote>
<h3 id="类图的作用"><a href="#类图的作用" class="headerlink" title="类图的作用"></a>类图的作用</h3><blockquote>
<ul>
<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>
<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>
</ul>
</blockquote>
<h3 id="类图表示法"><a href="#类图表示法" class="headerlink" title="类图表示法"></a>类图表示法</h3><h4 id="类的表示方式"><a href="#类的表示方式" class="headerlink" title="类的表示方式"></a>类的表示方式</h4><blockquote>
<p>在 <code>UML</code> 类图中，类使用包含类名、属性(<code>field</code>) 和方法(<code>method</code>) 且带有分割线的矩形来表示，比如下图表示一个<code>Employee</code>类，它包含<code>name</code>,<code>age</code>和<code>address</code>这<code>3</code>个属性，以及<code>work()</code>方法。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/Employee.jpg"></p>
<p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，<code>UML</code> 类图中表示可见性的符号有三种：</p>
<ul>
<li><p>+：表示 <code>public</code></p>
</li>
<li><p>-：表示 <code>private</code></p>
</li>
<li><p>#：表示 <code>protected</code></p>
</li>
</ul>
<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong>  </p>
<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>
<p>注意：</p>
<p>​	1，中括号中的内容表示是可选的</p>
<p>​	2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>
<p><strong>举个例子：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/demo.png"></p>
<p>上图 <code>Demo</code> 类定义了三个方法：</p>
<ul>
<li><code>method()</code>方法：修饰符为 <code>public</code>，没有参数，没有返回值。</li>
<li><code>method1()</code>方法：修饰符为 <code>private</code>，没有参数，返回值类型为 <code>String</code>。</li>
<li><code>method2()</code>方法：修饰符为 <code>protected</code>，接收两个参数，第一个参数类型为 <code>int</code>，第二个参数类型为 <code>String</code>，返回值类型是 <code>int</code>。</li>
</ul>
</blockquote>
<h4 id="类与类之间关系的表示方式"><a href="#类与类之间关系的表示方式" class="headerlink" title="类与类之间关系的表示方式"></a>类与类之间关系的表示方式</h4><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><blockquote>
<p>​	关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>​	一般关联又可以分为单向关联，双向关联，自关联。</p>
</blockquote>
<h6 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h6><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/customer_address.png"></p>
<p>​	在 <code>UML </code>类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让 <code>Customer</code> 类持有一个类型为<code>Address</code> 的成员变量类实现。</p>
</blockquote>
<h6 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h6><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/customer_product.png"></p>
<p>​	从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>
<p>​	在 <code>UML</code> 类图中，双向关联用一个不带箭头的直线表示。上图中在 <code>Customer</code> 类中维护一个 <code>List\&lt;Product&gt;</code> ，表示一个顾客可以购买多个商品；在 <code>Product</code> 类中维护一个 <code>Customer</code> 类型的成员变量表示这个产品被哪个顾客所购买。</p>
</blockquote>
<h6 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h6><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/node.png"></p>
<p>自关联在 <code>UML</code>c类图中用一个带有箭头且指向自身的线表示。上图的意思就是 <code>Node</code> 类包含类型为 <code>Node</code> 的成员变量，也就是“自己包含自己”。</p>
</blockquote>
<h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><blockquote>
<p>​	聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>
<p>​	聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>​	在 <code>UML</code> 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/image-20191229173422328.png"></p>
</blockquote>
<h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><blockquote>
<p>​	组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>
<p>​	在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>​	在 <code>UML</code> 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/image-20191229173455149.png"></p>
</blockquote>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><blockquote>
<p>​	依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>​	在 <code>UML</code> 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/image-20191229173518926.png"></p>
</blockquote>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><blockquote>
<p>​	继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>
<p>​	在 <code>UML</code> 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，<code>Student</code> 类和 <code>Teacher</code> 类都是 <code>Person</code> 类的子类，其类图如下图所示：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/image-20191229173539838.png"></p>
</blockquote>
<h5 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h5><blockquote>
<p>​	实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>​	在 <code>UML</code> 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图所示。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/image-20191229173554296.png"></p>
</blockquote>
<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><blockquote>
<p>​	在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
</blockquote>
<h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则 (Single Responsibility Principle)"></a>单一职责原则 (<code>Single Responsibility Principle</code>)</h3><blockquote>
<p>​	一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>
<p><strong>问题由来：</strong>类T负责两个不同的职责：职责<code>P1</code>，职责<code>P2</code>。当由于职责<code>P1</code>需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责<code>P2</code>功能发生故障。</p>
<p><strong>解决方案：</strong>遵循单一职责原则。分别建立两个类<code>T1</code>、<code>T2</code>，使<code>T1</code>完成职责<code>P1</code>功能，<code>T2</code>完成职责<code>P2</code>功能。这样，当修改类<code>T1</code>时，不会使职责<code>P2</code>发生故障风险；同理，当修改<code>T2</code>时，也不会使职责<code>P1</code>发生故障风险。</p>
<p><strong>举例：</strong>类T只负责一个职责<code>P</code>，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责<code>P</code>细分为粒度更细的职责<code>P1</code>，<code>P2</code>，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类<code>T1</code>和<code>T2</code>，分别负责<code>P1</code>、<code>P2</code>两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类<code>T</code>，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责<code>P</code>，在未来可能会扩散为<code>P1，P2，P3，P4……Pn</code>。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<p>举例说明，用一个类描述动物呼吸这个场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">        牛呼吸空气</span><br><span class="line">        羊呼吸空气</span><br><span class="line">        猪呼吸空气</span><br></pre></td></tr></table></figure>

<p>​	程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将<code>Animal</code>类细分为陆生动物类<code>Terrestrial</code>，水生动物<code>Aquatic</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Terrestrial</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aquatic</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸水&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Terrestrial</span> <span class="variable">terrestrial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Terrestrial</span>();</span><br><span class="line">		terrestrial.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		terrestrial.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		terrestrial.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Aquatic</span> <span class="variable">aquatic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aquatic</span>();</span><br><span class="line">		aquatic.breathe(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">        牛呼吸空气</span><br><span class="line">        羊呼吸空气</span><br><span class="line">        猪呼吸空气</span><br><span class="line"></span><br><span class="line">        鱼呼吸水</span><br></pre></td></tr></table></figure>

<p>​	我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;鱼&quot;</span>.equals(animal))&#123;</span><br><span class="line">			System.out.println(animal+<span class="string">&quot;呼吸水&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>​	可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改<code>Animal</code>类的<code>breathe</code>方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe2</span><span class="params">(String animal)</span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸水&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">		animal.breathe2(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>​	可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>​	例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<p><strong>优点：</strong></p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
</blockquote>
<h3 id="开放-关闭原则-Open-Closed-Principle"><a href="#开放-关闭原则-Open-Closed-Principle" class="headerlink" title="开放-关闭原则 (Open-Closed Principle)"></a>开放-关闭原则 (<code>Open-Closed Principle</code>)</h3><blockquote>
<p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>能够扩展已存在的系统，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</p>
</li>
<li><p>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</p>
</li>
</ul>
<p><strong>举例：</strong>有个生产电脑的公司，根据输入的类型，生产出不同的电脑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Macbook</span> <span class="keyword">implements</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Surface</span> <span class="keyword">implements</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">produceComputer</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="title class_">Macbook</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="title class_">Surface</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的代码违背了开放 - 关闭原则，如果需要添加新的电脑产品，那么修改 produceComputer 原本已有的方法，正确的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Macbook</span> <span class="keyword">implements</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Surface</span> <span class="keyword">implements</span> <span class="title class_">Computer</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">produceComputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">produceComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Macbook</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MSFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">produceComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Surface</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的方式应该是将 <code>Factory</code> 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p>
</blockquote>
<h3 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 (Liskov Substitution Principle)"></a>里氏替换原则 (<code>Liskov Substitution Principle</code>)</h3><blockquote>
<p>定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<ul>
<li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</p>
</li>
<li><p>子类中可以增加自己特有的方法</p>
</li>
<li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</p>
</li>
<li><p>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</p>
<p>里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</strong>例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>
<p>例如：有两个类，一个类为<code>BaseClass</code>，另一个是<code>SubClass</code>类，并且<code>SubClass</code>类是<code>BaseClass</code>类的子类，那么一个方法如果可以接受一个<code>BaseClass</code>类型的基类对象<code>base</code>的话，如：<code>method1(base)</code>，那么它必然可以接受一个<code>BaseClass</code>类型的子类对象<code>sub</code>，<code>method1(sub)</code>能够正常运行。反过来的代换不成立，如一个方法<code>method2</code>接受<code>BaseClass</code>类型的子类对象sub为参数：<code>method2(sub)</code>，那么一般而言不可以有<code>method2(base)</code>，除非是重载方法。</p>
<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p>
</li>
</ul>
<p>举例：继承的风险，我们需要完成一个两数相减的功能，由类<code>A</code>来负责。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a-b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100-80=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">        <span class="number">100</span>-<span class="number">50</span>=<span class="number">50</span></span><br><span class="line">        <span class="number">100</span>-<span class="number">80</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与<code>100</code>求和，由类<code>B</code>来负责。即类<code>B</code>需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加<code>100</code>。</li>
</ul>
<p>由于类<code>A</code>已经实现了第一个功能，所以类<code>B</code>继承类<code>A</code>后，只需要再完成第二个功能就可以了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100-80=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100+20+100=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类B完成后，运行结果：</span><br><span class="line">        <span class="number">100</span>-<span class="number">50</span>=<span class="number">150</span></span><br><span class="line">        <span class="number">100</span>-<span class="number">80</span>=<span class="number">180</span></span><br><span class="line">        <span class="number">100</span>+<span class="number">20</span>+<span class="number">100</span>=<span class="number">220</span></span><br></pre></td></tr></table></figure>

<p>​	我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类<code>B</code>重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类<code>A</code>完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
</blockquote>
<h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（<code>Dependence Inversion Principle</code>）</h3><blockquote>
<ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li>
<li>依赖倒转（倒置）的中心思想是<strong>面向接口编程</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在<code>java</code>中，抽象指的是接口或抽象类，细节就是具体的实现类。</li>
<li>使用<strong>接口或抽象类</strong>的目的是<strong>制定好规范</strong>，而不涉及任何具体的操作，把<strong>展现细节的任务交给他们的实现类</strong>去完成。</li>
</ul>
<h4 id="依赖倒置原则，究竟倒置在哪里？"><a href="#依赖倒置原则，究竟倒置在哪里？" class="headerlink" title="依赖倒置原则，究竟倒置在哪里？"></a>依赖倒置原则，究竟倒置在哪里？</h4><p>​	<strong>在依赖倒置原则中的倒置指的是和一般设计的思考方式完全相反。</strong></p>
<p>​	举个例子，现在你需要实现一个比萨店，你第一件想到的事情是什么？我想到的是一个比萨店，里面有很多具体的比萨，如：芝士比萨、素食比萨、海鲜比萨……<br>​	比萨店是上层模块，比萨是下层模块，如果把比萨店和它依赖的对象画成一张图，看起来是这样：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/9571610-1970cb0205d4a656.webp"></p>
<p>​	没错！先从顶端开始，然后往下到具体类，但是，正如你看到的你不想让比萨店理会这些具体类，要不然比萨店将全都依赖这些具体类。现在“倒置”你的想法……别从上层模块比萨店开始思考，而是从下层模块比萨开始，然后想想看能抽象化些什么。你可能会想到，芝士比萨、素食比萨、海鲜比萨都是比萨，所以它们应该共享一个<code>Pizza</code>接口。对了，你想要抽象化一个<code>Pizza</code>。好，现在回头重新思考如何设计比萨店。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/9571610-9917220623b99e19.webp"></p>
<p>​	第一幅图的依赖箭头都是从上往下的，第二幅图的箭头出现了从下往上，依赖关系确实“倒置”了</p>
<p>​	另外，此例子也很好的解释了“上层模块不应该依赖底层模块，它们都应该依赖于抽象。”，在最开始的设计中，高层模块<code>PizzaStroe</code>直接依赖低层模块（各种具体的<code>Pizaa</code>）,调整设计后，高层模块和低层模块都依赖于抽象（<code>Pizza</code>）</p>
</blockquote>
<h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（<code>Interface Segregation Principle</code>）</h3><blockquote>
<ul>
<li>客户端不应该依赖它不需要的接口</li>
<li>类间的依赖关系应该建立在最小的接口上</li>
</ul>
<p>​	其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿不堪。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加轻便灵活。或许看到接口隔离原则这样的定义很多人会觉得和单一职责原则很像，但是这两个原则还是有着很鲜明的区别。<strong>接口隔离原则和单一职责原则的审视角度是不同的，单一职责原则要求类和接口职责单一，注重的是职责，是业务逻辑上的划分，而接口隔离原则要求方法要尽可能的少，是在接口设计上的考虑。例如一个接口的职责包含<code>10</code>个方法，这<code>10</code>个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，并规定了“不使用的方法不能访问”，这样的设计是不符合接口隔离原则的，接口隔离原则要求“尽量使用多个专门的接口”，这里专门的接口就是指提供给每个模块的都应该是单一接口(即每一个模块对应一个接口)，而不是建立一个庞大臃肿的接口来容纳所有的客户端访问。</strong></p>
<p>【例】安全门案例</p>
<p>​	我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png"></p>
<p>​	上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现<code>SafetyDoor</code>接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png"></p>
</blockquote>
<h3 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（<code>Demeter Principle</code>）</h3><blockquote>
<p>​	迪米特法则(<code>Law of Demeter</code>)又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。</p>
<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一类的某一个方法的话，可以通过第三者转发这个调用。</p>
<p>【例】明星与经纪人的关系实例</p>
<p>​	明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99.png"></p>
</blockquote>
<h3 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（<code>Composite Reuse Principle</code>）</h3><blockquote>
<p>​	尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>​	通常类的复用分为继承复用和合成复用两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在类的成员位置声明抽象。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
<p>【例】汽车分类管理程序</p>
<p>​	汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99.png"></p>
<p>​	从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%991.png"></p>
</blockquote>
<h2 id="静态代码块、构造代码块、构造函数、普通代码块"><a href="#静态代码块、构造代码块、构造函数、普通代码块" class="headerlink" title="静态代码块、构造代码块、构造函数、普通代码块"></a>静态代码块、构造代码块、构造函数、普通代码块</h2><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><blockquote>
<p>​	在<code>java</code>类中（方法中不能存在静态代码块）使用<code>static</code>关键字和<code>&#123;&#125;</code>声明的代码块：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h4><blockquote>
<p>　　静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序依次执行。后面在比较的时候会通过具体实例来证明。</p>
</blockquote>
<h4 id="静态代码块的作用"><a href="#静态代码块的作用" class="headerlink" title="静态代码块的作用"></a>静态代码块的作用</h4><blockquote>
<p>　　一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</p>
</blockquote>
<h4 id="静态代码块不能存在任何方法体中"><a href="#静态代码块不能存在任何方法体中" class="headerlink" title="静态代码块不能存在任何方法体中"></a>静态代码块不能存在任何方法体中</h4><blockquote>
<p>　　这个应该很好理解，首先我们要明确静态代码块是在类加载的时候就要运行了。我们分情况讨论：</p>
<p>　　对于普通方法，由于普通方法是通过加载类，然后new出实例化对象，通过对象才能运行这个方法，而静态代码块只需要加载类之后就能运行了。</p>
<p>　　对于静态方法，在类加载的时候，静态方法也已经加载了，但是我们必须要通过类名或者对象名才能访问，也就是说相比于静态代码块，静态代码块是主动运行的，而静态方法是被动运行的。</p>
<p>　　不管是哪种方法，我们需要明确静态代码块的存在在类加载的时候就自动运行了，而放在不管是普通方法还是静态方法中，都是不能自动运行的。</p>
</blockquote>
<h4 id="静态代码块不能访问普通变量"><a href="#静态代码块不能访问普通变量" class="headerlink" title="静态代码块不能访问普通变量"></a>静态代码块不能访问普通变量</h4><blockquote>
<p>　　这个理解思维同上，普通变量只能通过对象来调用，是不能放在静态代码块中的。</p>
</blockquote>
<h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><blockquote>
<p>　　在<code>java</code>类中使用<code>&#123;&#125;</code>声明的代码块（和静态代码块的区别是少了<code>static</code>关键字）:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行时机-1"><a href="#执行时机-1" class="headerlink" title="执行时机"></a>执行时机</h4><blockquote>
<p>　　构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，听名字我们就知道，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。怎么理解呢？我们看看下面这段代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　我们反编译生成的<code>class</code>文件：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1120165-20180104181114674-1561697917.png"></p>
<blockquote>
<p><strong>如果存在多个构造代码块，则执行顺序按照书写顺序依次执行。</strong></p>
</blockquote>
<h4 id="构造代码块的作用"><a href="#构造代码块的作用" class="headerlink" title="构造代码块的作用"></a>构造代码块的作用</h4><blockquote>
<p>​	和构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。但是反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数）。</p>
<p>​	利用每次创建对象的时候都会提前调用一次构造代码块特性，我们可以做诸如统计创建对象的次数等功能。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>​	构造函数的命名必须和类名完全相同。在<code>java</code>中普通函数可以和构造函数同名，但是必须带有返回值；</p>
<p>​	构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用<code>void</code>来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是<code>void</code>返回值。尽管方法体本身不会自动返回什么，但仍然可以让它返回一些东西，而这些东西可能是不安全的；</p>
<p>​	构造函数不能被直接调用，必须通过<code>new</code>运算符在创建对象时才会自动调用；而一般的方法是在程序执行到它的时候被调用的；</p>
<p>​	当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略，不过<code>Java</code>编译器会提供一个默认的构造函数，此默认构造函数是不带参数的,而一般的方法不存在这一特点；</p>
</blockquote>
<h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><blockquote>
<p>​	普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><blockquote>
<p><strong>静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块</strong>　</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了main方法&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlock</span>().sayHello();;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlock</span>().sayHello();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反编译生成的<code>class</code>文件：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1120165-20180104191946799-1728553747.png"></p>
<p>　　<strong>执行结果：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1120165-20180104192057253-11181881.png"></p>
<blockquote>
<p> 我们创建了两个匿名对象，但是静态代码块只是调用了一次。</p>
</blockquote>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">(String system)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有参构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我在 main 啥也不是&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="type">CodeBlock</span> <span class="variable">codeBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是 普通方法 里 啥也不是&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;气不气，我是第二个构造代码块，但是在所有方法在下面&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;气不气，我是第二个静态代码块，但是在所有方法在下面&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">气不气，我是第二个静态代码块，但是在所有方法在下面</span><br><span class="line">我在 main 啥也不是</span><br><span class="line">我是 普通方法 里 啥也不是</span><br><span class="line">普通代码块</span><br><span class="line">构造代码块</span><br><span class="line">气不气，我是第二个构造代码块，但是在所有方法在下面</span><br><span class="line">无参构造函数</span><br></pre></td></tr></table></figure>

<h3 id="父类和子类执行顺序"><a href="#父类和子类执行顺序" class="headerlink" title="父类和子类执行顺序"></a>父类和子类执行顺序</h3><blockquote>
<p>　　对象的初始化顺序：</p>
<p>　　首先执行父类静态的内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有构造代码块，如果有就执行父类的构造代码块，父类的构造代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有构造代码块，如果有就执行子类的构造代码块。子类的构造代码块执行完毕再去执行子类的构造方法。</p>
<p>　　总之一句话，静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法。</p>
</blockquote>
<p>　　父类：<code>SuperClass.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.extend;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　子类：<code>SubClass.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.extend;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　打印结果：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img/1120165-20180104193548237-277863554.png"></p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p><strong>定义：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p><strong>应用实例：</strong></p>
<ul>
<li>一个班级只有一个班主任。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 <code>I/O</code> 与数据库的连接等。</li>
</ul>
<p><strong>注意事项：</strong><code>getInstance()</code> 方法中需要使用同步锁 <code>synchronized (Singleton.class)</code> 防止多线程同时进入造成 <code>instance</code> 被多次实例化。</p>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
</blockquote>
<h4 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h4><blockquote>
<p>单例设计模式分类两种：</p>
<p>​	饿汉式：类加载就会导致该单实例对象被创建	</p>
<p>​	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<h5 id="饿汉式-方式1（静态变量方式）"><a href="#饿汉式-方式1（静态变量方式）" class="headerlink" title="饿汉式-方式1（静态变量方式）"></a>饿汉式-方式1（静态变量方式）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	该方式在成员位置声明<code>Singleton</code>类型的静态变量，并创建<code>Singleton</code>类的对象<code>instance</code>。<code>instance</code>对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p>
</blockquote>
<h5 id="饿汉式-方式2（静态代码块方式）"><a href="#饿汉式-方式2（静态代码块方式）" class="headerlink" title="饿汉式-方式2（静态代码块方式）"></a>饿汉式-方式2（静态代码块方式）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恶汉式</span></span><br><span class="line"><span class="comment"> *      在静态代码块中创建该类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	该方式在成员位置声明<code>Singleton</code>类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式<code>1</code>基本上一样，当然该方式也存在内存浪费问题。</p>
</blockquote>
<h5 id="懒汉式-方式1（线程不安全）"><a href="#懒汉式-方式1（线程不安全）" class="headerlink" title="懒汉式-方式1（线程不安全）"></a>懒汉式-方式1（线程不安全）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	从上面代码我们可以看出该方式在成员位置声明<code>Singleton</code>类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用<code>getInstance()</code>方法获取<code>Singleton</code>类的对象的时候才创建<code>Singleton</code>类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p>
</blockquote>
<h5 id="懒汉式-方式2（线程安全）"><a href="#懒汉式-方式2（线程安全）" class="headerlink" title="懒汉式-方式2（线程安全）"></a>懒汉式-方式2（线程安全）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在<code>getInstance()</code>方法上添加了<code>synchronized</code>关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化<code>instance</code>的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p>
</blockquote>
<p><strong>双重检查加锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="懒汉式-方式3（双重检查锁）"><a href="#懒汉式-方式3（双重检查锁）" class="headerlink" title="懒汉式-方式3（双重检查锁）"></a>懒汉式-方式3（双重检查锁）</h5><blockquote>
<p>​	再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是<code>JVM</code>在实例化对象的时候会进行优化和指令重排序操作。</p>
</blockquote>
<blockquote>
<p>​	要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">小结：</font></p>
<blockquote>
<p>​	添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
</blockquote>
<h5 id="懒汉式-方式4（静态内部类方式）"><a href="#懒汉式-方式4（静态内部类方式）" class="headerlink" title="懒汉式-方式4（静态内部类方式）"></a>懒汉式-方式4（静态内部类方式）</h5><blockquote>
<p>​	静态内部类单例模式中实例由内部类创建，由于 <code>JVM</code> 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	第一次加载<code>Singleton</code>类时不会去初始化<code>INSTANCE</code>，只有第一次调用<code>getInstance</code>，虚拟机加载<code>SingletonHolder</code>，并初始化<code>INSTANCE</code>，这样不仅能确保线程安全，也能保证 <code>Singleton</code> 类的唯一性。</p>
</blockquote>
<p><font color="red">小结：</font></p>
<blockquote>
<p>​	静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
</blockquote>
<h5 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h5><blockquote>
<p>​	枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>说明：</font></p>
<blockquote>
<p>​	枚举方式属于饿汉式方式。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p>​	由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br>​	<code>Java</code>中的代理按照代理类生成时机不同又分为静态代理和动态代理。<strong>静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成</strong>。动态代理又有<code>JDK</code>代理和<code>CGLib</code>代理两种。</p>
<p>​	代理模式是常用的<code>java</code>设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p>
</blockquote>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><blockquote>
<p>代理（<code>Proxy</code>）模式分为三种角色：</p>
<ul>
<li>抽象主题（<code>Subject</code>）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（<code>Real Subject</code>）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（<code>Proxy</code>）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
</blockquote>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。</p>
<p>类图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img3/%E8%8C%83%E5%BE%B7%E8%90%A8%E5%8F%91%E5%A4%A7%E6%B0%B4%E6%B3%95%E5%9B%BD%E7%88%B1%E5%9B%BD%E7%83%AD%E7%83%AD%E7%89%B9%E6%84%9F%E5%8A%A8sv.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站 火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	从上面代码中可以看出测试类直接访问的是<code>ProxyPoint</code>类对象，也就是说<code>ProxyPoint</code>作为访问对象和目标对象的中介。同时也对<code>sell</code>方法进行了增强（代理点收取一些服务费用）。</p>
</blockquote>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><blockquote>
<p>​	接下来我们使用动态代理实现上面案例，先说说<code>JDK</code>提供的动态代理。<code>Java</code>中提供了一个动态代理类<code>Proxy</code>，<code>Proxy</code>并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（<code>newProxyInstance</code>方法）来获取代理对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p><code>ProxyFactory</code>是代理类吗？</p>
<p><code>ProxyFactory</code>不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 <code>Java </code>诊断工具（<code>Arthas</code>【阿尔萨斯】）查看代理类的结构：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（<code>$Proxy0</code>）实现了<code>SellTickets</code>。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（<code>$Proxy0</code>）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
<p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里是调用了这个方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">              new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;);</span></span><br><span class="line"><span class="comment">                        Object result = method.invoke(station, args);</span></span><br><span class="line"><span class="comment">                        return result;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">	<span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<blockquote>
<ol>
<li>在测试类中通过代理对象调用<code>sell()</code>方法</li>
<li>根据多态的特性，执行的是代理类（<code>$Proxy0</code>）中的<code>sell()</code>方法</li>
<li>代理类（<code>$Proxy0</code>）中的<code>sell()</code>方法中又调用了<code>InvocationHandler</code>接口的子实现类对象的<code>invoke</code>方法</li>
<li><code>invoke</code>方法通过反射执行了真实对象所属类(<code>TrainStation</code>)中的<code>sell()</code>方法</li>
</ol>
</blockquote>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><blockquote>
<p><code>CGLIB（Code Generator Library）</code>是一个强大的、高性能的代码生成库。 </p>
<p>其被广泛应用于<code>AOP</code>框架（<code>Spring</code>）中，用以提供方法拦截操作。 </p>
<p><code>CGLIB</code>代理主要通过对字节码的操作，以控制对象的访问。 </p>
<p><code>CGLIB</code>底层使用了<code>ASM</code>（一个短小精悍的字节码操作框架）来操作字节码生成新的类。 </p>
<p><code>CGLIB</code>相比于<code>JDK</code>动态代理更加强大：    </p>
<p>​	<code>JDK</code>动态代理虽然简单易用，但只能对接口进行代理。    </p>
<p>​	如果要代理的类为一个普通类，没有接口，那么<code>Java</code>动态代理就没法使用了。 </p>
<p><code>Java</code>动态代理使用<code>Java</code>原生的反射<code>API</code>进行操作（运行期），在生成类上比较高效。 <code>CGLIB</code>使用<code>ASM</code>框架直接对字节码进行操作（编译期），在类的执行过程中比较高效</p>
</blockquote>
<h5 id="Enhancer介绍"><a href="#Enhancer介绍" class="headerlink" title="Enhancer介绍"></a>Enhancer介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Enhancer：</span><br><span class="line">    Enhancer既能够代理普通的class，也能够代理接口。</span><br><span class="line">    Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。</span><br><span class="line">    Enhancer不能够拦截<span class="keyword">final</span>类与方法。</span><br><span class="line"></span><br><span class="line">用来设置父类型</span><br><span class="line">Enhancer.setSuperclass(Class superclass);</span><br><span class="line">    </span><br><span class="line">增强</span><br><span class="line">Enhancer.setCallback(Callback callback);</span><br><span class="line">Enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;&#125;);</span><br><span class="line">Enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">方法是用来创建代理对象，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。</span><br><span class="line">Enhancer.create(Class type, Callback callback);</span><br><span class="line">Enhancer.create(Class superclass, Class[] interfaces, Callback callback);</span><br><span class="line">Enhancer.create(Class[] argumentTypes, Object[] arguments);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="Callback介绍"><a href="#Callback介绍" class="headerlink" title="Callback介绍"></a>Callback介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Callback是一个空的接口，在Cglib中它的实现类有以下几种：</span><br><span class="line">    MethodInterceptor</span><br><span class="line">    InvocationHandler</span><br><span class="line"></span><br><span class="line">MethodInterceptor：</span><br><span class="line">    它可以实现类似于AOP编程中的环绕增强（around-advice）。</span><br><span class="line"></span><br><span class="line">    它只有一个方法：</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy)</span></span><br><span class="line"></span><br><span class="line">    代理类的所有方法调用都会转而执行这个接口中的intercept方法而不是原方法。</span><br><span class="line">    如果需要在intercept方法中执行原方法可以使用参数method进行反射调用，</span><br><span class="line">    或者使用参数proxy 一 proxy.invokeSuper(obj, args);</span><br><span class="line">    后者会快一些（反射调用比正常的方法调用的速度慢很多）。</span><br><span class="line">    MethodInterceptor允许我们完全控制被拦截的方法，并且提供了手段对原方法进行调用，</span><br><span class="line"></span><br><span class="line">    因为 MethodInterceptor的效率不高，它需要产生不同类型的字节码，</span><br><span class="line">    并且需要生成一些运行时对象（InvocationHandler就不需要），所以Cglib提供了其它的接口供我们选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InvocationHandler：</span><br><span class="line">    它的使用方式和MethodInterceptor差不多。</span><br><span class="line">    需要注意的一点是，所有对invoke()方法的参数proxy对象的方法调用都会被委托给同一个InvocationHandler，</span><br><span class="line">    所以可能会导致无限循环。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样是上面的案例，我们再次使用<code>CGLIB</code>代理实现。</p>
<p>如果没有定义<code>SellTickets</code>接口，只定义了<code>TrainStation</code>(火车站类)。很显然<code>JDK</code>代理是无法使用了，因为<code>JDK</code>动态代理要求必须定义接口，对接口进行代理。</p>
<p><code>CGLIB</code>是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为<code>JDK</code>的动态代理提供了很好的补充。</p>
</blockquote>
<p><code>CGLIB</code>是第三方提供的包，所以需要引入<code>jar</code>包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><blockquote>
<p><strong>1）、<code>JDK</code>和<code>CGLib</code>的区别</strong></p>
<ul>
<li><code>JDK</code>动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li><code>CGLib</code>是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）</li>
</ul>
<p><strong>2）、<code>Spring</code>在选择用<code>JDK</code>还是<code>CGLib</code>的依据</strong></p>
<ul>
<li>当<code>Bean</code>实现接口时，<code>Spring</code>就会用<code>JDK</code>的动态代理</li>
<li>当<code>Bean</code>没有实现接口时，<code>Spring</code>使用<code>CGLib</code>来实现</li>
<li>可以强制使用<code>CGLib</code>（在<code>Spring</code>配置中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;</code>）</li>
</ul>
<p><strong>3）、<code>JDK</code>和<code>CGLib</code>的性能对比</strong></p>
<ul>
<li>使用<code>CGLib</code>实现动态代理，<code>CGLib</code>底层采用<code>ASM</code>字节码生成框架，使用字节码技术生成代理类，在<code>JDK1.6</code>之前比使用<code>Java</code>反射效率要高。唯一需要注意的是，<code>CGLib</code>不能对声明为<code>final</code>的方法进行代理，因为<code>CGLib</code>原理是动态生成被代理类的子类。</li>
<li>在<code>JDK1.6</code>、<code>JDK1.7</code>、<code>JDK1.8</code>逐步对<code>JDK</code>动态代理优化之后，在调用次数较少的情况下，<code>JDK</code>代理效率高于<code>CGLib</code>代理效率，只有当进行大量调用的时候，<code>JDK1.6</code>和<code>JDK1.7</code>比<code>CGLib</code>代理效率低一点，但是到<code>JDK1.8</code>的时候，<code>JDK</code>代理效率高于<code>CGLib</code>代理。</li>
</ul>
<p>总结：<code>CGLib</code>创建的动态代理对象性能<code>jdk1.6</code>、<code>1.7</code>比<code>JDK</code>创建的动态代理对象的性能高不少，（<code>1.8</code>之后则不如<code>jdk</code>动态代理)，但是<code>CGLib</code>在创建代理对象时所花费的时间却比<code>JDK</code>多得多，所以对于单例的对象，因为无需频繁创建对象，用<code>CGLib</code>合适，反之，使用<code>JDK</code>方式要更为合适一些。同时，由于<code>CGLib</code>由于是采用动态创建子类的方法，对于<code>final</code>方法，无法进行代理。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clpsh979d001bxgvs96mqcsem" data-title="常见的设计模式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-11-25T03:33:06.000Z" itemprop="datePublished">2021-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="问题：Java和C-的区别"><a href="#问题：Java和C-的区别" class="headerlink" title="问题：Java和C++的区别"></a>问题：Java和C++的区别</h1><blockquote>
<ol>
<li><code>Java</code>源码会先经过一次编译，成为中间码，中间码再被解释器解释成机器码。对于<code>Java</code>而言，中间码就是字节码<code>(.class)</code>，而解释器在<code>JVM</code>中内置了。</li>
<li><code>C++</code>源码一次编译，直接在编译的过程中链接了，形成了机器码。</li>
<li><code>C++</code>比<code>Java</code>执行速度快，但是<code>Java</code>可以利用<code>JVM</code>跨平台。</li>
<li><code>C++</code>中有指针，<code>Java</code>中没有，但是有引用。</li>
<li><code>C++</code>支持多继承，<code>Java</code>中类都是单继承的。但是继承都有传递性，同时<code>Java</code>中的接口是多继承，类对接口的实现也是多实现。</li>
<li><code>C++</code>中，开发需要自己去管理内存，但是<code>Java</code>中<code>JVM</code>有自己的<code>GC</code>机制，虽然有自己的<code>GC</code>机制，但是也会出现<code>OOM</code>和内存泄漏的问题。<code>C++</code>中有析构函数，<code>Java</code>中<code>Object</code>的<code>finalize</code>方法。</li>
<li><code>C++</code>运算符可以重载，但是<code>Java</code>中不可以。同时<code>C++</code>中支持强制自动转型，<code>Java</code>中不行，会出现<code>ClassCastException</code>（类型不匹配）。</li>
</ol>
</blockquote>
<h1 id="问题：Java是编译型语言还是解释型语言"><a href="#问题：Java是编译型语言还是解释型语言" class="headerlink" title="问题：Java是编译型语言还是解释型语言"></a>问题：Java是编译型语言还是解释型语言</h1><blockquote>
<p>​	由<code>Java</code>的代码执行过程 ，一个<code>Java</code> 代码的执行过程是由</p>
<p><code>.Java</code>–&gt;<code>.class</code>–&gt;<code>对应平台机器码</code>; <code>.Java</code>–&gt;<code>.class</code>是由 <code>Javac</code> 编译，这个过程符合编译型语言的特点（一次性编译，注意 并未编译为实际平台的机器码）</p>
<p><code>.class</code>–&gt;<code>对应平台机器码</code>的这一过程是由<code>JVM</code>解释执行（逐行解释为特定平台机器码）这一过程符合解释语言的特点 ；</p>
<p>所以我认为 <strong><code>Java</code>既是编译语言 ，又是解释语言</strong>。</p>
</blockquote>
<h1 id="问题：面向对象特性"><a href="#问题：面向对象特性" class="headerlink" title="问题：面向对象特性"></a>问题：面向对象特性</h1><blockquote>
<p>​	面向对象和面向过程是一种软件开发思想。</p>
<ul>
<li>面向过程就是<strong>分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了</strong>。</li>
<li>面向对象是<strong>把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成系统</strong>。</li>
<li>简而言之面向过程只用函数实现，面向对象是用类实现各个功能模块。</li>
</ul>
<p>面向对象的基本要素：封装、继承、多态。</p>
<p><strong>封装</strong>的目的是隐藏类的实现细节，对外只公布需要公开的属性和行为。在java中能使用private、default、protected、public四种访问修饰符来对外部的访问做限制。</p>
<p><strong>继承</strong>是子类可以继承父类的属性和行为。</p>
<p>　　构造方法不能继承</p>
<p>　　被private修饰的数据不能继承外</p>
<p>　　其他的都可以被继承</p>
<p><strong>多态</strong>是指<strong>父类对象中的同一个行为能在其多个子类对象中有不同的表现</strong>。继承、重写、父类引用指向子类对象是多态存在的必要条件。<strong>多态有两种机制：编译时多态、运行时多态</strong>，对应重载（overload）和重写（override）。简单说，重写是父子类中相同名字和参数的方法，但是拥有不同的实现；重载是指同一类中有多个同名的方法，但这些方法有着不同的参数（返回值随便相不相同），本质上这些方法签名是不一样的。</p>
</blockquote>
<h1 id="问题：JVM、JDK-和-JRE-有什么区别"><a href="#问题：JVM、JDK-和-JRE-有什么区别" class="headerlink" title="问题：JVM、JDK 和 JRE 有什么区别"></a>问题：JVM、JDK 和 JRE 有什么区别</h1><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/src=http___www.pianshen.com_images_862_a08d9ee969fcaa90eededee0c0fbcb8e.png&refer=http___www.pianshen.webp">	</p>
<p>​	JDK是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。</p>
<ul>
<li><code>JVM</code>(<code>JAVA</code>虚拟机)是运行<code>Java</code>字节码的虚拟机,通过编译<code>.java</code>文件为<code>.class</code>文件得到字节码文件<code>.class</code>文件包含<code>JVM</code>可以理解的字节码。</li>
<li>JDK(Java Development Kit) 是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar），JDK是java开发工具包。</li>
<li>JRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），JRE是指java运行环境。</li>
</ul>
</blockquote>
<h1 id="问题：Java如何实现跨平台"><a href="#问题：Java如何实现跨平台" class="headerlink" title="问题：Java如何实现跨平台"></a>问题：Java如何实现跨平台</h1><blockquote>
<p>​	同一个.class文件在不同的虚拟机会得到不同的机器指令（Windows和Linux的机器指令不同），但是最终执行的结果却是相同的</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/kmjnibuvfcdtxretyvubjomk,l.png"></p>
</blockquote>
<h1 id="问题：装箱与拆箱"><a href="#问题：装箱与拆箱" class="headerlink" title="问题：装箱与拆箱"></a>问题：装箱与拆箱</h1><blockquote>
<h6 id="1、何为包装类型"><a href="#1、何为包装类型" class="headerlink" title="1、何为包装类型"></a>1、何为包装类型</h6><p>​	Java是一种面向对象的语言，但是它不是纯面向对象的。Java中存在基本数据类型，谈不上对象。为了向纯面向对象靠拢，Java5的时候推出了基本数据类型的包装类型。</p>
<p>​	基本数据类型与包装类型的对应关系如下： </p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/kbhjghcfhhbkjnkvgucygvhbjnklmnbh.png"></p>
<hr>
<h6 id="2、何为装箱与拆箱"><a href="#2、何为装箱与拆箱" class="headerlink" title="2、何为装箱与拆箱"></a>2、何为装箱与拆箱</h6><p>​	装箱就是将基本数据类型转化为包装类型，那么拆箱就是将包装类型转化为基本数据类型。</p>
<p>​	以基本数据类型int为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//自动装箱，底层其实执行了Integer a=Integer.valueOf(1);</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//自动拆箱，底层其实执行了int b=a.intValue();</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	Integer的valueOf（int i）方法可以将一个基本数据类型转化为对应的包装类型，即装箱方法。</p>
<p>​	而Integer的intValue（）方法则可以将一个包装类型转化为对应的基本数据类型，即拆箱方法。</p>
<hr>
<h6 id="3、装箱与自动装箱的区别"><a href="#3、装箱与自动装箱的区别" class="headerlink" title="3、装箱与自动装箱的区别"></a>3、装箱与自动装箱的区别</h6><p>​	装箱：利用Integer的构造方法Integer（int value），即Integer c &#x3D; new Integer(1);</p>
<p>​	自动装箱：或者叫隐式装箱，直接给Integer赋值，即Integer d&#x3D;1,在编译的时候，会调用Integer.valueOf（）方法完成装箱。</p>
<p>​	相比而言，自动装箱可能比装箱具有更高的效率，体现在自动装箱的缓存上，下面从几道题目来讲自动装箱的缓存。</p>
<hr>
<h6 id="4、相关面试题目"><a href="#4、相关面试题目" class="headerlink" title="4、相关面试题目"></a>4、相关面试题目</h6><p>第一题：以下代码的输出结果为？（&#x3D;&#x3D;号两边如果都是引用类型的话，则判断它们是否指向同一个对象。如果都是基本数据类型的话，则判断它们的数值是否相等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 结果</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>​	为什么一个是true，一个是false呢？</p>
<p>​	刚才我们知道，Integer a&#x3D;100这条语句会触发自动装箱，而自动装箱的方法为Integer.valueOf（）方法，让我们去寻找这个方法，一探究竟。</p>
<p>​	观察Integer类的源码中的valueOf（）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">  return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以看得出，当i的值位于[-128,127]的时候，会直接返回Integer缓存数组中相应对象的引用，如果i大于127或小于-128，会重新创建一个Integer实例，并返回。</p>
<p>​	那么第一条式子a和b的值都在缓存范围内，因此他们指向同一个对象，因此返回true。c和d的值不在范围内，都是通过new创建出来的，因此不是同一个对象，返回false。</p>
<p>​	注意：Byte、Short、Integer、Long、Character的valueOf（）实现机制类似。</p>
<p>​	其中相同值的Byte比较永远返回true，因为byte取值范围就是[-128,127]。</p>
<p>​	Short、Integer、Long的valueOf（）基本一样，i的范围都需要在[-128,127]。</p>
<p>​	Character中i的范围只要小于等于127即可，因为char最小值为0，本来就大于等于-128。</p>
<p>​	但是Float、Double中的valueOf（），永远返回新创建的对象，因为一个范围内的整数是有限的，但是小数却是无限的，无法保存在缓存中。</p>
<p>​	Boolean中只有两个对象，要么是true的Boolean，要么是false的Boolean，只要boolean的值相同，Boolean就相等。</p>
<hr>
<p>第二题：以下代码的输出结果为？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和数值类型判断==时，则触发包装类型的自动拆箱，转为数值类型的比较</span></span><br><span class="line">  System.out.println(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">300</span>) == <span class="number">300</span>);<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和数值类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算</span></span><br><span class="line">  System.out.println(c == (a + f));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦有包装类型和包装类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算</span></span><br><span class="line">  System.out.println(c == (a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只有对象类型才有equals方法，因此首先a,b触发包装类型的自动拆箱，转为数值类型的运算。</span></span><br><span class="line">  <span class="comment">//运算完，再将结果3自动装箱，Integer重写了equals,因此可以转为包装类型与包装类型的比较。</span></span><br><span class="line">  <span class="comment">//当两边的包装类型不一致时，必定返回false。</span></span><br><span class="line">  <span class="comment">//当两边的包装类型一致时,再进行拆箱，判断两者代表的数值是否相等。</span></span><br><span class="line">  System.out.println(c.equals(a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//不同数据类型的数值进行运算，首先会将低精度的数据类型转化为高精度的数据类型，即自动类型转换。</span></span><br><span class="line">  <span class="comment">//比如现在的int+long,会提升到long+long,再进行运算。</span></span><br><span class="line">  System.out.println(e == (a + d));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//==号两边类型不一致时，直接执行自动拆箱，比较之后的数值</span></span><br><span class="line">  System.out.println(e == (a + b));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，拆箱，数值比较</span></span><br><span class="line">  System.out.println(e.equals(a + d));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，两边类型不一致，直接返回false</span></span><br><span class="line">  System.out.println(c.equals(a + d));<span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h6><p>​	如果想要深入了解自动装箱拆箱的过程，必须得反编译class文件，了解底层编译的细节，才可以解除自己此方面的疑问。1</p>
</blockquote>
<h1 id="问题：重载和重写的区别"><a href="#问题：重载和重写的区别" class="headerlink" title="问题：重载和重写的区别"></a>问题：重载和重写的区别</h1><blockquote>
<h6 id="1、overload（重载）"><a href="#1、overload（重载）" class="headerlink" title="1、overload（重载）"></a>1、overload（重载）</h6><ul>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li>
</ul>
<hr>
<h6 id="2、override（重写）"><a href="#2、override（重写）" class="headerlink" title="2、override（重写）"></a>2、override（重写）</h6><ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为final不能被重写。</li>
</ul>
</blockquote>
<h1 id="问题：a-a-b与a-b的区别"><a href="#问题：a-a-b与a-b的区别" class="headerlink" title="问题：a&#x3D;a+b与a+&#x3D;b的区别"></a>问题：a&#x3D;a+b与a+&#x3D;b的区别</h1><blockquote>
<p>​	<code>a=a+b</code>是加法运算，需要两次寻找地址，而<code>a+=b</code>是增量运算，有寄存器优先时 只有一次地址查找。</p>
<p>**<code>a += b</code>**执行实际过程实际是 <strong>是先计算出<code>a</code>的值，然后用一个temp对象存储，之后和b进行相加，然后将值赋值给a引用。</strong></p>
<p><strong><code>a = a+b</code> 的执行过程则是先计算 <code>a + b</code>，然后再赋值给a引用，给a引用的时候如果 引用a 有计算过程，则会再次计算。</strong></p>
<p><strong><code>+=</code>如果两边的操作数的精度不一样时会自动向低转化，如：</strong></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img10/20180607195102802.png"></p>
<p><strong>实际上和 <code>a = (short)（a+ 65536）</code>;是一样的。</strong></p>
<p><strong>而<code>a = a+b</code>则不会自动转化，需要手动进行强制类型转化。</strong></p>
</blockquote>
<h1 id="问题：String-equals-源码分析"><a href="#问题：String-equals-源码分析" class="headerlink" title="问题：String.equals()源码分析"></a>问题：String.equals()源码分析</h1><blockquote>
<p>​	String.equals()方法简单说就是判断地址值是否相等，如果相等，则返回true，如果不相等，则继续判断内容是否相同，如果存在任意一个字符不相同（区分大小写），则返回false。如果长度相同而且所有字符均相同，才被认定为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">		<span class="comment">//判断地址值是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">		<span class="comment">//判断对象类型是否为String</span></span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">			<span class="comment">//判断长度是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">          <span class="type">char</span> v1[] = value;</span><br><span class="line">          <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//每一个字符都必须相同</span></span><br><span class="line">              <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="问题：this关键字有什么作用"><a href="#问题：this关键字有什么作用" class="headerlink" title="问题：this关键字有什么作用"></a>问题：this关键字有什么作用</h1><blockquote>
<p>this是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。 </p>
<p>this的用法在Java中大体可以分为3种： </p>
<ul>
<li>普通的直接引用，this相当于是指向当前对象本身 </li>
<li>形参与成员变量名字重名，用this来区分：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.name=name; </span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用本类的构造函数</li>
</ul>
</blockquote>
<h1 id="问题：equals-和hashCode-区别"><a href="#问题：equals-和hashCode-区别" class="headerlink" title="问题：equals()和hashCode()区别"></a>问题：equals()和hashCode()区别</h1><blockquote>
<p>​	因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存,地址则相等，否则不相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。</p>
<p>​	对于Object类来说，不同Object对象的hashCode值是不同的（Object类的hashcode值表示的是对象的地址）</p>
<p>​	object对象中的 <code>public boolean equals(Object obj)</code>，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；</p>
<hr>
<p>​	注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p>
<ul>
<li>当<code>obj1.equals(obj2)</code>为<code>true</code>时，<code>obj1.hashCode() == obj2.hashCode()</code>必须为<code>true</code> </li>
<li>当<code>obj1.hashCode() == obj2.hashCode()</code>为<code>false</code>时，<code>obj1.equals(obj2)</code>必须为<code>false</code></li>
</ul>
<p>​	如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址hashcode是用于散列数据的快速存取，如利用HashSet&#x2F;HashMap&#x2F;Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p>
<p>​	这样如果我们对一个对象重写了<code>equals</code>，意思是只要对象的成员变量值都相等那么<code>euqals</code>就等于<code>true</code>，但不重写hashcode，那么我们再new一个新的对象，当<code>原对象.equals（新对象）</code>等于<code>true</code>时，两者的<code>hashcode</code>却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写<code>hashcode()</code></p>
</blockquote>
<h1 id="问题：equals-和-的区别"><a href="#问题：equals-和-的区别" class="headerlink" title="问题：equals 和 &#x3D;&#x3D; 的区别"></a>问题：equals 和 &#x3D;&#x3D; 的区别</h1><blockquote>
<p>对于 <code>==</code> 和 <code>!=</code> 这两个关系运算符来说，它们有两种使用场景：</p>
<ul>
<li>作用于基本数据类型： 比较的是值</li>
<li>作用于对象：比较的是内存地址</li>
</ul>
<p>它们的使用经常困扰 Java 的初学者。下面是代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    System.out.println(n1 == n2);</span><br><span class="line">    System.out.println(n1 != n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>尽管对象的内容一样，<code>n1</code> 和 <code>n2</code> 对象的引用却不一样。看到这输出结果估计很多同学都懵了，应该是先输出 <code>false</code>，再输出 <code>true</code> 啊。</p>
<p>你可以把上面的 47 都改成 128，你就会发现打印的结果变成了 <code>false true</code> 了。那么为什么会这样呢？</p>
<p>⭐ <strong>因为 <code>Integer</code> 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 <code>==</code> 和 <code>!=</code> 比较也能得到正确的结果，但是不推荐用关系运算符比较</strong>。</p>
<p>那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 <code>equals()</code> 方法，<strong>该方法用于判断两个对象是否具有相同的引用（地址）</strong>。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(n1.equals(n2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例的结果看起来是我们所期望的。但其实事情并非那么简单。下面我们来创建自己的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 equals() 方法没有比较内容</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsMethod2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        <span class="type">Value</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        v1.i = v2.i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(v1.equals(v2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例的结果再次令人困惑：结果是 <code>false</code>。</p>
<p>原因： <strong><code>Object</code> 类默认的 <code>equals()</code> 的行为是比较对象的引用而非具体内容</strong>。虽然 <code>v1</code> 和 <code>v2</code> 的内容相等，但是它们并不指向同一个地址。那为什么上述 Integer 类中的 equals 方法看起来比较的是值呢？</p>
<p>答：因为 Integer 类中重写了 equals 方法，它实际比较的就是值而不是引用。事实上，大部分类都会选择重写 equals 方法让其变成基于值的比较。</p>
<p>所以总结一下 <code>equals()</code>的两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 <code>equals()</code> 方法。则通过 <code>equals()</code> 比较该类的两个对象时，等价于通过 “&#x3D;&#x3D;” 比较这两个对象。</li>
<li>情况 2：类覆盖了 <code>equals()</code> 方法。一般来说，我们都会覆盖 <code>equals()</code> 方法来比较两个对象的内容而不是其引用</li>
</ul>
</blockquote>
<h1 id="问题：JDK8新特性"><a href="#问题：JDK8新特性" class="headerlink" title="问题：JDK8新特性"></a>问题：JDK8新特性</h1><blockquote>
<h6 id="1、Java-8-Lambda-表达式"><a href="#1、Java-8-Lambda-表达式" class="headerlink" title="1、Java 8 Lambda 表达式"></a>1、Java 8 Lambda 表达式</h6><p>​	Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p>
<hr>
<h6 id="2、接口的默认方法和静态方法"><a href="#2、接口的默认方法和静态方法" class="headerlink" title="2、接口的默认方法和静态方法"></a>2、接口的默认方法和静态方法</h6><p>​	Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>​	默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line"><span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line"><span class="comment">// may not implement (override) them.</span></span><br><span class="line"><span class="keyword">default</span> String <span class="title function_">notRequired</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Default implementation&quot;</span>; </span><br><span class="line">&#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OverridableImpl</span> <span class="keyword">implements</span> <span class="title class_">Defaulable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">notRequired</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Overridden implementation&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Defaulable</strong>接口使用关键字<strong>default</strong>定义了一个默认方法<strong>notRequired()<strong>。</strong>DefaultableImpl</strong>类实现了这个接口，同时默认继承了这个接口中的默认方法；<strong>OverridableImpl</strong>类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">DefaulableFactory</span> &#123;</span><br><span class="line"><span class="comment">// Interfaces now allow static methods</span></span><br><span class="line"><span class="keyword">static</span> Defaulable <span class="title function_">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> &#123;</span><br><span class="line"><span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="3、使用元空间代替永久代"><a href="#3、使用元空间代替永久代" class="headerlink" title="3、使用元空间代替永久代"></a>3、使用元空间代替永久代</h6></blockquote>
<h1 id="问题：接口和抽象类的区别"><a href="#问题：接口和抽象类的区别" class="headerlink" title="问题：接口和抽象类的区别"></a>问题：接口和抽象类的区别</h1><blockquote>
<ol>
<li>接口使用关键字 interface 来定义。 抽象类使用关键字 abstract 来定义。</li>
<li>接口使用 implements 关键字定义其具体实现。 </li>
<li>抽象类使用 extends 关键字实现继承。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量。</li>
<li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li>
<li>抽象类中的抽象方法的访问类型可以是public，protected和默认类型。 </li>
<li>接口中方法的默认控制符是 public，并且不能定义为其他控制符。</li>
</ol>
</blockquote>
<h1 id="问题：静态变量和实例变量区别"><a href="#问题：静态变量和实例变量区别" class="headerlink" title="问题：静态变量和实例变量区别"></a>问题：静态变量和实例变量区别</h1><blockquote>
<ul>
<li><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。 </li>
<li><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</li>
</ul>
</blockquote>
<h1 id="问题：静态方法和实例方法区别"><a href="#问题：静态方法和实例方法区别" class="headerlink" title="问题：静态方法和实例方法区别"></a>问题：静态方法和实例方法区别</h1><blockquote>
<ul>
<li><strong>静态方法</strong>：static修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。 </li>
<li><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法。</li>
</ul>
</blockquote>
<h1 id="问题：深拷贝和浅拷贝"><a href="#问题：深拷贝和浅拷贝" class="headerlink" title="问题：深拷贝和浅拷贝"></a>问题：深拷贝和浅拷贝</h1><blockquote>
<ul>
<li><strong>浅拷贝：</strong>浅拷贝会创建一个新的对象，这个对象拥有被拷贝对象的一个精确的副本。在该类的成员变量中，对于基本数据类型，拷贝的就是其值；对于引用数据类型，拷贝的就是其内存地址。如果其中一个对象改变了这个引用数据类型的变量的数据，相应地，另一个对象地该引用数据类型地数据也会随之改变。</li>
<li><strong>深拷贝：</strong>深拷贝不仅会为拷贝新建对象，也会对该对象中任何的引用类型变量建立新的对象，这样，拷贝对象和原对象就是两个完全相同的对象，两者各自的成员变量也互不受影响了。</li>
</ul>
</blockquote>
<h1 id="问题：Java是值传递，还是引用传递"><a href="#问题：Java是值传递，还是引用传递" class="headerlink" title="问题：Java是值传递，还是引用传递"></a>问题：Java是值传递，还是引用传递</h1><blockquote>
<p><strong>Java是值传递</strong></p>
<p><strong>值传递：</strong>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p><strong>引用传递：</strong>“引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向同一块内存地址，对形参的操作会影响的真实内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      update(user);</span><br><span class="line">      System.out.println(user.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">  	user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/njbugcftdxcgbhjnivguyc.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">seven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">          user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">          update(user);</span><br><span class="line">          System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">          temp.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">          user = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/QQ%E6%88%AA%E5%9B%BE20220401145237.png"></p>
<p><strong>值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。</strong></p>
<p>实参：真实传给函数的参数</p>
<p>形参：函数名后括号中的变量</p>
</blockquote>
<h1 id="问题：Java-创建对象有哪几种方式"><a href="#问题：Java-创建对象有哪几种方式" class="headerlink" title="问题：Java 创建对象有哪几种方式"></a>问题：Java 创建对象有哪几种方式</h1><blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/78b5dad5942e431c8c217b4b41024530.png"></p>
</blockquote>
<h1 id="问题：static关键字"><a href="#问题：static关键字" class="headerlink" title="问题：static关键字"></a>问题：static关键字</h1><blockquote>
<p>static 修饰的资源是属于类级别的，可以在没有对象的时候调用，只有一个副本，全局共享</p>
<p><strong>static</strong> <strong>修饰方法</strong>：静态方法。不依赖于对象就可以访问，可以直接类名.静态方法访问。静态方法不可以访问对象的非静态方法和非静态变量。</p>
<p><strong>static</strong> <strong>变量</strong>：静态变量被所有的对象所共享，在内存中只有一个副本，存在方法区中，当且仅当 在类初次加载时会被初始化。</p>
<p><strong>static</strong> <strong>静态代码块</strong>：在类被初次加载时执行，比如某个方法会new一个固定内容的对象，那么每次调用该方法就会new一次对象，于是可以将该对象放到 static 代码块里面提前初始化好，让该方法直接使用，这就提升了程序的性能了。</p>
<p><strong>static</strong> <strong>静态内部类</strong>:静态内部类和一般的类一致可以定义静态变量、方法、构造方法。静态内部类可以访问外部类所有的静态变量和方法。外部类可以用“this.静态内部类”方式可以在外部类访问静态内部类。</p>
</blockquote>
<h1 id="问题：final关键字"><a href="#问题：final关键字" class="headerlink" title="问题：final关键字"></a>问题：final关键字</h1><blockquote>
<p>final可以修饰变量、方法、类。</p>
<ul>
<li>final修饰变量：如果是基础数据类型的变量那么初始化后值不可改变，如果是引用类型则该变量不能在初始化后不可再指向其他对象。</li>
<li>final修饰方法：final修饰方法表示方法不可以被重写。private方法也是final的，final方法在编译时静态绑定，所以比非final方法快。</li>
<li>final修饰类：表示类不可被继承。（我们也可以将类的构造方法声明为private使得类不可被继承，若被继承，子类没法调用父类的构造方法出错）</li>
</ul>
</blockquote>
<h1 id="问题：Exception与Error"><a href="#问题：Exception与Error" class="headerlink" title="问题：Exception与Error"></a>问题：Exception与Error</h1><blockquote>
</blockquote>
<h1 id="问题：Java中的内部类"><a href="#问题：Java中的内部类" class="headerlink" title="问题：Java中的内部类"></a>问题：Java中的内部类</h1><blockquote>
</blockquote>
<h1 id="问题：RESTful"><a href="#问题：RESTful" class="headerlink" title="问题：RESTful"></a>问题：RESTful</h1><blockquote>
</blockquote>
<h1 id="问题：序列化与反序列化"><a href="#问题：序列化与反序列化" class="headerlink" title="问题：序列化与反序列化"></a>问题：序列化与反序列化</h1><blockquote>
<h4 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h4><blockquote>
<p><strong>序列化：</strong>把Java对象转换为字节序列的过程。对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p>
<p><strong>反序列化：</strong>把字节序列恢复为Java对象的过程。客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
</blockquote>
<h4 id="为什么需要序列化与反序列化"><a href="#为什么需要序列化与反序列化" class="headerlink" title="为什么需要序列化与反序列化"></a>为什么需要序列化与反序列化</h4><blockquote>
<p>​	我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p>
<p>​	那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！</p>
<p>​	换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p>
<p>​	当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<p>总的来说可以归结为以下几点：</p>
<p>（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br>（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；<br>（3）通过序列化在进程间传递对象；</p>
</blockquote>
<h4 id="序列化算法一般会按步骤做如下事情"><a href="#序列化算法一般会按步骤做如下事情" class="headerlink" title="序列化算法一般会按步骤做如下事情"></a>序列化算法一般会按步骤做如下事情</h4><blockquote>
<p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
</blockquote>
<blockquote>
<p>   1、实现序列化的必备要求：</p>
<pre><code>   只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） 
</code></pre>
<p>   2、JDK中序列化和反序列化的API：</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①java.io.ObjectInputStream：对象输入流。</span><br><span class="line"></span><br><span class="line">   该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</span><br><span class="line"></span><br><span class="line">②java.io.ObjectOutputStream：对象输出流。</span><br><span class="line"></span><br><span class="line">   该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</span><br></pre></td></tr></table></figure>

<p>   3、实现序列化和反序列化的三种实现：</p>
<p>   ①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 </span><br><span class="line">ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。</span><br></pre></td></tr></table></figure>

<p>   ②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。</span><br></pre></td></tr></table></figure>

<p>   ③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="序列化和反序列化的注意点"><a href="#序列化和反序列化的注意点" class="headerlink" title="序列化和反序列化的注意点"></a>序列化和反序列化的注意点</h4><blockquote>
<ol>
<li><p>序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
</li>
<li><p>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
</li>
<li><p>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
</li>
<li><p>并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<ul>
<li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li>
<li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li>
</ul>
</li>
<li><p>声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
</li>
<li><p>序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ul>
</li>
<li><p>Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
</li>
<li><p>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
</li>
</ol>
<p>注意：浅拷贝请使用Clone接口的原型模式。</p>
</blockquote>
</blockquote>
<h1 id="问题：-Resource和-Autowire的区别"><a href="#问题：-Resource和-Autowire的区别" class="headerlink" title="问题：@Resource和@Autowire的区别"></a>问题：@Resource和@Autowire的区别</h1><blockquote>
<ul>
<li><p><code>@Resource</code>和<code>@Autowired</code>都可以用来装配<code>bean</code>，都可以用于字段或<code>setter</code>方法。</p>
</li>
<li><p><code>@Autowired</code><strong>默认按类型装配</strong>，默认情况下必须要求依赖对象必须存在，如果要允许<code>null</code>值，可以设置它的<code>required</code>属性为<code>false</code>。</p>
</li>
<li><p><code>@Resource</code><strong>默认按名称装配</strong>，当找不到与名称匹配的<code>bean</code>时才按照类型进行装配。名称可以通过<code>name</code>属性指定，如果没有指定<code>name</code>属性，当注解写在字段上时，默认取字段名，当注解写在<code>setter</code>方法上时，默认取属性名进行装配。</p>
</li>
</ul>
<hr>
<p><code>@Autowire</code>和<code>@Qualifier</code>配合使用效果和<code>@Resource</code>一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Autowired(required = false)</span> <span class="meta">@Qualifier(&quot;example&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Example example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource(name = &quot;example&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Example example;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="Resource装配顺序"><a href="#Resource装配顺序" class="headerlink" title="@Resource装配顺序"></a>@Resource装配顺序</h6><ol>
<li>如果同时指定name和type，则从容器中查找唯一匹配的bean装配，找不到则抛出异常</li>
<li>如果指定name属性，则从容器中查找名称匹配的bean装配，找不到则抛出异常</li>
<li>如果指定type属性，则从容器中查找类型唯一匹配的bean装配，找不到或者找到多个抛出异常</li>
<li>如果都不指定，则自动按照byName方式装配，如果没有匹配，则回退一个原始类型进行匹配，如果匹配则自动装配</li>
</ol>
</blockquote>
<h1 id="问题：count-1-、count-与count-列名-的执行区别"><a href="#问题：count-1-、count-与count-列名-的执行区别" class="headerlink" title="问题：count(1)、count(*)与count(列名)的执行区别"></a>问题：count(1)、count(*)与count(列名)的执行区别</h1><blockquote>
<ul>
<li><strong>count(*)包括了所有的列，相当于行数</strong>，在统计结果的时候， <strong>不会忽略列值为NULL</strong> </li>
<li>**count(1)**包括了忽略所有列，用1代表代码行，在统计结果的时候， <strong>不会忽略列值为NULL</strong>  </li>
<li>**count(列名)**只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， <strong>即某个字段值为NULL时，不统计</strong>。</li>
<li>列名为主键，count(列名)会比count(1)快  </li>
<li>列名不为主键，count(1)会比count(列名)快</li>
</ul>
</blockquote>
<h1 id="问题：new一个对象的过程"><a href="#问题：new一个对象的过程" class="headerlink" title="问题：new一个对象的过程"></a>问题：new一个对象的过程</h1><blockquote>
<ul>
<li><strong>之前没有进行类加载</strong></li>
</ul>
<ol>
<li>类加载,同时初始化类中静态的属性(赋默认值)</li>
<li>执行静态代码块</li>
<li>分配内存空间,同时初始化非静态的属性(赋默认值)</li>
<li>调用父类构造器</li>
<li>父类构造器执行完后,如果自己声明属性的同时有显示的赋值,那么进行显示赋值把默认值覆盖</li>
<li>执行匿名代码块</li>
<li>执行构造器</li>
<li>返回内存地址</li>
</ol>
<hr>
<ul>
<li><strong>之前已经进行了类加载</strong></li>
</ul>
<ol>
<li>分配内存空间,同时初始化非静态的属性(赋默认值)</li>
<li>调用父类构造器</li>
<li>父类构造器执行完后,如果自己声明属性的同时有显示的赋值,那么进行显示赋值把默认值覆盖</li>
<li>执行匿名代码块</li>
<li>执行构造器</li>
<li>返回内存地址</li>
</ol>
<hr>
<ol>
<li><p>当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能 <strong>在常量池中能否定位到一个类的符号引用</strong> （即类的带路径全名），并且检查这个符号引用代表的类是否已被加载、解析和初始化过，即<strong>验证是否是第一次使用该类</strong>。如果没有（不是第一次使用），那必须先执行相应的类加载过程（class.forname()）。</p>
</li>
<li><p>在类加载检查通过后，接下来虚拟机将 <strong>为新生的对象分配内存</strong> 。对象所需的内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式，根据使用的垃圾收集器的不同使用不同的分配机制：</p>
</li>
</ol>
<p>　　2.1. <strong>指针碰撞</strong>（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<p>　　2.2. <strong>空闲列表</strong>（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。</p>
<ol start="3">
<li><p>内存分配完后，虚拟机需要将分配到的内存空间中的数据类型都 <strong>初始化为零值（不包括对象头）</strong>；</p>
</li>
<li><p>虚拟机要 <strong>对对象头进行必要的设置</strong> ，例如这个对象是哪个类的实例（即所属类）、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。</p>
</li>
</ol>
<p>至此，从虚拟机视角来看，一个新的对象已经产生了。但是在Java程序视角来看，执行new操作后会接着执行如下步骤：</p>
<ol start="5">
<li><p><strong>调用对象的init()方法</strong> ,根据传入的属性值给对象属性赋值。</p>
</li>
<li><p>在线程 <strong>栈中新建对象引用</strong> ，并指向堆中刚刚新建的对象实例。</p>
</li>
</ol>
</blockquote>
<h1 id="问题：多进程与多线程"><a href="#问题：多进程与多线程" class="headerlink" title="问题：多进程与多线程"></a>问题：多进程与多线程</h1><blockquote>
<table>
<thead>
<tr>
<th align="center">对比维度</th>
<th align="center">多进程</th>
<th align="center">多线程</th>
<th align="center">总结</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据共享、同步</td>
<td align="center">数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td align="center">因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td align="center">各有优势</td>
</tr>
<tr>
<td align="center">内存、CPU</td>
<td align="center">占用内存多，切换复杂，CPU利用率低</td>
<td align="center">占用内存少，切换简单，CPU利用率高</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td align="center">创建销毁、切换</td>
<td align="center">创建销毁、切换复杂，速度慢</td>
<td align="center">创建销毁、切换简单，速度很快</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td align="center">编程、调试</td>
<td align="center">编程简单，调试简单</td>
<td align="center">编程复杂，调试复杂</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">进程间不会互相影响</td>
<td align="center">一个线程挂掉将导致整个进程挂掉</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">分布式</td>
<td align="center">适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td align="center">适应于多核分布式</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">nginx主流的工作模式是多进程模式（也支持多线程模型） <br/>几乎所有的web server服务器服务都有多进程</td>
<td align="center">需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）<br/>需要进行大量计算的优先使用线程（CPU频繁切换）</td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
<h1 id="问题：HTTP-1-0、HTTP-1-1、HTTP-2-0"><a href="#问题：HTTP-1-0、HTTP-1-1、HTTP-2-0" class="headerlink" title="问题：HTTP 1.0、HTTP 1.1、HTTP 2.0"></a>问题：HTTP 1.0、HTTP 1.1、HTTP 2.0</h1><blockquote>
<h4 id="HTTP-1-0-HTTP-1-1区别"><a href="#HTTP-1-0-HTTP-1-1区别" class="headerlink" title="HTTP 1.0 HTTP 1.1区别"></a>HTTP 1.0 HTTP 1.1区别</h4><blockquote>
<h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>​	HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>​	HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p>
<h5 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h5><p>​	HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>​	这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>​	另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<h5 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h5><p>​	现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>​	HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
</blockquote>
<h4 id="HTTP1-1-HTTP-2-0区别"><a href="#HTTP1-1-HTTP-2-0区别" class="headerlink" title="HTTP1.1 HTTP 2.0区别"></a>HTTP1.1 HTTP 2.0区别</h4><blockquote>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>​	HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>​	当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>​	TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/cfvgbhnfjmnhgdfsfvggtrhytujtyrter.jpg"></p>
<h5 id="头部数据压缩"><a href="#头部数据压缩" class="headerlink" title="头部数据压缩"></a>头部数据压缩</h5><p>​	在HTTP1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
<p>​	HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p>​	服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p>
<p>​	为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/gthytrytuilkrtytrgethyjuydcfgthyujy.jpg"></p>
</blockquote>
</blockquote>
<h1 id="问题：HTTP请求方法"><a href="#问题：HTTP请求方法" class="headerlink" title="问题：HTTP请求方法"></a>问题：HTTP请求方法</h1><blockquote>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/11-07-58-fcdctfybhnjmk,l0wNV4a.png"></p>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>GET 是最常用的 HTTP 请求方***显示请求指定的资源，并返回响应主体，一般对它的期望是安全且幂等的。</p>
<p>所谓安全是指该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改和增加数据，不会影响资源的状态。</p>
<blockquote>
<p>这里安全的含义仅仅是指是非修改信息。</p>
</blockquote>
<p>幂等的概念简单点来说，就是指对同一个 URL 的多个请求应该返回同样的结果。</p>
<p>查询字符串（名称&#x2F;值对）是在 GET 请求的 URL 中发送的，在 URL 后加 <code>?</code> 连接查询字符串，多条查询字符串通过 <code>&amp;</code> 来连接，比如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;https://cn.bing.com/search?q=%E7%BC%96%E7%A8%8B%E4%B8%89%E6%98%A7&amp;PC=U316&amp;FORM=CHROMN</span><br></pre></td></tr></table></figure>

<h3 id="GET-请求的一些其他特性："><a href="#GET-请求的一些其他特性：" class="headerlink" title="GET 请求的一些其他特性："></a>GET 请求的一些其他特性：</h3><ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据（不修改）</li>
</ul>
<h2 id="HEAD-方法"><a href="#HEAD-方法" class="headerlink" title="HEAD 方法"></a>HEAD 方法</h2><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回头部消息。</p>
<p>它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据），对资源的首部进行检查，比如：</p>
<ul>
<li>如果 GET &#x2F;users 返回用户列表，</li>
<li>那么 HEAD &#x2F;users 将发出相同的请求，但不会返回用户列表。</li>
</ul>
<h3 id="HEAD-方法的使用场景"><a href="#HEAD-方法的使用场景" class="headerlink" title="HEAD 方法的使用场景"></a>HEAD 方法的使用场景</h3><ul>
<li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li>
<li>通过查看响应中的状态码，可以确定资源是否存在；</li>
<li>通过查看首部，测试资源是否被修改。</li>
</ul>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>POST 方法用于向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件），数据被包含在请求本文中。</p>
<p>POST 请求可能会创建新的资源或修改现有资源，或二者皆有。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。</p>
<h3 id="浏览器发出的POST请求的body的主要格式"><a href="#浏览器发出的POST请求的body的主要格式" class="headerlink" title="浏览器发出的POST请求的body的主要格式"></a>浏览器发出的POST请求的body的主要格式</h3><ul>
<li><strong>application&#x2F;x-www-form-urlencoded</strong> 用来传输简单的数据，如 “key1&#x3D;value1&amp;key2&#x3D;value2” 这样的格式。</li>
<li><strong>multipart&#x2F;form-data</strong> 主要用来传输文件内容。</li>
<li><strong>application&#x2F;json</strong> 告诉服务端消息主体是序列化后的 JSON 字符串。</li>
<li><strong>text&#x2F;plain</strong> 纯文本格式</li>
</ul>
<blockquote>
<p>采用 multipart&#x2F;form-data 是因为 application&#x2F;x-www-form-urlencoded 的编码方式对于文件这种二进制的数据非常低效。</p>
</blockquote>
<blockquote>
<p>除了原生的content-type，开发人员也可以完全自定义数据提交格式！</p>
</blockquote>
<h3 id="POST-请求的其他特性："><a href="#POST-请求的其他特性：" class="headerlink" title="POST 请求的其他特性："></a>POST 请求的其他特性：</h3><ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h2><p>PUT 方法用于将数据发送到服务器来创建&#x2F;更新资源。</p>
<p>PUT 与 POST 方法的区别在于，PUT 方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次 POST 方法可能会有副作用，比如将一个订单重复提交多次。</p>
<h3 id="PUT-方法可能的响应"><a href="#PUT-方法可能的响应" class="headerlink" title="PUT 方法可能的响应"></a>PUT 方法可能的响应</h3><ul>
<li>如果目标资源不存在，并且PUT方法成功创建了一份，那么源头服务器必须返回 201(<code>Created</code>) 来通知客户端资源已创建。</li>
<li>如果目标资源已经存在，并且依照请求中封装的表现形式成功进行了更新，那么，源头服务器必须返回 200 (<code>OK</code>) 或者 204 (<code>No Content</code>) 来表示请求的成功完成。</li>
</ul>
<h2 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h2><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。但是，客户端无法保证删除操作一定会被执行，因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。</p>
<h3 id="DELETE-方法可能的响应码"><a href="#DELETE-方法可能的响应码" class="headerlink" title="DELETE 方法可能的响应码"></a>DELETE 方法可能的响应码</h3><p>如果 DELETE 方法成功执行，那么可能会有以下几种状态码：</p>
<ul>
<li>状态码 202 (Accepted) 表示请求的操作可能会成功执行，但是尚未开始执行。</li>
<li>状态码 204 (No Content) 表示操作已执行，但是无进一步的相关信息。</li>
<li>状态码 200 (OK) 表示操作已执行，并且响应中提供了相关状态的描述信息。</li>
</ul>
<h2 id="TRACE-方法"><a href="#TRACE-方法" class="headerlink" title="TRACE 方法"></a>TRACE 方法</h2><p>TRACE 方法实现沿通向目标资源的路径的消息“回环”（loop-back）测试 ，提供了一种实用的 debug 机制。</p>
<p>请求的最终接收者应当原样反射（reflect）它接收到的消息，作为一个 Content-Type 为 message&#x2F;http 的200（OK）响应的消息的主体（body）返回给客户端 。</p>
<blockquote>
<p>最终接收者是指初始（origin）服务器，或者第一个接收到 Max-Forwards 值为 0的请求的服务器。</p>
</blockquote>
<p>我们都知道，客户端在发起一个请求时，这个请求可能要穿过***、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的 HTTP 请求。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看 HTTP 请求报文在发送的途中，是否被修改过了。</p>
<h2 id="PATCH-方法"><a href="#PATCH-方法" class="headerlink" title="PATCH 方法"></a>PATCH 方法</h2><p>在HTTP协议中，请求方法 PATCH 用于对资源进行部分修改。</p>
<p>在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于 PUT 方法，而与 POST 方法类似，PATCH 方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p>
<p>要判断一台服务器是否支持 PATCH 方法，那么就看它是否将其添加到了响应首部 Allow 或者 Access-Control-Allow-Methods （在跨域访问的场合，CORS）的方法列表中 。</p>
<p>另外一个支持 PATCH 方法的隐含迹象是 Accept-Patch 首部的出现，这个首部明确了服务器端可以接受的补丁文件的格式。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>204 状态码表示这是一个操作成功的响应，因为响应中不带有消息主体。</p>
<h2 id="OPTIONS-方法"><a href="#OPTIONS-方法" class="headerlink" title="OPTIONS 方法"></a>OPTIONS 方法</h2><p>OPTIONS 方法用于获取目的资源所支持的通信选项。</p>
<p>客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</p>
<p>若请求成功，则它会在 HTTP 头中包含一个名为 “Allow” 的头，值是所支持的方法，如 “GET, POST”。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>可以使用 OPTIONS 方法对服务器发起请求，以检测服务器支持哪些 HTTP 方法，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;HTTP/1.1 200 OK``Allow: OPTIONS, GET, HEAD, POST``Cache-Control: max-age=604800``Date: Thu, 13 Oct 2016 11:45:00 GMT``Expires: Thu, 20 Oct 2016 11:45:00 GMT``Server: EOS (lax004/2813)``x-ec-custom-error: 1``Content-Length: 0</span><br></pre></td></tr></table></figure>

<h2 id="CONNECT-方法"><a href="#CONNECT-方法" class="headerlink" title="CONNECT 方法"></a>CONNECT 方法</h2><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 HTTP 方法的内容总结，根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</p>
</blockquote>
<h1 id="问题：GET-和-POST-的区别"><a href="#问题：GET-和-POST-的区别" class="headerlink" title="问题：GET 和 POST 的区别"></a>问题：GET 和 POST 的区别</h1><blockquote>
<p>（1）GET 参数通过 <strong>url</strong> 传递，POST 放在 <strong>request body</strong> 中。</p>
<p>（2）GET 请求在 url 中传递的参数是有长度限制的，而 post 没有。</p>
<p>（3）<strong>GET 比 POST 更不安全</strong>，因为参数直接暴露在 url 中，所以不能用来传递敏感信息；POST 不会作为 url 的一部分，不会被缓存，保存在服务器日志以及在浏览器浏览记录中。</p>
<p>（4）GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</p>
<p>（5）GET 请求会浏览器主动缓存。</p>
<p>（6）<strong>GET 请求参数会被完整保留在浏览历史记录里</strong>，而 post 中的参数不会被保留。</p>
<p>（7）GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。<strong>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包</strong>。浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p>
<p>GET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存；</p>
<p>POST 不同，POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此，GET 请求适合于做请求缓存。</p>
</blockquote>
<h1 id="问题：HTTP状态码"><a href="#问题：HTTP状态码" class="headerlink" title="问题：HTTP状态码"></a>问题：HTTP状态码</h1><blockquote>
<h4 id="一、状态码告知从服务器端返回的请求结果"><a href="#一、状态码告知从服务器端返回的请求结果" class="headerlink" title="一、状态码告知从服务器端返回的请求结果"></a>一、状态码告知从服务器端返回的请求结果</h4><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p>表：状态码的类别</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>只要遵守状态码类别的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<p>仅记录在RFC2616上的HTTP状态码就达40种，若再加上WebDAV（Web-based DistributedAuthoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842）和附加HTTP状态码（RFC6585）等扩展，数量就达60余种。别看种类繁多，实际上经常使用的大概只有14种。接下来，我们就介绍一下这些具有代表性的14个状态码。</p>
<h4 id="二、2XX成功"><a href="#二、2XX成功" class="headerlink" title="二、2XX成功"></a>二、2XX成功</h4><p>2XX的响应结果表明请求被正常处理了。</p>
<h5 id="2-1、-200-OK"><a href="#2-1、-200-OK" class="headerlink" title="2.1、 200 OK"></a>2.1、 200 OK</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/dfsgsbtarfgtynumytrty.png"></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。</p>
<h5 id="2-2、-204-No-Content"><a href="#2-2、-204-No-Content" class="headerlink" title="2.2、 204 No Content"></a>2.2、 204 No Content</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435001563_2B8Cdsafasd.png"></p>
<p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<h5 id="2-3、-206-Partial-Content"><a href="#2-3、-206-Partial-Content" class="headerlink" title="2.3、 206 Partial Content"></a>2.3、 206 Partial Content</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_15914350.fdsfd.png"></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
<h4 id="三、3XX重定向"><a href="#三、3XX重定向" class="headerlink" title="三、3XX重定向"></a>三、3XX重定向</h4><p>​	3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h5 id="3-1、301-Moved-Permanently"><a href="#3-1、301-Moved-Permanently" class="headerlink" title="3.1、301 Moved Permanently"></a>3.1、301 Moved Permanently</h5><p>​	永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</p>
<p>像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠“&#x2F;”，就会产生301状态码。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200606/321375129_1591435001715_DE0B2B36D620C93C14CD95A779FF2F96" alt="img"></p>
<h5 id="3-2、302-Found"><a href="#3-2、302-Found" class="headerlink" title="3.2、302 Found"></a>3.2、302 Found</h5><p>​	临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。</p>
<p>​	和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI。</p>
<h5 id="3-3、303-See-Other"><a href="#3-3、303-See-Other" class="headerlink" title="3.3、303 See Other"></a>3.3、303 See Other</h5><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p>
<p>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<p>301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。</p>
<h5 id="3-4、-304-Not-Modified"><a href="#3-4、-304-Not-Modified" class="headerlink" title="3.4、 304 Not Modified"></a>3.4、 304 Not Modified</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435001817_8dvbryntuyrtere.png"></p>
<p>​	该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</p>
<h5 id="3-5、-307-Temporary-Redirect"><a href="#3-5、-307-Temporary-Redirect" class="headerlink" title="3.5、 307 Temporary Redirect"></a>3.5、 307 Temporary Redirect</h5><p>​	临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h4 id="四、4XX客户端错误"><a href="#四、4XX客户端错误" class="headerlink" title="四、4XX客户端错误"></a>四、4XX客户端错误</h4><p>​	4XX的响应结果表明客户端是发生错误的原因所在。</p>
<h5 id="4-1、-400-Bad-Request"><a href="#4-1、-400-Bad-Request" class="headerlink" title="4.1、 400 Bad Request"></a>4.1、 400 Bad Request</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_15914350019yrterfgthyuyky.png"></p>
<p>​	该状态示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码。</p>
<h5 id="4-2、-401-Unauthorized"><a href="#4-2、-401-Unauthorized" class="headerlink" title="4.2、 401 Unauthorized"></a>4.2、 401 Unauthorized</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002039_2856B3352hyejtyteres.png"></p>
<p>​	该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p>
<p>​	返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p>
<h5 id="4-3、-403-Forbidden"><a href="#4-3、-403-Forbidden" class="headerlink" title="4.3、 403 Forbidden"></a>4.3、 403 Forbidden</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002136_93B3D78FEEEA80vfdcasx.png"></p>
<p>​	该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。</p>
<h5 id="4-4、-404-Not-Found"><a href="#4-4、-404-Not-Found" class="headerlink" title="4.4、 404 Not Found"></a>4.4、 404 Not Found</h5><p>​	该状态码表明服务器上无法找到请求的资源或是服务器无法回应且不知原因。。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<h4 id="五、5XX服务器错误"><a href="#五、5XX服务器错误" class="headerlink" title="五、5XX服务器错误"></a>五、5XX服务器错误</h4><p>5XX的响应结果表明服务器本身发生错误。</p>
<h5 id="5-1、-500-Internal-Server-Error"><a href="#5-1、-500-Internal-Server-Error" class="headerlink" title="5.1、 500 Internal Server Error"></a>5.1、 500 Internal Server Error</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002223_FB81F7gfvdcasdf.png"></p>
<p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p>
<h5 id="5-2、-503-Service-Unavailable"><a href="#5-2、-503-Service-Unavailable" class="headerlink" title="5.2、 503 Service Unavailable"></a>5.2、 503 Service Unavailable</h5><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/321375129_1591435002223_FB81F7gfvdcasdf.png"></p>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p>
<h4 id="状态码和状况的不一致"><a href="#状态码和状况的不一致" class="headerlink" title="状态码和状况的不一致"></a>状态码和状况的不一致</h4><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到。</p>
<h4 id="HTTP状态码大全"><a href="#HTTP状态码大全" class="headerlink" title="HTTP状态码大全"></a>HTTP状态码大全</h4><p>基本涵盖了所有问题<br>HTTP 400 – 请求无效<br>HTTP 401.1 – 未授权：登录失败<br>HTTP 401.2 – 未授权：服务器配置问题导致登录失败<br>HTTP 401.3 – ACL 禁止访问资源<br>HTTP 401.4 – 未授权：授权被筛选器拒绝<br>HTTP 401.5 – 未授权：ISAPI 或 CGI 授权失败</p>
<p>HTTP 403 – 禁止访问<br>HTTP 403 – 对 Internet 服务管理器 的访问仅限于 Localhost<br>HTTP 403.1 禁止访问：禁止可执行访问<br>HTTP 403.2 – 禁止访问：禁止读访问<br>HTTP 403.3 – 禁止访问：禁止写访问<br>HTTP 403.4 – 禁止访问：要求 SSL<br>HTTP 403.5 – 禁止访问：要求 SSL 128<br>HTTP 403.6 – 禁止访问：IP 地址被拒绝<br>HTTP 403.7 – 禁止访问：要求客户证书<br>HTTP 403.8 – 禁止访问：禁止站点访问<br>HTTP 403.9 – 禁止访问：连接的用户过多<br>HTTP 403.10 – 禁止访问：配置无效<br>HTTP 403.11 – 禁止访问：密码更改<br>HTTP 403.12 – 禁止访问：映射器拒绝访问<br>HTTP 403.13 – 禁止访问：客户证书已被吊销<br>HTTP 403.15 – 禁止访问：客户访问许可过多<br>HTTP 403.16 – 禁止访问：客户证书不可信或者无效<br>HTTP 403.17 – 禁止访问：客户证书已经到期或者尚未生效 HTTP 404.1 -</p>
<p>无法找到 Web 站点<br>HTTP 404- 无法找到文件<br>HTTP 405 – 资源被禁止<br>HTTP 406 – 无法接受<br>HTTP 407 – 要求***身份验证<br>HTTP 410 – 永远不可用<br>HTTP 412 – 先决条件失败<br>HTTP 414 – 请求 – URI 太长</p>
<p>HTTP 500 – 内部服务器错误<br>HTTP 500.100 – 内部服务器错误 – ASP 错误<br>HTTP 500-11 服务器关闭<br>HTTP 500-12 应用程序重新启动<br>HTTP 500-13 – 服务器太忙<br>HTTP 500-14 – 应用程序无效<br>HTTP 500-15 – 不允许请求 global.asa<br>Error 501 – 未实现<br>HTTP 502 – 网关错误</p>
</blockquote>
<h1 id="问题：HTTP请求的完全过程"><a href="#问题：HTTP请求的完全过程" class="headerlink" title="问题：HTTP请求的完全过程"></a>问题：HTTP请求的完全过程</h1><blockquote>
<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h4><p>在浏览器的地址栏输入一个 URL 后回车，背后到底发生了什么才能使得一个界面完美的展现在我们眼前？</p>
<p>今天讲解的这道题目，由于其涉及大量网络协议，可以非常直观的看出诸位小伙伴对计算机网络体系的整体把握程度，所以自然成为了各大公司的面试常客。</p>
<p>在浏览中输入 URL 并且获取响应的过程，其实就是浏览器和该 URL 对应的服务器的网络通信过程。比如我们输入 <code>www.baidu.com</code>，那么会返回一个百度搜索的界面，这其实就是浏览器和百度服务器之间的网络通信过程。浏览器就是客户端，用于发出请求，而百度的服务器就是服务端，用于接收并响应请求。</p>
<p>下面我们就来详细讲解这个庞大的网络通信过程。</p>
<h4 id="1-解析-URL"><a href="#1-解析-URL" class="headerlink" title="1. 解析 URL"></a>1. 解析 URL</h4><p>不知道有没有同学会混淆域名和 URL 的概念，可以这样理解，URL 就是我们输入的网址，而网址里面含有域名。举个例子：<code>www.baidu.com/veal98</code> 是一个网址，而 <code>www.baidu.com</code> 就是服务器的域名。</p>
<p>URL 各元素的组成如下（当然，下述请求文件的路径名可以省略）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020dfgbfhngfbdbgnumnhg7210245.png"></p>
<p>这个 URL 请求的目标服务器上的文件路径就是：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210207bghngbdfnhngbfdgnhmhngbdfv210750.png"></p>
<p>那么首先，浏览器做的第一步就是解析 URL 得到里面的参数，将域名和需要请求的资源分离开来，从而了解需要请求的是哪个服务器，请求的是服务器上什么资源等等。</p>
<h4 id="2-浏览器封装-HTTP-请求报文"><a href="#2-浏览器封装-HTTP-请求报文" class="headerlink" title="2. 浏览器封装 HTTP 请求报文"></a>2. 浏览器封装 HTTP 请求报文</h4><p>对 <code>URL</code> 进行解析之后，浏览器确定了目标服务器和文件名，接下来就需要根据这些消息<strong>封装</strong>成一个 HTTP 请求报文发送出去。举个 HTTP 请求报文的例子：</p>
<blockquote>
<p>关于 HTTP 协议详细可见 HTTP 协议的前世今生 这篇文章，这里不再赘述</p>
</blockquote>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020721bgnbgvvbnbtrecrvtbynt2035.png"></p>
<p>解释一下<strong>封装</strong>，这是一个贯穿整个计算机网络的概念。就是说发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层就会把该层对应的首部信息消去。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021020fvgytrfegtsyumyiuytrertytu7230329.png"></p>
<h4 id="3-DNS-域名解析获取-IP-地址"><a href="#3-DNS-域名解析获取-IP-地址" class="headerlink" title="3. DNS 域名解析获取 IP 地址"></a>3. DNS 域名解析获取 IP 地址</h4><p>封装好 HTTP 请求报文后，在正式还有一项准备工作没有做，那就是获取目标服务器的 IP 地址。</p>
<p>虽然解析得到了域名，理论浏览器已经知道目标服务器是谁了。但是实际上，域名并不是目标服务器真正意义上的地址，互联网上每一台计算机都被全世界唯一 IP 地址标识着，但是 IP 地址并不方便记忆，所以才设计出了域名。</p>
<p>那么就需要解析域名获取目标服务器的 IP 地址。不然空有一个方便记忆的域名咋知道这个请求到底发送到哪里去呢。由域名转换得到 IP 地址就是 DNS 协议做的事情，如下：</p>
<blockquote>
<p>关于 DNS 详细的内容各位可以回顾 超详细 DNS 协议解析 这篇文章，比如什么是域名，域名服务器，递归查询和迭代查询等等，写的已经足够详细，此处只列出 DNS 的解析过程。</p>
</blockquote>
<p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护着一张域名与 IP 地址的对应表；</p>
<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>
<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>
<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>
<ul>
<li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>
<li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>
<p>配合下图直观理解：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021vfrytujjtrhtergtryjtukyikutjrtegr0120123619.png"></p>
<p>需要注意的是，DNS 使用的是 UDP 协议，也就是说上面各种请求的转发，都是基于 UDP 这个无连接协议的。</p>
<h4 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h4><p>获取到了目标服务器的 IP 地址之后，浏览器就知道我等下请求要发给谁了，这个时候就可以开始发送封装好了的 HTTP 请求报文了，那么既然需要发送请求，必然就需要 TCP 通过三次握手为浏览器和服务器之间建立可靠的连接，<strong>保证双方都具有可靠的接收和发送能力</strong>。</p>
<blockquote>
<p>这里又是一道经典的面试题：TCP 三次握手和四次挥手，详细可见 关于 TCP 三次握手和四次挥手，满分回答在此 这篇文章。</p>
</blockquote>
<p>三次握手过程如下图：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210dvfbrytujyikyujhrterewfgethryjuk107175526.png"></p>
<h4 id="5-浏览器发送请求"><a href="#5-浏览器发送请求" class="headerlink" title="5. 浏览器发送请求"></a>5. 浏览器发送请求</h4><p>TCP 三次握手完成后，浏览器与目标服务器之间就建立了一个可靠的虚拟通道，于是浏览器就可以发送自己的 HTTP 请求了。</p>
<p>需要注意的是，HTTP 请求报文或者响应报文在 TCP 连接通道上进行传输的时候，由于这些报文比较大，为了更容易和准确可靠的传输，<strong>TCP 会将 HTTP 报文按序号分割成若干报文段并加上 TCP 首部，分别进行传输。接收方在收到这些报文段后，按照序号以原来的顺序重组 HTTP 报文</strong>。</p>
<h4 id="6-负责传输的-IP-协议"><a href="#6-负责传输的-IP-协议" class="headerlink" title="6. 负责传输的 IP 协议"></a>6. 负责传输的 IP 协议</h4><p>实际上，TCP 在三次握手建立连接、四次握手断开连接、以及连接建立过程中的收发数据（TCP 报文段）等各阶段操作时，都是通过 IP 协议进行传输的，IP 协议将这些阶段的数据添加 IP 首部封装成 IP 数据报再进行传输。</p>
<p>IP 数据报的首部存有<strong>源 IP 地址</strong>和 <strong>目标 IP 地址</strong>。所谓源 IP 地址 就是发送方的 IP 地址；目标 IP 地址就是通过 DNS 域名解析得到的目标服务器的 IP 地址。</p>
<p>事实上，<strong>IP 协议身处的网络层规定的是：数据报要通过怎样的路径（传输路线）才能到达对方计算机，并传送给对方</strong>。不理解这句话的详细解释马上就来，继续往下读。</p>
<h4 id="7-使用-ARP-协议凭借-MAC-地址通信"><a href="#7-使用-ARP-协议凭借-MAC-地址通信" class="headerlink" title="7. 使用 ARP 协议凭借 MAC 地址通信"></a>7. 使用 ARP 协议凭借 MAC 地址通信</h4><blockquote>
<p>关于 IP 协议、IP 地址、MAC 地址等详细请看 别再恐惧 IP 协议（万字长文 | 多图预警） 这篇文章。</p>
</blockquote>
<p>上面说了，IP 协议的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中必要的两个就是 IP 地址 和 MAC 地址。</p>
<p>MAC 地址也是用来唯一标识一个接入互联网的设备的，可能不禁有小伙伴要问，既然网络层已经有了唯一标识的 IP 地址，为啥还需要 MAC 地址？</p>
<p>看下面这幅图，在网络上，<strong>通信的双方在同一局域网内的情况是很少见的，通常是需要多台计算机和网络设备的中转才能连接到对方。而在进行中转时，就需要利用下一站中转设备的 MAC 地址来搜索下一个中转目标</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021011414sdvrthryjukloikyuyterefr3919.png"></p>
<ul>
<li><p>网络层指定了从哪个主机（「源 IP 地址」）发送到哪个主机（「目的 IP 地址」）。<strong>源 IP 地址和目标 IP 地址在传输过程中是不会变化的</strong></p>
</li>
<li><p>而数据链路层则是根据 MAC 地址在一个接一个的区间中进行传输的，每个区间内的出发地址即「源 MAC 地址」，每个区间内的目的地址即「目的 MAC 地址」。显然，随着数据的传输，<strong>源 MAC 地址和目的 MAC 地址会不断的发生变化</strong></p>
<p>比如上图，<strong>网络层告知了 1-2-3 路线，也就是说指明了这几个路由器的 IP 地址。那么数据链路层就会根据这几个 IP 地址对应的 MAC 地址依次找到 1、2、3，并在他们之间传输数据</strong>。</p>
</li>
</ul>
<p>🍉 这么说吧，举个形象点的例子：我们把数据链路层当成乘坐高铁从苏州到南京，再在南京转乘到北京，再在北京转乘到西藏的旅客，那么网络层就相当于每个车站的工作人员，<strong>在数据链路层每次转乘时，网络层为其购买了一张标有下一个 MAC 地址的车票</strong>。因此，即使旅客（数据链路层）不知道其最终目的地也没有关系，工作人员（网络层）会给你做出指引。</p>
<p>实际上，网络层做出指引的过程，我们将其称为<strong>路由控制</strong>，其中又涉及到了路由协议比如 OSPF 等</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202101dvfbnyuyiotuiutrthgwef15151809.png"></p>
<p>那么，<strong>将 IP 地址转化为 MAC 地址</strong>，从而在数据链路层精确的传输数据的协议就是 <strong>ARP 协议</strong>。</p>
<p>ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。并且每个主机都有一个 <strong>ARP 高速缓存</strong>，里面有本局域网上的各主机和路由器的 <strong>IP 地址到 MAC 地址的映射表</strong>。</p>
<p>如下图所示，假定主机 A 向同一链路上的主机 B 发送 IP 数据报，已知主机 A 和主机 B 的 IP 地址，它们互不知道对方的 MAC 地址：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021cadvethyukilutyuhtewef0123213052.png"></p>
<p>1）首先，主机 A 为了获得主机 B 的 MAC 地址，它会先去查询自己的 ARP 高速缓存中有没有主机 B 的相关记录；</p>
<p>2）如果主机 A 的 ARP 高速缓存中没有主机 B 的 IP 地址到 MAC 地址的映射，主机 A 就会通过<strong>广播</strong>的方式发送 <strong>ARP 请求包</strong>（该包携带自己的 IP 地址 和 MAC 地址 以及 目标主机的 IP 地址），表明自己想要获得主机 B 的 MAC 地址；</p>
<p>2） 由于广播请求可以被同一个链路上的所有主机或路由器接收，因此如果这条链路上某个主机或路由的 IP 地址与这个 ARP 请求包中包含的目标主机的 IP 地址相同，那么这个节点就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>中返回给主机 A；</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021012322vrtryjuykiuytegrwgthryjuyki0759.png"></p>
<blockquote>
<p>当然，ARP 响应包是以单播的形式进行发送的，毕竟 ARP 请求包中已经包含了主机 A 的 IP 地址，所以主机 B 非常清楚这个响应包应该发送给谁。</p>
<p>大部分网络协议在设计的时候，都是保持极度克制的，不需要的交互就砍掉，能合并的信息就合并，能不用广播就用单播，以此让带宽变得更多让网络变得更快。</p>
</blockquote>
<p>3）主机 A 在收到主机 B 发过来的 ARP 响应包后，向其 ARP 高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202004272scdvfbytumi,yutytegrwgethryjt10248.png"></p>
<p>当然，缓存是有一定期限的，超过这个期限，缓存的内容将被清空。这也使得即使 MAC 地址和 IP 地址的映射关系发生了变化，也依然能够正确的将数据包发送给目标地址。</p>
<h4 id="8-服务器响应请求"><a href="#8-服务器响应请求" class="headerlink" title="8. 服务器响应请求"></a>8. 服务器响应请求</h4><p>浏览器的 HTTP 请求报文通过 TCP 三次握手建立的连接通道被切分成若干报文段分别发送给服务器，服务器在收到这些报文段后，按照序号以原来的顺序重组 HTTP 请求报文。然后处理并返回一个 HTTP 响应。当然，HTTP 响应报文也要经过和 HTTP 请求报文一样的过程。</p>
<p>看下方这个图回顾一下（图片来源《图解 HTTP》）：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210srgtrhyuyiluyutyterewfgethyju207224444.png"></p>
<h4 id="9-断开-TCP-连"><a href="#9-断开-TCP-连" class="headerlink" title="9. 断开 TCP 连"></a>9. 断开 TCP 连</h4><p>浏览器和服务器都不再需要发送数据后，四次挥手断开 TCP 连接</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/fafsdvsfvfsbfgndgftrytuyty.png"></p>
<h4 id="10-浏览器显示界面"><a href="#10-浏览器显示界面" class="headerlink" title="10. 浏览器显示界面"></a>10. 浏览器显示界面</h4><p>浏览器接收到服务器返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>屏蔽掉底层细节，笼统的总结一下上述过程：</p>
<p>应用层：</p>
<ul>
<li>浏览器封装 HTTP 请求报文</li>
<li>DNS 解析域名获得目标服务器地址</li>
</ul>
<p>传输层：</p>
<ul>
<li>建立连接</li>
<li>把应用层传过来的 HTTP 请求报文进行分割，并在各个报文上打上标记序号及端口号转发给网络层</li>
</ul>
<p>网络层：</p>
<ul>
<li>利用 ARP 协议根据 IP 地址获取作为通信目的地的 MAC 地址后转发给链路层</li>
</ul>
<p>服务端在链路层收到数据，按序往上层发送，一直到应用层接收到浏览器发送来的 HTTP 请求报文，然后处理该请求并返回 HTTP 响应报文，浏览器接收到响应报文之后解析渲染界面。最后 TCP 断开连接。</p>
</blockquote>
<h1 id="问题：B树-B-树"><a href="#问题：B树-B-树" class="headerlink" title="问题：B树 B+树"></a>问题：B树 B+树</h1><blockquote>
<ul>
<li>B+树中只有叶子节点会带有指向记录的指针（<code>ROWID</code>），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<p>B+树的优点：<strong>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</strong></p>
<p>B树的优点：<strong>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位</strong></p>
</blockquote>
<h1 id="问题：进程间通信方式"><a href="#问题：进程间通信方式" class="headerlink" title="问题：进程间通信方式"></a>问题：进程间通信方式</h1><blockquote>
<p>全文脉络思维导图如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022522003cdvfbgnhmj,k.l.png"></p>
<h2 id="1-什么是进程通信"><a href="#1-什么是进程通信" class="headerlink" title="1. 什么是进程通信"></a><strong>1. 什么是进程通信</strong></h2><p>​	顾名思义，进程通信（ InterProcess Communication，IPC）就是指<strong>进程之间的信息交换</strong>。实际上，<strong>进程的同步与互斥本质上也是一种进程通信</strong>（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它<strong>缺乏传递数据的能力</strong>。</p>
<p>​	虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，<strong>进程之间需要交换大批数据</strong>，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。</p>
<p>​	再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以<strong>进程之间想要进行信息交换就必须通过内核</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210223112csadvfbgnhmj,k14.png"></p>
<p>下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：</p>
<ul>
<li>管道（也称作共享文件）</li>
<li>消息队列（也称作消息传递）</li>
<li>共享内存（也称作共享存储）</li>
<li>信号量和 PV 操作</li>
<li>信号</li>
<li>套接字（Socket）</li>
</ul>
<h2 id="2-管道"><a href="#2-管道" class="headerlink" title="2. 管道"></a><strong>2. 管道</strong></h2><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a><strong>匿名管道</strong></h3><p>​	各位如果学过 Linux 命令，那对管道肯定不陌生，Linux 管道使用竖线 <code>|</code> 连接多个命令，这被称为管道符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxxxxxxxxx  $ command1 | command2	</span><br></pre></td></tr></table></figure>

<p>​	以上这行代码就组成了一个管道，它的功能是将前一个命令（<code>command1</code>）的输出，作为后一个命令（<code>command2</code>）的输入，从这个功能描述中，我们可以看出<strong>管道中的数据只能单向流动</strong>，也就是半双工通信，如果想实现相互通信（全双工通信），我们需要创建两个管道才行。</p>
<p>​	另外，通过管道符 <code>|</code> 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，<strong>匿名管道只能用于父子进程之间的通信</strong>。</p>
<p>​	在 Linux 的实际编码中，是通过 <code>pipe</code> 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe (int fd[2]);</span><br></pre></td></tr></table></figure>

<p>该函数拥有一个存储空间为 2 的文件描述符数组：</p>
<ul>
<li><code>fd[0]</code> 指向管道的读端，<code>fd[1]</code> 指向管道的写端</li>
<li><code>fd[1]</code> 的输出是 <code>fd[0]</code> 的输入</li>
</ul>
<p>粗略的解释一下通过匿名管道实现进程间通信的步骤：</p>
<p>1）父进程创建两个匿名管道，管道 1（<code>fd1[0]</code>和 <code>fd1[1]</code>）和管道 2（<code>fd2[0]</code> 和 <code>fd2[1]</code>）；</p>
<blockquote>
<p>因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个。</p>
</blockquote>
<p>2）父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</p>
<p>3）父进程关闭管道 1 的读端 <code>fd1[0]</code> 和 管道 2 的写端 <code>fd2[1]</code>，子进程关闭管道 1 的写端 <code>fd1[1]</code> 和 管道 2 的读端 <code>fd2[0]</code>，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用<strong>环形队列</strong>实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314csdvfbgnhmj,k.l2402.png"></p>
<p>​	看完上面这些讲述，我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了），但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>​	简单来说，<strong>管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作</strong>。</p>
<h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a><strong>有名管道</strong></h3><p>​	匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
<p>​	所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。</p>
<p>使用 Linux 命令 <code>mkfifo</code> 来创建有名管道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure>

<p>​	<code>myPipe</code> 就是这个管道的名称，接下来，我们往 myPipe 这个有名管道中写入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxxxxxxxxx  $ echo &quot;hello&quot; &gt; myPipe	</span><br></pre></td></tr></table></figure>

<p>​	执行这行命令后，你会发现它就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个有名管道里的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe</span><br><span class="line"> hello</span><br></pre></td></tr></table></figure>

<h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a><strong>3. 消息队列</strong></h2><p>​	可以看出，<strong>管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流</strong>。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314dvfbgfhmj,jmhngbnhm2747.png"></p>
<p><strong>消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong>。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：</p>
<ul>
<li><p>消息队列允许一个或多个进程向它写入或读取消息。</p>
</li>
<li><p>消息队列可以实现消息的<strong>随机查询</strong>，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。</p>
</li>
<li><p>对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。</p>
</li>
<li><p>消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</p>
<p>需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
</li>
</ul>
<h2 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a><strong>4. 共享内存</strong></h2><p>​	为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。</p>
<p>​	顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将<strong>立即</strong>影响到可以访问同一段共享内存的任何其他进程。</p>
<p>​	集合内存管理的内容，我们来深入理解下共享内存的原理。首先，每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。<strong>两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存</strong>。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022314csdvfbgnhmjh,khjmhngbdf4949.png"></p>
<p>​	不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2cdsvgfhjkj.khjndfds0210223142910.png"></p>
<h2 id="5-信号量和-PV-操作"><a href="#5-信号量和-PV-操作" class="headerlink" title="5. 信号量和 PV 操作"></a><strong>5. 信号量和 PV 操作</strong></h2><p>​	实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为<strong>消息队列无需避免冲突，而共享内存机制可能会发生冲突</strong>。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。</p>
<p>​	并且，在多道批处理系统中，多个进程是可以并发执行的，但由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进（异步性）。但有时候我们又希望多个进程能密切合作，按照某个特定的顺序依次执行，以实现一个共同的任务。</p>
<p>​	举个例子，如果有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210scdvfgnhj,kj.k,jgfgbvdcs222182849.png"></p>
<p>​	因此，为了解决上述这两个问题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。</p>
<p>​	<strong>进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信</strong>。</p>
<blockquote>
<p>下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。</p>
</blockquote>
<p>​	信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
<p>​	用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：</p>
<p>1）<strong>P 操作</strong>：将信号量值减 1，表示<strong>申请占用一个资源</strong>。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。</p>
<p>可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。</p>
<p>2）<strong>V 操作</strong>：将信号量值加 1，表示<strong>释放一个资源</strong>，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。</p>
<p>我觉得已经讲的足够通俗了，不过对于 V 操作大家可能仍然有困惑，下面再来看两个关于 V 操作的问答：</p>
<p>问：<strong>信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程</strong>？</p>
<p>答：所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。</p>
<p>问：<strong>信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程</strong>？</p>
<p>答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。</p>
<p>信号量和 PV 操作具体的定义如下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202102scdvfbhmj,kjmhnt22182011.png"></p>
<h3 id="互斥访问共享内存"><a href="#互斥访问共享内存" class="headerlink" title="互斥访问共享内存"></a><strong>互斥访问共享内存</strong></h3><p>两步走即可实现不同进程对共享内存的互斥访问：</p>
<ul>
<li>定义一个互斥信号量，并初始化为 1</li>
<li>把对共享内存的访问置于 P 操作和 V 操作之间</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202102231532cdvfbfhmj,kj.,hjhfgbvdc21.png"></p>
<p>​	<strong>P 操作和 V 操作必须成对出现</strong>。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022315csdsvdghjh,kjhgbef3236.png"></p>
<h3 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a><strong>实现进程同步</strong></h3><p>回顾一下进程同步，就是要各并发进程按要求有序地运行。</p>
<p>​	举个例子，以下两个进程 P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。假设 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022cdvsfdgfhmj,k.,jmnt2181857.png"></p>
<p>如果 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p>使用信号量和 PV 操作实现进程的同步也非常方便，三步走：</p>
<ul>
<li>定义一个同步信号量，并初始化为当前可用资源的数量</li>
<li>在优先级较<strong>高</strong>的操作的<strong>后</strong>面执行 V 操作，释放资源</li>
<li>在优先级较<strong>低</strong>的操作的<strong>前</strong>面执行 P 操作，申请占用资源</li>
</ul>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210222csdvfbgngdjfk.jmhnbfv181925.png"></p>
<p>配合下面这张图直观理解下：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/20210222cdsvdgfhjmhggbdfds171312.png"></p>
<h2 id="6-信号"><a href="#6-信号" class="headerlink" title="6. 信号"></a><strong>6. 信号</strong></h2><p>​	注意！<strong>信号和信号量是完全不同的两个概念</strong>！</p>
<p>​	信号是进程通信机制中唯一的<strong>异步</strong>通信机制，它可以在任何时候发送信号给某个进程。<strong>通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行</strong>。用户、内核和进程都能生成和发送信号。</p>
<p>​	信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；而软件来源就是通过 <code>kill</code> 系列的命令给进程发送信号，比如 <code>kill -9 1111</code> ，表示给 PID 为 1111 的进程发送 <code>SIGKILL</code> 信号，让其立即结束。我们来查看一下 Linux 中有哪些信号：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/2021022315dvfgfhjhk,hjgfgbvds4622.png"></p>
<h4 id="7-Socket"><a href="#7-Socket" class="headerlink" title="7. Socket"></a>7. Socket</h4><p>​	至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要<strong>跨网络与不同主机上的进程进行通信</strong>，那该怎么做呢？这就是 Socket 通信做的事情了（<strong>当然，Socket 也能完成同主机上的进程通信</strong>）。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202012defwgtrhjuymujdhnfdfgb05112439.png"></p>
<p>​	Socket 起源于 Unix，原意是<strong>插座</strong>，在计算机通信领域，Socket 被翻译为<strong>套接字</strong>，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>​	从计算机网络层面来说，<strong>Socket 套接字是网络通信的基石</strong>，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。</p>
<p>​	Socket 的本质其实是一个编程接口（API），是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它对 TCP&#x2F;IP 进行了封装。它<strong>把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面</strong>。对用户来说，只要通过一组简单的 API 就可以实现网络的连接。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img11/202ghtsdgrsdfdsgdsgdf10223163258.png"></p>
<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>简单总结一下上面六种 Linux 内核提供的进程通信机制：</p>
<p>1）首先，最简单的方式就是<strong>管道</strong>，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。</p>
<p>2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此<strong>消息队列</strong>应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。</p>
<p>3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，<strong>共享内存</strong>可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p>4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。</p>
<p>5）<strong>信号</strong>和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。</p>
<p>6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 <strong>Socket</strong> 通信。另外，Socket 也能完成同主机上的进程通信。</p>
</blockquote>
<h1 id="问题：time-wait状态存在的原因"><a href="#问题：time-wait状态存在的原因" class="headerlink" title="问题：time_wait状态存在的原因"></a>问题：time_wait状态存在的原因</h1><blockquote>
<p><strong>第一个理由：</strong>如果客户端的ACK丢失了，服务器将确保最后一个确认报文能够到达。如果没能到达，服务端就会会重发FIN请求释放连接。等待一段时间没有收到重发就说明服务的已经CLOSE了。如果有重发，则客户端再发送一次LAST ack信号。</p>
<p><strong>第二个理由：</strong>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</blockquote>
<h1 id="问题：既然MAC地址是唯一的，为什么还需要IP地址？"><a href="#问题：既然MAC地址是唯一的，为什么还需要IP地址？" class="headerlink" title="问题：既然MAC地址是唯一的，为什么还需要IP地址？"></a>问题：既然MAC地址是唯一的，为什么还需要IP地址？</h1><blockquote>
<ul>
<li><p>因为如果我们只用MAC地址的话，我们会发现路由器需要记住每个MAC地址所在的子网是哪一个(不然每一次收到数据包的时候路由 器都要重新满世界地去找这个MAC地址的位置)。而世界上有248个MAC地址，这就意味着即使我们给每个MAC地址只留1字节的储存空间，每个路由器也需要256 TB的内存!这显然是不可能实现的。</p>
</li>
<li><p>和MAC不同的是，IP 地址是和地域相关的。对于位于同一个子网上的设备，我们给他们分配的IP地址前缀都是一样的。 这个前缀就像邮政编码一样。这样，路由器过IP地址的前缀就能知道这个设备在哪个子网上了。现在，路由器只需要记住每个子网的位置即可，大大减少了路由器所需要的内存。</p>
</li>
<li><p>只拥有MAC地址的话，只有在同一网络区域内，才能进行数据传输，不能跨网络区域。</p>
</li>
<li><p>如果不使用IP地址，那么就需要维护一个极其庞大的MAC地址表，在查找目的机器的时候，就需要向全世界发送数据包，可想而知会造成多大的网络流量。</p>
</li>
</ul>
</blockquote>
<h1 id="问题：String-s-与-String-s-null"><a href="#问题：String-s-与-String-s-null" class="headerlink" title="问题：String s 与 String s &#x3D; null"></a>问题：String s 与 String s &#x3D; null</h1><blockquote>
<p><code>String s</code></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img17/dassadcdscdscdscdsvdbh09104705.png"></p>
<hr>
<p><code>String s = null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：s <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clpsh979m002vxgvsbhem9nfa" data-title="面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数组array与集合List互相转换" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/17/%E6%95%B0%E7%BB%84array%E4%B8%8E%E9%9B%86%E5%90%88List%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time class="dt-published" datetime="2021-11-17T08:33:27.000Z" itemprop="datePublished">2021-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/17/%E6%95%B0%E7%BB%84array%E4%B8%8E%E9%9B%86%E5%90%88List%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/">数组array与集合List互相转换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h6 id="int-转-List"><a href="#int-转-List" class="headerlink" title="int[] 转 List&lt;Integer&gt;"></a><code>int[]</code> 转 <code>List&lt;Integer&gt;</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = Arrays.stream(data).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// Arrays.stream(arr) 可以替换成IntStream.of(arr)。</span></span><br><span class="line"><span class="comment">// 1.使用Arrays.stream将int[]转换成IntStream。</span></span><br><span class="line"><span class="comment">// 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream&lt;Integer&gt;。</span></span><br><span class="line"><span class="comment">// 3.使用Stream的collect()，将Stream&lt;T&gt;转换成List&lt;T&gt;，因此正是List&lt;Integer&gt;。</span></span><br></pre></td></tr></table></figure>

<h6 id="int-转-Integer"><a href="#int-转-Integer" class="headerlink" title="int[] 转 Integer[]"></a><code>int[]</code> 转 <code>Integer[]</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 前两步同上，此时是Stream&lt;Integer&gt;。</span></span><br><span class="line"><span class="comment">// 然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator。</span></span><br><span class="line"><span class="comment">// 这样就可以返回Integer数组。</span></span><br><span class="line"><span class="comment">// 不然默认是Object[]。</span></span><br></pre></td></tr></table></figure>

<h6 id="List-转-Integer"><a href="#List-转-Integer" class="headerlink" title="List&lt;Integer&gt; 转 Integer[]"></a><code>List&lt;Integer&gt;</code> 转 <code>Integer[]</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers2 = list1.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//  调用toArray。传入参数T[] a。这种用法是目前推荐的。</span></span><br><span class="line"><span class="comment">// List&lt;String&gt;转String[]也同理。</span></span><br></pre></td></tr></table></figure>

<h6 id="List-转-int"><a href="#List-转-int" class="headerlink" title="List&lt;Integer&gt; 转 int[]"></a><code>List&lt;Integer&gt;</code> 转 <code>int[]</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line"><span class="comment">// 想要转换成int[]类型，就得先转成IntStream。</span></span><br><span class="line"><span class="comment">// 这里就通过mapToInt()把Stream&lt;Integer&gt;调用Integer::valueOf来转成IntStream</span></span><br><span class="line"><span class="comment">// 而IntStream中默认toArray()转成int[]。</span></span><br></pre></td></tr></table></figure>

<h6 id="Integer-转-int"><a href="#Integer-转-int" class="headerlink" title="Integer[] 转 int[]"></a><code>Integer[]</code> 转 <code>int[]</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();</span><br><span class="line"><span class="comment">// 思路同上。先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream。</span></span><br></pre></td></tr></table></figure>

<h6 id="Integer-转-List"><a href="#Integer-转-List" class="headerlink" title="Integer[] 转 List&lt;Integer&gt;"></a><code>Integer[]</code> 转 <code>List&lt;Integer&gt;</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(integers1);</span><br><span class="line"><span class="comment">// 最简单的方式。String[]转List&lt;String&gt;也同理。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] strings1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// String[] 转 List&lt;String&gt;</span></span><br><span class="line">List&lt;String&gt; list3 = Arrays.asList(strings1);</span><br><span class="line"><span class="comment">// List&lt;String&gt; 转 String[]</span></span><br><span class="line">String[] strings2 = list3.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/17/%E6%95%B0%E7%BB%84array%E4%B8%8E%E9%9B%86%E5%90%88List%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/" data-id="clpsh979d001exgvs66ne9g27" data-title="数组array与集合List互相转换" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-StringTable讲解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/13/StringTable%E8%AE%B2%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-11-13T13:28:09.000Z" itemprop="datePublished">2021-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/13/StringTable%E8%AE%B2%E8%A7%A3/">StringTable讲解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h1><blockquote>
<p><code>String table</code>又称为<code>String pool</code>，字符串常量池，其存在于堆中(<code>jdk1.7</code>之后改的)。</p>
</blockquote>
<blockquote>
<p>​	字面量方式创建的字符串，会放入 <code>StringTable</code> 中，<code>StringTable</code> 管理的字符串，才具有不重复的特性。<br>​	而 <code>char[]</code>，<code>byte[]</code>，<code>int[]</code>，<code>String</code>，以及 <code>+</code> 方式本质上都是使用 <code>new</code> 来创建，它们都是在堆中创建新的字符串对象，不会考虑字符串重不重复，这种字符串的缺点就是如果存在大量值相同的字符串，对内存占用非常严重</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str= <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​	<code>jdk</code>使用的是字符串常量池的方法来解决这个问题，其数据结构上就是一个 <code>hash</code> 表，字符串对象就充当 <code>hash</code> 表中的 <code>key</code>，<code>key</code> 的不重复性，是 <code>hash</code> 表的基本特性。</p>
<p>​	当代码运行到一个字面量 <code>&quot;abc&quot;</code> 时，会首先检查 <code>StringTable</code> 中有没有相同的 key，如果没有，创建新字符串对象加入；否则直接返回已有的字符串对象。</p>
</blockquote>
<blockquote>
<p>​	字符串池在<code>JDK1.7</code>之后存在于堆中的一块区域，<code>String s1 = &quot;abc&quot;</code>这样声明的字符串会放入字符串池中，<code>String s1 = new String(&quot;abcd&quot;)</code>会在字符串池有一个<code>&quot;abcd&quot;</code>的字符串对象，堆中也有<code>1</code>个，<code>2</code>个不同。</p>
</blockquote>
<h2 id="拼接创建"><a href="#拼接创建" class="headerlink" title="拼接创建"></a>拼接创建</h2><p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会优化，先自己拼接成 &quot;ab&quot;，然后去字符串常量池找是否有 &quot;ab&quot;。</span></span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用final修饰之后，final 意味着 x 的值不可改变，因此其它引用 x 的地方都可以安全地被替换为 &quot;b&quot;，而不用担心 x 被改变，从源码编译为字节码时，javac 就也进行了优化，把所有出现 x 的地方都替换成为了 &quot;b&quot;，因此这个和String s = &quot;a&quot; + &quot;b&quot;;结果一样。</span></span><br></pre></td></tr></table></figure>

<p>例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个拼接的原理是类似StringBuilder</span></span><br><span class="line"><span class="comment">// String x = &quot;b&quot;;</span></span><br><span class="line"><span class="comment">// String s = new StringBuilder().append(&quot;a&quot;).append(x).toString();</span></span><br></pre></td></tr></table></figure>

<p>例4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个拼接的原理是类似StringBuilder</span></span><br><span class="line"><span class="comment">// String s = new StringBuilder().append(&quot;a&quot;).append(&quot;1&quot;).toString();</span></span><br></pre></td></tr></table></figure>

<h2 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str.intern();</span><br></pre></td></tr></table></figure>

<p>如果常量池中已有：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/njibhuvyctxcryvubijnokm.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;); <span class="comment">// 新创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">// 将 &quot;abc&quot; 加入 StringTable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> x.intern(); <span class="comment">// 已有，返回 StringTable 中 &quot;abc&quot;，即 y</span></span><br><span class="line">System.out.println(z == y); <span class="comment">// true</span></span><br><span class="line">System.out.println(z == x); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果常量池中没有：</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img8/kmjnibuvycrtytvubiom.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> x.intern(); <span class="comment">//  x 加入 StringTable，StringTable 中有了 &quot;abc&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 &quot;abc&quot;</span></span><br><span class="line">System.out.println(z == x); <span class="comment">// true</span></span><br><span class="line">System.out.println(z == y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>; <span class="comment">// 家</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// 野生</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2.intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//#1  false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//#2  true</span></span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseStr</span> <span class="operator">=</span> <span class="string">&quot;baseStr&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">baseFinalStr</span> <span class="operator">=</span> <span class="string">&quot;baseStr&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;baseStr01&quot;</span>; <span class="comment">// 家</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;baseStr&quot;</span>+<span class="string">&quot;01&quot;</span>; <span class="comment">// 家</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> baseStr + <span class="string">&quot;01&quot;</span>; <span class="comment">// 野生</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> baseFinalStr+<span class="string">&quot;01&quot;</span>;<span class="comment">// 家</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;baseStr01&quot;</span>).intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//#3 true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//#4 false </span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">//#5 true</span></span><br><span class="line">System.out.println(str1 == str5);<span class="comment">//#6 true</span></span><br></pre></td></tr></table></figure>

<p>例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;01&quot;</span>);</span><br><span class="line">str2.intern(); <span class="comment">// jdk1.6</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str01&quot;</span>;</span><br><span class="line">System.out.println(str2==str1);<span class="comment">//#7 1.7 true, 1.6 false</span></span><br></pre></td></tr></table></figure>

<p>例4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str01&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;01&quot;</span>);</span><br><span class="line">str2.intern();</span><br><span class="line">System.out.println(str2 == str1);<span class="comment">//# false</span></span><br></pre></td></tr></table></figure>

<p>例5：</p>
<p><strong>String s &#x3D; new String(“xyz”)，创建了几个String Object?</strong></p>
<blockquote>
<p>第一个对象是字符串常量<code>&quot;xyz&quot;</code> 第二个对象是<code>new String(“xyz”)</code>的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容是指向字符串常量<code>&quot;xyz&quot;</code>，另外还有一个引用<code>s</code>，指向第二个对象。这是一个变量，在栈中分配内存。</p>
</blockquote>
<p>例6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>例7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>例8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;bc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s2 + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>例9：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;bc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s2 + s3;</span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>例10：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 野生</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">// 家</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 野生</span></span><br><span class="line">System.out.println(s == s1.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s == s2.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="String、StringBuilder、StringBUffer"><a href="#String、StringBuilder、StringBUffer" class="headerlink" title="String、StringBuilder、StringBUffer"></a>String、StringBuilder、StringBUffer</h1><blockquote>
<ol>
<li><code>String</code>变量不可修改，<code>StringBuffer</code>和<code>StringBuilder</code>可以修改</li>
<li><code>StringBuffer</code>是线程安全的，<code>StringBuilder</code>不是线程安全的。</li>
<li><code>StringBuffer</code>使用了缓存区，<code>StringBuilder</code>没有使用缓存区，所以没有修改数据的情况下，多次调用<code>StringBuffer</code>的<code>toString</code>方法获取的字符串是共享底层的字符数组的。而<code>StringBuilder</code>不是共享底层数组的，每次都生成了新的字符数组。</li>
<li>因为方法被上锁，所以<code>StringBuffer</code>的性能一般会比<code>StringBuilder</code>差，单线程中建议使用<code>StringBuilder</code>。</li>
<li><code>String</code>对象的相加底层调用的是<code>StringBuilder</code>对象，分别调用了<code>append</code>方法和<code>toString</code>方法，所以在大量字符串相加时，使用<code>String</code>对象相加效率低于使用<code>StringBuffer</code>和<code>StringBuilder</code>，因为还有有<code>StringBuilder</code>对象的创建过程和<code>toString</code>方法中字符数组的拷贝过程。</li>
</ol>
</blockquote>
<blockquote>
<p>​	<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 <code>String</code> 对象是不可变的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/13/StringTable%E8%AE%B2%E8%A7%A3/" data-id="clpsh979b0010xgvs8gc68cum" data-title="StringTable讲解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/11/RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2021-11-11T08:41:26.000Z" itemprop="datePublished">2021-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/11/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h1><blockquote>
<p><strong>MQ：</strong>全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>说明：优点部分主要借鉴：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44240587/article/details/104630567?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164370692916780271511405%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164370692916780271511405&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104630567.pc_search_result_control_group&utm_term=mq&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_44240587/article/details/104630567?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164370692916780271511405%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164370692916780271511405&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104630567.pc_search_result_control_group&amp;utm_term=mq&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><p>首先举例下面这个场景，现有ABCDE五个系统，最初的时候BCD三个系统都要调用A系统的接口获取数据，一切都很正常，但是突然，D系统说：我不要了，你不用给我传数据了，A系统无奈，只能修改代码，将调用D系统的代码删除，这时候还没删除呢，E系统发送了请求，但是A系统这时候还没处理完D系统的请求，A系统卒！！！彻底崩溃。看下图↓↓↓↓↓↓↓↓↓↓↓</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mknjbuvtyvuybujnojbuvtyvuhbj.png"></p>
<p>​	上述场景中，BCDE都需要用到A系统提供的数据，A系统跟其他四个系统严重耦合，需要时时刻刻考虑其他四个系统要是挂了怎么办，需不需要重新发送数据给他们，这个时候的A系统内心是崩溃的。</p>
<p>​	但是如果使用了MQ之后 ，A系统的数据只需要放到MQ里面，其他的系统想请求获取数据只需要去MQ里面消费即可，如果突然不想请求了，就取消对MQ的消费就行了，A系统根本不需要考虑给谁去响应这个数据，也不需要去维护代码，也不用考虑其他系统是否调用成功，失败超时等情况。详细看下图↓↓↓↓↓↓↓↓</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhugvytdxrzwerextcyvb.png"></p>
<p>总结：<strong>通过MQ发布订阅消息的模型，A系统就成功的跟其他系统解耦了。</strong></p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>场景二，还是ABCD四个系统，A系统收到一个请求，需要在自己本地写库，还需要往BCD三个系统写库，A系统自己写本地库需要3ms，往其他系统写库相对较慢，B系统200ms ，C系统350ms，D系统400ms，这样算起来，整个功能从请求到响应的时间为3ms+200ms+350ms+400ms&#x3D;953ms，接近一秒，对于用户来说，点个按钮要等这么长时间，基本是无法接受的，侧面也反映出这家研发人员技术不咋地。详情如下图↓↓↓↓↓↓<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/cyvgubhjlkjhbufctdxguj.png"></p>
<p>​	一般的互联网企业，对于用户请求响应的时间要求在100ms-200ms之间，这样，用户的眼睛存在视觉暂停现象，用户响应时间在此范围内就可以了，所以上面的现象是不可取的。</p>
<p>​	如果用了MQ，用户发送请求到A系统耗时3ms，A系统发送三条消息到MQ，假如耗时5ms，用户从发送请求到相应3ms+5ms&#x3D;8ms，仅用了8ms，用户的体验非常好。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibgvyfcdxtgvujnokmp.png"></p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>加入京东系统每天0—19点，系统风平浪静，结果一到八点抢购的时候，每秒并发达到百万，假设JD数据库没秒能处理1.5w条并发请求（并非实际数据，主要为了举例）,到八点抢购的时候，每秒并发百万，这直接导致系统异常，但是八点一过，可能也就几万用户在线操作，每秒的请求可能也就几百条，对整个系统毫无压力。<br><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibtvycrytvbiuompionyutrtu.png">如果使用了MQ，每秒百万个请求写入MQ，因为JD系统每秒能处理1W+的请求，JD系统处理	完然后再去MQ里面，再拉取1W+的请求处理，每次不要超过自己能处理的最大请求量就ok，这样下来，等到八点高峰期的时候，系统也不会挂掉，但是近一个小时内，系统处理请求的速度是肯定赶不上用户的并发请求的，所以都会积压在MQ中，甚至可能积压千万条，但是高峰期过后，每秒只会有一千多的并发请求进入MQ，但是JD系统还是会以每秒1W+的速度处理请求，所以高峰期一过，JD系统会很快消化掉积压在MQ的请求，在用户那边可能也就是等的时间长一点，但是绝对不会让系统挂掉。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnhbugvfctdxcfyubjkm;l.png"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h3><p>​	系统引入的外部依赖越多，系统要面对的风险越高，拿场景一来说，本来ABCD四个系统配合的好好的，没啥问题，但是你偏要弄个MQ进来插一脚，虽然好处挺多，但是万一MQ挂掉了呢，那样你系统不也就挂掉了。</p>
<h3 id="系统复杂程度提高"><a href="#系统复杂程度提高" class="headerlink" title="系统复杂程度提高"></a>系统复杂程度提高</h3><p>​	非要加个MQ进来，如何保证没有重复消费呢？如何处理消息丢失的情况？怎么保证消息传递的顺序？问题太多。</p>
<h3 id="一致性的问题"><a href="#一致性的问题" class="headerlink" title="一致性的问题"></a>一致性的问题</h3><p>​	A系统处理完再传递给MQ就直接返回成功了，用户以为你这个请求成功了，但是，如果在BCD的系统里，BC两个系统写库成功，D系统写库失败了怎么办，这样就导致数据不一致了。所以。消息队列其实是一套非常复杂的架构，你在享受MQ带来的好处的同时，也要做各种技术方案把MQ带来的一系列的问题解决掉，等一切都做好之后，系统的复杂程度硬生生提高了一个等级。</p>
<h2 id="kafka、ActiveMQ、RabbitMQ、RocketMQ对比"><a href="#kafka、ActiveMQ、RabbitMQ、RocketMQ对比" class="headerlink" title="kafka、ActiveMQ、RabbitMQ、RocketMQ对比"></a>kafka、ActiveMQ、RabbitMQ、RocketMQ对比</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibuytvcrtbyuio.png"></p>
<h2 id="AMQP和JMS"><a href="#AMQP和JMS" class="headerlink" title="AMQP和JMS"></a>AMQP和JMS</h2><p>现在实现MQ的有两种主流方式：AMQP、JMS。</p>
<p>两者间的区别和联系：</p>
<ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</li>
</ul>
<p>常见MQ产品:</p>
<ul>
<li>ActiveMQ：基于JMS</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li>
<li>Kafka：分布式消息系统，高吞吐量</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="AMQP模型的几大组件"><a href="#AMQP模型的几大组件" class="headerlink" title="AMQP模型的几大组件"></a>AMQP模型的几大组件</h2><ul>
<li>交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。</li>
<li>队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。</li>
<li>绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>
</ul>
<h2 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/cyrtxcytvuybijnkm.png"></p>
<h3 id="组成部分说明"><a href="#组成部分说明" class="headerlink" title="组成部分说明"></a>组成部分说明</h3><ul>
<li>Broker：消息队列服务进程，RabbitMQ Server就是Message Broker，此进程包括两个部分：Exchange和Queue</li>
<li>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</li>
<li>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的</li>
<li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送</li>
<li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li>
<li>Connection：publisher／consumer和broker之间的TCP连接</li>
<li>Channel：如果每一次访问 RabbitMQ 都建立一个Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id 帮助客户端和message broker 识别 channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</li>
</ul>
<h3 id="生产者发送消息流程"><a href="#生产者发送消息流程" class="headerlink" title="生产者发送消息流程"></a>生产者发送消息流程</h3><ul>
<li><ol>
<li>生产者和Broker建立TCP连接。</li>
</ol>
</li>
<li><ol start="2">
<li>生产者和Broker建立通道。</li>
</ol>
</li>
<li><ol start="3">
<li>生产者通过通道消息发送给Broker，由Exchange将消息进行转发。</li>
</ol>
</li>
<li><ol start="4">
<li>Exchange将消息转发到指定的Queue（队列）</li>
</ol>
</li>
</ul>
<h3 id="消费者接收消息流程"><a href="#消费者接收消息流程" class="headerlink" title="消费者接收消息流程"></a>消费者接收消息流程</h3><ul>
<li><ol>
<li>消费者和Broker建立TCP连接</li>
</ol>
</li>
<li><ol start="2">
<li>消费者和Broker建立通道</li>
</ol>
</li>
<li><ol start="3">
<li>消费者监听指定的Queue（队列）</li>
</ol>
</li>
<li><ol start="4">
<li>当有消息到达Queue时Broker默认将消息推送给消费者。</li>
</ol>
</li>
<li><ol start="5">
<li>消费者接收到消息。</li>
</ol>
</li>
<li><ol start="6">
<li>ack回复</li>
</ol>
</li>
</ul>
<h2 id="六种消息模型"><a href="#六种消息模型" class="headerlink" title="六种消息模型"></a>六种消息模型</h2><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/hbugvyctrexrzweexrctyubhi.jpg"></p>
<h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p>（1）生产者将消息发送到队列，消费者从队列获取消息。</p>
<p>（2）一个队列对应一个消费者。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njibhugvyfcdxrtcfygujnk.png"></p>
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
<p><strong>连接工具类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立与RabbitMQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.103&quot;</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/kavito&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;kavito&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过工厂获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>依赖：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.7</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 3、声明（创建）队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4、消息内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">// 向指定的队列中发送消息</span></span><br><span class="line">        <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</span></span><br><span class="line"><span class="comment">         * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">         * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">         * 4、body，消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭通道和连接(资源关闭最好用try-catch-finally语句处理)</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印。</p>
</blockquote>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>（1）一个生产者，多个消费者。</p>
<p>（2）一个消息发送到队列时，只能被一个消费者获取。</p>
<p>（3）多个消费者并行处理消息，提升消息处理速度。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/nibuvyctcyvgubhimk,l.png"></p>
<p>work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。</p>
<p>这个消息模型在Web应用程序中特别有用，可以处理短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<ul>
<li>P：生产者：任务的发布者</li>
<li>C1：消费者1：领取任务并且完成任务，假设完成速度较慢（模拟耗时）</li>
<li>C2：消费者2：领取任务并且完成任务，假设完成速度较快</li>
</ul>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;task .. &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                <span class="comment">//模拟任务耗时1s</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数：是否自动进行消息确认。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布-订阅模式-Publish-Subcribe"><a href="#发布-订阅模式-Publish-Subcribe" class="headerlink" title="发布&#x2F;订阅模式(Publish&#x2F;Subcribe)"></a>发布&#x2F;订阅模式(Publish&#x2F;Subcribe)</h3><p>将消息发送到交换机，队列从交换机获取消息，队列需要绑定到交换机。</p>
<p>（1）一个生产者，多个消费者。</p>
<p>（2）每一个消费者都有自己的一个队列。</p>
<p>（3）生产者没有将消息直接发送到队列，而是发送到交换机。</p>
<p>（4）每一个队列都要绑定到交换机。</p>
<p>（5）生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的。</p>
<p>（6）交换机类型为“fanout”。</p>
<pre><code>    注意：交换机本身没有存储消息的能力，消息只能存储到队列中。
</code></pre>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/jnibhugvyctxertcryubyinom.png"></p>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;注册成功！！&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [生产者] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange_queue_sms&quot;</span>;<span class="comment">//短信队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [短信服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange_queue_email&quot;</span>;<span class="comment">//邮件队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [邮件服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个消费者会消费同样的信息，都会打印“[短信服务] received : 注册成功！！”</strong></p>
<h3 id="Routing-路由模型"><a href="#Routing-路由模型" class="headerlink" title="Routing 路由模型"></a>Routing 路由模型</h3><p>（1）路由模式的交换机类型为“direct”。</p>
<p>（2）绑定队列到交换机时指定 key，即路由键，一个队列可以指定多个路由键。</p>
<p>（3）生产者发送消息时指定路由键，这时，消息只会发送到绑定的key的对应队列中。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/khjghfdrsxdtcrytvuybinoim.png"></p>
<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>
</ul>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 消息内容，</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;注册成功！请短信回复[T]退订&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;sms&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange_queue_sms&quot;</span>;<span class="comment">//短信队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;sms&quot;</span>);<span class="comment">//指定接收发送方指定routing key为sms的消息</span></span><br><span class="line">        <span class="comment">//channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [短信服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange_queue_email&quot;</span>;<span class="comment">//邮件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;email&quot;</span>);<span class="comment">//指定接收发送方指定routing key为email的消息</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [邮件服务] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主题模式（Topic）"><a href="#主题模式（Topic）" class="headerlink" title="主题模式（Topic）"></a>主题模式（Topic）</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/jnibhugvyctdxcfyvgubhijnomk;l.png"></p>
<p>每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms</p>
<p><strong>通配符规则：</strong></p>
<ul>
<li><code>#</code>：匹配一个或多个词</li>
<li><code>*</code>：匹配1个词</li>
</ul>
<p><strong>举例：</strong></p>
<ul>
<li><p>audit.#：能够匹配audit.irs.corporate 或者 audit.irs</p>
</li>
<li><p>audit.*：只能匹配audit.irs</p>
</li>
</ul>
<p>从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</p>
<p>我们创建了三个绑定：Q1绑定了“*.orange.<em>”，Q2绑定了“.</em>.*.rabbit”和“lazy.＃”。</p>
<ul>
<li>Q1匹配所有的橙色动物。</li>
<li>Q2匹配关于兔子以及懒惰动物的消息。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">规则</th>
<th align="center">匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="center">quick.orange.rabbit</td>
<td align="center">Q1 Q2   routingKey&#x3D;”quick.orange.rabbit”的消息会同时路由到Q1与Q2</td>
</tr>
<tr>
<td align="center">lazy.orange.elephant</td>
<td align="center">Q1 Q2</td>
</tr>
<tr>
<td align="center">quick.orange.fox</td>
<td align="center">Q1</td>
</tr>
<tr>
<td align="center">lazy.pink.rabbit</td>
<td align="center">Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)</td>
</tr>
<tr>
<td align="center">quick.brown.fox</td>
<td align="center">不匹配任意队列，被丢弃</td>
</tr>
<tr>
<td align="center">quick.orange.male.rabbit</td>
<td align="center">不匹配任意队列，被丢弃</td>
</tr>
<tr>
<td align="center">orange</td>
<td align="center">不匹配任意队列，被丢弃</td>
</tr>
</tbody></table>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;这是一只行动迅速的橙色的兔子&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key为：quick.orange.rabbit</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [动物描述：] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_queue_Q1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者1] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange_queue_Q2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;lazy.＃&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                                       <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot; [消费者2] received : &quot;</span> + msg + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/hbgvyfctdxrdctfvgbuhnjomk.png"></p>
<h2 id="消息基于什么传输"><a href="#消息基于什么传输" class="headerlink" title="消息基于什么传输"></a>消息基于什么传输</h2><blockquote>
<p>​	由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
</blockquote>
<h2 id="消息应答机制"><a href="#消息应答机制" class="headerlink" title="消息应答机制"></a>消息应答机制</h2><blockquote>
<p>​	消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。<br>​	为了保证消息在发送过程中不丢失，rabbitmq引入消息应答机制，消息应答就是:消费者在接收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了。</p>
</blockquote>
<h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><blockquote>
<p>​	消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
</blockquote>
<h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><blockquote>
<p>​	用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * deliveryTag:该消息的index</span></span><br><span class="line"><span class="comment"> * multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.basicAck(deliveryTag,multiple);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	用于否定确认</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deliveryTag:该消息的index</span></span><br><span class="line"><span class="comment"> * multiple：是否批量应答。true:将一次性拒绝所有小于deliveryTag的消息。</span></span><br><span class="line"><span class="comment"> * requeue：被拒绝的是否重新入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.basicNack(deliveryTag,multiple,requeue);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	用于否定确认，与 channel.basicReject() 的区别在于 basicNack() 可以拒绝多条消息，而 basicReject() 一次只能拒绝一条消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deliveryTag:该消息的index</span></span><br><span class="line"><span class="comment"> * requeue：被拒绝的是否重新入队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.basicReject(deliveryTag,requeue);</span><br></pre></td></tr></table></figure>

<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><blockquote>
<p>​	如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibhugvyfdxtrtcfyvguimkl,;.jpg"></p>
</blockquote>
<h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><blockquote>
<p>​	默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p>
</blockquote>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">//发布消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较 短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2：</strong></p>
<p>把时间改成30秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较 短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong></p>
<p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/mkljnbiytycbuinionuiytvuvy.png"></p>
<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnibhugvyfctdxrtcfytvu.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/jnbhfcgdxrszxdtrtvuy.png"></p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/nhbjgvyfctdxerextrct.png"></p>
<h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><blockquote>
<p>​	当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p>
</blockquote>
<h3 id="队列如何实现持久化"><a href="#队列如何实现持久化" class="headerlink" title="队列如何实现持久化"></a>队列如何实现持久化</h3><blockquote>
<p>​	之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数明细</span></span><br><span class="line"><span class="comment">* 1、queue 队列名称</span></span><br><span class="line"><span class="comment">* 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">* 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">* 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">* 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><p>需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>
</blockquote>
<h3 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h3><blockquote>
<p>​	如果不设置exchange的持久化对消息的可靠性来说没有什么影响，但是同样如果exchange不设置持久化，那么当broker服务重启之后，exchange将不复存在，那么既而发送方rabbitmq producer就无法正常发送消息。</p>
</blockquote>
<blockquote>
<p>​	一般只需要：channel.exchangeDeclare(exchangeName, “direct&#x2F;topic&#x2F;header&#x2F;fanout”, true);即在声明的时候讲durable字段设置为true即可。</p>
</blockquote>
<h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><blockquote>
<p>​	在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
</blockquote>
<blockquote>
<p>​	为了避免这种情况，<strong>在消费者中消费之前</strong>，我们可以设置参数 <code>channel.basicQos(1);</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"><span class="comment">//采用手动应答  prefetchCount在手动ack的情况下才生效，自动ack不生效。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure>

<h2 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h2><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。</p>
<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>
<p>通常，增加预取将提高 向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>
<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img6/njibuvyctxercytvuybioij.png"></p>
<h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//未确认消息个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        outstandingMessageCount++;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">            outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel.waitForConfirms();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>异步确认为在发送前创建一个支持高并发的Map，key存储消息tag，values存储message，并调用监听器进行监听消息发送。一般在每次发送后用Map记录下发送消息，监听器根据结果回调相关函数，若发送成功，回调成功函数，在Map中删去该消息。发送失败，回调失败函数，在失败函数中通过Map显示该消息。异步确认在所有确认中综合性能最佳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步发布确认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表     适用于高并发的情况下</span></span><br><span class="line"><span class="comment">         *  1、轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         *  2、轻松批量删除条目  只要给到序号</span></span><br><span class="line"><span class="comment">         *  3、支持高并发（多线程）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息确认成功 回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2、删除掉已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">            <span class="keyword">if</span> (multiple)&#123;<span class="comment">//是否是批量消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息 ：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息确认失败 回调函数</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 :</span></span><br><span class="line"><span class="comment">         *  1、消息的标记</span></span><br><span class="line"><span class="comment">         *  2、是否为批量确认</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  3、打印下未确认的消息都有哪些</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息tag ：&quot;</span> + deliveryTag + <span class="string">&quot;未确认消息是：&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备消息的监听器 监听那些消息成功了 哪些消息失败了  异步监听</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数</span></span><br><span class="line"><span class="comment">         *  1、监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         *  2、监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">// 1、记录下所有要发送的消息</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印用时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息，耗时 &quot;</span> + (end - begin)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p>
<h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul>
<li><p>消息 TTL 过期</p>
<p>TTL是Time To Live的缩写, 也就是生存时间</p>
</li>
<li><p>队列达到最大长度</p>
<p>队列满了，无法再添加数据到 mq 中</p>
</li>
<li><p>消息被拒绝</p>
<p>(basic.reject 或 basic.nack) 并且 requeue&#x3D;false.</p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/iygutfrd6ftgyihuojip.png"></p>
<h4 id="消息-TTL-过期"><a href="#消息-TTL-过期" class="headerlink" title="消息 TTL 过期"></a>消息 TTL 过期</h4><p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//设置消息的 TTL 时间 10s</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者C1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/khbjgvycrtcytvubini.png"></p>
<p><strong>消费者 C2 ：</strong></p>
<p>以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 2、从连接中创建通道，使用通道才能完成消息相关的操作</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信消息........... &quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/hbgvcftdxrdtcfyvgubhij.png"></p>
<h4 id="死信之最大长度"><a href="#死信之最大长度" class="headerlink" title="死信之最大长度"></a>死信之最大长度</h4><p>1、消息生产者代码去掉 TTL 属性</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/uycrtxerzextrcytbiunom.png"></p>
<p>2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/jnkbhjgvfcdxrzsdxcg.png"></p>
<p>3、C2 消费者代码不变(启动 C2 消费者)</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/jnbhgvyfdxtrszrxdtg.png"></p>
<h4 id="死信之消息被拒"><a href="#死信之消息被拒" class="headerlink" title="死信之消息被拒"></a>死信之消息被拒</h4><p>1、消息生产者代码同上生产者一致</p>
<p>2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)</p>
<p>拒收消息 “info5”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//        //设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class="line"><span class="comment">//        params.put(&quot;x-max-length&quot;,6);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正常队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息........... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开启手动应答</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/bjghfgcdxzsxdcfygvb.png"></p>
<p>3、C2 消费者代码不变</p>
<p>启动消费者 1 然后再启动消费者 2</p>
<p><img src="https://wyy-blog-picture.oss-cn-beijing.aliyuncs.com/img7/ibugvytdxrzsdxcvbiuni.png"></p>
<h2 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote>
<p>第一个场景，在生产者发送消息给rabbitMQ服务器的时候，有可能因为网络波动等情况，导致生产者收不到rabbitMQ服务器的应答，导致生产者再发送一条消息。</p>
</blockquote>
<blockquote>
<p>第二个场景，也是因为网络波动等问题，导致rabbitMQ服务器在向消费者发送消息的时候，没有收到消费者的应答，重复向消费者发生消息。</p>
</blockquote>
<blockquote>
<p>这两个场景，其实最终都是导致消费者重复消费多次消息，所以在一般的场景下，我们只需要在消费者那里做消息重复消费的保障即可。</p>
</blockquote>
<h3 id="生产时消息重复"><a href="#生产时消息重复" class="headerlink" title="生产时消息重复"></a>生产时消息重复</h3><p>由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ已经接收到了消息。这时候生产者就会重新发送一遍这条消息。</p>
<p>生产者中如果消息未被确认，或确认失败，我们可以使用定时任务+（redis&#x2F;db）来进行消息重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4J</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessage</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大投递次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_TRY_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每30s拉取投递失败的消息, 重新投递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/30 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resend</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行定时任务(重新投递消息)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;MsgLog&gt; msgLogs = messageService.selectTimeoutMsg();</span><br><span class="line">        msgLogs.forEach(msgLog -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msgId</span> <span class="operator">=</span> msgLog.getMsgId();</span><br><span class="line">            <span class="keyword">if</span> (msgLog.getTryCount() &gt;= MAX_TRY_COUNT) &#123;</span><br><span class="line">                messageService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_FAIL);</span><br><span class="line">                log.info(<span class="string">&quot;超过最大重试次数, 消息投递失败, msgId: &#123;&#125;&quot;</span>, msgId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messageService.updateTryCount(msgId, msgLog.getNextTryTime());<span class="comment">// 投递次数+1</span></span><br><span class="line"></span><br><span class="line">                <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(msgId);</span><br><span class="line">                rabbitTemplate.convertAndSend(msgLog.getExchange(), msgLog.getRoutingKey(), MessageHelper.objToMsg(msgLog.getMsg()), correlationData);<span class="comment">// 重新投递</span></span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;第 &quot;</span> + (msgLog.getTryCount() + <span class="number">1</span>) + <span class="string">&quot; 次重新投递消息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;定时任务执行结束(重新投递消息)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h3><blockquote>
<p>消费者消费成功后，再给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息被消费，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。</p>
</blockquote>
<p><strong>修改消费者，模拟异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;javatrip&quot;, durable = &quot;true&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message, <span class="meta">@Headers</span> Map&lt;String,Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;重试&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置yml重试策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        retry:</span><br><span class="line">          enabled: <span class="literal">true</span> # 开启消费者进行重试</span><br><span class="line">          max-attempts: <span class="number">5</span> # 最大重试次数</span><br><span class="line">          initial-interval: <span class="number">3000</span> # 重试时间间隔</span><br></pre></td></tr></table></figure>

<p><strong>由于重复消息是由于网络原因造成的，因此不可避免重复消息。但是我们需要保证消息的幂等性</strong>。</p>
<h3 id="如何保证消息幂等性"><a href="#如何保证消息幂等性" class="headerlink" title="如何保证消息幂等性"></a>如何保证消息幂等性</h3><h4 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h4><p>生产者方面：可以对每条消息生成一个msgID，以控制消息重复投递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">porperties.messageId(String.valueOF(UUID.randomUUID()))</span><br></pre></td></tr></table></figure>

<p>消费者方面：消息体中必须携带一个业务ID，如银行流水号，消费者可以根据业务ID去重，避免重复消费	</p>
<blockquote>
<p>​	在消息生产时，MQ内部针对每条生产者发送的消息生成一个<code>inner-msg-id</code>，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个<code>bizId</code>（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</p>
</blockquote>
<blockquote>
<p>让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：</p>
<ol>
<li>消费者获取到消息后先根据id去查询redis&#x2F;db是否存在该消息</li>
<li>如果不存在，则正常消费，消费完毕后写入redis&#x2F;db</li>
<li>如果存在，则证明消息被消费过，直接丢弃。</li>
</ol>
</blockquote>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/send&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    jsonObject.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;Java旅途&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(json.getBytes()).setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding(<span class="string">&quot;UTF-8&quot;</span>).setMessageId(UUID.randomUUID()+<span class="string">&quot;&quot;</span>).build();</span><br><span class="line">    amqpTemplate.convertAndSend(<span class="string">&quot;javatrip&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;javatrip&quot;, durable = &quot;true&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息为：&quot;</span>+msg+<span class="string">&quot;==消息id为：&quot;</span>+messageId);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageIdRedis</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;messageId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(messageId == messageIdRedis)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        jedis.set(<span class="string">&quot;messageId&quot;</span>,messageId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息如何被优先消费"><a href="#消息如何被优先消费" class="headerlink" title="消息如何被优先消费"></a>消息如何被优先消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"> Map&lt;String, Object&gt; argss = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        argss.put(<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">                .priority(<span class="number">5</span>) <span class="comment">// 优先级，默认为5，配合队列的 x-max-priority 属性使用</span></span><br></pre></td></tr></table></figure>

<h2 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h2><blockquote>
<p>​	一个队列只有一个消费者的情况下才能保证顺序，否则只能通过全局ID实现（每条消息都一个msgId，关联的消息拥有一个parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息）</p>
</blockquote>
<h2 id="如何解决丢数据的问题"><a href="#如何解决丢数据的问题" class="headerlink" title="如何解决丢数据的问题"></a>如何解决丢数据的问题</h2><p><strong>1.生产者丢数据</strong></p>
<blockquote>
<p>​	生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>​	transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>​	然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p>
</blockquote>
<p><strong>2.消息队列丢数据</strong></p>
<blockquote>
<p>​	处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p>
<p>​	①、将queue的持久化标识durable设置为true,则代表是一个持久的队列</p>
<p>​	②、发送消息的时候将deliveryMode&#x3D;2</p>
<p>​	这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p>
</blockquote>
<p><strong>3.消费者丢数据</strong></p>
<blockquote>
<p>启用手动确认模式可以解决这个问题</p>
<p>​	①自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。</p>
<p>​	②手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。</p>
<p>​	③不确认模式，acknowledge&#x3D;”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/11/RabbitMQ/" data-id="clpsh9797000exgvsf20a7kig" data-title="RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JWT/">JWT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Framework/">Spring Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/">智力题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Framework/" rel="tag">Spring Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" rel="tag">智力题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" rel="tag">项目部署</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/Spring-Framework/" style="font-size: 10px;">Spring Framework</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 10px;">智力题</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">项目部署</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/22/Spring-Framework/">Spring Framework</a>
          </li>
        
          <li>
            <a href="/2022/01/13/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/2022/01/13/MyBatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2022/01/04/Java%E5%8F%8D%E5%B0%84/">Java反射</a>
          </li>
        
          <li>
            <a href="/2022/01/02/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>